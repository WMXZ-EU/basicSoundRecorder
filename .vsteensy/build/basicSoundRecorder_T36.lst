
.vsteensy/build/basicSoundRecorder_T36.elf:     file format elf32-littlearm

SYMBOL TABLE:
00000000 l    d  .text	00000000 .text
00012d1c l    d  .fini	00000000 .fini
00012d20 l    d  .ARM.exidx	00000000 .ARM.exidx
1fff0000 l    d  .usbdescriptortable	00000000 .usbdescriptortable
1fff0200 l    d  .dmabuffers	00000000 .dmabuffers
1fff0bd0 l    d  .usbbuffers	00000000 .usbbuffers
1fff0f30 l    d  .data	00000000 .data
1fff1dc0 l    d  .bss	00000000 .bss
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 mk20dx128.c
00008cb4 l     F .text	0000000c startup_default_early_hook
00008cc0 l     F .text	00000002 startup_default_late_hook
00000000 l    df *ABS*	00000000 crtstuff.c
00000410 l     F .text	00000000 __do_global_dtors_aux
1fff1dc0 l       .bss	00000000 completed.8605
00000434 l     F .text	00000000 frame_dummy
1fff1dc4 l       .bss	00000000 object.8610
00012ccc l     O .text	00000000 __frame_dummy_init_array_entry
00000000 l    df *ABS*	00000000 acq.cpp
00000654 l     F .text	00000050 acq_isr()
1fff0200 l     O .dmabuffers	00000800 tdm_rx_buffer
1fff1de4 l     O .bss	00000400 acq_rx_buffer
00000000 l    df *ABS*	00000000 main.cpp
1fff21e8 l     O .bss	00000004 checkToCloseFile(short, unsigned long)::to
1fff0f34 l     O .data	00000002 loop::status
00000000 l    df *ABS*	00000000 menu.cpp
000009bc l     F .text	00000024 File::dec_refcount() [clone .isra.15]
00000000 l    df *ABS*	00000000 mTime.cpp
00011f8d l     O .text	0000000c monthDays
00000000 l    df *ABS*	00000000 filing.cpp
000016a0 l     F .text	00000002 __tcf_0
00001764 l     F .text	00000024 File::dec_refcount() [clone .isra.23]
000020dc l     F .text	000000d0 _GLOBAL__sub_I_data_buffer
1fff0f3c l     O .data	00000004 checkDiskSpace()::isd_
1fff2268 l     O .bss	00000200 saveData(short)::header
00011fc4 l     O .text	0000001c cs
1fff0f40 l     O .data	00000004 isd
1fff45e0 l     O .bss	00000050 saveData(short)::fileName
1fff4630 l     O .bss	00000004 saveData(short)::dirFlag
1fff4658 l     O .bss	00000050 saveData(short)::dirName
1fff46a8 l     O .bss	00000800 dummy_buffer
00000000 l    df *ABS*	00000000 adc.cpp
00000000 l    df *ABS*	00000000 utils.cpp
00000000 l    df *ABS*	00000000 SPI.cpp
000021ec l     F .text	00000022 DMAChanneltransferCount(DMAChannel*, unsigned int) [clone .isra.9]
00000000 l    df *ABS*	00000000 output_pwm.cpp
00002548 l     F .text	00000018 _GLOBAL__sub_I__ZN14AudioOutputPWM21update_responsibilityE
00000000 l    df *ABS*	00000000 input_i2s.cpp
00002560 l     F .text	00000018 _GLOBAL__sub_I__ZN13AudioInputI2S10block_leftE
00000000 l    df *ABS*	00000000 output_pt8211.cpp
00002578 l     F .text	00000018 _GLOBAL__sub_I__ZN17AudioOutputPT821114block_left_1stE
00000000 l    df *ABS*	00000000 output_adat.cpp
00002590 l     F .text	00000018 _GLOBAL__sub_I__ZN15AudioOutputADAT13block_ch1_1stE
00000000 l    df *ABS*	00000000 input_adc.cpp
000025a8 l     F .text	00000018 _GLOBAL__sub_I__ZN16AudioInputAnalog10block_leftE
00000000 l    df *ABS*	00000000 output_dac.cpp
000025c0 l     F .text	00000018 _GLOBAL__sub_I__ZN17AudioOutputAnalog14block_left_1stE
00000000 l    df *ABS*	00000000 input_adcs.cpp
000025d8 l     F .text	00000030 _GLOBAL__sub_I__ZN22AudioInputAnalogStereo10block_leftE
00000000 l    df *ABS*	00000000 input_i2s_quad.cpp
00002608 l     F .text	00000018 _GLOBAL__sub_I__ZN17AudioInputI2SQuad9block_ch1E
00000000 l    df *ABS*	00000000 output_dacs.cpp
00002620 l     F .text	00000018 _GLOBAL__sub_I__ZN23AudioOutputAnalogStereo14block_left_1stE
00000000 l    df *ABS*	00000000 output_i2s_quad.cpp
00002638 l     F .text	00000018 _GLOBAL__sub_I__ZN18AudioOutputI2SQuad13block_ch1_1stE
00000000 l    df *ABS*	00000000 input_i2s_oct.cpp
00002650 l     F .text	00000018 _GLOBAL__sub_I__ZN16AudioInputI2SOct9block_ch1E
00000000 l    df *ABS*	00000000 output_tdm.cpp
00002668 l     F .text	00000018 _GLOBAL__sub_I__ZN14AudioOutputTDM11block_inputE
00000000 l    df *ABS*	00000000 input_tdm.cpp
00002680 l     F .text	00000018 _GLOBAL__sub_I__ZN13AudioInputTDM14block_incomingE
00000000 l    df *ABS*	00000000 input_i2s_hex.cpp
00002698 l     F .text	00000018 _GLOBAL__sub_I__ZN16AudioInputI2SHex9block_ch1E
00000000 l    df *ABS*	00000000 input_pdm.cpp
000026b0 l     F .text	00000018 _GLOBAL__sub_I__ZN13AudioInputPDM10block_leftE
00000000 l    df *ABS*	00000000 output_i2s.cpp
000026c8 l     F .text	00000018 _GLOBAL__sub_I__ZN14AudioOutputI2S14block_left_1stE
00000000 l    df *ABS*	00000000 output_spdif.cpp
000026e0 l     F .text	00000018 _GLOBAL__sub_I__ZN16AudioOutputSPDIF14block_left_1stE
00000000 l    df *ABS*	00000000 WireKinetis.cpp
1fff7f4c l     O .bss	00000001 TwoWire::isr()::receiving
00000000 l    df *ABS*	00000000 SD.cpp
00002c6c l     F .text	00000064 _GLOBAL__sub_I_SD
00000000 l    df *ABS*	00000000 FsUtf.cpp
00000000 l    df *ABS*	00000000 FsGetPartitionInfo.cpp
00012290 l     O .text	00000010 FsGetPartitionInfo::mbdpGuid
00000000 l    df *ABS*	00000000 FsStructs.cpp
00000000 l    df *ABS*	00000000 FsCache.cpp
00000000 l    df *ABS*	00000000 upcase.cpp
000122aa l     O .text	0000012c lookupTable
000123d6 l     O .text	000000d4 mapTable
00000000 l    df *ABS*	00000000 FsName.cpp
00000000 l    df *ABS*	00000000 ExFatFormatter.cpp
00000000 l    df *ABS*	00000000 ExFatName.cpp
00000000 l    df *ABS*	00000000 ExFatFile.cpp
00000000 l    df *ABS*	00000000 ExFatPartition.cpp
00000000 l    df *ABS*	00000000 ExFatVolume.cpp
00000000 l    df *ABS*	00000000 ExFatFileWrite.cpp
000044d0 l     F .text	0000002e exFatDirChecksum(unsigned char const*, unsigned short)
00000000 l    df *ABS*	00000000 FatFormatter.cpp
00004e18 l     F .text	00000028 initFatDirCallback(unsigned long, void*)
00000000 l    df *ABS*	00000000 FatName.cpp
00000000 l    df *ABS*	00000000 FatFile.cpp
00000000 l    df *ABS*	00000000 FatPartition.cpp
00000000 l    df *ABS*	00000000 FatVolume.cpp
00000000 l    df *ABS*	00000000 FatFileLFN.cpp
000065ba l     F .text	0000001e FatFile::lfnChecksum(unsigned char*) [clone .isra.14]
00000000 l    df *ABS*	00000000 FsFile.cpp
00000000 l    df *ABS*	00000000 FsVolume.cpp
00000000 l    df *ABS*	00000000 FsNew.cpp
00000000 l    df *ABS*	00000000 SdSpiCard.cpp
00006f98 l     F .text	00000006 SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]
00006f9e l     F .text	00000006 SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]
00000000 l    df *ABS*	00000000 SdioTeensy.cpp
00007780 l     F .text	00000028 sdIrs()
000077a8 l     F .text	00000018 isBusyCommandComplete()
000077c0 l     F .text	00000010 isBusyCommandInhibit()
000077d0 l     F .text	00000014 isBusyDat()
000077e4 l     F .text	0000000c isBusyDMA()
000077f0 l     F .text	00000014 isBusyFifoRead()
00007804 l     F .text	00000014 isBusyFifoWrite()
00007818 l     F .text	00000018 isBusyTransferComplete()
00007830 l     F .text	00000098 setSdclk(unsigned long)
0000792c l     F .text	00000024 waitTimeout(bool (*)())
00007950 l     F .text	00000040 yieldTimeout(bool (*)())
000079c0 l     F .text	00000054 cardCommand(unsigned long, unsigned long)
00007a14 l     F .text	00000020 statusCMD13()
00007a34 l     F .text	00000010 isBusyCMD13()
00007a48 l     F .text	00000068 readReg16(unsigned long, void*)
00007ab0 l     F .text	00000020 waitDmaStatus() [clone .part.4]
00007ad0 l     F .text	0000009c rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)
00007ca8 l     F .text	0000005c waitTransferComplete()
00008044 l     F .text	00000098 cardCMD6(unsigned long, unsigned char*)
1fff8428 l     O .bss	00000001 m_version2
1fff8429 l     O .bss	00000010 m_cid
1fff843c l     O .bss	00000004 m_busyFcn
1fff8440 l     O .bss	00000001 m_highCapacity
1fff8444 l     O .bss	00000004 m_ocr
1fff8448 l     O .bss	00000004 m_rca
1fff844c l     O .bss	00000001 m_transferActive
1fff8450 l     O .bss	00000004 m_irqstat
1fff1358 l     O .data	00000001 m_errorCode
1fff8454 l     O .bss	00000001 m_initDone
1fff8455 l     O .bss	00000010 m_csd
1fff8465 l     O .bss	00000001 m_dmaBusy
1fff8468 l     O .bss	00000004 m_sdClkKhz
1fff846c l     O .bss	00000004 m_errorLine
00000000 l    df *ABS*	00000000 memcpy-armv7m.o
00000000 l    df *ABS*	00000000 memset.o
00000000 l    df *ABS*	00000000 usb_serial.c
1fff8471 l     O .bss	00000001 tx_noautoflush
1fff8474 l     O .bss	00000004 tx_packet
1fff8478 l     O .bss	00000001 transmit_previous_timeout
1fff847c l     O .bss	00000004 rx_packet
00000000 l    df *ABS*	00000000 analog.c
1fff8481 l     O .bss	00000001 calibrating
1fff1359 l     O .data	00000001 analog_config_bits
1fff8482 l     O .bss	00000001 analog_reference_internal
1fff135a l     O .data	00000001 analog_num_average
00000000 l    df *ABS*	00000000 pins_teensy.c
00008d30 l     F .text	00000002 startup_default_middle_hook
00000000 l    df *ABS*	00000000 usb_mem.c
1fff1360 l     O .data	00000004 usb_buffer_available
00000000 l    df *ABS*	00000000 usb_dev.c
00008f8c l     F .text	00000040 endpoint0_transmit
1fff8488 l     O .bss	00000004 ep0_tx_ptr
1fff848c l     O .bss	00000010 rx_last
1fff849c l     O .bss	00000004 tx_state
1fff84a0 l     O .bss	00000040 ep0_rx0_buf
1fff84e0 l     O .bss	00000010 rx_first
1fff84f0 l     O .bss	00000001 ep0_tx_bdt_bank
1fff84f4 l     O .bss	00000040 ep0_rx1_buf
1fff8534 l     O .bss	00000010 tx_first
1fff0000 l     O .usbdescriptortable	000000a0 table
1fff8544 l     O .bss	00000010 tx_last
1fff8554 l     O .bss	00000008 setup
1fff855c l     O .bss	00000002 ep0_tx_len
1fff855f l     O .bss	00000008 reply_buffer
1fff8568 l     O .bss	00000001 ep0_tx_data_toggle
00000000 l    df *ABS*	00000000 yield.cpp
1fff8569 l     O .bss	00000001 yield::running
00000000 l    df *ABS*	00000000 DMAChannel.cpp
00000000 l    df *ABS*	00000000 EventResponder.cpp
00000000 l    df *ABS*	00000000 usb_inst.cpp
00000000 l    df *ABS*	00000000 Print.cpp
00000000 l    df *ABS*	00000000 main.cpp
00000000 l    df *ABS*	00000000 AudioStream.cpp
00000000 l    df *ABS*	00000000 Stream.cpp
00000000 l    df *ABS*	00000000 serialEvent.cpp
00000000 l    df *ABS*	00000000 new.cpp
00000000 l    df *ABS*	00000000 usb_desc.c
1fff1379 l     O .data	00000012 device_descriptor
1fff13a4 l     O .data	00000043 config_descriptor
00000000 l    df *ABS*	00000000 nonstd.c
00000000 l    df *ABS*	00000000 sf_nan.c
00000000 l    df *ABS*	00000000 atexit_arm.cc
00000000 l    df *ABS*	00000000 _lshrdi3.o
00000000 l    df *ABS*	00000000 _arm_addsubdf3.o
00000000 l    df *ABS*	00000000 _arm_muldivdf3.o
00000000 l    df *ABS*	00000000 _arm_cmpdf2.o
00000000 l    df *ABS*	00000000 _arm_unorddf2.o
00000000 l    df *ABS*	00000000 _arm_fixdfsi.o
00000000 l    df *ABS*	00000000 _arm_fixunsdfsi.o
00000000 l    df *ABS*	00000000 _arm_truncdfsf2.o
00000000 l    df *ABS*	00000000 _aeabi_uldivmod.o
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 _dvmd_tls.o
00000000 l    df *ABS*	00000000 cxa_atexit.c
00000000 l    df *ABS*	00000000 errno.c
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 locale.c
0000aa6c l     F .text	00000018 __get_current_locale
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 mbtowc_r.c
00000000 l    df *ABS*	00000000 lib_a-memchr.o
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mlock.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 sscanf.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 lib_a-strlen.o
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 strtod.c
0000b87c l     F .text	00000038 sulp
000128b8 l     O .text	00000014 fpi.6173
000128dc l     O .text	00000014 fpinan.6209
000128f0 l     O .text	00000028 tinytens
00000000 l    df *ABS*	00000000 strtol.c
0000c7b0 l     F .text	00000136 _strtol_l.isra.0
00000000 l    df *ABS*	00000000 vfprintf.c
00012918 l     O .text	00000010 zeroes.7258
0001296c l     O .text	00000010 blanks.7257
00000000 l    df *ABS*	00000000 vfscanf.c
0001297c l     O .text	00000022 basefix.7328
00000000 l    df *ABS*	00000000 vdprintf.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
0000efcc l     F .text	00000014 register_fini
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 dtoa.c
0000efec l     F .text	00000128 quorem
00000000 l    df *ABS*	00000000 fini.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 gdtoa-gethex.c
000101e0 l     F .text	000000a8 rshift
00000000 l    df *ABS*	00000000 gdtoa-hexnan.c
00000000 l    df *ABS*	00000000 iswspace.c
00000000 l    df *ABS*	00000000 localeconv.c
00000000 l    df *ABS*	00000000 mbrtowc.c
00000000 l    df *ABS*	00000000 mprec.c
00012cb0 l     O .text	0000000c p05.6087
00000000 l    df *ABS*	00000000 sccl.c
00000000 l    df *ABS*	00000000 strtoll.c
0001133c l     F .text	000001ac _strtoll_l.isra.0
00000000 l    df *ABS*	00000000 strtoul.c
0001150c l     F .text	00000168 _strtoul_l.isra.0
00000000 l    df *ABS*	00000000 strtoull.c
00011698 l     F .text	000001ec _strtoull_l.isra.0
00000000 l    df *ABS*	00000000 vfprintf.c
00000000 l    df *ABS*	00000000 vfscanf.c
00000000 l    df *ABS*	00000000 ungetc.c
00000000 l    df *ABS*	00000000 vasnprintf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 impure.c
1fff1418 l     O .data	00000428 impure_data
00000000 l    df *ABS*	00000000 ctype_.c
00000000 l    df *ABS*	00000000 c:/users/zimme/documents/arduino-1.8.19/hardware/tools/arm/bin/../lib/gcc/arm-none-eabi/5.4.1/armv7e-m/fpu/crti.o
00000000 l    df *ABS*	00000000 c:/users/zimme/documents/arduino-1.8.19/hardware/tools/arm/bin/../lib/gcc/arm-none-eabi/5.4.1/armv7e-m/fpu/crtn.o
00000000 l    df *ABS*	00000000 FsDateTime.cpp
00000000 l    df *ABS*	00000000 HardwareSerial.cpp
00000000 l    df *ABS*	00000000 reent.c
00000000 l    df *ABS*	00000000 
1fff1dc0 l       .bss	00000000 __bss_start__
1fff85f0 l       .bss	00000000 __bss_end__
00000000 l       *UND*	00000000 software_init_hook
00000000 l       *UND*	00000000 hardware_init_hook
00000000 l       *UND*	00000000 __stack
000054ac  w    F .text	00000026 FatPartition::cacheSync()
00008cac  w    F .text	00000006 adc0_isr
000008da  w    F .text	00000066 SDFile::getModifyTime(DateTimeFields&)
000030c0 g     F .text	000000a4 toUpcase(unsigned short)
000018d4 g     F .text	00000034 pushData(unsigned long*)
0000a590 g     F .text	0000002c .hidden __aeabi_dcmpun
00008990 g     F .text	0000001c usb_serial_available
0000117c g     F .text	000001b4 menu()
00011268 g     F .text	0000005e __any_on
0000a554 g     F .text	00000012 .hidden __aeabi_dcmple
0000620c g     F .text	0000002e FatPartition::freeClusterCount_cb_fat16(unsigned long, unsigned char*, void*)
0000a490 g     F .text	0000007a .hidden __cmpdf2
00007fcc g     F .text	00000078 SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)
000097d8  w    F .text	000000d8 yield
1fff1de0 g     O .bss	00000004 acq_miss
0000604c g     F .text	000001c0 FatFile::write(void const*, unsigned int)
0000a490 g     F .text	0000007a .hidden __eqdf2
00006f08  w    F .text	00000002 SdSpiCard::~SdSpiCard()
00009a58 g     F .text	000000a6 Print::printNumber64(unsigned long long, unsigned char, unsigned char)
1fff138c g     O .data	00000018 usb_string_manufacturer_name_default
00005fe2 g     F .text	00000068 FatFile::truncate()
1fff121c g     O .data	0000013c Wire1
000032c4 g     F .text	00000458 ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)
1fff463c g     O .bss	0000001c clusterSize
0000a000 g     F .text	0000005a .hidden __floatdidf
00001330 g     F .text	00000024 newHour()
00008c78  w    F .text	00000034 hard_fault_isr
00008cac  w    F .text	00000006 dma_ch6_isr
00001788  w    F .text	00000054 MySpiClass::deactivate()
1fff8418 g     O .bss	00000004 FsDateTime::callback
00002454  w    F .text	000000d8 SPIClass::dma_rxisr()
00002b62  w    F .text	00000050 SdBase<FsVolume>::restart()
00004ee8 g     F .text	0000005c FatFormatter::initPbs()
00009998 g     F .text	00000020 Print::println()
00002798 g     F .text	00000114 TwoWire::isr()
00008cac  w    F .text	00000006 uart0_lon_isr
00003b58 g     F .text	000000d0 ExFatFile::seekSet(unsigned long long)
00009028 g     F .text	00000078 usb_rx_memory
00006eec  w    F .text	00000004 SdSpiCard::errorCode() const
00000826  w    F .text	0000000c File::flush()
00000874  w    F .text	00000066 SDFile::getCreateTime(DateTimeFields&)
00008cac  w    F .text	00000006 dma_ch8_isr
0000b250 g     F .text	00000002 __malloc_unlock
00006fb8 g     F .text	00000026 SdSpiCard::spiStart()
00000df0  w    F .text	00000088 SDFile::openNextFile(unsigned char)
1fff8424 g     O .bss	00000004 FsVolume::m_cwv
00005ad0 g     F .text	000000a8 FatFile::open(FatFile*, char const*, int)
1fff7eb8 g     O .bss	00000004 SerNum
00008bc0 g     F .text	000000b8 analog_init
00001750  w    F .text	00000014 MySpiClass::begin(SdSpiConfig)
000090a0 g     F .text	00000080 usb_tx
0000c790 g     F .text	00000020 _strtod_r
00008cac  w    F .text	00000006 portcd_isr
000018a4  w    F .text	00000016 MySpiClass::setSckSpeed(unsigned long)
0000ee7c g     F .text	0000004a _vdprintf_r
00005bba g     F .text	00000020 FatFile::getCreateDateTime(unsigned short*, unsigned short*)
00001cc4 g     F .text	00000418 saveData(short)
00009cd4 g     F .text	00000018 .hidden __aeabi_llsr
00011d04  w    O .text	0000005c vtable for SDFile
00011a68 g     F .text	00000082 _sfread_r
0000b184 g     F .text	000000c6 memmove
1fff7f04 g     O .bss	00000008 AudioOutputAnalogStereo::dma
0000aaa8 g     F .text	00000014 __locale_ctype_ptr
00008634 g     F .text	00000060 SdioCard::stopTransmission(bool)
000109e0 g     F .text	0000004c _Balloc
00008cac  w    F .text	00000006 can1_rx_warn_isr
00012d28 g       .ARM.exidx	00000000 __exidx_end
00008cac  w    F .text	00000006 dma_error_isr
00002b28  w    F .text	0000003a SdBase<FsVolume>::cardBegin(SdSpiConfig)
000063ca g     F .text	00000046 FatPartition::freeChain(unsigned long)
1fff857c g     O .bss	00000001 EventResponder::runningFromYield
0000719e g     F .text	0000007c SdSpiCard::cardCommand(unsigned char, unsigned long)
000028ac g     F .text	0000000c i2c0_isr
000015e8  w    F .text	0000009c MySpiClass::activate()
0000996e g     F .text	00000028 Print::write(unsigned char const*, unsigned int)
0000a480 g     F .text	0000008a .hidden __gtdf2
0000aa10 g     F .text	0000000c __errno
00000ae4  w    F .text	0000000a SDFile::isDirectory()
00004a38 g     F .text	00000112 ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)
000007fe  w    F .text	0000000c File::write(unsigned char const*, unsigned int)
00008cac  w    F .text	00000006 portd_isr
00000f80 g     F .text	0000001c saveParameters()
00008cac  w    F .text	00000006 enet_error_isr
0000721a  w    F .text	0000001e SdSpiCard::cardAcmd(unsigned char, unsigned long)
0001221c g     O .text	00000020 TwoWire::i2c2_hardware
000009e0  w    F .text	0000001c File::~File()
1fff856c g     O .bss	00000004 EventResponder::firstInterrupt
00010964 g     F .text	00000004 __localeconv_l
00006f0a  w    F .text	0000000e SdSpiCard::~SdSpiCard()
00003216 g     F .text	0000001c ExFatFormatter::writeUpcaseUnicode(unsigned short)
00000494 g     F .text	00000028 acq_startClocks()
00006c9e g     F .text	00000062 FsBaseFile::FsBaseFile(FsBaseFile const&)
00008cac  w    F .text	00000006 tpm1_isr
00004464 g     F .text	00000018 ExFatPartition::rootLength()
00000d22  w    F .text	00000036 SDFile::setCreateTime(DateTimeFields const&)
00006ef0  w    F .text	00000004 SdSpiCard::errorData() const
00009960  w    F .text	00000008 usb_serial_class::write(unsigned char const*, unsigned int)
00012620 g     O .text	00000200 digital_pin_to_info_PGM
0000046c g     F .text	00000028 acq_stopClocks()
1fff85ec g     O .bss	00000004 errno
000073ec g     F .text	00000038 SdSpiCard::readOCR(unsigned long*)
000041f0 g     F .text	0000003e ExFatPartition::fatGet(unsigned long, unsigned long*)
0000b6fc g     F .text	00000004 __seofread
00012d28 g       .ARM.exidx	00000000 _etext
0000252c g     F .text	00000010 _spi_dma_rxISR0()
00001c44 g     F .text	00000078 listDisks()
1fff1dc0 g       .bss	00000000 _sbss
00004f44 g     F .text	0000005c FatFormatter::writeMbr()
0000194c g     F .text	0000001c sdCsInit(unsigned char)
00002c16 g     F .text	00000054 SDClass::mediaPresent()
0000a51c g     F .text	00000010 .hidden __aeabi_cdcmple
000078d4 g     F .text	0000000c SdioCard::errorData() const
00000b92  w    F .text	00000018 FsBaseFile::peek()
00007f0c g     F .text	000000c0 SdioCard::writeSector(unsigned long, unsigned char const*)
00008cac  w    F .text	00000006 porte_isr
0000075c g     F .text	0000009c loop
00008cac  w    F .text	00000006 portb_isr
00008cac  w    F .text	00000006 spi1_isr
00008cac  w    F .text	00000006 uart3_status_isr
0000392c g     F .text	0000007c ExFatFile::parsePathName(char const*, ExName_t*, char const**)
00008cac  w    F .text	00000006 mcm_isr
00008438 g     F .text	000000c4 SdioCard::readData(unsigned char*)
00007036 g     F .text	00000060 SdSpiCard::readData(unsigned char*, unsigned int)
1fff8570 g     O .bss	00000004 EventResponder::lastInterrupt
00008cac  w    F .text	00000006 uart1_status_isr
00006d00 g     F .text	00000028 FsBaseFile::close()
00008720 g     F .text	000001a6 memcpy
00008cac  w    F .text	00000006 randnum_isr
000107c8 g     F .text	00000180 __hexnan
0000a50c g     F .text	00000020 .hidden __aeabi_cdrcmple
0000080a  w    F .text	0000000c File::available()
0000180c  w    F .text	00000014 Print::println(unsigned long)
00002cd0 g     F .text	00000094 FsUtf::cpToMb(unsigned long, char*, char*)
00000ef0 g     F .text	00000090 storeConfig(unsigned short*, int)
000042d6 g     F .text	0000005e ExFatPartition::freeChain(unsigned long)
00005788 g     F .text	00000028 FatFile::peek()
0000c910 g     F .text	000016e4 _svfprintf_r
00009f90 g     F .text	00000022 .hidden __floatsidf
1fff21f0  w    O .bss	00000001 SDFile::name()::zeroterm
1fff8484 g     O .bss	00000004 systick_millis_count
0000a488 g     F .text	00000082 .hidden __ltdf2
00004992 g     F .text	000000a6 ExFatFile::rename(ExFatFile*, char const*)
00008c78  w    F .text	00000034 bus_fault_isr
00000980  w    F .text	0000003c SDFile::truncate(unsigned long long)
00008cac  w    F .text	00000006 watchdog_isr
0000a6ec g     F .text	00000000 .hidden __aeabi_uldivmod
000028b8 g     F .text	0000000c i2c1_isr
1fff8567 g     O .bss	00000001 usb_configuration
00008cac  w    F .text	00000006 dma_ch11_isr
000015e2  w    F .text	00000006 SdCardInterface::status()
00008694 g     F .text	0000001c SdioCard::syncDevice()
00007d8c g     F .text	00000094 SdioCard::writeData(unsigned char const*)
00000000  w      *UND*	00000000 __fini_array_end
00000ab0  w    F .text	0000000a StreamFile<FsBaseFile, unsigned long long>::available()
1fff21f2 g     O .bss	00000020 store
000057b0 g     F .text	0000003a FatFile::readDirCache(bool)
000111c0 g     F .text	00000060 __ratio
000028c4 g     F .text	0000000c i2c2_isr
1fff7ee4 g     O .bss	00000008 AudioOutputAnalog::dma
1fff138c  w    O .data	00000018 usb_string_manufacturer_name
1fff85e4 g     O .bss	00000008 usb_rx_byte_count_data
00008cac  w    F .text	00000006 pit1_isr
0000aabc g     F .text	00000010 malloc
00008cac  w    F .text	00000006 dma_ch4_isr
000121fc g     O .text	00000020 TwoWire::i2c1_hardware
00009b10 g     F .text	00000074 software_isr
00006fa4  w    F .text	00000014 SysCall::curTimeMS()
00002bb2 g     F .text	00000064 SDClass::format(int, char, Print&)
00011cb4  w    O .text	00000024 vtable for FsFile
00010948 g     F .text	0000001c iswspace
00008cac  w    F .text	00000006 dma_ch7_isr
00002704  w    F .text	0000001e TwoWire::read()
00012bc0 g     O .text	000000c8 __mprec_tens
00009744 g     F .text	00000094 usb_init
00006f04  w    F .text	00000004 SdSpiCard::type() const
0000a60c g     F .text	00000040 .hidden __fixunsdfsi
00008cac  w    F .text	00000006 lptmr_isr
00000c28  w    F .text	00000058 SDFile::seek(unsigned long long, int)
1fff85ac g     O .bss	00000004 __malloc_top_pad
00008d10 g     F .text	00000020 rtc_set
00011a2c g     F .text	0000003a __ssrefill_r
00007096 g     F .text	0000006a SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)
00004b4a g     F .text	000000be ExFatFile::truncate()
1fff0f30 g     O .data	00000000 .hidden __dso_handle
00009f70 g     F .text	0000001e .hidden __aeabi_ui2d
00010968 g     F .text	0000001c _localeconv_r
1fff0f44 g     O .data	0000001c sd_str
00011884 g     F .text	00000024 _strtoull_r
00008cf4 g     F .text	00000010 attachInterruptVector
00010bf4 g     F .text	00000012 __i2b
1fff0f30 g       .data	00000000 _sdata
000121dc g     O .text	00000020 TwoWire::i2c0_hardware
000050a4 g     F .text	000001a8 FatFormatter::makeFat32()
0000a71c g     F .text	000002e2 .hidden __udivmoddi4
00009cec g     F .text	00000000 .hidden __aeabi_drsub
000054d2 g     F .text	00000036 FatFile::addCluster()
0000b634 g     F .text	00000024 _sbrk_r
00007424 g     F .text	00000036 SdSpiCard::readRegister(unsigned char, void*)
000079a0 g     F .text	00000020 SdioCard::type() const
000001d0 g     F .text	000001f0 ResetHandler
0000890c g     F .text	0000004c usb_serial_getchar
00008cac  w    F .text	00000006 can1_bus_off_isr
00008cac  w    F .text	00000006 ftm2_isr
00000940  w    F .text	00000040 SDFile::name()
1fff85d8 g     O .bss	00000008 usb_cdc_line_coding
1fff8574 g     O .bss	00000004 EventResponder::lastYield
00008cac  w    F .text	00000006 uart5_status_isr
00008cac  w    F .text	00000006 lpuart0_status_isr
00003906 g     F .text	00000026 ExFatFile::openRoot(ExFatVolume*)
0001284a g     O .text	00000004 usb_endpoint_config_table
00008cac  w    F .text	00000006 dma_ch9_isr
00000a40  w    F .text	0000001c Print::write(char const*)
00000bd6  w    F .text	00000020 StreamFile<FsBaseFile, unsigned long long>::read()
00008cac  w    F .text	00000006 pit2_isr
000031ac g     F .text	00000028 ExFatFormatter::syncUpcase()
00000cec  w    F .text	00000036 SDFile::setModifyTime(DateTimeFields const&)
0000a540 g     F .text	00000012 .hidden __aeabi_dcmplt
00012180 g     O .text	0000005c SPISettings::ctar_clock_table
1fff85a8 g     O .bss	00000004 __malloc_max_sbrked_mem
00000a10  w    F .text	00000018 SDFile::position()
00008d34 g     F .text	00000064 pinMode
0000767a g     F .text	00000028 SdSpiCard::writeStop()
00008f48 g     F .text	00000044 usb_free
00008cac  w    F .text	00000006 i2c3_isr
00009fb4 g     F .text	0000003a .hidden __extendsfdf2
0000dff4 g     F .text	00000e88 __ssvfscanf_r
0000a2b0 g     F .text	000001d0 .hidden __aeabi_ddiv
00000bbe  w    F .text	00000018 FsBaseFile::read(void*, unsigned int)
00009cf8 g     F .text	00000276 .hidden __adddf3
1fff0fa4 g     O .data	0000013c Wire2
000006c8 g     F .text	00000030 checkToCloseFile(short, unsigned long)
000076ee g     F .text	0000002c SdSpiCard::writeData(unsigned char const*)
00000816  w    F .text	00000010 File::peek()
00006410 g     F .text	0000005c FatPartition::freeClusterCount()
00000e78  w    F .text	00000078 SDClass::open(char const*, unsigned char)
00011034 g     F .text	000000d0 __b2d
000021ac g     F .text	00000002 adc_init()
00012d20 g       .ARM.exidx	00000000 __exidx_start
0000a05c g     F .text	00000254 .hidden __aeabi_dmul
0000253c  w    F .text	0000000c DMAChannel::~DMAChannel()
000075b8 g     F .text	00000030 SdSpiCard::writeStart(unsigned long)
00008cac  w    F .text	00000006 pit0_isr
1fff8578 g     O .bss	00000004 EventResponder::firstYield
000128a4 g     O .text	00000004 _global_impure_ptr
00001804  w    F .text	00000008 Print::print(unsigned long)
00008cac  w    F .text	00000006 can1_error_isr
00002d64 g     F .text	00000084 FsUtf::mbToCp(char const*, char const*, unsigned long*)
00000d76  w    F .text	00000018 StreamFile<FsBaseFile, unsigned long long>::write(unsigned char)
00000db4  w    F .text	0000003c SDFile::SDFile(FsFile const&)
0000b254 g     F .text	000003de _realloc_r
00000bf6  w    F .text	0000000a SDFile::read(void*, unsigned int)
0000aa1c g     F .text	00000050 __libc_init_array
1fff85f0 g       .bss	00000000 __bss_end
00000aee  w    F .text	00000028 SDFile::rewindDirectory()
000026f8  w    F .text	0000000c TwoWire::available()
00008cac  w    F .text	00000006 can0_wakeup_isr
00004032 g     F .text	0000000e ExFatFile::open(ExFatVolume*, char const*, int)
000078e0 g     F .text	0000001c SdioCard::readCID(CID*)
00012abc g     O .text	00000100 __hexdig
000047ae g     F .text	000000de ExFatFile::addDirCluster()
00008cac  w    F .text	00000006 flash_cmd_isr
00007500 g     F .text	00000076 SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)
000076a2 g     F .text	0000004c SdSpiCard::writeData(unsigned char, unsigned char const*)
00012c88 g     O .text	00000028 __mprec_bigtens
00010ac0 g     F .text	00000098 __s2b
00009948  w    F .text	00000004 usb_serial_class::clear()
00009f70 g     F .text	0000001e .hidden __floatunsidf
00008cac  w    F .text	00000006 uart2_status_isr
00008cc4 g     F .text	0000002c _sbrk
00001684  w    F .text	0000001c MySpiClass::send(unsigned char)
00010e88 g     F .text	00000042 __mcmp
00012260 g     O .text	00000030 vtable for SDClass
1fff7f1c g     O .bss	00000008 AudioOutputTDM::dma
1fff135c g     O .data	00000004 __brkval
1fff8480 g     O .bss	00000001 usb_cdc_line_rtsdtr
00008b78 g     F .text	00000048 usb_serial_flush_callback
00012cbc g     F .text	00000000 _init
00005594 g     F .text	0000001e FatFile::cacheDirEntry(unsigned char)
00008cac  w    F .text	00000006 svcall_isr
0000296a  w    F .text	00000056 SDClass::remove(char const*)
00000b28  w    F .text	00000026 SDFile::close()
00008cac  w    F .text	00000006 dma_ch15_isr
00000b50  w    F .text	00000024 SDFile::~SDFile()
0000a64c g     F .text	0000009e .hidden __aeabi_d2f
0001223c g     O .text	00000024 vtable for TwoWire
00008cac  w    F .text	00000006 uart1_error_isr
0000ff4c g     F .text	00000028 __libc_fini_array
0000b8b8 g     F .text	00000ed8 _strtod_l
00010798 g     F .text	00000030 __match
00008cac  w    F .text	00000006 usbhs_phy_isr
1fff7eec g     O .bss	00000008 AudioInputAnalogStereo::dma0
1fff85f0 g       .bss	00000000 _ebss
00007e94 g     F .text	00000078 SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)
1fff2214 g     O .bss	00000004 hour_
1fff7ed4 g     O .bss	00000008 AudioOutputADAT::dma
00000c94  w    F .text	0000000a StreamFile<FsBaseFile, unsigned long long>::flush()
000015ae  w    F .text	00000034 BlockDeviceInterface::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)
00010b58 g     F .text	00000040 __hi0bits
0000387a g     F .text	00000038 ExFatFile::dirCache(unsigned char, unsigned char)
0000a5bc g     F .text	0000004e .hidden __fixdfsi
0000488c g     F .text	00000048 ExFatFile::mkdir(ExFatFile*, ExName_t*)
00008cac g     F .text	00000006 unused_isr
00000db4  w    F .text	0000003c SDFile::SDFile(FsFile const&)
00008cac  w    F .text	00000006 spi0_isr
00008cac  w    F .text	00000006 dma_ch3_isr
000028d0  w    F .text	00000002 SDClass::~SDClass()
0000447c g     F .text	00000054 ExFatVolume::chdir(char const*)
0000253c  w    F .text	0000000c DMAChannel::~DMAChannel()
1fff76b8 g     O .bss	00000800 diskBuffer
1fff2468 g     O .bss	00002178 sdx
00006870 g     F .text	00000092 FatFile::makeUniqueSfn(FatName_t*)
000009e0  w    F .text	0000001c File::~File()
00001984 g     F .text	000002c0 storage_configure()
0000524c g     F .text	000000a0 FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)
00005306 g     F .text	00000028 FatFile::getLfnChar(DirLfn_t*, unsigned char)
00009c08 g     F .text	00000004 operator delete(void*, unsigned int)
00008cac  w    F .text	00000006 flash_error_isr
00009cd4 g     F .text	00000018 .hidden __lshrdi3
00009cf8 g     F .text	00000276 .hidden __aeabi_dadd
1fff2254 g     O .bss	00000014 file
0000a488 g     F .text	00000082 .hidden __ledf2
00008cac  w    F .text	00000006 uart5_error_isr
00008cac  w    F .text	00000006 rtc_seconds_isr
000120ec g     O .text	00000094 SPIClass::spi0_hardware
00008cac  w    F .text	00000006 pdb_isr
00010d38 g     F .text	000000a0 __pow5mult
000059f0 g     F .text	0000004e FatFile::rmdir()
00009ff0 g     F .text	0000006a .hidden __aeabi_ul2d
00008c78  w    F .text	00000034 usage_fault_isr
00008cac  w    F .text	00000006 dac1_isr
00000000 g     O .text	000001d0 _VectorsFlash
0000634a g     F .text	00000080 FatPartition::allocateCluster(unsigned long, unsigned long*)
00008cac  w    F .text	00000006 dma_ch14_isr
000098f2  w    F .text	00000006 MillisTimer::enableTimerInterrupt(bool)
000028d2  w    F .text	00000044 SDClass::exists(char const*)
00000000  w      *UND*	00000000 __deregister_frame_info
1fff85e0 g     O .bss	00000004 usb_cdc_line_rtsdtr_millis
000006a4  w    F .text	00000024 Print::println(char const*)
00009938 g     F .text	00000010 systick_isr
00000634 g     F .text	0000001e extract(void*, void*)
00001130 g     F .text	0000004c menuGet3Int(int*, int*, int*)
00008cac  w    F .text	00000006 rtc_alarm_isr
1fff4ea8 g     O .bss	0000000c mySpi
0000749a g     F .text	00000066 SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)
1fff8580 g     O .bss	00000004 AudioStream::first_update
00008cac  w    F .text	00000006 dma_ch2_isr
1fff1368 g     O .data	00000010 Serial
00008cac  w    F .text	00000006 ftm1_isr
00009968  w    F .text	00000006 usb_serial_class::write(unsigned char)
00006da6 g     F .text	0000005e FsBaseFile::openNext(FsBaseFile*, int)
00008cb4  w    F .text	0000000c startup_early_hook
0000771a g     F .text	00000048 SdSpiCard::writeSingle(unsigned long, unsigned char const*)
00008cac  w    F .text	00000006 dma_ch13_isr
00004524 g     F .text	00000092 ExFatFile::addCluster()
00011cd8  w    O .text	0000002c vtable for File
00008cac  w    F .text	00000006 uart2_error_isr
00002abc  w    F .text	00000036 SDClass::usedSize()
00008958 g     F .text	00000038 usb_serial_peekchar
0000a57c g     F .text	00000012 .hidden __aeabi_dcmpgt
00000f9c g     F .text	000000d4 printMenu()
0000b080 g     F .text	00000000 memchr
000062ee g     F .text	0000005c FatPartition::fatPut(unsigned long, unsigned long)
1fff1402 g     O .data	00000016 usb_string_serial_number_default
00008c78 g     F .text	00000034 fault_isr
00010010 g     F .text	000001d0 _free_r
00007d04 g     F .text	00000088 SdioCard::readStop()
00003072 g     F .text	0000004e FsCache::get(unsigned long, unsigned char)
0000aa84 g     F .text	0000001c __locale_mb_cur_max
0000a568 g     F .text	00000012 .hidden __aeabi_dcmpge
00008cac  w    F .text	00000006 usb_charge_isr
00006748 g     F .text	00000128 FatFile::makeSFN(FatName_t*)
00009958  w    F .text	00000004 usb_serial_class::flush()
00003232 g     F .text	00000090 ExFatFormatter::writeUpcase(unsigned long)
000119a8 g     F .text	00000082 _sungetc_r
00008cac  w    F .text	00000006 cmt_isr
00009cf4 g     F .text	0000027a .hidden __aeabi_dsub
0000646c g     F .text	00000108 FatPartition::init(BlockDeviceInterface*, unsigned char)
00008cac  w    F .text	00000006 usbhs_isr
1fff1dbc g     O .data	00000004 __malloc_sbrk_base
00009950  w    F .text	00000004 usb_serial_class::read()
00008cac  w    F .text	00000006 ftm3_isr
000114e8 g     F .text	00000024 _strtoll_r
00008cac  w    F .text	00000006 tsi0_isr
00006bec g     F .text	000000b2 FatFile::remove()
00009ff0 g     F .text	0000006a .hidden __floatundidf
1fff2218 g     O .bss	00000004 msd
00008cf0  w    F .text	00000002 __cxa_pure_virtual
000021ae g     F .text	00000002 adcStatus()
00010dd8 g     F .text	000000ae __lshift
00005cf4 g     F .text	000000aa FatFile::mkdir(FatFile*, char const*, bool)
000004d4 g     F .text	00000014 acq_stop()
00008cac  w    F .text	00000006 spi2_isr
1fff7ef4 g     O .bss	00000008 AudioInputAnalogStereo::dma1
000118a8 g     F .text	00000100 __ssprint_r
00011b64 g     F .text	0000005e _vasnprintf_r
00009c02  w    F .text	00000002 serialEvent()
1fff84f1 g     O .bss	00000001 usb_reboot_timer
1fff7ebc g     O .bss	00000008 AudioOutputPWM::dma
0000ef28 g     F .text	000000a4 __register_exitproc
00003f78 g     F .text	000000ba ExFatFile::open(ExFatFile*, char const*, int)
0000b7dc g     F .text	000000a0 strncmp
00000ca8  w    F .text	00000044 FsBaseFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)
000048d4 g     F .text	000000be ExFatFile::mkdir(ExFatFile*, char const*, bool)
00004fa0 g     F .text	00000104 FatFormatter::makeFat16()
000089ac g     F .text	00000030 usb_serial_flush_input
00004334 g     F .text	00000064 ExFatPartition::freeClusterCount()
00010c08 g     F .text	00000130 __multiply
1fff1ddc g     O .bss	00000004 acq_count
00008abc g     F .text	00000016 usb_serial_putchar
00000022 g       *ABS*	00000000 _teensy_model_identifier
1fff85b0 g     O .bss	00000028 __malloc_current_mallinfo
00011104 g     F .text	000000ba __d2b
1fff8588 g     O .bss	00000018 HardwareSerial::s_serials_with_serial_events
00008cac  w    F .text	00000006 can0_bus_off_isr
00007990  w    F .text	0000000e SdioCard::~SdioCard()
00001898  w    F .text	0000000c SPISettings::SPISettings(unsigned long, unsigned char, unsigned char)
1fff855e g     O .bss	00000001 usb_rx_memory_needed
00007e20 g     F .text	00000074 SdioCard::writeStart(unsigned long)
00011674 g     F .text	00000024 _strtoul_r
00009120 g     F .text	00000624 usb_isr
0000aa04 g     F .text	0000000c __cxa_atexit
000039a8 g     F .text	00000184 ExFatFile::read(void*, unsigned int)
00009f90 g     F .text	00000022 .hidden __aeabi_i2d
00000bb4  w    F .text	0000000a SDFile::peek()
00003026 g     F .text	0000004c FsCache::sync()
1fff0f64 g     O .data	00000040 SPI
0000b120 g     F .text	00000062 memcmp
00012820  w    O .text	00000028 vtable for usb_serial_class
00006674 g     F .text	000000d4 FatFile::createLFN(unsigned short, FatName_t*, unsigned char)
00008cac  w    F .text	00000006 uart3_error_isr
00001968 g     F .text	0000001c sdCsWrite(unsigned char, bool)
0000b6a4 g     F .text	00000058 sscanf
0000aa00  w    F .text	00000002 .hidden __aeabi_ldiv0
0000463c g     F .text	00000052 ExFatFile::rmdir()
000010f4 g     F .text	0000003c menuGetInt(int*)
1fff7f2c g     O .bss	00000008 AudioInputI2SHex::dma
00008cac  w    F .text	00000006 porta_isr
00002a76  w    F .text	00000020 FsVolume::bytesPerCluster() const
0000a2b0 g     F .text	000001d0 .hidden __divdf3
00011220 g     F .text	00000046 __copybits
1fff0bd0 g     O .usbbuffers	00000360 usb_buffer_memory
00006f18 g     F .text	00000080 SdSpiCard::sectorCount()
00008cac  w    F .text	00000006 low_voltage_isr
1fff19b0 g     O .data	00000408 __malloc_av_
00008cac  w    F .text	00000006 can0_error_isr
1fff21e4 g     O .bss	00000004 max_write
00008e00 g     F .text	0000010c _init_Teensyduino_internal_
00000c9e  w    F .text	0000000a SDFile::flush()
0000a05c g     F .text	00000254 .hidden __muldf3
00008b1c g     F .text	0000005c usb_serial_flush_output
00008cac  w    F .text	00000006 dma_ch12_isr
1fff7ec4 g     O .bss	00000008 AudioInputI2S::dma
0000b24c g     F .text	00000002 __malloc_lock
00003768 g     F .text	000000b0 ExFatFile::getName8(char*, unsigned int)
00000000  w      *UND*	00000000 __fini_array_start
00008cac  w    F .text	00000006 can1_wakeup_isr
1fff0a00 g     O .dmabuffers	000001d0 _VectorsRam
00004e40 g     F .text	000000a8 FatFormatter::initFatDir(unsigned char, unsigned long)
00011bc4 g     F .text	0000005e _calloc_r
00008cac  w    F .text	00000006 pit3_isr
00002210 g     F .text	00000078 SPIClass::begin()
1fff0f38 g     O .data	00000004 t_acq
1fff1364 g     O .data	00000001 yield_active_check_flags
00008cac  w    F .text	00000006 enet_rx_isr
00004770 g     F .text	0000003e ExFatFile::sync()
00005d9e g     F .text	00000196 FatFile::rename(FatFile*, char const*)
000086b0 g     F .text	00000070 SdioCard::isBusy()
00008cac  w    F .text	00000006 portc_isr
00007576 g     F .text	00000026 SdSpiCard::readStop()
1fff7efc g     O .bss	00000008 AudioInputI2SQuad::dma
000088c8 g     F .text	00000000 memset
000018bc g     F .text	00000018 getCount()
00009afe g     F .text	00000010 main
1fff7f3c g     O .bss	00000008 AudioOutputI2S::dma
1fff21ec g     O .bss	00000004 max_count
1fff4634 g     O .bss	00000008 rawData
1fff85a4 g     O .bss	00000004 __malloc_max_total_mem
0000406e g     F .text	000000a6 ExFatPartition::bitmapFind(unsigned long, unsigned long)
00001cbc g     F .text	00000006 checkReboot()
00004c08 g     F .text	00000210 ExFatFile::write(void const*, unsigned int)
00008c78  w    F .text	00000034 memmanage_fault_isr
00002f98 g     F .text	0000008e lbaToMbrChs(unsigned char*, unsigned long, unsigned long)
00005b86 g     F .text	00000034 FatFile::dirEntry(DirFat_t*)
00000aba  w    F .text	0000000a SDFile::available()
00000d98  w    F .text	0000001c File::close()
00009c0c g     F .text	00000070 usb_init_serialnumber
00001540 g     F .text	00000036 setRTCTime(int, int, int, int, int, int)
0000c8e8 g     F .text	00000024 _strtol_r
0000a64c g     F .text	0000009e .hidden __truncdfsf2
00012d1c g       .text	00000000 __init_array_end
0000f118 g     F .text	00000e34 _dtoa_r
0000aadc g     F .text	00000570 _malloc_r
1fff85a0 g     O .bss	00000001 HardwareSerial::s_count_serials_with_serial_events
00008cac  w    F .text	00000006 debugmonitor_isr
0000eee0 g     F .text	0000001a __ascii_wctomb
00000b88  w    F .text	0000000a SDFile::isOpen()
00006c9e g     F .text	00000062 FsBaseFile::FsBaseFile(FsBaseFile const&)
0000a000 g     F .text	0000005a .hidden __aeabi_l2d
1fff8420 g     O .bss	00000004 FatVolume::m_cwv
1fff7f14 g     O .bss	00000008 AudioInputI2SOct::dma
000017fc  w    F .text	00000008 Print::print(char const*)
00011aec g     F .text	00000078 __submore
00009bbc g     F .text	00000046 Stream::readBytesUntil(char, char*, unsigned int)
00002288 g     F .text	000001cc SPIClass::transfer(void const*, void*, unsigned int)
61f992f7 g       *ABS*	00000000 __rtc_localtime
00008d98 g     F .text	0000003c micros
00000000  w      *UND*	00000000 __libc_fini
00008cac  w    F .text	00000006 cmp1_isr
00008cac  w    F .text	00000006 ftm0_isr
00004690 g     F .text	000000e0 ExFatFile::syncDir()
0000ff74 g     F .text	0000009c _malloc_trim_r
1fff13fe g     O .data	00000004 string0
000089dc g     F .text	000000e0 usb_serial_write
00008cc0  w    F .text	00000002 startup_late_hook
00000a5c  w    F .text	00000054 FsBaseFile::available() const
00009954  w    F .text	00000004 usb_serial_class::available()
1fff1378 g     O .data	00000001 _serialEvent_default
00005a40 g     F .text	00000080 FatFile::sync()
000004e8 g     F .text	0000014c acq_init(int)
000065d8 g     F .text	0000009c FatFile::cmpName(unsigned short, FatName_t*, unsigned char)
000029c0  w    F .text	0000004e SDClass::mkdir(char const*)
000044fe  w    F .text	00000026 ExFatPartition::cacheSync()
1fff13e8  w    O .data	00000016 usb_string_product_name
00008dd4 g     F .text	0000002a delay
0000a490 g     F .text	0000007a .hidden __nedf2
00008cac  w    F .text	00000006 tpm0_isr
1fff856a g     O .bss	00000002 dma_channel_allocated_mask
000038e6 g     F .text	00000020 ExFatFile::getModifyDateTime(unsigned short*, unsigned short*)
00000c00  w    F .text	00000028 FsBaseFile::seekSet(unsigned long long)
00012d1c g     F .fini	00000000 _fini
00000c80  w    F .text	00000014 FsBaseFile::sync()
0000273a g     F .text	00000026 TwoWire::write(unsigned char)
1fff7ecc g     O .bss	00000008 AudioOutputPT8211::dma
000120be g     O .text	0000002e SPISettings::ctar_div_table
0000746a g     F .text	00000030 SdSpiCard::readStart(unsigned long)
00004040 g     F .text	0000002e ExFatFile::openNext(ExFatFile*, int)
00007100 g     F .text	00000076 SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)
0000b658 g     F .text	0000004c sprintf
000099b8 g     F .text	0000001a Print::printf(char const*, ...)
00008cac  w    F .text	00000006 i2s0_rx_isr
00008cac  w    F .text	00000006 uart4_error_isr
00009a48 g     F .text	00000010 Print::print(long)
00005ac0 g     F .text	00000010 FatFile::close()
00000b74  w    F .text	00000014 SDFile::~SDFile()
0000efe0 g     F .text	0000000c atexit
00007928  w    F .text	00000002 SdioCard::~SdioCard()
00000baa  w    F .text	0000000a StreamFile<FsBaseFile, unsigned long long>::peek()
00000858  w    F .text	0000001c File::write(unsigned char)
0000eefc g     F .text	0000002c _write_r
1fff7f50 g     O .bss	000004c8 SD
00001354 g     F .text	0000012c breakTime(unsigned long, tmElements_t&)
00007bd0 g     F .text	000000d8 SdioCard::erase(unsigned long, unsigned long)
00006264  w    F .text	00000020 FsCache::clear()
00008cac  w    F .text	00000006 can0_message_isr
00009cbc g     F .text	0000000c nanf
1fff1840 g     O .data	00000004 _impure_ptr
00011c6c  w    O .text	00000024 vtable for Stream
00008cac  w    F .text	00000006 can1_message_isr
00003b2c g     F .text	0000002c ExFatFile::peek()
00011c90  w    O .text	00000024 vtable for StreamFile<FsBaseFile, unsigned long long>
1fff7f44 g     O .bss	00000008 AudioOutputSPDIF::dma
00010984 g     F .text	0000005c _mbrtowc_r
00008cac  w    F .text	00000006 nmi_isr
1fff10e0 g     O .data	0000013c Wire
00001838  w    F .text	00000060 SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)
00000d8e  w    F .text	0000000a SDFile::write(void const*, unsigned int)
00006ec0 g     F .text	00000028 FsVolume::open(char const*, int)
000078c8 g     F .text	0000000c SdioCard::errorCode() const
00005b78 g     F .text	0000000e FatFile::open(FatVolume*, char const*, int)
00000d6c  w    F .text	0000000a StreamFile<FsBaseFile, unsigned long long>::write(unsigned char const*, unsigned int)
1fff2238 g     O .bss	0000001c diskSize
00012cc8 g       .text	00000000 __preinit_array_end
000016a2 g     F .text	00000076 dateTime(unsigned short*, unsigned short*, unsigned char*)
00006f08  w    F .text	00000002 SdSpiCard::~SdSpiCard()
1fff7f24 g     O .bss	00000008 AudioInputTDM::dma
00008cac  w    F .text	00000006 sdhc_isr
00004398 g     F .text	000000cc ExFatPartition::init(BlockDeviceInterface*, unsigned char)
000041ba g     F .text	00000036 ExFatPartition::dirCache(DirPos_t*, unsigned char)
000075e8 g     F .text	00000092 SdSpiCard::erase(unsigned long, unsigned long)
0000b04c g     F .text	0000002a __ascii_mbtowc
00007004 g     F .text	00000032 SdSpiCard::isBusy()
00010fe0 g     F .text	00000054 __ulp
00012560 g     O .text	00000060 vtable for SdSpiCard
00007462  w    F .text	00000008 SdSpiCard::readCID(CID*)
00002722  w    F .text	00000016 TwoWire::peek()
00002738  w    F .text	00000002 TwoWire::flush()
000006f8 g     F .text	00000064 setup
00012850 g     O .text	00000054 usb_descriptor_list
00008fcc g     F .text	00000038 usb_rx
00007a44 g     F .text	00000004 SdioCard::status()
00008cac  w    F .text	00000006 dma_ch10_isr
00001718  w    F .text	00000014 MySpiClass::send(unsigned char const*, unsigned int)
00005bda g     F .text	00000020 FatFile::getModifyDateTime(unsigned short*, unsigned short*)
000007fc  w    F .text	00000002 Print::flush()
00000b16  w    F .text	00000012 FsBaseFile::isOpen() const
0000a60c g     F .text	00000040 .hidden __aeabi_d2uiz
00008cac  w    F .text	00000006 uart0_error_isr
00000ac4  w    F .text	00000020 FsBaseFile::isDir() const
00002916  w    F .text	00000054 SDClass::rmdir(char const*)
00011f9c  w    O .text	00000028 vtable for MySpiClass
00008f0c g     F .text	0000003c usb_malloc
00005610 g     F .text	00000178 FatFile::read(void*, unsigned int)
00008cac  w    F .text	00000006 i2s0_isr
000055b2 g     F .text	00000030 FatFile::openRoot(FatVolume*)
1fff841c g     O .bss	00000004 ExFatVolume::m_cwv
00001820  w    F .text	00000018 FsVolume::freeClusterCount() const
20030000 g       .bss	00000000 _estack
00006ee8 g     F .text	00000004 operator new(unsigned int, unsigned long*)
0000745a  w    F .text	00000008 SdSpiCard::readCSD(csd_t*)
000098b0 g     F .text	00000034 DMAChannel::release()
00000832  w    F .text	00000026 File::read()
00008ad4 g     F .text	00000048 usb_serial_write_buffer_free
00007176 g     F .text	00000028 SdSpiCard::waitNotBusy(unsigned short)
00006fde g     F .text	00000026 SdSpiCard::spiStop()
00008cac  w    F .text	00000006 enet_timer_isr
00006904 g     F .text	00000250 FatFile::open(FatFile*, FatName_t*, int)
0000a52c g     F .text	00000012 .hidden __aeabi_dcmpeq
00001480 g     F .text	000000c0 makeTime(tmElements_t const&)
1fff7f34 g     O .bss	00000008 AudioInputPDM::dma
00002760 g     F .text	00000038 TwoWire::write(unsigned char const*, unsigned int)
000009fc  w    F .text	00000014 File::~File()
000021b0 g     F .text	0000003c _write
1fff1dc0 g       .data	00000000 _edata
0000429c g     F .text	0000003a ExFatPartition::fatPut(unsigned long, unsigned long)
00007928  w    F .text	00000002 SdioCard::~SdioCard()
00008cac  w    F .text	00000006 i2s0_tx_isr
00008cac  w    F .text	00000006 adc1_isr
00003164 g     F .text	00000048 FsName::get16()
0000759c g     F .text	0000001c SdSpiCard::syncDevice()
00003818 g     F .text	00000062 ExFatFile::hashName(ExName_t*)
00005508 g     F .text	0000008c FatFile::addDirCluster()
00005bfa g     F .text	000000fa FatFile::mkdir(FatFile*, FatName_t*)
0000995c  w    F .text	00000004 usb_serial_class::availableForWrite()
00008cac  w    F .text	00000006 cmp0_isr
000017dc  w    F .text	00000020 MySpiClass::receive()
0000623a g     F .text	0000002a FatPartition::freeClusterCount_cb_fat32(unsigned long, unsigned char*, void*)
00009c7c g     F .text	00000040 ultoa
000028d0  w    F .text	00000002 SDClass::~SDClass()
00007238 g     F .text	000001b4 SdSpiCard::begin(SdSpiConfig)
00006d28 g     F .text	0000007e FsBaseFile::open(FsVolume*, char const*, int)
000098e4  w    F .text	0000000e MillisTimer::disableTimerInterrupt()
00009c04 g     F .text	00000004 operator new(unsigned int)
000098f8 g     F .text	0000003c EventResponder::runFromInterrupt()
00001070 g     F .text	00000084 printMenuEntries()
1fff1db8 g     O .data	00000004 __malloc_trim_threshold
0000994c  w    F .text	00000004 usb_serial_class::peek()
00010ecc g     F .text	00000114 __mdiff
00007918 g     F .text	00000010 SdioCard::readOCR(unsigned long*)
0000a5bc g     F .text	0000004e .hidden __aeabi_d2iz
00004258 g     F .text	00000044 ExFatPartition::dirSeek(DirPos_t*, unsigned long)
1fff8470 g     O .bss	00000001 usb_cdc_transmit_flush_timer
000053b8 g     F .text	000000f0 FatFile::getName8(char*, unsigned int)
00003c28 g     F .text	00000350 ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)
1fff8586 g     O .bss	00000002 AudioStream::cpu_cycles_total
00008cac  w    F .text	00000006 pit_isr
00007d04 g     F .text	00000088 SdioCard::writeStop()
00007762  w    F .text	0000001c SdSpiCard::writeSector(unsigned long, unsigned char const*)
000112c8 g     F .text	00000072 __sccl
000038b2 g     F .text	00000014 ExFatFile::close()
000129a8 g     O .text	00000101 _ctype_
00008cac  w    F .text	00000006 dac0_isr
00006ef4  w    F .text	00000010 SdSpiCard::readSector(unsigned long, unsigned char*)
00012cc8 g       .text	00000000 __init_array_start
0000aa00  w    F .text	00000002 .hidden __aeabi_idiv0
00008cac  w    F .text	00000006 can1_tx_warn_isr
0000a590 g     F .text	0000002c .hidden __unorddf2
1fff76b4 g     O .bss	00000004 disk_count
000031d4 g     F .text	00000042 ExFatFormatter::writeUpcaseByte(unsigned char)
00002de8 g     F .text	000001b0 FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)
00002a0e  w    F .text	00000068 SDClass::rename(char const*, char const*)
00008cac  w    F .text	00000006 uart0_status_isr
00006574 g     F .text	00000046 FatVolume::chdir(char const*)
000004bc g     F .text	00000018 acq_start()
00008cac  w    F .text	00000006 mcg_isr
00009b84 g     F .text	00000038 Stream::timedRead()
00000400 g     O .text	00000010 flashconfigbytes
0000b700 g     F .text	000000dc strlen
000055e2 g     F .text	0000002e FatFile::openCluster(FatFile*)
0000aaa0 g     F .text	00000006 __locale_ctype_ptr_l
00002af2  w    F .text	00000036 SdBase<FsVolume>::begin(SdioConfig)
0000a51c g     F .text	00000010 .hidden __aeabi_cdcmpeq
0000a480 g     F .text	0000008a .hidden __gedf2
000057ea g     F .text	000000ac FatFile::seekSet(unsigned long)
00006b54 g     F .text	00000098 FatFile::parsePathName(char const*, FatName_t*, char const**)
00010288 g     F .text	00000510 __gethex
1fff13e8 g     O .data	00000016 usb_string_product_name_default
1fff7f0c g     O .bss	00000008 AudioOutputI2SQuad::dma
0000eec8 g     F .text	00000018 vdprintf
00008cac  w    F .text	00000006 dma_ch1_isr
00007b6c g     F .text	00000064 SdioCard::sectorCount()
00006e04 g     F .text	000000bc FsVolume::begin(BlockDeviceInterface*)
0000172c  w    F .text	00000024 MySpiClass::receive(unsigned char*, unsigned int)
00009004 g     F .text	00000024 usb_tx_packet_count
00005958 g     F .text	00000098 FatFile::openNext(FatFile*, int)
1fff221c g     O .bss	0000001c diskSpace
00008d30  w    F .text	00000002 startup_middle_hook
000125c0 g     O .text	00000060 vtable for SdioCard
00009fb4 g     F .text	0000003a .hidden __aeabi_f2d
00008cac  w    F .text	00000006 dma_ch5_isr
000054a8 g     F .text	00000004 FatFile::getName(char*, unsigned int)
00008cac  w    F .text	00000006 can0_rx_warn_isr
00001898  w    F .text	0000000c SPISettings::SPISettings(unsigned long, unsigned char, unsigned char)
00008cac  w    F .text	00000006 can0_tx_warn_isr
00008cac  w    F .text	00000006 uart4_status_isr
000084fc g     F .text	00000074 SdioCard::readStart(unsigned long)
00000000  w      *UND*	00000000 _Jv_RegisterClasses
1fff7edc g     O .bss	00000008 AudioInputAnalog::dma
1fff8584 g     O .bss	00000002 AudioStream::cpu_cycles_total_max
000052ec  w    F .text	0000001a FatFile::cacheDir(unsigned short)
00009cf4 g     F .text	0000027a .hidden __subdf3
00001908 g     F .text	00000044 pullData(unsigned long*, unsigned long)
00012cc8 g       .text	00000000 __preinit_array_start
00004114 g     F .text	000000a6 ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)
00000d58  w    F .text	00000014 FsBaseFile::write(void const*, unsigned int)
1fff4eb4 g     O .bss	00002800 data_buffer
00010b98 g     F .text	0000005a __lo0bits
0000422e g     F .text	0000002a ExFatPartition::chainSize(unsigned long)
00005896 g     F .text	000000c2 FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)
00005f34 g     F .text	000000ae FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)
1fff0f60 g     O .data	00000004 stdPrint
00001576  w    F .text	00000038 BlockDeviceInterface::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)
00009cc8 g     F .text	0000000a __aeabi_atexit
00000000  w      *UND*	00000000 __register_frame_info
00008d04 g     F .text	0000000c rtc_get
000045b6 g     F .text	00000086 ExFatFile::remove()
00008cac  w    F .text	00000006 cmp2_isr
00009934 g     F .text	00000004 pendablesrvreq_isr
00002a96  w    F .text	00000026 SDClass::totalSize()
000007f8  w    F .text	00000004 Print::availableForWrite()
1fff1844 g     O .data	0000016c __global_locale
00008cac  w    F .text	00000006 wakeup_isr
000080dc g     F .text	0000035c SdioCard::begin(SdioConfig)
000038c6 g     F .text	00000020 ExFatFile::getCreateDateTime(unsigned short*, unsigned short*)
00008cac  w    F .text	00000006 cmp3_isr
000099d2 g     F .text	00000076 Print::printNumber(unsigned long, unsigned char, unsigned char)
00006284 g     F .text	0000006a FatPartition::fatGet(unsigned long, unsigned long*)
0000aacc g     F .text	00000010 free
00008cac  w    F .text	00000006 tpm2_isr
0000371c g     F .text	0000004c ExFatFile::cmpName(DirName_t const*, ExName_t*)
00010a40 g     F .text	00000080 __multadd
00010a2c g     F .text	00000012 _Bfree
00000a28  w    F .text	00000018 SDFile::size()
0000532e g     F .text	00000088 FatFile::getSFN(char*, unsigned int)
00008cac  w    F .text	00000006 dma_ch0_isr
00000b50  w    F .text	00000024 SDFile::~SDFile()
1fff1402  w    O .data	00000016 usb_string_serial_number
00008cac  w    F .text	00000006 enet_tx_isr
00008570 g     F .text	000000c4 SdioCard::readSector(unsigned long, unsigned char*)
000078fc g     F .text	0000001c SdioCard::readCSD(csd_t*)



Disassembly of section .text:

00000000 <_VectorsFlash>:
  return fsFmtTime(str, time);
}
//------------------------------------------------------------------------------
char* fsFmtTimeZone(char* str, int8_t tz) {
  char sign;
  if (tz & 0X80) {
       0:	... ........y...
    if (tz & 0X40) {
      sign = '-';
      10:	y...y...y...y...
    } else {
      sign = '+';
      tz &= 0X7F;
    }
    if (tz) {
      str = fsFmtField(str, 15*(tz%4), 0);
      20:	y...y...y.......
      30:	....y...5...9...
      str = fsFmtField(str, tz/4, ':');
      40:	................
      *--str = sign;
      50:	................
    }
    *--str = 'C';
    *--str = 'T';
    *--str = 'U';
      60:	................
      70:	................
      80:	................
      90:	................
      a0:	.(...(..........
      b0:	................
      c0:	................
      d0:	................
      e0:	................
      f0:	................
     100:	................
     110:	....!...........
     120:	................
     130:	................
     140:	................
     150:	................
     160:	.........(......
     170:	................
     180:	................
     190:	................
     1a0:	................
     1b0:	................
     1c0:	................

000001d0 <ResetHandler>:
	volatile int n;
#endif
	//volatile int count;

#ifdef KINETISK
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
     1d0:	ldr	r3, [pc, #356]	; (338 <ResetHandler+0x168>)
     1d2:	movw	r2, #50464	; 0xc520
#else
// hopefully all others fit into startup section (below 0x400)
__attribute__ ((section(".startup"),optimize("-Os")))
#endif
void ResetHandler(void)
{
     1d6:	push	{r4, lr}
	volatile int n;
#endif
	//volatile int count;

#ifdef KINETISK
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
     1d8:	strh	r2, [r3, #0]
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ2;
     1da:	movw	r2, #55592	; 0xd928
     1de:	strh	r2, [r3, #0]
	__asm__ volatile ("nop");
     1e0:	nop
	__asm__ volatile ("nop");
     1e2:	nop
#endif
	// programs using the watchdog timer or needing to initialize hardware as
	// early as possible can implement startup_early_hook()
	startup_early_hook();
     1e4:	bl	8cb4 <startup_early_hook>
#elif defined(__MK20DX256__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2;
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2 | SIM_SCGC3_FTM3;
     1e8:	ldr	r3, [pc, #336]	; (33c <ResetHandler+0x16c>)
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#endif
    
	// TODO: do this while the PLL is waiting to lock....
	while (dest < &_edata) *dest++ = *src++;
     1ea:	ldr	r1, [pc, #340]	; (340 <ResetHandler+0x170>)
#elif defined(__MK20DX256__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2;
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2 | SIM_SCGC3_FTM3;
     1ec:	mov.w	r2, #184549376	; 0xb000000
     1f0:	str	r2, [r3, #0]
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
     1f2:	ldr	r2, [pc, #336]	; (344 <ResetHandler+0x174>)
     1f4:	str	r2, [r3, #8]
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
     1f6:	ldr	r2, [pc, #336]	; (348 <ResetHandler+0x178>)
     1f8:	str	r2, [r3, #12]
	SIM_SCGC4 = SIM_SCGC4_USBOTG | 0xF0000030;
	SIM_SCGC5 = 0x00003F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_ADC0 | SIM_SCGC6_TPM0 | SIM_SCGC6_TPM1 | SIM_SCGC6_TPM2 | SIM_SCGC6_FTFL;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SCB_CPACR = 0x00F00000;
     1fa:	ldr	r3, [pc, #336]	; (34c <ResetHandler+0x17c>)
     1fc:	mov.w	r2, #15728640	; 0xf00000
     200:	str	r2, [r3, #0]
#endif
#if defined(__MK66FX1M0__)
	LMEM_PCCCR = 0x85000003;
     202:	ldr	r3, [pc, #332]	; (350 <ResetHandler+0x180>)
     204:	ldr	r2, [pc, #332]	; (354 <ResetHandler+0x184>)
     206:	str	r2, [r3, #0]
		RTC_SR = 0;
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
	}
#endif
	// release I/O pins hold, if we woke up from VLLS mode
	if (PMC_REGSC & PMC_REGSC_ACKISO) PMC_REGSC |= PMC_REGSC_ACKISO;
     208:	ldr	r3, [pc, #332]	; (358 <ResetHandler+0x188>)
     20a:	ldrb	r2, [r3, #0]
     20c:	lsls	r0, r2, #28
     20e:	ittt	mi
     210:	ldrbmi	r2, [r3, #0]
     212:	orrmi.w	r2, r2, #8
     216:	strbmi	r2, [r3, #0]

    // since this is a write once register, make it visible to all F_CPU's
    // so we can into other sleep modes in the future at any speed
#if defined(__MK66FX1M0__)
	SMC_PMPROT = SMC_PMPROT_AHSRUN | SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
     218:	ldr	r3, [pc, #320]	; (35c <ResetHandler+0x18c>)
     21a:	movs	r2, #170	; 0xaa
     21c:	strb	r2, [r3, #0]
     21e:	ldr	r2, [pc, #320]	; (360 <ResetHandler+0x190>)
     220:	ldr	r3, [pc, #320]	; (364 <ResetHandler+0x194>)
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#endif
    
	// TODO: do this while the PLL is waiting to lock....
	while (dest < &_edata) *dest++ = *src++;
     222:	cmp	r3, r1
     224:	bcs.n	230 <ResetHandler+0x60>
     226:	ldr.w	r0, [r2, #4]!
     22a:	str.w	r0, [r3], #4
     22e:	b.n	222 <ResetHandler+0x52>
     230:	ldr	r3, [pc, #308]	; (368 <ResetHandler+0x198>)
	dest = &_sbss;
	while (dest < &_ebss) *dest++ = 0;
     232:	ldr	r2, [pc, #312]	; (36c <ResetHandler+0x19c>)
     234:	movs	r1, #0
     236:	cmp	r3, r2
     238:	bcs.n	240 <ResetHandler+0x70>
     23a:	str.w	r1, [r3], #4
     23e:	b.n	236 <ResetHandler+0x66>

	// default all interrupts to medium priority level
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = _VectorsFlash[i];
     240:	ldr	r2, [pc, #300]	; (370 <ResetHandler+0x1a0>)
     242:	ldr	r0, [pc, #304]	; (374 <ResetHandler+0x1a4>)
     244:	movs	r3, #0
     246:	ldr.w	r1, [r0, r3, lsl #2]
     24a:	str.w	r1, [r2, r3, lsl #2]
     24e:	adds	r3, #1
     250:	cmp	r3, #116	; 0x74
     252:	bne.n	246 <ResetHandler+0x76>
     254:	ldr	r3, [pc, #288]	; (378 <ResetHandler+0x1a8>)
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
     256:	ldr	r2, [pc, #292]	; (37c <ResetHandler+0x1ac>)
     258:	movs	r1, #128	; 0x80
     25a:	strb.w	r1, [r3], #1
     25e:	cmp	r3, r2
     260:	bne.n	25a <ResetHandler+0x8a>
	SCB_VTOR = (uint32_t)_VectorsRam;	// use vector table in RAM
     262:	ldr	r3, [pc, #284]	; (380 <ResetHandler+0x1b0>)
     264:	ldr	r2, [pc, #264]	; (370 <ResetHandler+0x1a0>)
     266:	str	r2, [r3, #0]
	//  C6[PLLS] bit is written to 0
	//  C2[LP] bit is written to 1
#else
    #if defined(KINETISK)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
     268:	ldr	r3, [pc, #280]	; (384 <ResetHandler+0x1b4>)
     26a:	movs	r2, #138	; 0x8a
     26c:	strb	r2, [r3, #0]
    #elif defined(KINETISL)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
    #endif
	// enable osc, 8-32 MHz range, low power mode
	MCG_C2 = MCG_C2_RANGE0(2) | MCG_C2_EREFS;
     26e:	sub.w	r3, r3, #4096	; 0x1000
     272:	movs	r2, #36	; 0x24
     274:	strb	r2, [r3, #1]
	// switch to crystal as clock source, FLL input = 16 MHz / 512
	MCG_C1 =  MCG_C1_CLKS(2) | MCG_C1_FRDIV(4);
     276:	movs	r2, #160	; 0xa0
     278:	strb	r2, [r3, #0]
	// wait for crystal oscillator to begin
	while ((MCG_S & MCG_S_OSCINIT0) == 0) ;
     27a:	ldrb	r2, [r3, #6]
     27c:	lsls	r1, r2, #30
     27e:	bpl.n	27a <ResetHandler+0xaa>
	// wait for FLL to use oscillator
	while ((MCG_S & MCG_S_IREFST) != 0) ;
     280:	ldrb	r2, [r3, #6]
     282:	lsls	r2, r2, #27
     284:	bmi.n	280 <ResetHandler+0xb0>
	// wait for MCGOUT to use oscillator
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(2)) ;
     286:	ldr	r2, [pc, #256]	; (388 <ResetHandler+0x1b8>)
     288:	ldrb	r3, [r2, #6]
     28a:	and.w	r3, r3, #12
     28e:	cmp	r3, #8
     290:	ldr	r3, [pc, #244]	; (388 <ResetHandler+0x1b8>)
     292:	bne.n	288 <ResetHandler+0xb8>
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(2);
    #elif F_CPU == 120000000
	MCG_C5 = MCG_C5_PRDIV0(1);
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(14);
    #elif F_CPU == 96000000 || F_CPU == 48000000 || F_CPU == 24000000
	MCG_C5 = MCG_C5_PRDIV0(1);
     294:	movs	r2, #1
     296:	strb	r2, [r3, #4]
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(8);
     298:	movs	r2, #72	; 0x48
     29a:	strb	r2, [r3, #5]
    #error "This clock speed isn't supported..."
    #endif
   #endif

	// wait for PLL to start using xtal as its input
	while (!(MCG_S & MCG_S_PLLST)) ;
     29c:	ldrb	r2, [r3, #6]
     29e:	lsls	r4, r2, #26
     2a0:	bpl.n	29c <ResetHandler+0xcc>
	// wait for PLL to lock
	while (!(MCG_S & MCG_S_LOCK0)) ;
     2a2:	ldr	r1, [pc, #228]	; (388 <ResetHandler+0x1b8>)
     2a4:	ldrb	r2, [r1, #6]
     2a6:	ldr	r3, [pc, #224]	; (388 <ResetHandler+0x1b8>)
     2a8:	lsls	r0, r2, #25
     2aa:	bpl.n	2a4 <ResetHandler+0xd4>
	#endif
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(4) | SIM_CLKDIV2_USBFRAC;
#elif F_CPU == 96000000
	// config divisors: 96 MHz core, 48 MHz bus, 24 MHz flash, USB = 96 / 2
	#if F_BUS == 48000000
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(1) | SIM_CLKDIV1_OUTDIV4(3);
     2ac:	ldr	r2, [pc, #220]	; (38c <ResetHandler+0x1bc>)
     2ae:	ldr	r1, [pc, #224]	; (390 <ResetHandler+0x1c0>)
     2b0:	str	r1, [r2, #0]
	#elif F_BUS == 96000000
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(0) | SIM_CLKDIV1_OUTDIV4(3);
	#else
	#error "This F_CPU & F_BUS combination is not supported"
	#endif
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(1);
     2b2:	movs	r1, #2
     2b4:	str	r1, [r2, #4]
#error "Error, F_CPU must be 256, 240, 216, 192, 180, 168, 144, 120, 96, 72, 48, 24, 16, 8, 4, or 2 MHz"
#endif

#if F_CPU > 16000000
	// switch to PLL as clock source, FLL input = 16 MHz / 512
	MCG_C1 = MCG_C1_CLKS(0) | MCG_C1_FRDIV(4);
     2b6:	movs	r2, #32
     2b8:	strb	r2, [r3, #0]
	// wait for PLL clock to be used
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(3)) ;
     2ba:	ldrb	r2, [r3, #6]
     2bc:	and.w	r2, r2, #12
     2c0:	cmp	r2, #12
     2c2:	bne.n	2ba <ResetHandler+0xea>
	#if F_CPU == 256000000 || F_CPU == 216000000 || F_CPU == 180000000
	// USB uses IRC48
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_IRC48SEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);
	#else
	// USB uses PLL clock
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_PLLFLLSEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);
     2c4:	ldr	r3, [pc, #204]	; (394 <ResetHandler+0x1c4>)
     2c6:	ldr	r2, [pc, #208]	; (398 <ResetHandler+0x1c8>)
     2c8:	str	r2, [r3, #0]
#endif

#if defined(__MK66FX1M0__)
	// If the RTC oscillator isn't enabled, get it started.  For Teensy 3.6
	// we don't do this early.  See comment above about slow rising power.
	if (!(RTC_CR & RTC_CR_OSCE)) {
     2ca:	ldr	r2, [pc, #208]	; (39c <ResetHandler+0x1cc>)
     2cc:	ldr	r4, [pc, #208]	; (3a0 <ResetHandler+0x1d0>)
     2ce:	ldr	r3, [r2, #0]
     2d0:	ands.w	r3, r3, #256	; 0x100
		RTC_SR = 0;
     2d4:	ittt	eq
     2d6:	streq	r3, [r4, #0]
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
     2d8:	moveq.w	r3, #5376	; 0x1500
     2dc:	streq	r3, [r2, #0]
	}
#endif

	// initialize the SysTick counter
	SYST_RVR = (F_CPU / 1000) - 1;
     2de:	ldr	r3, [pc, #196]	; (3a4 <ResetHandler+0x1d4>)
     2e0:	ldr	r2, [pc, #196]	; (3a8 <ResetHandler+0x1d8>)
     2e2:	str	r2, [r3, #0]
	SYST_CVR = 0;
     2e4:	movs	r2, #0
     2e6:	str	r2, [r3, #4]
	SYST_CSR = SYST_CSR_CLKSOURCE | SYST_CSR_TICKINT | SYST_CSR_ENABLE;
     2e8:	movs	r2, #7
     2ea:	str.w	r2, [r3, #-4]
	SCB_SHPR3 = 0x20200000;  // Systick = priority 32
     2ee:	ldr	r2, [pc, #188]	; (3ac <ResetHandler+0x1dc>)
     2f0:	str.w	r2, [r3, #3340]	; 0xd0c

	//init_pins();
	__enable_irq();
     2f4:	cpsie	i

	_init_Teensyduino_internal_();
     2f6:	bl	8e00 <_init_Teensyduino_internal_>

#if defined(KINETISK)
	// RTC initialization
	if (RTC_SR & RTC_SR_TIF) {
     2fa:	ldr	r3, [r4, #0]
     2fc:	lsls	r2, r3, #31
     2fe:	bpl.n	30c <ResetHandler+0x13c>
		// compiled-in time will be stale.  Write a special
		// flag into the VBAT register file indicating the
		// RTC is set with known-stale time and should be
		// updated when fresh time is known.
		#if ARDUINO >= 10600
		rtc_set((uint32_t)&__rtc_localtime);
     300:	ldr	r0, [pc, #172]	; (3b0 <ResetHandler+0x1e0>)
     302:	bl	8d10 <rtc_set>
		#else
		rtc_set(TIME_T);
		#endif
		*(uint32_t *)0x4003E01C = 0x5A94C3A5;
     306:	ldr	r3, [pc, #172]	; (3b4 <ResetHandler+0x1e4>)
     308:	ldr	r2, [pc, #172]	; (3b8 <ResetHandler+0x1e8>)
     30a:	str	r2, [r3, #0]
	}
	if ((RCM_SRS0 & RCM_SRS0_PIN) && (*(uint32_t *)0x4003E01C == 0x5A94C3A5)) {
     30c:	ldr	r3, [pc, #172]	; (3bc <ResetHandler+0x1ec>)
     30e:	ldrb	r3, [r3, #0]
     310:	lsls	r3, r3, #25
     312:	bpl.n	328 <ResetHandler+0x158>
     314:	ldr	r4, [pc, #156]	; (3b4 <ResetHandler+0x1e4>)
     316:	ldr	r3, [pc, #160]	; (3b8 <ResetHandler+0x1e8>)
     318:	ldr	r2, [r4, #0]
     31a:	cmp	r2, r3
     31c:	bne.n	328 <ResetHandler+0x158>
		// Our compiled-in time will be very fresh, so set
		// the RTC with this, and clear the VBAT resister file
		// data so we don't mess with the time after it's been
		// set well.
		#if ARDUINO >= 10600
		rtc_set((uint32_t)&__rtc_localtime);
     31e:	ldr	r0, [pc, #144]	; (3b0 <ResetHandler+0x1e0>)
     320:	bl	8d10 <rtc_set>
		#else
		rtc_set(TIME_T);
		#endif
		*(uint32_t *)0x4003E01C = 0;
     324:	movs	r3, #0
     326:	str	r3, [r4, #0]
	}
#endif

	startup_late_hook();
     328:	bl	8cc0 <startup_late_hook>
	__libc_init_array();
     32c:	bl	aa1c <__libc_init_array>

	main();
     330:	bl	9afe <main>
     334:	b.n	334 <ResetHandler+0x164>
     336:	nop
     338:	.word	0x4005200e
     33c:	.word	0x40048030
     340:	.word	0x1fff1dc0
     344:	.word	0x00043f82
     348:	.word	0x2b000001
     34c:	.word	0xe000ed88
     350:	.word	0xe0082000
     354:	.word	0x85000003
     358:	.word	0x4007d002
     35c:	.word	0x4007e000
     360:	.word	0x00012d24
     364:	.word	0x1fff0f30
     368:	.word	0x1fff1dc0
     36c:	.word	0x1fff85f0
     370:	.word	0x1fff0a00
     374:	.word	0x00000000
     378:	.word	0xe000e400
     37c:	.word	0xe000e464
     380:	.word	0xe000ed08
     384:	.word	0x40065000
     388:	.word	0x40064000
     38c:	.word	0x40048044
     390:	.word	0x01030000
     394:	.word	0x40048004
     398:	.word	0x000510c0
     39c:	.word	0x4003d010
     3a0:	.word	0x4003d014
     3a4:	.word	0xe000e014
     3a8:	.word	0x000176ff
     3ac:	.word	0x20200000
     3b0:	.word	0x61f992f7
     3b4:	.word	0x4003e01c
     3b8:	.word	0x5a94c3a5
     3bc:	.word	0x4007f000
     3c0:	.word	0xffffffff
     3c4:	.word	0xffffffff
     3c8:	.word	0xffffffff
     3cc:	.word	0xffffffff
     3d0:	.word	0xffffffff
     3d4:	.word	0xffffffff
     3d8:	.word	0xffffffff
     3dc:	.word	0xffffffff
     3e0:	.word	0xffffffff
     3e4:	.word	0xffffffff
     3e8:	.word	0xffffffff
     3ec:	.word	0xffffffff
     3f0:	.word	0xffffffff
     3f4:	.word	0xffffffff
     3f8:	.word	0xffffffff
     3fc:	.word	0xffffffff

00000400 <flashconfigbytes>:
     400:	................

00000410 <__do_global_dtors_aux>:
     410:	push	{r4, lr}
     412:	ldr	r4, [pc, #20]	; (428 <__do_global_dtors_aux+0x18>)
     414:	ldrb	r3, [r4, #0]
     416:	cbnz	r3, 426 <__do_global_dtors_aux+0x16>
     418:	ldr	r3, [pc, #16]	; (42c <__do_global_dtors_aux+0x1c>)
     41a:	cbz	r3, 422 <__do_global_dtors_aux+0x12>
     41c:	ldr	r0, [pc, #16]	; (430 <__do_global_dtors_aux+0x20>)
     41e:	nop.w
     422:	movs	r3, #1
     424:	strb	r3, [r4, #0]
     426:	pop	{r4, pc}
     428:	.word	0x1fff1dc0
     42c:	.word	0x00000000
     430:	.word	0x00012d20

00000434 <frame_dummy>:
     434:	ldr	r3, [pc, #32]	; (458 <frame_dummy+0x24>)
     436:	push	{r4, lr}
     438:	cbz	r3, 442 <frame_dummy+0xe>
     43a:	ldr	r1, [pc, #32]	; (45c <frame_dummy+0x28>)
     43c:	ldr	r0, [pc, #32]	; (460 <frame_dummy+0x2c>)
     43e:	nop.w
     442:	ldr	r0, [pc, #32]	; (464 <frame_dummy+0x30>)
     444:	ldr	r3, [r0, #0]
     446:	cbnz	r3, 44a <frame_dummy+0x16>
     448:	pop	{r4, pc}
     44a:	ldr	r3, [pc, #28]	; (468 <frame_dummy+0x34>)
     44c:	cmp	r3, #0
     44e:	beq.n	448 <frame_dummy+0x14>
     450:	ldmia.w	sp!, {r4, lr}
     454:	bx	r3
     456:	nop
     458:	.word	0x00000000
     45c:	.word	0x1fff1dc4
     460:	.word	0x00012d20
     464:	.word	0x1fff1dc0
     468:	.word	0x00000000

0000046c <acq_stopClocks()>:
    const int32_t fsamp0=(((F_PLL*MCLK_MULT)/MCLK_DIV)/512);

    
    void acq_stopClocks(void)
    {
        SIM_SCGC6 &= ~SIM_SCGC6_DMAMUX;
     46c:	ldr	r3, [pc, #28]	; (48c <acq_stopClocks()+0x20>)
        SIM_SCGC7 &= ~SIM_SCGC7_DMA;
     46e:	ldr	r1, [pc, #32]	; (490 <acq_stopClocks()+0x24>)
    const int32_t fsamp0=(((F_PLL*MCLK_MULT)/MCLK_DIV)/512);

    
    void acq_stopClocks(void)
    {
        SIM_SCGC6 &= ~SIM_SCGC6_DMAMUX;
     470:	ldr	r2, [r3, #0]
     472:	bic.w	r2, r2, #2
     476:	str	r2, [r3, #0]
        SIM_SCGC7 &= ~SIM_SCGC7_DMA;
     478:	ldr	r2, [r1, #0]
     47a:	bic.w	r2, r2, #2
     47e:	str	r2, [r1, #0]
        SIM_SCGC6 &= ~SIM_SCGC6_I2S;
     480:	ldr	r2, [r3, #0]
     482:	bic.w	r2, r2, #32768	; 0x8000
     486:	str	r2, [r3, #0]
     488:	bx	lr
     48a:	nop
     48c:	.word	0x4004803c
     490:	.word	0x40048040

00000494 <acq_startClocks()>:
    }

    void acq_startClocks(void)
    {
    SIM_SCGC6 |= SIM_SCGC6_I2S;
     494:	ldr	r3, [pc, #28]	; (4b4 <acq_startClocks()+0x20>)
    SIM_SCGC7 |= SIM_SCGC7_DMA;
     496:	ldr	r1, [pc, #32]	; (4b8 <acq_startClocks()+0x24>)
        SIM_SCGC6 &= ~SIM_SCGC6_I2S;
    }

    void acq_startClocks(void)
    {
    SIM_SCGC6 |= SIM_SCGC6_I2S;
     498:	ldr	r2, [r3, #0]
     49a:	orr.w	r2, r2, #32768	; 0x8000
     49e:	str	r2, [r3, #0]
    SIM_SCGC7 |= SIM_SCGC7_DMA;
     4a0:	ldr	r2, [r1, #0]
     4a2:	orr.w	r2, r2, #2
     4a6:	str	r2, [r1, #0]
    SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
     4a8:	ldr	r2, [r3, #0]
     4aa:	orr.w	r2, r2, #2
     4ae:	str	r2, [r3, #0]
     4b0:	bx	lr
     4b2:	nop
     4b4:	.word	0x4004803c
     4b8:	.word	0x40048040

000004bc <acq_start()>:
    }

    void acq_start(void)
    {
     4bc:	push	{r3, lr}
        acq_startClocks();
     4be:	bl	494 <acq_startClocks()>
        //DMA_SERQ = dma.channel;
        I2S0_RCSR |= (I2S_RCSR_RE | I2S_RCSR_BCE);
     4c2:	ldr	r2, [pc, #12]	; (4d0 <acq_start()+0x14>)
     4c4:	ldr	r3, [r2, #0]
     4c6:	orr.w	r3, r3, #2415919104	; 0x90000000
     4ca:	str	r3, [r2, #0]
     4cc:	pop	{r3, pc}
     4ce:	nop
     4d0:	.word	0x4002f080

000004d4 <acq_stop()>:
    }

    void acq_stop(void)
    {
        I2S0_RCSR &= ~(I2S_RCSR_RE | I2S_RCSR_BCE);
     4d4:	ldr	r2, [pc, #12]	; (4e4 <acq_stop()+0x10>)
     4d6:	ldr	r3, [r2, #0]
     4d8:	bic.w	r3, r3, #2415919104	; 0x90000000
     4dc:	str	r3, [r2, #0]
        acq_stopClocks();
     4de:	b.w	46c <acq_stopClocks()>
     4e2:	nop
     4e4:	.word	0x4002f080

000004e8 <acq_init(int)>:
    }


    void acq_init(int fsamp)
    {
        Serial.printf("%d %d\n",fsamp,fsamp0);
     4e8:	mov	r2, r0
     4ea:	ldr	r3, [pc, #244]	; (5e0 <acq_init(int)+0xf8>)
     4ec:	ldr	r1, [pc, #244]	; (5e4 <acq_init(int)+0xfc>)
     4ee:	ldr	r0, [pc, #248]	; (5e8 <acq_init(int)+0x100>)
        acq_stopClocks();
    }


    void acq_init(int fsamp)
    {
     4f0:	push	{r4, lr}
        Serial.printf("%d %d\n",fsamp,fsamp0);
     4f2:	bl	99b8 <Print::printf(char const*, ...)>
//        SIM_SCGC6 |= SIM_SCGC6_I2S;
        acq_startClocks();
     4f6:	bl	494 <acq_startClocks()>

        #if I2S_CONFIG==0
            CORE_PIN39_CONFIG = PORT_PCR_MUX(6);  //pin39, PTA17, I2S0_MCLK
     4fa:	ldr	r3, [pc, #240]	; (5ec <acq_init(int)+0x104>)
     4fc:	mov.w	r2, #1536	; 0x600
     500:	str	r2, [r3, #0]
            CORE_PIN11_CONFIG = PORT_PCR_MUX(4);  //pin11, PTC6,  I2S0_RX_BCLK
     502:	ldr	r2, [pc, #236]	; (5f0 <acq_init(int)+0x108>)
     504:	mov.w	r3, #1024	; 0x400
     508:	str	r3, [r2, #0]
            CORE_PIN12_CONFIG = PORT_PCR_MUX(4);  //pin12, PTC7,  I2S0_RX_FS
     50a:	str	r3, [r2, #4]
            CORE_PIN13_CONFIG = PORT_PCR_MUX(4);  //pin13, PTC5,  I2S0_RXD0
     50c:	str.w	r3, [r2, #-4]
            CORE_PIN36_CONFIG = PORT_PCR_MUX(4);  //pin36, PTC9,   I2S0_RX_BCLK
            CORE_PIN37_CONFIG = PORT_PCR_MUX(4);  //pin37, PTC10,  I2S0_RX_FS
            CORE_PIN27_CONFIG = PORT_PCR_MUX(6);  //pin27, PTA15,  I2S0_RXD0
        #endif

        I2S0_RCSR=0;
     510:	sub.w	r2, r2, #114176	; 0x1be00
     514:	sub.w	r2, r2, #408	; 0x198
     518:	movs	r3, #0
     51a:	str	r3, [r2, #0]

        // enable MCLK output
        I2S0_MDR = I2S_MDR_FRACT((MCLK_MULT-1)) | I2S_MDR_DIVIDE((MCLK_DIV-1));
     51c:	ldr	r3, [pc, #212]	; (5f4 <acq_init(int)+0x10c>)
     51e:	movs	r1, #1
     520:	str	r1, [r3, #0]
        while(I2S0_MCR & I2S_MCR_DUF);
     522:	ldr	r1, [pc, #212]	; (5f8 <acq_init(int)+0x110>)
     524:	ldr	r3, [r1, #0]
     526:	cmp	r3, #0
     528:	blt.n	524 <acq_init(int)+0x3c>
        I2S0_MCR = I2S_MCR_MICS(MCLK_SRC) | I2S_MCR_MOE;
     52a:	ldr	r3, [pc, #204]	; (5f8 <acq_init(int)+0x110>)
        DMA_TCD0_SLAST = 0;
        
        DMA_TCD0_ATTR = DMA_TCD_ATTR_SSIZE(2) | DMA_TCD_ATTR_DSIZE(2);
        DMA_TCD0_NBYTES_MLNO = 4;
            
        DMA_TCD0_DADDR = tdm_rx_buffer;
     52c:	ldr	r4, [pc, #204]	; (5fc <acq_init(int)+0x114>)
        I2S0_RCSR=0;

        // enable MCLK output
        I2S0_MDR = I2S_MDR_FRACT((MCLK_MULT-1)) | I2S_MDR_DIVIDE((MCLK_DIV-1));
        while(I2S0_MCR & I2S_MCR_DUF);
        I2S0_MCR = I2S_MCR_MICS(MCLK_SRC) | I2S_MCR_MOE;
     52e:	mov.w	r1, #1124073472	; 0x43000000
     532:	str	r1, [r3, #0]
        
        I2S0_RMR=0; // enable receiver mask
     534:	ldr	r1, [pc, #200]	; (600 <acq_init(int)+0x118>)
     536:	movs	r3, #0
        I2S0_RCR1 = I2S_RCR1_RFW(3); 
     538:	movs	r0, #3
        // enable MCLK output
        I2S0_MDR = I2S_MDR_FRACT((MCLK_MULT-1)) | I2S_MDR_DIVIDE((MCLK_DIV-1));
        while(I2S0_MCR & I2S_MCR_DUF);
        I2S0_MCR = I2S_MCR_MICS(MCLK_SRC) | I2S_MCR_MOE;
        
        I2S0_RMR=0; // enable receiver mask
     53a:	str	r3, [r1, #0]
        I2S0_RCR1 = I2S_RCR1_RFW(3); 
     53c:	str.w	r0, [r1, #-92]

        I2S0_RCR2 = I2S_RCR2_SYNC(0) 
                    | I2S_RCR2_BCP ;
     540:	mov.w	r0, #33554432	; 0x2000000
     544:	str.w	r0, [r1, #-88]
                    
        I2S0_RCR3 = I2S_RCR3_RCE; // single rx channel
     548:	mov.w	r0, #65536	; 0x10000
     54c:	str.w	r0, [r1, #-84]

        I2S0_RCR4 = I2S_RCR4_FRSZ((NCHAN_I2S-1)) // 8 words (TDM - mode)
                    | I2S_RCR4_FSE  // frame sync early
                    | I2S_RCR4_MF;
     550:	adds	r0, #24
     552:	str.w	r0, [r1, #-80]
        #if ADC_MODEL == CS5361 
            I2S0_RCR4 |=  I2S_RCR4_SYWD(31);
     556:	ldr.w	r0, [r1, #-80]
     55a:	orr.w	r0, r0, #7936	; 0x1f00
     55e:	str.w	r0, [r1, #-80]
        #endif
        
        I2S0_RCR5 = I2S_RCR5_WNW(31) | I2S_RCR5_W0W(31) | I2S_RCR5_FBT(31);
     562:	ldr	r0, [pc, #160]	; (604 <acq_init(int)+0x11c>)
     564:	str.w	r0, [r1, #-76]
        // DMA 
//        SIM_SCGC7 |= SIM_SCGC7_DMA;
//        SIM_SCGC6 |= SIM_SCGC6_DMAMUX;

        DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG;
     568:	ldr	r1, [pc, #156]	; (608 <acq_init(int)+0x120>)
     56a:	movs	r0, #130	; 0x82
     56c:	str	r0, [r1, #0]
        DMA_CR |= DMA_CR_GRP1PRI;
     56e:	ldr	r0, [r1, #0]
     570:	orr.w	r0, r0, #1024	; 0x400
     574:	str	r0, [r1, #0]
        
        DMA_TCD0_SADDR = &I2S0_RDR0;
     576:	add.w	r1, r1, #4096	; 0x1000
     57a:	ldr	r0, [pc, #144]	; (60c <acq_init(int)+0x124>)
     57c:	str	r0, [r1, #0]
        DMA_TCD0_SOFF  = 0;
        DMA_TCD0_SLAST = 0;
        
        DMA_TCD0_ATTR = DMA_TCD_ATTR_SSIZE(2) | DMA_TCD_ATTR_DSIZE(2);
     57e:	movw	r0, #514	; 0x202

        DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG;
        DMA_CR |= DMA_CR_GRP1PRI;
        
        DMA_TCD0_SADDR = &I2S0_RDR0;
        DMA_TCD0_SOFF  = 0;
     582:	strh	r3, [r1, #4]
        DMA_TCD0_SLAST = 0;
     584:	str	r3, [r1, #12]
        
        DMA_TCD0_ATTR = DMA_TCD_ATTR_SSIZE(2) | DMA_TCD_ATTR_DSIZE(2);
     586:	strh	r0, [r1, #6]
        DMA_TCD0_NBYTES_MLNO = 4;
     588:	ldr	r0, [pc, #132]	; (610 <acq_init(int)+0x128>)
     58a:	movs	r1, #4
     58c:	str	r1, [r0, #0]
            
        DMA_TCD0_DADDR = tdm_rx_buffer;
     58e:	str	r4, [r0, #8]
        DMA_TCD0_DOFF = 4;
     590:	strh	r1, [r0, #12]
        DMA_TCD0_DLASTSGA = -sizeof(tdm_rx_buffer); // Bytes
     592:	ldr	r1, [pc, #128]	; (614 <acq_init(int)+0x12c>)
     594:	ldr	r0, [pc, #128]	; (618 <acq_init(int)+0x130>)
     596:	str	r0, [r1, #0]
            
        DMA_TCD0_CITER_ELINKNO = DMA_TCD0_BITER_ELINKNO = sizeof(tdm_rx_buffer)/4;
     598:	ldr	r0, [pc, #128]	; (61c <acq_init(int)+0x134>)
     59a:	mov.w	r1, #512	; 0x200
     59e:	strh	r1, [r0, #0]
     5a0:	strh.w	r1, [r0, #-8]
            
        DMA_TCD0_CSR = DMA_TCD_CSR_INTHALF | DMA_TCD_CSR_INTMAJOR;
     5a4:	ldr	r1, [pc, #120]	; (620 <acq_init(int)+0x138>)
     5a6:	movs	r0, #6
     5a8:	strh	r0, [r1, #0]
            
        DMAMUX0_CHCFG0 = DMAMUX_DISABLE;
     5aa:	add.w	r1, r1, #97792	; 0x17e00
     5ae:	add.w	r1, r1, #484	; 0x1e4
        DMAMUX0_CHCFG0 = DMAMUX_SOURCE_I2S0_RX | DMAMUX_ENABLE;
     5b2:	movs	r0, #140	; 0x8c
            
        DMA_TCD0_CITER_ELINKNO = DMA_TCD0_BITER_ELINKNO = sizeof(tdm_rx_buffer)/4;
            
        DMA_TCD0_CSR = DMA_TCD_CSR_INTHALF | DMA_TCD_CSR_INTMAJOR;
            
        DMAMUX0_CHCFG0 = DMAMUX_DISABLE;
     5b4:	strb	r3, [r1, #0]
        DMAMUX0_CHCFG0 = DMAMUX_SOURCE_I2S0_RX | DMAMUX_ENABLE;
     5b6:	strb	r0, [r1, #0]

        // partial start I2S
        I2S0_RCSR |= I2S_RCSR_FR | I2S_RCSR_FRDE;
     5b8:	ldr	r1, [r2, #0]
     5ba:	orr.w	r1, r1, #33554432	; 0x2000000
     5be:	orr.w	r1, r1, #1
     5c2:	str	r1, [r2, #0]

        //start DMA
        _VectorsRam[IRQ_DMA_CH0 + 16] = acq_isr;
     5c4:	ldr	r2, [pc, #92]	; (624 <acq_init(int)+0x13c>)
     5c6:	ldr	r1, [pc, #96]	; (628 <acq_init(int)+0x140>)
     5c8:	str	r1, [r2, #64]	; 0x40
        NVIC_SET_PRIORITY(IRQ_DMA_CH0, I2S_DMA_PRIO);
     5ca:	ldr	r2, [pc, #96]	; (62c <acq_init(int)+0x144>)
     5cc:	movs	r1, #80	; 0x50
     5ce:	strb	r1, [r2, #0]
        NVIC_ENABLE_IRQ(IRQ_DMA_CH0); 
     5d0:	sub.w	r2, r2, #768	; 0x300
     5d4:	movs	r1, #1
     5d6:	str	r1, [r2, #0]
        DMA_SERQ = 0;
     5d8:	ldr	r2, [pc, #84]	; (630 <acq_init(int)+0x148>)
     5da:	strb	r3, [r2, #0]
     5dc:	pop	{r4, pc}
     5de:	nop
     5e0:	.word	0x00016e36
     5e4:	.word	0x00011c24
     5e8:	.word	0x1fff1368
     5ec:	.word	0x40049044
     5f0:	.word	0x4004b018
     5f4:	.word	0x4002f104
     5f8:	.word	0x4002f100
     5fc:	.word	0x1fff0200
     600:	.word	0x4002f0e0
     604:	.word	0x1f1f1f00
     608:	.word	0x40008000
     60c:	.word	0x4002f0a0
     610:	.word	0x40009008
     614:	.word	0x40009018
     618:	.word	0xfffff800
     61c:	.word	0x4000901e
     620:	.word	0x4000901c
     624:	.word	0x1fff0a00
     628:	.word	0x00000655
     62c:	.word	0xe000e400
     630:	.word	0x4000801b

00000634 <extract(void*, void*)>:


    const int adc_shift=8;
    #if ACQ_MODEL == CS5361 // have stereo I2S
        void extract(void *out, void *inp)
        {   int32_t *dout = (int32_t *) out;
     634:	push	{r4, lr}
     636:	movs	r3, #0
            int32_t *din  = (int32_t *) inp;
            for(int ii=0; ii < NSAMP; ii++)
            {   dout[0+ii*NCHAN_ACQ] = din[0+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
     638:	ldr	r2, [r1, r3]
     63a:	asrs	r2, r2, #8
     63c:	str	r2, [r0, r3]
                dout[1+ii*NCHAN_ACQ] = din[1+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
     63e:	adds	r2, r1, r3
     640:	adds	r4, r0, r3
     642:	ldr	r2, [r2, #4]
     644:	adds	r3, #8
     646:	asrs	r2, r2, #8
    const int adc_shift=8;
    #if ACQ_MODEL == CS5361 // have stereo I2S
        void extract(void *out, void *inp)
        {   int32_t *dout = (int32_t *) out;
            int32_t *din  = (int32_t *) inp;
            for(int ii=0; ii < NSAMP; ii++)
     648:	cmp.w	r3, #1024	; 0x400
            {   dout[0+ii*NCHAN_ACQ] = din[0+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
                dout[1+ii*NCHAN_ACQ] = din[1+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
     64c:	str	r2, [r4, #4]
    const int adc_shift=8;
    #if ACQ_MODEL == CS5361 // have stereo I2S
        void extract(void *out, void *inp)
        {   int32_t *dout = (int32_t *) out;
            int32_t *din  = (int32_t *) inp;
            for(int ii=0; ii < NSAMP; ii++)
     64e:	bne.n	638 <extract(void*, void*)+0x4>
            {   dout[0+ii*NCHAN_ACQ] = din[0+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
                dout[1+ii*NCHAN_ACQ] = din[1+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
            }
        }
     650:	pop	{r4, pc}
     652:	Address 0x00000652 is out of bounds.


00000654 <acq_isr()>:
            }
        }
    #endif

    void acq_isr(void)
    {
     654:	push	{r3, lr}
        uint32_t daddr;
        uint32_t *src;

        //dma.clearInterrupt();
        #if defined(__MK66FX1M0__)
            DMA_CINT = 0;
     656:	ldr	r3, [pc, #56]	; (690 <acq_isr()+0x3c>)

        #if IMXRT_CACHE_ENABLED >=1
            arm_dcache_delete((void*)src, sizeof(tdm_rx_buffer) / 2);
        #endif

        extract((void *) acq_rx_buffer, (void *) src);
     658:	ldr	r0, [pc, #56]	; (694 <acq_isr()+0x40>)
        uint32_t daddr;
        uint32_t *src;

        //dma.clearInterrupt();
        #if defined(__MK66FX1M0__)
            DMA_CINT = 0;
     65a:	movs	r2, #0
     65c:	strb	r2, [r3, #0]
            daddr = (uint32_t) DMA_TCD0_DADDR;
     65e:	ldr.w	r1, [r3, #4081]	; 0xff1
            daddr = (uint32_t) dma.destinationAddress();
            asm volatile("dsb");
        #endif


        if (daddr < ((uint32_t)tdm_rx_buffer + sizeof(tdm_rx_buffer) / 2)) {
     662:	ldr	r3, [pc, #52]	; (698 <acq_isr()+0x44>)
            // need to remove data from the second half
            src = &tdm_rx_buffer[NBUF_I2S];
        } else {
            // DMA is receiving to the second half of the buffer
            // need to remove data from the first half
            src = &tdm_rx_buffer[0];
     664:	sub.w	r2, r3, #1024	; 0x400

        #if IMXRT_CACHE_ENABLED >=1
            arm_dcache_delete((void*)src, sizeof(tdm_rx_buffer) / 2);
        #endif

        extract((void *) acq_rx_buffer, (void *) src);
     668:	cmp	r1, r3
     66a:	ite	cc
     66c:	movcc	r1, r3
     66e:	movcs	r1, r2
     670:	bl	634 <extract(void*, void*)>

        if(!pushData(acq_rx_buffer)) acq_miss++;
     674:	ldr	r0, [pc, #28]	; (694 <acq_isr()+0x40>)
     676:	bl	18d4 <pushData(unsigned long*)>
     67a:	cbnz	r0, 684 <acq_isr()+0x30>
     67c:	ldr	r2, [pc, #28]	; (69c <acq_isr()+0x48>)
     67e:	ldr	r3, [r2, #0]
     680:	adds	r3, #1
     682:	str	r3, [r2, #0]
        acq_count++;
     684:	ldr	r2, [pc, #24]	; (6a0 <acq_isr()+0x4c>)
     686:	ldr	r3, [r2, #0]
     688:	adds	r3, #1
     68a:	str	r3, [r2, #0]
     68c:	pop	{r3, pc}
     68e:	nop
     690:	.word	0x4000801f
     694:	.word	0x1fff1de4
     698:	.word	0x1fff0600
     69c:	.word	0x1fff1de0
     6a0:	.word	0x1fff1ddc

000006a4 <Print::println(char const*)>:
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
     6a4:	push	{r3, r4, r5, lr}
     6a6:	mov	r4, r0
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
     6a8:	mov	r0, r1
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
     6aa:	mov	r5, r1
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
     6ac:	bl	b700 <strlen>
     6b0:	ldr	r3, [r4, #0]
     6b2:	mov	r2, r0
     6b4:	mov	r1, r5
     6b6:	ldr	r3, [r3, #4]
     6b8:	mov	r0, r4
     6ba:	blx	r3
     6bc:	mov	r5, r0
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
     6be:	mov	r0, r4
     6c0:	bl	9998 <Print::println()>
     6c4:	add	r0, r5
     6c6:	pop	{r3, r4, r5, pc}

000006c8 <checkToCloseFile(short, unsigned long)>:

uint32_t t_start;

/* check if we should close file */
int16_t checkToCloseFile(int16_t status, uint32_t t_acq)
{ if((status == OPENED) || (status == RUNNING))
     6c8:	push	{r3, r4, r5, lr}
     6ca:	subs	r3, r0, #1
     6cc:	uxth	r3, r3
     6ce:	cmp	r3, #1
     6d0:	mov	r5, r0
     6d2:	mov	r4, r1
     6d4:	bhi.n	6ee <checkToCloseFile(short, unsigned long)+0x26>
  {
    //
    static uint32_t to =0;
    uint32_t tx=rtc_get();
     6d6:	bl	8d04 <rtc_get>
    tx %= t_acq;
    if(tx<to) status = DOCLOSE; // time wrapped, file must be closed
     6da:	ldr	r3, [pc, #24]	; (6f4 <checkToCloseFile(short, unsigned long)+0x2c>)
{ if((status == OPENED) || (status == RUNNING))
  {
    //
    static uint32_t to =0;
    uint32_t tx=rtc_get();
    tx %= t_acq;
     6dc:	udiv	r1, r0, r4
    if(tx<to) status = DOCLOSE; // time wrapped, file must be closed
     6e0:	ldr	r2, [r3, #0]
{ if((status == OPENED) || (status == RUNNING))
  {
    //
    static uint32_t to =0;
    uint32_t tx=rtc_get();
    tx %= t_acq;
     6e2:	mls	r0, r1, r4, r0
    if(tx<to) status = DOCLOSE; // time wrapped, file must be closed
     6e6:	cmp	r0, r2
     6e8:	it	cc
     6ea:	movcc	r5, #3
    to=tx;
     6ec:	str	r0, [r3, #0]
  } 
  return status;
}
     6ee:	mov	r0, r5
     6f0:	pop	{r3, r4, r5, pc}
     6f2:	nop
     6f4:	.word	0x1fff21e8

000006f8 <setup>:

void setup()
{
     6f8:	push	{r3, r4, r5, lr}
        uint8_t paritytype(void) { return usb_cdc_line_coding[1] >> 8; } // 0=none, 1=odd, 2=even
        uint8_t numbits(void) { return usb_cdc_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() { return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
		((uint32_t)(systick_millis_count - usb_cdc_line_rtsdtr_millis) >= 15);
     6fa:	ldr	r0, [pc, #68]	; (740 <setup+0x48>)
        uint8_t stopbits(void) { uint8_t b = usb_cdc_line_coding[1]; if (!b) b = 1; return b; }
        uint8_t paritytype(void) { return usb_cdc_line_coding[1] >> 8; } // 0=none, 1=odd, 2=even
        uint8_t numbits(void) { return usb_cdc_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() { return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
     6fc:	ldr	r4, [pc, #68]	; (744 <setup+0x4c>)
     6fe:	ldr	r5, [pc, #72]	; (748 <setup+0x50>)
		((uint32_t)(systick_millis_count - usb_cdc_line_rtsdtr_millis) >= 15);
     700:	ldr	r1, [pc, #72]	; (74c <setup+0x54>)
        uint8_t stopbits(void) { uint8_t b = usb_cdc_line_coding[1]; if (!b) b = 1; return b; }
        uint8_t paritytype(void) { return usb_cdc_line_coding[1] >> 8; } // 0=none, 1=odd, 2=even
        uint8_t numbits(void) { return usb_cdc_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() { return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
     702:	ldrb	r3, [r4, #0]
     704:	cmp	r3, #0
     706:	beq.n	702 <setup+0xa>
     708:	ldrb	r3, [r5, #0]
     70a:	lsls	r3, r3, #31
     70c:	bpl.n	702 <setup+0xa>
		((uint32_t)(systick_millis_count - usb_cdc_line_rtsdtr_millis) >= 15);
     70e:	ldr	r3, [r0, #0]
     710:	ldr	r2, [r1, #0]
        uint8_t stopbits(void) { uint8_t b = usb_cdc_line_coding[1]; if (!b) b = 1; return b; }
        uint8_t paritytype(void) { return usb_cdc_line_coding[1] >> 8; } // 0=none, 1=odd, 2=even
        uint8_t numbits(void) { return usb_cdc_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() { return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
     712:	subs	r3, r3, r2
     714:	cmp	r3, #14
     716:	bls.n	702 <setup+0xa>
  while(!Serial) continue;

  Serial.println("basic Sound Recorder Version: " __DATE__  " " __TIME__ );
     718:	ldr	r1, [pc, #52]	; (750 <setup+0x58>)
     71a:	ldr	r0, [pc, #56]	; (754 <setup+0x5c>)
     71c:	bl	6a4 <Print::println(char const*)>

  storage_configure();
     720:	bl	1984 <storage_configure()>
  
  adc_init();
     724:	bl	21ac <adc_init()>
  acq_init(FSAMP);
     728:	movw	r0, #48000	; 0xbb80
     72c:	bl	4e8 <acq_init(int)>

  acq_start(); 
     730:	bl	4bc <acq_start()>

  Serial.println("End of Setup");
     734:	ldr	r1, [pc, #32]	; (758 <setup+0x60>)
     736:	ldr	r0, [pc, #28]	; (754 <setup+0x5c>)
     738:	bl	6a4 <Print::println(char const*)>
     73c:	pop	{r3, r4, r5, pc}
     73e:	nop
     740:	.word	0x1fff8484
     744:	.word	0x1fff8567
     748:	.word	0x1fff8480
     74c:	.word	0x1fff85e0
     750:	.word	0x00011c2b
     754:	.word	0x1fff1368
     758:	.word	0x00011c5e

0000075c <loop>:
}

void loop()
{ static int16_t status=START_MODE; 
     75c:	push	{r0, r1, r4, r5, r6, lr}

  if(status==MUST_REBOOT) status=checkReboot(); // hapens only if microSD card write fails: reboot if space on disk
     75e:	ldr	r4, [pc, #132]	; (7e4 <loop+0x88>)
     760:	ldrsh.w	r3, [r4]
     764:	adds	r3, #2
     766:	bne.n	76e <loop+0x12>
     768:	bl	1cbc <checkReboot()>
     76c:	strh	r0, [r4, #0]

  // normal operation
  int16_t ch=menu();  // check if we have serial line command (0: no input; 1: start; -1: stop)
     76e:	bl	117c <menu()>

  if(ch>0 && status==STOPPED)  // was stopped, should run now 
     772:	cmp	r0, #0
     774:	ble.n	788 <loop+0x2c>
     776:	ldrsh.w	r3, [r4]
     77a:	adds	r3, #1
     77c:	bne.n	79c <loop+0x40>
  { 
    acq_start(); adcStatus();
     77e:	bl	4bc <acq_start()>
     782:	bl	21ae <adcStatus()>
     786:	b.n	79c <loop+0x40>
  }  
  
  if(ch<0 && status>=CLOSED)  // was running, should stop now
     788:	beq.n	79c <loop+0x40>
     78a:	ldrsh.w	r3, [r4]
     78e:	cmp	r3, #0
     790:	blt.n	7de <loop+0x82>
  { status=MUSTSTOP;  acq_stop();  
     792:	ldr	r3, [pc, #80]	; (7e4 <loop+0x88>)
     794:	movs	r2, #4
     796:	strh	r2, [r3, #0]
     798:	bl	4d4 <acq_stop()>
  } 

  if(status >= CLOSED) // CLOSED or HIGHER
     79c:	ldrsh.w	r0, [r4]
     7a0:	ldr	r5, [pc, #64]	; (7e4 <loop+0x88>)
     7a2:	cmp	r0, #0
     7a4:	blt.n	7de <loop+0x82>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     7a6:	ldr	r4, [pc, #64]	; (7e8 <loop+0x8c>)
     7a8:	ldr	r3, [r4, #0]
     7aa:	str	r3, [sp, #0]
  {
    uint32_t to=millis();
    status = checkToCloseFile(status, (uint32_t) t_acq); // check if we reached file size or aquisition time
     7ac:	ldr	r3, [pc, #60]	; (7ec <loop+0x90>)
	return ret;
     7ae:	ldr	r6, [sp, #0]
     7b0:	ldr	r1, [r3, #0]
     7b2:	bl	6c8 <checkToCloseFile(short, unsigned long)>
     7b6:	strh	r0, [r5, #0]
    //
    status = saveData(status);  
     7b8:	bl	1cc4 <saveData(short)>
     7bc:	strh	r0, [r5, #0]
    //
    uint32_t mc = getCount();
     7be:	bl	18bc <getCount()>
    if(mc>max_count) max_count=mc;
     7c2:	ldr	r2, [pc, #44]	; (7f0 <loop+0x94>)
     7c4:	ldr	r3, [r2, #0]
     7c6:	cmp	r0, r3
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     7c8:	ldr	r3, [r4, #0]
     7ca:	it	hi
     7cc:	strhi	r0, [r2, #0]
     7ce:	str	r3, [sp, #4]
    //
    uint32_t dt=millis()-to;
    if(max_write<dt) max_write=dt;
     7d0:	ldr	r2, [pc, #32]	; (7f4 <loop+0x98>)
	return ret;
     7d2:	ldr	r3, [sp, #4]
     7d4:	ldr	r1, [r2, #0]
    status = saveData(status);  
    //
    uint32_t mc = getCount();
    if(mc>max_count) max_count=mc;
    //
    uint32_t dt=millis()-to;
     7d6:	subs	r3, r3, r6
    if(max_write<dt) max_write=dt;
     7d8:	cmp	r3, r1
     7da:	it	hi
     7dc:	strhi	r3, [r2, #0]
  }
     7de:	add	sp, #8
     7e0:	pop	{r4, r5, r6, pc}
     7e2:	nop
     7e4:	.word	0x1fff0f34
     7e8:	.word	0x1fff8484
     7ec:	.word	0x1fff0f38
     7f0:	.word	0x1fff21ec
     7f4:	.word	0x1fff21e4

000007f8 <Print::availableForWrite()>:
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
	virtual size_t write(const uint8_t *buffer, size_t size);
	virtual int availableForWrite(void)		{ return 0; }
     7f8:	movs	r0, #0
     7fa:	bx	lr

000007fc <Print::flush()>:
	virtual void flush()				{ }
     7fc:	bx	lr

000007fe <File::write(unsigned char const*, unsigned int)>:
		return (f) ? f->read(buf, nbyte) : 0;
	}
	
	// override print version
	virtual size_t write(const uint8_t *buf, size_t size) {
		return (f) ? f->write((void*)buf, size) : 0;
     7fe:	ldr	r0, [r0, #16]
     800:	cbz	r0, 808 <File::write(unsigned char const*, unsigned int)+0xa>
     802:	ldr	r3, [r0, #0]
     804:	ldr	r3, [r3, #12]
     806:	bx	r3
	}
     808:	bx	lr

0000080a <File::available()>:

	size_t write(const void *buf, size_t size) {
		return (f) ? f->write(buf, size) : 0;
	}
	int available() {
		return (f) ? f->available() : 0;
     80a:	ldr	r0, [r0, #16]
     80c:	cbz	r0, 814 <File::available()+0xa>
     80e:	ldr	r3, [r0, #0]
     810:	ldr	r3, [r3, #16]
     812:	bx	r3
	}
     814:	bx	lr

00000816 <File::peek()>:
	int peek() {
		return (f) ? f->peek() : -1;
     816:	ldr	r0, [r0, #16]
     818:	cbz	r0, 820 <File::peek()+0xa>
     81a:	ldr	r3, [r0, #0]
     81c:	ldr	r3, [r3, #20]
     81e:	bx	r3
	}
     820:	mov.w	r0, #4294967295
     824:	bx	lr

00000826 <File::flush()>:
	void flush() {
		if (f) f->flush();
     826:	ldr	r0, [r0, #16]
     828:	cbz	r0, 830 <File::flush()+0xa>
     82a:	ldr	r3, [r0, #0]
     82c:	ldr	r3, [r3, #24]
     82e:	bx	r3
     830:	bx	lr

00000832 <File::read()>:
		return (f) ? f->setModifyTime(tm) : false;
	}
	bool seek(uint64_t pos) {
		return seek(pos, SeekSet);
	}
	int read() {
     832:	push	{r0, r1, r2, lr}
		if (!f) return -1;
     834:	ldr	r0, [r0, #16]
     836:	cbnz	r0, 83e <File::read()+0xc>
     838:	mov.w	r0, #4294967295
     83c:	b.n	852 <File::read()+0x20>
		unsigned char b;
		if (f->read(&b, 1) < 1) return -1;
     83e:	ldr	r3, [r0, #0]
     840:	movs	r2, #1
     842:	ldr	r3, [r3, #8]
     844:	add.w	r1, sp, #7
     848:	blx	r3
     84a:	cmp	r0, #0
     84c:	beq.n	838 <File::read()+0x6>
		return b;
     84e:	ldrb.w	r0, [sp, #7]
	}
     852:	add	sp, #12
     854:	ldr.w	pc, [sp], #4

00000858 <File::write(unsigned char)>:
	size_t write(uint8_t b) {
     858:	push	{r0, r1, r2, lr}
		return (f) ? f->write(&b, 1) : 0;
     85a:	ldr	r0, [r0, #16]
		if (!f) return -1;
		unsigned char b;
		if (f->read(&b, 1) < 1) return -1;
		return b;
	}
	size_t write(uint8_t b) {
     85c:	strb.w	r1, [sp, #7]
		return (f) ? f->write(&b, 1) : 0;
     860:	cbz	r0, 86e <File::write(unsigned char)+0x16>
     862:	ldr	r3, [r0, #0]
     864:	movs	r2, #1
     866:	ldr	r3, [r3, #12]
     868:	add.w	r1, sp, #7
     86c:	blx	r3
	}
     86e:	add	sp, #12
     870:	ldr.w	pc, [sp], #4

00000874 <SDFile::getCreateTime(DateTimeFields&)>:
		return File();
	}
	virtual void rewindDirectory(void) {
		sdfatfile.rewindDirectory();
	}
	virtual bool getCreateTime(DateTimeFields &tm) {
     874:	push	{r0, r1, r4, lr}
     876:	mov	r3, r0
   * \param[out] ptime Packed time for directory entry.
   *
   * \return true for success or false for failure.
   */
  bool getCreateDateTime(uint16_t* pdate, uint16_t* ptime) {
    return m_fFile ? m_fFile->getCreateDateTime(pdate, ptime) :
     878:	ldr	r0, [r0, #80]	; 0x50
     87a:	mov	r4, r1
           m_xFile ? m_xFile->getCreateDateTime(pdate, ptime) : false;
     87c:	cbz	r0, 88a <SDFile::getCreateTime(DateTimeFields&)+0x16>
     87e:	add.w	r2, sp, #6
     882:	add	r1, sp, #4
     884:	bl	5bba <FatFile::getCreateDateTime(unsigned short*, unsigned short*)>
     888:	b.n	89c <SDFile::getCreateTime(DateTimeFields&)+0x28>
     88a:	ldr	r0, [r3, #84]	; 0x54
     88c:	cbnz	r0, 892 <SDFile::getCreateTime(DateTimeFields&)+0x1e>
		uint16_t fat_date, fat_time;
		if (!sdfatfile.getCreateDateTime(&fat_date, &fat_time)) return false;
     88e:	movs	r0, #0
     890:	b.n	8d6 <SDFile::getCreateTime(DateTimeFields&)+0x62>
     892:	add.w	r2, sp, #6
     896:	add	r1, sp, #4
     898:	bl	38c6 <ExFatFile::getCreateDateTime(unsigned short*, unsigned short*)>
     89c:	cmp	r0, #0
     89e:	beq.n	88e <SDFile::getCreateTime(DateTimeFields&)+0x1a>
		if ((fat_date == 0) && (fat_time == 0)) return false;
     8a0:	ldrh.w	r3, [sp, #4]
     8a4:	ldrh.w	r2, [sp, #6]
     8a8:	cbnz	r3, 8ae <SDFile::getCreateTime(DateTimeFields&)+0x3a>
     8aa:	cmp	r2, #0
     8ac:	beq.n	88e <SDFile::getCreateTime(DateTimeFields&)+0x1a>
		tm.sec = FS_SECOND(fat_time);
     8ae:	and.w	r1, r2, #31
     8b2:	lsls	r1, r1, #1
     8b4:	strb	r1, [r4, #0]
		tm.min = FS_MINUTE(fat_time);
     8b6:	ubfx	r1, r2, #5, #6
		tm.hour = FS_HOUR(fat_time);
     8ba:	asrs	r2, r2, #11
     8bc:	strb	r2, [r4, #2]
		tm.mday = FS_DAY(fat_date);
     8be:	and.w	r2, r3, #31
     8c2:	strb	r2, [r4, #4]
		tm.mon = FS_MONTH(fat_date) - 1;
     8c4:	ubfx	r2, r3, #5, #4
		tm.year = FS_YEAR(fat_date) - 1900;
     8c8:	asrs	r3, r3, #9
		if ((fat_date == 0) && (fat_time == 0)) return false;
		tm.sec = FS_SECOND(fat_time);
		tm.min = FS_MINUTE(fat_time);
		tm.hour = FS_HOUR(fat_time);
		tm.mday = FS_DAY(fat_date);
		tm.mon = FS_MONTH(fat_date) - 1;
     8ca:	subs	r2, #1
		tm.year = FS_YEAR(fat_date) - 1900;
     8cc:	add.w	r3, r3, #1872	; 0x750
	virtual bool getCreateTime(DateTimeFields &tm) {
		uint16_t fat_date, fat_time;
		if (!sdfatfile.getCreateDateTime(&fat_date, &fat_time)) return false;
		if ((fat_date == 0) && (fat_time == 0)) return false;
		tm.sec = FS_SECOND(fat_time);
		tm.min = FS_MINUTE(fat_time);
     8d0:	strb	r1, [r4, #1]
		tm.hour = FS_HOUR(fat_time);
		tm.mday = FS_DAY(fat_date);
		tm.mon = FS_MONTH(fat_date) - 1;
     8d2:	strb	r2, [r4, #5]
		tm.year = FS_YEAR(fat_date) - 1900;
     8d4:	strb	r3, [r4, #6]
		return true;
	}
     8d6:	add	sp, #8
     8d8:	pop	{r4, pc}

000008da <SDFile::getModifyTime(DateTimeFields&)>:
	virtual bool getModifyTime(DateTimeFields &tm) {
     8da:	push	{r0, r1, r4, lr}
     8dc:	mov	r3, r0
   * \param[out] ptime Packed time for directory entry.
   *
   * \return true for success or false for failure.
   */
  bool getModifyDateTime(uint16_t* pdate, uint16_t* ptime) {
    return m_fFile ? m_fFile->getModifyDateTime(pdate, ptime) :
     8de:	ldr	r0, [r0, #80]	; 0x50
     8e0:	mov	r4, r1
           m_xFile ? m_xFile->getModifyDateTime(pdate, ptime) : false;
     8e2:	cbz	r0, 8f0 <SDFile::getModifyTime(DateTimeFields&)+0x16>
     8e4:	add.w	r2, sp, #6
     8e8:	add	r1, sp, #4
     8ea:	bl	5bda <FatFile::getModifyDateTime(unsigned short*, unsigned short*)>
     8ee:	b.n	902 <SDFile::getModifyTime(DateTimeFields&)+0x28>
     8f0:	ldr	r0, [r3, #84]	; 0x54
     8f2:	cbnz	r0, 8f8 <SDFile::getModifyTime(DateTimeFields&)+0x1e>
		uint16_t fat_date, fat_time;
		if (!sdfatfile.getModifyDateTime(&fat_date, &fat_time)) return false;
     8f4:	movs	r0, #0
     8f6:	b.n	93c <SDFile::getModifyTime(DateTimeFields&)+0x62>
     8f8:	add.w	r2, sp, #6
     8fc:	add	r1, sp, #4
     8fe:	bl	38e6 <ExFatFile::getModifyDateTime(unsigned short*, unsigned short*)>
     902:	cmp	r0, #0
     904:	beq.n	8f4 <SDFile::getModifyTime(DateTimeFields&)+0x1a>
		if ((fat_date == 0) && (fat_time == 0)) return false;
     906:	ldrh.w	r3, [sp, #4]
     90a:	ldrh.w	r2, [sp, #6]
     90e:	cbnz	r3, 914 <SDFile::getModifyTime(DateTimeFields&)+0x3a>
     910:	cmp	r2, #0
     912:	beq.n	8f4 <SDFile::getModifyTime(DateTimeFields&)+0x1a>
		tm.sec = FS_SECOND(fat_time);
     914:	and.w	r1, r2, #31
     918:	lsls	r1, r1, #1
     91a:	strb	r1, [r4, #0]
		tm.min = FS_MINUTE(fat_time);
     91c:	ubfx	r1, r2, #5, #6
		tm.hour = FS_HOUR(fat_time);
     920:	asrs	r2, r2, #11
     922:	strb	r2, [r4, #2]
		tm.mday = FS_DAY(fat_date);
     924:	and.w	r2, r3, #31
     928:	strb	r2, [r4, #4]
		tm.mon = FS_MONTH(fat_date) - 1;
     92a:	ubfx	r2, r3, #5, #4
		tm.year = FS_YEAR(fat_date) - 1900;
     92e:	asrs	r3, r3, #9
		if ((fat_date == 0) && (fat_time == 0)) return false;
		tm.sec = FS_SECOND(fat_time);
		tm.min = FS_MINUTE(fat_time);
		tm.hour = FS_HOUR(fat_time);
		tm.mday = FS_DAY(fat_date);
		tm.mon = FS_MONTH(fat_date) - 1;
     930:	subs	r2, #1
		tm.year = FS_YEAR(fat_date) - 1900;
     932:	add.w	r3, r3, #1872	; 0x750
	virtual bool getModifyTime(DateTimeFields &tm) {
		uint16_t fat_date, fat_time;
		if (!sdfatfile.getModifyDateTime(&fat_date, &fat_time)) return false;
		if ((fat_date == 0) && (fat_time == 0)) return false;
		tm.sec = FS_SECOND(fat_time);
		tm.min = FS_MINUTE(fat_time);
     936:	strb	r1, [r4, #1]
		tm.hour = FS_HOUR(fat_time);
		tm.mday = FS_DAY(fat_date);
		tm.mon = FS_MONTH(fat_date) - 1;
     938:	strb	r2, [r4, #5]
		tm.year = FS_YEAR(fat_date) - 1900;
     93a:	strb	r3, [r4, #6]
		return true;
	}
     93c:	add	sp, #8
     93e:	pop	{r4, pc}

00000940 <SDFile::name()>:
		}
	}
	virtual bool isOpen() {
		return sdfatfile.isOpen();
	}
	virtual const char * name() {
     940:	push	{r3, r4, r5, lr}
		if (!filename) {
     942:	ldr	r5, [r0, #88]	; 0x58
		}
	}
	virtual bool isOpen() {
		return sdfatfile.isOpen();
	}
	virtual const char * name() {
     944:	mov	r4, r0
		if (!filename) {
     946:	cbnz	r5, 978 <SDFile::name()+0x38>
			filename = (char *)malloc(MAX_FILENAME_LEN);
     948:	mov.w	r0, #256	; 0x100
     94c:	bl	aabc <malloc>
     950:	mov	r1, r0
     952:	str	r0, [r4, #88]	; 0x58
			if (filename) {
     954:	cbz	r0, 974 <SDFile::name()+0x34>
   *             must be at least 13 bytes long.  The file's name will be
   *             truncated if the file's name is too long.
   * \return The length of the returned string.
   */
  size_t getName(char* name, size_t len) {
    *name = 0;
     956:	strb	r5, [r0, #0]
    return m_fFile ? m_fFile->getName(name, len) :
     958:	ldr	r0, [r4, #80]	; 0x50
           m_xFile ? m_xFile->getName(name, len) : 0;
     95a:	cbz	r0, 966 <SDFile::name()+0x26>
     95c:	mov.w	r2, #256	; 0x100
     960:	bl	54a8 <FatFile::getName(char*, unsigned int)>
     964:	b.n	978 <SDFile::name()+0x38>
     966:	ldr	r0, [r4, #84]	; 0x54
     968:	cbz	r0, 978 <SDFile::name()+0x38>
   * \param[in] size The size of the array in characters.
   * \return the name length.
   */
  size_t getName(char* name, size_t size) {
#if USE_UTF8_LONG_NAMES
    return getName8(name, size);
     96a:	mov.w	r2, #256	; 0x100
     96e:	bl	3768 <ExFatFile::getName8(char*, unsigned int)>
     972:	b.n	978 <SDFile::name()+0x38>
				sdfatfile.getName(filename, MAX_FILENAME_LEN);
			} else {
				static char zeroterm = 0;
				filename = &zeroterm;
     974:	ldr	r3, [pc, #4]	; (97c <SDFile::name()+0x3c>)
     976:	str	r3, [r4, #88]	; 0x58
			}
		}
		return filename;
	}
     978:	ldr	r0, [r4, #88]	; 0x58
     97a:	pop	{r3, r4, r5, pc}
     97c:	.word	0x1fff21f0

00000980 <SDFile::truncate(unsigned long long)>:
		sdfatfile.flush();
	}
	virtual size_t read(void *buf, size_t nbyte) {
		return sdfatfile.read(buf, nbyte);
	}
	virtual bool truncate(uint64_t size=0) {
     980:	push	{r4, r6, r7, lr}
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return m_fFile ? length < (1ULL << 32) && m_fFile->truncate(length) :
     982:	ldr	r4, [r0, #80]	; 0x50
           m_xFile ? m_xFile->truncate(length) : false;
     984:	cbz	r4, 9a2 <SDFile::truncate(unsigned long long)+0x22>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return m_fFile ? length < (1ULL << 32) && m_fFile->truncate(length) :
     986:	cmp	r3, #1
     988:	it	eq
     98a:	cmpeq	r2, #0
     98c:	bcs.n	9b8 <SDFile::truncate(unsigned long long)+0x38>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint32_t length) {
    return seekSet(length) && truncate();
     98e:	mov	r1, r2
     990:	mov	r0, r4
     992:	bl	57ea <FatFile::seekSet(unsigned long)>
     996:	cbz	r0, 9b8 <SDFile::truncate(unsigned long long)+0x38>
     998:	mov	r0, r4
     99a:	bl	5fe2 <FatFile::truncate()>
     99e:	cbz	r0, 9b8 <SDFile::truncate(unsigned long long)+0x38>
     9a0:	pop	{r4, r6, r7, pc}
           m_xFile ? m_xFile->truncate(length) : false;
     9a2:	ldr	r4, [r0, #84]	; 0x54
     9a4:	cbz	r4, 9b8 <SDFile::truncate(unsigned long long)+0x38>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return seekSet(length) && truncate();
     9a6:	mov	r0, r4
     9a8:	bl	3b58 <ExFatFile::seekSet(unsigned long long)>
     9ac:	cbz	r0, 9b8 <SDFile::truncate(unsigned long long)+0x38>
     9ae:	mov	r0, r4
		return sdfatfile.truncate(size);
	}
     9b0:	ldmia.w	sp!, {r4, r6, r7, lr}
     9b4:	b.w	4b4a <ExFatFile::truncate()>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return m_fFile ? length < (1ULL << 32) && m_fFile->truncate(length) :
     9b8:	movs	r0, #0
     9ba:	pop	{r4, r6, r7, pc}

000009bc <File::dec_refcount() [clone .isra.15]>:
	size_t write(long n) { return write((uint8_t)n); }
	size_t write(unsigned int n) { return write((uint8_t)n); }
	size_t write(int n) { return write((uint8_t)n); }
	using Print::write;
private:
	void dec_refcount() {
     9bc:	push	{r4, lr}
     9be:	mov	r4, r0
		if (--(f->refcount) == 0) {
     9c0:	ldr	r0, [r0, #0]
     9c2:	ldr	r3, [r0, #4]
     9c4:	subs	r3, #1
     9c6:	str	r3, [r0, #4]
     9c8:	cbnz	r3, 9da <File::dec_refcount() [clone .isra.15]+0x1e>
			f->close();
     9ca:	ldr	r3, [r0, #0]
     9cc:	ldr	r3, [r3, #44]	; 0x2c
     9ce:	blx	r3
			delete f;
     9d0:	ldr	r0, [r4, #0]
     9d2:	cbz	r0, 9da <File::dec_refcount() [clone .isra.15]+0x1e>
     9d4:	ldr	r3, [r0, #0]
     9d6:	ldr	r3, [r3, #4]
     9d8:	blx	r3
		}
		f = nullptr;
     9da:	movs	r3, #0
     9dc:	str	r3, [r4, #0]
     9de:	pop	{r4, pc}

000009e0 <File::~File()>:
		if (f) { dec_refcount(); /*Serial.println("File move assignment autoclose");*/ }
		f = file.f;
		return *this;
	}
#endif
	virtual ~File() {
     9e0:	ldr	r3, [pc, #20]	; (9f8 <File::~File()+0x18>)
     9e2:	push	{r4, lr}
     9e4:	str	r3, [r0, #0]
		//Serial.printf("File dtor %x, refcount=%d\n", (int)f, get_refcount());
		if (f) dec_refcount();
     9e6:	ldr	r3, [r0, #16]
		if (f) { dec_refcount(); /*Serial.println("File move assignment autoclose");*/ }
		f = file.f;
		return *this;
	}
#endif
	virtual ~File() {
     9e8:	mov	r4, r0
		//Serial.printf("File dtor %x, refcount=%d\n", (int)f, get_refcount());
		if (f) dec_refcount();
     9ea:	cbz	r3, 9f2 <File::~File()+0x12>
     9ec:	adds	r0, #16
     9ee:	bl	9bc <File::dec_refcount() [clone .isra.15]>
	}
     9f2:	mov	r0, r4
     9f4:	pop	{r4, pc}
     9f6:	nop
     9f8:	.word	0x00011ce0

000009fc <File::~File()>:
		if (f) { dec_refcount(); /*Serial.println("File move assignment autoclose");*/ }
		f = file.f;
		return *this;
	}
#endif
	virtual ~File() {
     9fc:	push	{r4, lr}
     9fe:	mov	r4, r0
		//Serial.printf("File dtor %x, refcount=%d\n", (int)f, get_refcount());
		if (f) dec_refcount();
	}
     a00:	bl	9e0 <File::~File()>
     a04:	mov	r0, r4
     a06:	movs	r1, #20
     a08:	bl	9c08 <operator delete(void*, unsigned int)>
     a0c:	mov	r0, r4
     a0e:	pop	{r4, pc}

00000a10 <SDFile::position()>:
    return m_fFile ? m_fFile->contiguousRange(bgnSector, endSector) :
           m_xFile ? m_xFile->contiguousRange(bgnSector, endSector) : false;
  }
  /** \return The current position for a file or directory. */
  uint64_t curPosition() const {
    return m_fFile ? m_fFile->curPosition() :
     a10:	ldr	r3, [r0, #80]	; 0x50
           m_xFile ? m_xFile->curPosition() : 0;
     a12:	cbz	r3, a1a <SDFile::position()+0xa>
     a14:	ldr	r0, [r3, #20]
     a16:	movs	r1, #0
     a18:	bx	lr
     a1a:	ldr	r3, [r0, #84]	; 0x54
     a1c:	cbz	r3, a24 <SDFile::position()+0x14>
   *
   * \return true for success or false for failure.
   */
  bool contiguousRange(uint32_t* bgnSector, uint32_t* endSector);
  /** \return The current position for a file or directory. */
  uint64_t curPosition() const {return m_curPosition;}
     a1e:	ldmia.w	r3, {r0, r1}
     a22:	bx	lr
     a24:	mov	r0, r3
     a26:	b.n	a16 <SDFile::position()+0x6>

00000a28 <SDFile::size()>:
    return m_fFile ? m_fFile->fgets(str, num, delim) :
           m_xFile ? m_xFile->fgets(str, num, delim) : -1;
  }
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {
    return m_fFile ? m_fFile->fileSize() :
     a28:	ldr	r3, [r0, #80]	; 0x50
           m_xFile ? m_xFile->fileSize() : 0;
     a2a:	cbz	r3, a32 <SDFile::size()+0xa>
     a2c:	ldr	r0, [r3, #28]
     a2e:	movs	r1, #0
     a30:	bx	lr
     a32:	ldr	r3, [r0, #84]	; 0x54
     a34:	cbz	r3, a3c <SDFile::size()+0x14>
   * If no data is read, fgets() returns zero for EOF or -1 if an error
   * occurred.
   */
  int fgets(char* str, int num, char* delim = nullptr);
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {return m_validLength;}
     a36:	ldr	r0, [r3, #16]
     a38:	ldr	r1, [r3, #20]
     a3a:	bx	lr
     a3c:	mov	r0, r3
     a3e:	b.n	a2e <SDFile::size()+0x6>

00000a40 <Print::write(char const*)>:
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
     a40:	push	{r4, r5, r6, lr}
     a42:	mov	r4, r0
     a44:	mov	r0, r1
     a46:	mov	r5, r1
     a48:	bl	b700 <strlen>
     a4c:	ldr	r3, [r4, #0]
     a4e:	mov	r2, r0
     a50:	mov	r1, r5
     a52:	mov	r0, r4
     a54:	ldr	r3, [r3, #4]
     a56:	ldmia.w	sp!, {r4, r5, r6, lr}
     a5a:	bx	r3

00000a5c <FsBaseFile::available() const>:
  operator bool() const {return isOpen();}
  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() const {
    return m_fFile ? m_fFile->available() :
     a5c:	ldr	r2, [r0, #56]	; 0x38
    */
  operator bool() const {return isOpen();}
  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() const {
     a5e:	push	{r4, r5, lr}
    return m_fFile ? m_fFile->available() :
           m_xFile ? m_xFile->available() : 0;
     a60:	cbz	r2, a7c <FsBaseFile::available() const+0x20>
  }
  /** \return The number of bytes available from the current position
   * to EOF for normal files.  Zero is returned for directory files.
   */
  uint32_t available32() const {
    return isFile() ? fileSize() - curPosition() : 0;
     a62:	ldrb	r3, [r2, #0]
     a64:	and.w	r3, r3, #8
     a68:	and.w	r0, r3, #255	; 0xff
     a6c:	cbz	r3, aae <FsBaseFile::available() const+0x52>
     a6e:	ldr	r3, [r2, #28]
     a70:	ldr	r0, [r2, #20]
   * Zero is returned for directory files.
   *
   */
  int available() const {
    uint32_t n = available32();
    return n > INT_MAX ? INT_MAX : n;
     a72:	subs	r0, r3, r0
     a74:	bpl.n	aae <FsBaseFile::available() const+0x52>
     a76:	mvn.w	r0, #2147483648	; 0x80000000
     a7a:	b.n	aae <FsBaseFile::available() const+0x52>
     a7c:	ldr	r0, [r0, #60]	; 0x3c
     a7e:	cbz	r0, aae <FsBaseFile::available() const+0x52>
  }
  /** \return The number of bytes available from the current position
   * to EOF for normal files.  Zero is returned for directory files.
   */
  uint64_t available64() {
    return isFile() ? fileSize() - curPosition() : 0;
     a80:	ldrb.w	r3, [r0, #49]	; 0x31
     a84:	lsls	r3, r3, #28
     a86:	bpl.n	a98 <FsBaseFile::available() const+0x3c>
     a88:	ldrd	r4, r5, [r0, #16]
     a8c:	ldrd	r2, r3, [r0]
     a90:	subs	r0, r4, r2
     a92:	sbc.w	r1, r5, r3
     a96:	b.n	a9c <FsBaseFile::available() const+0x40>
     a98:	movs	r0, #0
     a9a:	movs	r1, #0
   * Zero is returned for directory files.
   *
   */
  int available() {
    uint64_t n = available64();
    return n > INT_MAX ? INT_MAX : n;
     a9c:	movs	r3, #0
     a9e:	mvn.w	r2, #2147483648	; 0x80000000
     aa2:	cmp	r3, r1
     aa4:	it	eq
     aa6:	cmpeq	r2, r0
     aa8:	bcs.n	aae <FsBaseFile::available() const+0x52>
     aaa:	mov	r0, r2
     aac:	pop	{r4, r5, pc}
  }
     aae:	pop	{r4, r5, pc}

00000ab0 <StreamFile<FsBaseFile, unsigned long long>::available()>:
  StreamFile() {}

  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() {
     ab0:	push	{r3, lr}
    return BaseFile::available();
     ab2:	adds	r0, #16
     ab4:	bl	a5c <FsBaseFile::available() const>
  }
     ab8:	pop	{r3, pc}

00000aba <SDFile::available()>:
		return sdfatfile.write(buf, size);
	}
	virtual int peek() {
		return sdfatfile.peek();
	}
	virtual int available() {
     aba:	push	{r3, lr}

  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() {
    return BaseFile::available();
     abc:	adds	r0, #24
     abe:	bl	a5c <FsBaseFile::available() const>
		return sdfatfile.available();
	}
     ac2:	pop	{r3, pc}

00000ac4 <FsBaseFile::isDir() const>:
    return m_xFile ? m_xFile->isContiguous() : false;
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  }
  /** \return True if this is a directory else false. */
  bool isDir() const {
    return m_fFile ? m_fFile->isDir() :
     ac4:	ldr	r3, [r0, #56]	; 0x38
           m_xFile ? m_xFile->isDir() : false;
     ac6:	cbz	r3, ad0 <FsBaseFile::isDir() const+0xc>
#if USE_FAT_FILE_FLAG_CONTIGUOUS
    /** \return True if the file is contiguous. */
  bool isContiguous() const {return m_flags & FILE_FLAG_CONTIGUOUS;}
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  /** \return True if this is a directory. */
  bool isDir() const {return m_attributes & FILE_ATTR_DIR;}
     ac8:	ldrb	r3, [r3, #0]
     aca:	tst.w	r3, #112	; 0x70
     ace:	b.n	adc <FsBaseFile::isDir() const+0x18>
     ad0:	ldr	r0, [r0, #60]	; 0x3c
     ad2:	cbz	r0, ae2 <FsBaseFile::isDir() const+0x1e>
   */
  bool isBusy();
  /** \return True if the file is contiguous. */
  bool isContiguous() const {return m_flags & FILE_FLAG_CONTIGUOUS;}
  /** \return True if this is a directory. */
  bool isDir() const  {return m_attributes & FILE_ATTR_DIR;}
     ad4:	ldrb.w	r3, [r0, #49]	; 0x31
     ad8:	tst.w	r3, #80	; 0x50
     adc:	ite	ne
     ade:	movne	r0, #1
     ae0:	moveq	r0, #0
  }
     ae2:	bx	lr

00000ae4 <SDFile::isDirectory()>:
				filename = &zeroterm;
			}
		}
		return filename;
	}
	virtual boolean isDirectory(void) {
     ae4:	push	{r3, lr}
  }
  /** This function reports if the current file is a directory or not.
  * \return true if the file is a directory.
  */
  bool isDirectory() {
    return BaseFile::isDir();
     ae6:	adds	r0, #24
     ae8:	bl	ac4 <FsBaseFile::isDir() const>
		return sdfatfile.isDirectory();
	}
     aec:	pop	{r3, pc}

00000aee <SDFile::rewindDirectory()>:
	virtual File openNextFile(uint8_t mode=0) {
		SDFAT_FILE file = sdfatfile.openNextFile();
		if (file) return File(new SDFile(file));
		return File();
	}
	virtual void rewindDirectory(void) {
     aee:	push	{r4, lr}
     af0:	mov	r4, r0
  int read() {
    return BaseFile::read();
  }
  /** Rewind a file if it is a directory */
  void rewindDirectory() {
    if (BaseFile::isDir()) {
     af2:	adds	r0, #24
     af4:	bl	ac4 <FsBaseFile::isDir() const>
     af8:	cbz	r0, b14 <SDFile::rewindDirectory()+0x26>
    return m_fFile ? m_fFile->rename(dirFile->m_fFile, newPath) :
           m_xFile ? m_xFile->rename(dirFile->m_xFile, newPath) : false;
  }
  /** Set the file's current position to zero. */
  void rewind() {
    if (m_fFile) m_fFile->rewind();
     afa:	ldr	r0, [r4, #80]	; 0x50
     afc:	cbz	r0, b04 <SDFile::rewindDirectory()+0x16>
   * \return true for success or false for failure.
   */
  bool rename(FatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
     afe:	movs	r1, #0
     b00:	bl	57ea <FatFile::seekSet(unsigned long)>
    if (m_xFile) m_xFile->rewind();
     b04:	ldr	r0, [r4, #84]	; 0x54
     b06:	cbz	r0, b14 <SDFile::rewindDirectory()+0x26>
   * \return true for success or false for failure.
   */
  bool rename(ExFatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
     b08:	movs	r2, #0
     b0a:	movs	r3, #0
		sdfatfile.rewindDirectory();
	}
     b0c:	ldmia.w	sp!, {r4, lr}
     b10:	b.w	3b58 <ExFatFile::seekSet(unsigned long long)>
     b14:	pop	{r4, pc}

00000b16 <FsBaseFile::isOpen() const>:
  bool isHidden() const {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() const {return m_fFile || m_xFile;}
     b16:	ldr	r3, [r0, #56]	; 0x38
     b18:	cbnz	r3, b24 <FsBaseFile::isOpen() const+0xe>
     b1a:	ldr	r0, [r0, #60]	; 0x3c
     b1c:	adds	r0, #0
     b1e:	it	ne
     b20:	movne	r0, #1
     b22:	bx	lr
     b24:	movs	r0, #1
     b26:	bx	lr

00000b28 <SDFile::close()>:
		return sdfatfile.curPosition();
	}
	virtual uint64_t size() {
		return sdfatfile.size();
	}
	virtual void close() {
     b28:	push	{r4, lr}
     b2a:	mov	r4, r0
		if (filename) {
     b2c:	ldr	r0, [r0, #88]	; 0x58
     b2e:	cbz	r0, b38 <SDFile::close()+0x10>
			free(filename);
     b30:	bl	aacc <free>
			filename = nullptr;
     b34:	movs	r3, #0
     b36:	str	r3, [r4, #88]	; 0x58
		}
		if (sdfatfile.isOpen()) {
     b38:	adds	r4, #24
     b3a:	mov	r0, r4
     b3c:	bl	b16 <FsBaseFile::isOpen() const>
     b40:	cbz	r0, b4c <SDFile::close()+0x24>
			sdfatfile.close();
     b42:	mov	r0, r4
		}
	}
     b44:	ldmia.w	sp!, {r4, lr}
		if (filename) {
			free(filename);
			filename = nullptr;
		}
		if (sdfatfile.isOpen()) {
			sdfatfile.close();
     b48:	b.w	6d00 <FsBaseFile::close()>
     b4c:	pop	{r4, pc}
     b4e:	Address 0x00000b4e is out of bounds.


00000b50 <SDFile::~SDFile()>:
	// Only the abstract File class which references these derived
	// classes is meant to have a public constructor!
	SDFile(const SDFAT_FILE &file) : sdfatfile(file), filename(nullptr) { }
	friend class SDClass;
public:
	virtual ~SDFile(void) {
     b50:	push	{r4, lr}
     b52:	ldr	r3, [pc, #24]	; (b6c <SDFile::~SDFile()+0x1c>)
     b54:	str	r3, [r0, #0]
     b56:	mov	r4, r0
		close();
     b58:	bl	b28 <SDFile::close()>
/**
 * \class StreamFile
 * \brief StreamFile class.
 */
template<class BaseFile, typename PosType>
class StreamFile : public stream_t, public BaseFile {
     b5c:	ldr	r3, [pc, #16]	; (b70 <SDFile::~SDFile()+0x20>)
     b5e:	str	r3, [r4, #8]
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
     b60:	add.w	r0, r4, #24
     b64:	bl	6d00 <FsBaseFile::close()>
	}
     b68:	mov	r0, r4
     b6a:	pop	{r4, pc}
     b6c:	.word	0x00011d0c
     b70:	.word	0x00011c98

00000b74 <SDFile::~SDFile()>:
	// Only the abstract File class which references these derived
	// classes is meant to have a public constructor!
	SDFile(const SDFAT_FILE &file) : sdfatfile(file), filename(nullptr) { }
	friend class SDClass;
public:
	virtual ~SDFile(void) {
     b74:	push	{r4, lr}
     b76:	mov	r4, r0
		close();
	}
     b78:	bl	b50 <SDFile::~SDFile()>
     b7c:	mov	r0, r4
     b7e:	movs	r1, #92	; 0x5c
     b80:	bl	9c08 <operator delete(void*, unsigned int)>
     b84:	mov	r0, r4
     b86:	pop	{r4, pc}

00000b88 <SDFile::isOpen()>:
		}
		if (sdfatfile.isOpen()) {
			sdfatfile.close();
		}
	}
	virtual bool isOpen() {
     b88:	push	{r3, lr}
		return sdfatfile.isOpen();
     b8a:	adds	r0, #24
     b8c:	bl	b16 <FsBaseFile::isOpen() const>
	}
     b90:	pop	{r3, pc}

00000b92 <FsBaseFile::peek()>:
  uint64_t position() const {return curPosition();}
  /** Return the next available byte without consuming it.
   *
   * \return The byte if no error and not at eof else -1;
   */
  int peek() {
     b92:	mov	r3, r0
    return m_fFile ? m_fFile->peek() :
     b94:	ldr	r0, [r0, #56]	; 0x38
           m_xFile ? m_xFile->peek() : -1;
     b96:	cbz	r0, b9c <FsBaseFile::peek()+0xa>
     b98:	b.w	5788 <FatFile::peek()>
     b9c:	ldr	r0, [r3, #60]	; 0x3c
     b9e:	cbz	r0, ba4 <FsBaseFile::peek()+0x12>
     ba0:	b.w	3b2c <ExFatFile::peek()>
  }
     ba4:	mov.w	r0, #4294967295
     ba8:	bx	lr

00000baa <StreamFile<FsBaseFile, unsigned long long>::peek()>:
  const char* name() const {return "use getName()";}
  /** Return the next available byte without consuming it.
   *
   * \return The byte if no error and not at eof else -1;
   */
  int peek() {
     baa:	push	{r3, lr}
    return BaseFile::peek();
     bac:	adds	r0, #16
     bae:	bl	b92 <FsBaseFile::peek()>
  }
     bb2:	pop	{r3, pc}

00000bb4 <SDFile::peek()>:
		close();
	}
	virtual size_t write(const void *buf, size_t size) {
		return sdfatfile.write(buf, size);
	}
	virtual int peek() {
     bb4:	push	{r3, lr}
  /** Return the next available byte without consuming it.
   *
   * \return The byte if no error and not at eof else -1;
   */
  int peek() {
    return BaseFile::peek();
     bb6:	adds	r0, #24
     bb8:	bl	b92 <FsBaseFile::peek()>
		return sdfatfile.peek();
	}
     bbc:	pop	{r3, pc}

00000bbe <FsBaseFile::read(void*, unsigned int)>:
   * if end of file is reached.
   * If an error occurs, read() returns -1.  Possible errors include
   * read() called before a file has been opened, corrupt file system
   * or an I/O error occurred.
   */
  int read(void* buf, size_t count) {
     bbe:	mov	r3, r0
    return m_fFile ? m_fFile->read(buf, count) :
     bc0:	ldr	r0, [r0, #56]	; 0x38
           m_xFile ? m_xFile->read(buf, count) : -1;
     bc2:	cbz	r0, bc8 <FsBaseFile::read(void*, unsigned int)+0xa>
     bc4:	b.w	5610 <FatFile::read(void*, unsigned int)>
     bc8:	ldr	r0, [r3, #60]	; 0x3c
     bca:	cbz	r0, bd0 <FsBaseFile::read(void*, unsigned int)+0x12>
     bcc:	b.w	39a8 <ExFatFile::read(void*, unsigned int)>
  }
     bd0:	mov.w	r0, #4294967295
     bd4:	bx	lr

00000bd6 <StreamFile<FsBaseFile, unsigned long long>::read()>:
  /** Read the next byte from a file.
   *
   * \return For success return the next byte in the file as an int.
   * If an error occurs or end of file is reached return -1.
   */
  int read() {
     bd6:	push	{r0, r1, r2, lr}
   * \return For success return the next byte in the file as an int.
   * If an error occurs or end of file is reached return -1.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
     bd8:	movs	r2, #1
     bda:	add.w	r1, sp, #7
     bde:	adds	r0, #16
     be0:	bl	bbe <FsBaseFile::read(void*, unsigned int)>
     be4:	cmp	r0, #1
     be6:	ite	eq
     be8:	ldrbeq.w	r0, [sp, #7]
     bec:	movne.w	r0, #4294967295
    return BaseFile::read();
  }
     bf0:	add	sp, #12
     bf2:	ldr.w	pc, [sp], #4

00000bf6 <SDFile::read(void*, unsigned int)>:
		return sdfatfile.available();
	}
	virtual void flush() {
		sdfatfile.flush();
	}
	virtual size_t read(void *buf, size_t nbyte) {
     bf6:	push	{r3, lr}
		return sdfatfile.read(buf, nbyte);
     bf8:	adds	r0, #24
     bfa:	bl	bbe <FsBaseFile::read(void*, unsigned int)>
	}
     bfe:	pop	{r3, pc}

00000c00 <FsBaseFile::seekSet(unsigned long long)>:
   *
   * \param[in] pos The new position in bytes from the beginning of the file.
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
     c00:	push	{r4, r6, r7}
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
     c02:	ldr	r4, [r0, #56]	; 0x38
           m_xFile ? m_xFile->seekSet(pos) : false;
     c04:	cbz	r4, c18 <FsBaseFile::seekSet(unsigned long long)+0x18>
   * \param[in] pos The new position in bytes from the beginning of the file.
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
     c06:	cmp	r3, #1
     c08:	it	eq
     c0a:	cmpeq	r2, #0
     c0c:	bcs.n	c22 <FsBaseFile::seekSet(unsigned long long)+0x22>
     c0e:	mov	r0, r4
     c10:	mov	r1, r2
           m_xFile ? m_xFile->seekSet(pos) : false;
  }
     c12:	pop	{r4, r6, r7}
   * \param[in] pos The new position in bytes from the beginning of the file.
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
     c14:	b.w	57ea <FatFile::seekSet(unsigned long)>
           m_xFile ? m_xFile->seekSet(pos) : false;
     c18:	ldr	r0, [r0, #60]	; 0x3c
     c1a:	cbz	r0, c22 <FsBaseFile::seekSet(unsigned long long)+0x22>
  }
     c1c:	pop	{r4, r6, r7}
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
           m_xFile ? m_xFile->seekSet(pos) : false;
     c1e:	b.w	3b58 <ExFatFile::seekSet(unsigned long long)>
  }
     c22:	movs	r0, #0
     c24:	pop	{r4, r6, r7}
     c26:	bx	lr

00000c28 <SDFile::seek(unsigned long long, int)>:
	virtual bool truncate(uint64_t size=0) {
		return sdfatfile.truncate(size);
	}
	virtual bool seek(uint64_t pos, int mode = SeekSet) {
     c28:	push	{r3, r4, r5, lr}
     c2a:	mov	r1, r0
     c2c:	ldr	r0, [sp, #16]
     c2e:	mov	r4, r2
     c30:	mov	r5, r3
		if (mode == SeekSet) return sdfatfile.seekSet(pos);
     c32:	cbnz	r0, c3a <SDFile::seek(unsigned long long, int)+0x12>
     c34:	add.w	r0, r1, #24
     c38:	b.n	c76 <SDFile::seek(unsigned long long, int)+0x4e>
		if (mode == SeekCur) return sdfatfile.seekCur(pos);
     c3a:	cmp	r0, #1
     c3c:	bne.n	c54 <SDFile::seek(unsigned long long, int)+0x2c>
    return m_fFile ? m_fFile->contiguousRange(bgnSector, endSector) :
           m_xFile ? m_xFile->contiguousRange(bgnSector, endSector) : false;
  }
  /** \return The current position for a file or directory. */
  uint64_t curPosition() const {
    return m_fFile ? m_fFile->curPosition() :
     c3e:	ldr	r3, [r1, #80]	; 0x50
     c40:	add.w	r0, r1, #24
           m_xFile ? m_xFile->curPosition() : 0;
     c44:	cbz	r3, c4a <SDFile::seek(unsigned long long, int)+0x22>
     c46:	ldr	r2, [r3, #20]
     c48:	b.n	c70 <SDFile::seek(unsigned long long, int)+0x48>
     c4a:	ldr	r3, [r1, #84]	; 0x54
     c4c:	cbz	r3, c6e <SDFile::seek(unsigned long long, int)+0x46>
   *
   * \return true for success or false for failure.
   */
  bool contiguousRange(uint32_t* bgnSector, uint32_t* endSector);
  /** \return The current position for a file or directory. */
  uint64_t curPosition() const {return m_curPosition;}
     c4e:	ldrd	r2, r3, [r3]
     c52:	b.n	c72 <SDFile::seek(unsigned long long, int)+0x4a>
		if (mode == SeekEnd) return sdfatfile.seekEnd(pos);
     c54:	cmp	r0, #2
     c56:	bne.n	c7c <SDFile::seek(unsigned long long, int)+0x54>
    return m_fFile ? m_fFile->fgets(str, num, delim) :
           m_xFile ? m_xFile->fgets(str, num, delim) : -1;
  }
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {
    return m_fFile ? m_fFile->fileSize() :
     c58:	ldr	r3, [r1, #80]	; 0x50
     c5a:	add.w	r0, r1, #24
           m_xFile ? m_xFile->fileSize() : 0;
     c5e:	cbz	r3, c64 <SDFile::seek(unsigned long long, int)+0x3c>
     c60:	ldr	r2, [r3, #28]
     c62:	b.n	c70 <SDFile::seek(unsigned long long, int)+0x48>
     c64:	ldr	r3, [r1, #84]	; 0x54
     c66:	cbz	r3, c6e <SDFile::seek(unsigned long long, int)+0x46>
   * If no data is read, fgets() returns zero for EOF or -1 if an error
   * occurred.
   */
  int fgets(char* str, int num, char* delim = nullptr);
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {return m_validLength;}
     c68:	ldrd	r2, r3, [r3, #16]
     c6c:	b.n	c72 <SDFile::seek(unsigned long long, int)+0x4a>
     c6e:	movs	r2, #0
     c70:	movs	r3, #0
   * Can't be used for directory files since file size is not defined.
   * \param[in] offset The new position in bytes from end-of-file.
   * \return true for success or false for failure.
   */
  bool seekEnd(int64_t offset = 0) {
    return seekSet(fileSize() + offset);
     c72:	adds	r2, r2, r4
     c74:	adcs	r3, r5
     c76:	bl	c00 <FsBaseFile::seekSet(unsigned long long)>
     c7a:	pop	{r3, r4, r5, pc}
		return false;
     c7c:	movs	r0, #0
	}
     c7e:	pop	{r3, r4, r5, pc}

00000c80 <FsBaseFile::sync()>:
  /** The sync() call causes all modified data and directory fields
   * to be written to the storage device.
   *
   * \return true for success or false for failure.
   */
  bool sync() {
     c80:	mov	r3, r0
    return m_fFile ? m_fFile->sync() :
     c82:	ldr	r0, [r0, #56]	; 0x38
           m_xFile ? m_xFile->sync() : false;
     c84:	cbz	r0, c8a <FsBaseFile::sync()+0xa>
     c86:	b.w	5a40 <FatFile::sync()>
     c8a:	ldr	r0, [r3, #60]	; 0x3c
     c8c:	cbz	r0, c92 <FsBaseFile::sync()+0x12>
     c8e:	b.w	4770 <ExFatFile::sync()>
  }
     c92:	bx	lr

00000c94 <StreamFile<FsBaseFile, unsigned long long>::flush()>:
   */
  int available() {
    return BaseFile::available();
  }
  /** Ensure that any bytes written to the file are saved to the SD card. */
  void flush() {
     c94:	push	{r3, lr}
    BaseFile::sync();
     c96:	adds	r0, #16
     c98:	bl	c80 <FsBaseFile::sync()>
     c9c:	pop	{r3, pc}

00000c9e <SDFile::flush()>:
		return sdfatfile.peek();
	}
	virtual int available() {
		return sdfatfile.available();
	}
	virtual void flush() {
     c9e:	push	{r3, lr}
     ca0:	adds	r0, #24
     ca2:	bl	c80 <FsBaseFile::sync()>
     ca6:	pop	{r3, pc}

00000ca8 <FsBaseFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>:
   * Modify and access timestamps may be overwritten if a date time callback
   * function has been set by dateTimeCallback().
   *
   * \return true for success or false for failure.
   */
  bool timestamp(uint8_t flags, uint16_t year, uint8_t month, uint8_t day,
     ca8:	push	{r4, r5, r6, r7, lr}
                 uint8_t hour, uint8_t minute, uint8_t second) {
    return m_fFile ?
     caa:	ldr.w	lr, [r0, #56]	; 0x38
   * Modify and access timestamps may be overwritten if a date time callback
   * function has been set by dateTimeCallback().
   *
   * \return true for success or false for failure.
   */
  bool timestamp(uint8_t flags, uint16_t year, uint8_t month, uint8_t day,
     cae:	ldrb.w	r4, [sp, #20]
     cb2:	ldrb.w	r5, [sp, #24]
     cb6:	ldrb.w	r6, [sp, #28]
     cba:	ldrb.w	r7, [sp, #32]
                 uint8_t hour, uint8_t minute, uint8_t second) {
    return m_fFile ?
           m_fFile->timestamp(flags, year, month, day, hour, minute, second) :
           m_xFile ?
           m_xFile->timestamp(flags, year, month, day, hour, minute, second) :
           false;
     cbe:	cmp.w	lr, #0
     cc2:	beq.n	cd6 <FsBaseFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x2e>
     cc4:	str	r7, [sp, #32]
     cc6:	str	r6, [sp, #28]
     cc8:	str	r5, [sp, #24]
     cca:	str	r4, [sp, #20]
     ccc:	mov	r0, lr
  }
     cce:	ldmia.w	sp!, {r4, r5, r6, r7, lr}
                 uint8_t hour, uint8_t minute, uint8_t second) {
    return m_fFile ?
           m_fFile->timestamp(flags, year, month, day, hour, minute, second) :
           m_xFile ?
           m_xFile->timestamp(flags, year, month, day, hour, minute, second) :
           false;
     cd2:	b.w	5f34 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>
   */
  bool timestamp(uint8_t flags, uint16_t year, uint8_t month, uint8_t day,
                 uint8_t hour, uint8_t minute, uint8_t second) {
    return m_fFile ?
           m_fFile->timestamp(flags, year, month, day, hour, minute, second) :
           m_xFile ?
     cd6:	ldr	r0, [r0, #60]	; 0x3c
           m_xFile->timestamp(flags, year, month, day, hour, minute, second) :
           false;
     cd8:	cbz	r0, cea <FsBaseFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x42>
     cda:	str	r7, [sp, #32]
     cdc:	str	r6, [sp, #28]
     cde:	str	r5, [sp, #24]
     ce0:	str	r4, [sp, #20]
  }
     ce2:	ldmia.w	sp!, {r4, r5, r6, r7, lr}
                 uint8_t hour, uint8_t minute, uint8_t second) {
    return m_fFile ?
           m_fFile->timestamp(flags, year, month, day, hour, minute, second) :
           m_xFile ?
           m_xFile->timestamp(flags, year, month, day, hour, minute, second) :
           false;
     ce6:	b.w	4a38 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>
  }
     cea:	pop	{r4, r5, r6, r7, pc}

00000cec <SDFile::setModifyTime(DateTimeFields const&)>:
	virtual bool setCreateTime(const DateTimeFields &tm) {
		if (tm.year < 80 || tm.year > 207) return false;
		return sdfatfile.timestamp(T_CREATE, tm.year + 1900, tm.mon + 1,
			tm.mday, tm.hour, tm.min, tm.sec);
	}
	virtual bool setModifyTime(const DateTimeFields &tm) {
     cec:	push	{r0, r1, r2, r3, r4, lr}
		if (tm.year < 80 || tm.year > 207) return false;
     cee:	ldrb	r2, [r1, #6]
     cf0:	sub.w	r3, r2, #80	; 0x50
     cf4:	lsls	r3, r3, #24
     cf6:	bmi.n	d1c <SDFile::setModifyTime(DateTimeFields const&)+0x30>
		return sdfatfile.timestamp(T_WRITE, tm.year + 1900, tm.mon + 1,
			tm.mday, tm.hour, tm.min, tm.sec);
     cf8:	ldrb	r4, [r1, #0]
     cfa:	ldrb	r3, [r1, #5]
     cfc:	str	r4, [sp, #12]
     cfe:	ldrb	r4, [r1, #1]
     d00:	str	r4, [sp, #8]
     d02:	ldrb	r4, [r1, #2]
     d04:	str	r4, [sp, #4]
     d06:	ldrb	r1, [r1, #4]
     d08:	str	r1, [sp, #0]
     d0a:	adds	r3, #1
     d0c:	uxtb	r3, r3
     d0e:	addw	r2, r2, #1900	; 0x76c
     d12:	movs	r1, #4
     d14:	adds	r0, #24
     d16:	bl	ca8 <FsBaseFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>
     d1a:	b.n	d1e <SDFile::setModifyTime(DateTimeFields const&)+0x32>
		if (tm.year < 80 || tm.year > 207) return false;
		return sdfatfile.timestamp(T_CREATE, tm.year + 1900, tm.mon + 1,
			tm.mday, tm.hour, tm.min, tm.sec);
	}
	virtual bool setModifyTime(const DateTimeFields &tm) {
		if (tm.year < 80 || tm.year > 207) return false;
     d1c:	movs	r0, #0
		return sdfatfile.timestamp(T_WRITE, tm.year + 1900, tm.mon + 1,
			tm.mday, tm.hour, tm.min, tm.sec);
	}
     d1e:	add	sp, #16
     d20:	pop	{r4, pc}

00000d22 <SDFile::setCreateTime(DateTimeFields const&)>:
		tm.mday = FS_DAY(fat_date);
		tm.mon = FS_MONTH(fat_date) - 1;
		tm.year = FS_YEAR(fat_date) - 1900;
		return true;
	}
	virtual bool setCreateTime(const DateTimeFields &tm) {
     d22:	push	{r0, r1, r2, r3, r4, lr}
		if (tm.year < 80 || tm.year > 207) return false;
     d24:	ldrb	r2, [r1, #6]
     d26:	sub.w	r3, r2, #80	; 0x50
     d2a:	lsls	r3, r3, #24
     d2c:	bmi.n	d52 <SDFile::setCreateTime(DateTimeFields const&)+0x30>
		return sdfatfile.timestamp(T_CREATE, tm.year + 1900, tm.mon + 1,
			tm.mday, tm.hour, tm.min, tm.sec);
     d2e:	ldrb	r4, [r1, #0]
     d30:	ldrb	r3, [r1, #5]
     d32:	str	r4, [sp, #12]
     d34:	ldrb	r4, [r1, #1]
     d36:	str	r4, [sp, #8]
     d38:	ldrb	r4, [r1, #2]
     d3a:	str	r4, [sp, #4]
     d3c:	ldrb	r1, [r1, #4]
     d3e:	str	r1, [sp, #0]
     d40:	adds	r3, #1
     d42:	uxtb	r3, r3
     d44:	addw	r2, r2, #1900	; 0x76c
     d48:	movs	r1, #2
     d4a:	adds	r0, #24
     d4c:	bl	ca8 <FsBaseFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>
     d50:	b.n	d54 <SDFile::setCreateTime(DateTimeFields const&)+0x32>
		tm.mon = FS_MONTH(fat_date) - 1;
		tm.year = FS_YEAR(fat_date) - 1900;
		return true;
	}
	virtual bool setCreateTime(const DateTimeFields &tm) {
		if (tm.year < 80 || tm.year > 207) return false;
     d52:	movs	r0, #0
		return sdfatfile.timestamp(T_CREATE, tm.year + 1900, tm.mon + 1,
			tm.mday, tm.hour, tm.min, tm.sec);
	}
     d54:	add	sp, #16
     d56:	pop	{r4, pc}

00000d58 <FsBaseFile::write(void const*, unsigned int)>:
   * \param[in] count Number of bytes to write.
   *
   * \return For success write() returns the number of bytes written, always
   * \a nbyte.  If an error occurs, write() returns zero and writeError is set.
   */
  size_t write(const void* buf, size_t count) {
     d58:	mov	r3, r0
    return m_fFile ? m_fFile->write(buf, count) :
     d5a:	ldr	r0, [r0, #56]	; 0x38
           m_xFile ? m_xFile->write(buf, count) : 0;
     d5c:	cbz	r0, d62 <FsBaseFile::write(void const*, unsigned int)+0xa>
     d5e:	b.w	604c <FatFile::write(void const*, unsigned int)>
     d62:	ldr	r0, [r3, #60]	; 0x3c
     d64:	cbz	r0, d6a <FsBaseFile::write(void const*, unsigned int)+0x12>
     d66:	b.w	4c08 <ExFatFile::write(void const*, unsigned int)>
  }
     d6a:	bx	lr

00000d6c <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char const*, unsigned int)>:
   * \param[in] size Number of bytes to write.
   *
   * \return For success write() returns the number of bytes written, always
   * \a size.
   */
  size_t write(const uint8_t* buffer, size_t size) {
     d6c:	push	{r3, lr}
    return BaseFile::write(buffer, size);
     d6e:	adds	r0, #16
     d70:	bl	d58 <FsBaseFile::write(void const*, unsigned int)>
  }
     d74:	pop	{r3, pc}

00000d76 <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char)>:
  /** Write a byte to a file. Required by the Arduino Print class.
   * \param[in] b the byte to be written.
   * Use getWriteError to check for errors.
   * \return 1 for success and 0 for failure.
   */
  size_t write(uint8_t b) {
     d76:	push	{r0, r1, r2, lr}
     d78:	add	r3, sp, #8
  /** Write a byte to a file. Required by the Arduino Print class.
   * \param[in] b the byte to be written.
   * Use getWriteError to check for errors.
   * \return 1 for success and 0 for failure.
   */
  size_t write(uint8_t b) {return write(&b, 1);}
     d7a:	movs	r2, #1
     d7c:	strb.w	r1, [r3, #-1]!
     d80:	adds	r0, #16
     d82:	mov	r1, r3
     d84:	bl	d58 <FsBaseFile::write(void const*, unsigned int)>
    return BaseFile::write(b);
  }
     d88:	add	sp, #12
     d8a:	ldr.w	pc, [sp], #4

00000d8e <SDFile::write(void const*, unsigned int)>:
	friend class SDClass;
public:
	virtual ~SDFile(void) {
		close();
	}
	virtual size_t write(const void *buf, size_t size) {
     d8e:	push	{r3, lr}
		return sdfatfile.write(buf, size);
     d90:	adds	r0, #24
     d92:	bl	d58 <FsBaseFile::write(void const*, unsigned int)>
	}
     d96:	pop	{r3, pc}

00000d98 <File::close()>:
		return (f) ? f->position() : 0;
	}
	uint64_t size() {
		return (f) ? f->size() : 0;
	}
	void close() {
     d98:	push	{r4, lr}
     d9a:	mov	r4, r0
		if (f) {
     d9c:	ldr	r0, [r0, #16]
     d9e:	cbz	r0, db2 <File::close()+0x1a>
			f->close();
     da0:	ldr	r3, [r0, #0]
     da2:	ldr	r3, [r3, #44]	; 0x2c
     da4:	blx	r3
			dec_refcount();
     da6:	add.w	r0, r4, #16
		}
	}
     daa:	ldmia.w	sp!, {r4, lr}
		return (f) ? f->size() : 0;
	}
	void close() {
		if (f) {
			f->close();
			dec_refcount();
     dae:	b.w	9bc <File::dec_refcount() [clone .isra.15]>
     db2:	pop	{r4, pc}

00000db4 <SDFile::SDFile(FsFile const&)>:
	// Classes derived from File are never meant to be constructed
	// anywhere other than open() in the parent FS class and
	// openNextFile() while traversing a directory.
	// Only the abstract File class which references these derived
	// classes is meant to have a public constructor!
	SDFile(const SDFAT_FILE &file) : sdfatfile(file), filename(nullptr) { }
     db4:	push	{r3, r4, r5, lr}
// FileImpl instances are automatically deleted when the last referencing
// File is closed or goes out of scope.  The refcount variable is meant to
// be maintained by File class instances, never access by FileImpl functions.
// The FileImpl functions are meant to be called only by use of File instances.
//
class FileImpl {
     db6:	movs	r5, #0
     db8:	ldr	r3, [pc, #40]	; (de4 <SDFile::SDFile(FsFile const&)+0x30>)
     dba:	str	r5, [r0, #4]
     dbc:	str	r3, [r0, #0]
//#define BYTE 0
//#endif

class __FlashStringHelper;

class Print
     dbe:	ldrb	r3, [r1, #4]
     dc0:	strb	r3, [r0, #12]
#define Stream_h

#include <inttypes.h>
#include "Print.h"

class Stream : public Print
     dc2:	ldr	r3, [pc, #36]	; (de8 <SDFile::SDFile(FsFile const&)+0x34>)
     dc4:	str	r3, [r0, #8]
     dc6:	ldr	r3, [r1, #8]
     dc8:	str	r3, [r0, #16]
     dca:	ldrb	r3, [r1, #12]
     dcc:	strb	r3, [r0, #20]
     dce:	mov	r4, r0
/**
 * \class StreamFile
 * \brief StreamFile class.
 */
template<class BaseFile, typename PosType>
class StreamFile : public stream_t, public BaseFile {
     dd0:	adds	r1, #16
     dd2:	adds	r0, #24
     dd4:	bl	6c9e <FsBaseFile::FsBaseFile(FsBaseFile const&)>
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
     dd8:	ldr	r3, [pc, #16]	; (dec <SDFile::SDFile(FsFile const&)+0x38>)
     dda:	str	r3, [r4, #8]
     ddc:	str	r5, [r4, #88]	; 0x58
     dde:	mov	r0, r4
     de0:	pop	{r3, r4, r5, pc}
     de2:	nop
     de4:	.word	0x00011d0c
     de8:	.word	0x00011c74
     dec:	.word	0x00011cbc

00000df0 <SDFile::openNextFile(unsigned char)>:
		return filename;
	}
	virtual boolean isDirectory(void) {
		return sdfatfile.isDirectory();
	}
	virtual File openNextFile(uint8_t mode=0) {
     df0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
     df4:	sub	sp, #84	; 0x54
{
  public:
	constexpr Print() : write_error(0) {}
     df6:	movs	r5, #0
     df8:	add.w	r8, sp, #80	; 0x50
     dfc:	ldr	r3, [pc, #108]	; (e6c <SDFile::openNextFile(unsigned char)+0x7c>)
     dfe:	str.w	r3, [r8, #-80]!
   * \param[in] oflag open flags.
   * \return a FatStream object.
   */
  FsFile openNextFile(oflag_t oflag = O_RDONLY) {
    FsFile tmpFile;
    tmpFile.openNext(this, oflag);
     e02:	mov	r2, r5
     e04:	adds	r1, #24
     e06:	mov	r4, r0
{
  public:
	constexpr Stream() : _timeout(1000), read_error(0) {}
     e08:	mov.w	r6, #1000	; 0x3e8
     e0c:	add	r0, sp, #16
     e0e:	strb.w	r5, [sp, #4]
     e12:	str	r6, [sp, #8]
     e14:	strb.w	r5, [sp, #12]
 * \brief FsBaseFile class.
 */
class FsBaseFile {
 public:
  /** Create an instance. */
  FsBaseFile() {}
     e18:	str	r5, [sp, #72]	; 0x48
     e1a:	str	r5, [sp, #76]	; 0x4c
   * \param[in] oflag open flags.
   * \return a FatStream object.
   */
  FsFile openNextFile(oflag_t oflag = O_RDONLY) {
    FsFile tmpFile;
    tmpFile.openNext(this, oflag);
     e1c:	bl	6da6 <FsBaseFile::openNext(FsBaseFile*, int)>
  FsBaseFile& operator=(const FsBaseFile& from);
  /** The parenthesis operator.
    *
    * \return true if a file is open.
    */
  operator bool() const {return isOpen();}
     e20:	add	r0, sp, #16
     e22:	bl	b16 <FsBaseFile::isOpen() const>
     e26:	ldr.w	r9, [pc, #76]	; e74 <SDFile::openNextFile(unsigned char)+0x84>
		SDFAT_FILE file = sdfatfile.openNextFile();
		if (file) return File(new SDFile(file));
     e2a:	cbz	r0, e4e <SDFile::openNextFile(unsigned char)+0x5e>
     e2c:	movs	r0, #92	; 0x5c
     e2e:	bl	9c04 <operator new(unsigned int)>
     e32:	mov	r7, r0
     e34:	mov	r1, r8
     e36:	bl	db4 <SDFile::SDFile(FsFile const&)>
	// functions derived from FS::open() and FileImpl::openNextFile().
	// Not normally called used from ordinary programs or libraries
	// which only access files.
	File(FileImpl *file) {
		f = file;
		if (f) f->refcount++;
     e3a:	ldr	r3, [r7, #4]
     e3c:	strb	r5, [r4, #4]
     e3e:	adds	r3, #1
     e40:	str	r6, [r4, #8]
     e42:	strb	r5, [r4, #12]
	// Explicit FileImpl constructor.  Used by libraries which provide
	// access to files stored on media.  Normally this is used within
	// functions derived from FS::open() and FileImpl::openNextFile().
	// Not normally called used from ordinary programs or libraries
	// which only access files.
	File(FileImpl *file) {
     e44:	str.w	r9, [r4]
		f = file;
     e48:	str	r7, [r4, #16]
		if (f) f->refcount++;
     e4a:	str	r3, [r7, #4]
     e4c:	b.n	e5a <SDFile::openNextFile(unsigned char)+0x6a>
     e4e:	strb	r0, [r4, #4]
     e50:	str	r6, [r4, #8]
     e52:	strb	r0, [r4, #12]
//
class File final : public Stream {
public:
	// Empty constructor, used when a program creates a File variable
	// but does not immediately assign or initialize it.
	constexpr File() : f(nullptr) { }
     e54:	str.w	r9, [r4]
     e58:	str	r0, [r4, #16]
     e5a:	ldr	r3, [pc, #20]	; (e70 <SDFile::openNextFile(unsigned char)+0x80>)
     e5c:	str	r3, [sp, #0]
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
     e5e:	add	r0, sp, #16
     e60:	bl	6d00 <FsBaseFile::close()>
		return File();
	}
     e64:	mov	r0, r4
     e66:	add	sp, #84	; 0x54
     e68:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
     e6c:	.word	0x00011cbc
     e70:	.word	0x00011c98
     e74:	.word	0x00011ce0

00000e78 <SDClass::open(char const*, unsigned char)>:
class SDClass : public FS
{
public:
	SDClass() { }
	bool begin(uint8_t csPin = 10);
	File open(const char *filepath, uint8_t mode = FILE_READ) {
     e78:	push	{r4, r5, r6, lr}
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
     e7a:	cmp	r3, #1
class SDClass : public FS
{
public:
	SDClass() { }
	bool begin(uint8_t csPin = 10);
	File open(const char *filepath, uint8_t mode = FILE_READ) {
     e7c:	sub	sp, #80	; 0x50
     e7e:	mov	r4, r0
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
     e80:	beq.n	e8e <SDClass::open(char const*, unsigned char)+0x16>
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
     e82:	cmp	r3, #2
     e84:	movw	r3, #514	; 0x202
     e88:	it	ne
     e8a:	movne	r3, #0
     e8c:	b.n	e92 <SDClass::open(char const*, unsigned char)+0x1a>
public:
	SDClass() { }
	bool begin(uint8_t csPin = 10);
	File open(const char *filepath, uint8_t mode = FILE_READ) {
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
     e8e:	movw	r3, #16898	; 0x4202
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
		SDFAT_FILE file = sdfs.open(filepath, flags);
     e92:	adds	r1, #4
     e94:	mov	r0, sp
     e96:	bl	6ec0 <FsVolume::open(char const*, int)>
  FsBaseFile& operator=(const FsBaseFile& from);
  /** The parenthesis operator.
    *
    * \return true if a file is open.
    */
  operator bool() const {return isOpen();}
     e9a:	add	r0, sp, #16
     e9c:	bl	b16 <FsBaseFile::isOpen() const>
     ea0:	ldr	r6, [pc, #68]	; (ee8 <SDClass::open(char const*, unsigned char)+0x70>)
		if (file) return File(new SDFile(file));
     ea2:	cbz	r0, eca <SDClass::open(char const*, unsigned char)+0x52>
     ea4:	movs	r0, #92	; 0x5c
     ea6:	bl	9c04 <operator new(unsigned int)>
     eaa:	mov	r1, sp
     eac:	mov	r5, r0
     eae:	bl	db4 <SDFile::SDFile(FsFile const&)>
     eb2:	movs	r3, #0
     eb4:	strb	r3, [r4, #4]
     eb6:	strb	r3, [r4, #12]
	// functions derived from FS::open() and FileImpl::openNextFile().
	// Not normally called used from ordinary programs or libraries
	// which only access files.
	File(FileImpl *file) {
		f = file;
		if (f) f->refcount++;
     eb8:	ldr	r3, [r5, #4]
	// Explicit FileImpl constructor.  Used by libraries which provide
	// access to files stored on media.  Normally this is used within
	// functions derived from FS::open() and FileImpl::openNextFile().
	// Not normally called used from ordinary programs or libraries
	// which only access files.
	File(FileImpl *file) {
     eba:	str	r6, [r4, #0]
     ebc:	mov.w	r2, #1000	; 0x3e8
		f = file;
		if (f) f->refcount++;
     ec0:	adds	r3, #1
     ec2:	str	r2, [r4, #8]
	// access to files stored on media.  Normally this is used within
	// functions derived from FS::open() and FileImpl::openNextFile().
	// Not normally called used from ordinary programs or libraries
	// which only access files.
	File(FileImpl *file) {
		f = file;
     ec4:	str	r5, [r4, #16]
		if (f) f->refcount++;
     ec6:	str	r3, [r5, #4]
     ec8:	b.n	ed8 <SDClass::open(char const*, unsigned char)+0x60>
     eca:	mov.w	r3, #1000	; 0x3e8
     ece:	strb	r0, [r4, #4]
     ed0:	str	r3, [r4, #8]
     ed2:	strb	r0, [r4, #12]
//
class File final : public Stream {
public:
	// Empty constructor, used when a program creates a File variable
	// but does not immediately assign or initialize it.
	constexpr File() : f(nullptr) { }
     ed4:	str	r6, [r4, #0]
     ed6:	str	r0, [r4, #16]
     ed8:	ldr	r3, [pc, #16]	; (eec <SDClass::open(char const*, unsigned char)+0x74>)
     eda:	str	r3, [sp, #0]
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
     edc:	add	r0, sp, #16
     ede:	bl	6d00 <FsBaseFile::close()>
		return File();
	}
     ee2:	mov	r0, r4
     ee4:	add	sp, #80	; 0x50
     ee6:	pop	{r4, r5, r6, pc}
     ee8:	.word	0x00011ce0
     eec:	.word	0x00011c98

00000ef0 <storeConfig(unsigned short*, int)>:
uint16_t store[16];

extern  int t_acq;

void storeConfig(uint16_t *store, int ns)
{ 
     ef0:	push	{r4, r5, r6, lr}
     ef2:	sub	sp, #56	; 0x38
  //  eeprom_write_block(store, 0, ns*sizeof(store[0]));  

    File configFile;
     ef4:	ldr	r3, [pc, #120]	; (f70 <storeConfig(unsigned short*, int)+0x80>)
     ef6:	str	r3, [sp, #4]
     ef8:	mov.w	r2, #1000	; 0x3e8
     efc:	movs	r3, #0
     efe:	strb.w	r3, [sp, #8]
     f02:	str	r2, [sp, #12]
     f04:	strb.w	r3, [sp, #16]
     f08:	str	r3, [sp, #20]
uint16_t store[16];

extern  int t_acq;

void storeConfig(uint16_t *store, int ns)
{ 
     f0a:	mov	r5, r0
  //  eeprom_write_block(store, 0, ns*sizeof(store[0]));  

    File configFile;
    char text[32];
    configFile=sdx[0].open(CONFIG_FILE,FILE_WRITE_BEGIN);
     f0c:	movs	r3, #2
uint16_t store[16];

extern  int t_acq;

void storeConfig(uint16_t *store, int ns)
{ 
     f0e:	mov	r6, r1
  //  eeprom_write_block(store, 0, ns*sizeof(store[0]));  

    File configFile;
    char text[32];
    configFile=sdx[0].open(CONFIG_FILE,FILE_WRITE_BEGIN);
     f10:	ldr	r2, [pc, #96]	; (f74 <storeConfig(unsigned short*, int)+0x84>)
     f12:	ldr	r1, [pc, #100]	; (f78 <storeConfig(unsigned short*, int)+0x88>)
     f14:	add	r0, sp, #24
     f16:	bl	e78 <SDClass::open(char const*, unsigned char)>
	}
#ifdef FILE_USE_MOVE
	// Move assignment.
	File& operator = (const File&& file) {
		//Serial.println("File move assignment");
		if (file.f) file.f->refcount++;
     f1a:	ldr	r3, [sp, #40]	; 0x28
     f1c:	cbz	r3, f24 <storeConfig(unsigned short*, int)+0x34>
     f1e:	ldr	r2, [r3, #4]
     f20:	adds	r2, #1
     f22:	str	r2, [r3, #4]
		if (f) { dec_refcount(); /*Serial.println("File move assignment autoclose");*/ }
     f24:	ldr	r3, [sp, #20]
     f26:	cbz	r3, f2e <storeConfig(unsigned short*, int)+0x3e>
     f28:	add	r0, sp, #20
     f2a:	bl	9bc <File::dec_refcount() [clone .isra.15]>
		f = file.f;
     f2e:	ldr	r3, [sp, #40]	; 0x28
     f30:	str	r3, [sp, #20]
     f32:	add	r0, sp, #24
     f34:	bl	9e0 <File::~File()>
      for(int ii=0; ii<ns; ii++)
     f38:	movs	r4, #0
     f3a:	cmp	r4, r6
     f3c:	bge.n	f5e <storeConfig(unsigned short*, int)+0x6e>
      { sprintf(text,"%10d\r\n",(int) store[ii]); configFile.write((uint8_t*)text,strlen(text)); }
     f3e:	ldrh.w	r2, [r5, r4, lsl #1]
     f42:	ldr	r1, [pc, #56]	; (f7c <storeConfig(unsigned short*, int)+0x8c>)
     f44:	add	r0, sp, #24
     f46:	bl	b658 <sprintf>
     f4a:	add	r0, sp, #24
     f4c:	bl	b700 <strlen>
     f50:	add	r1, sp, #24
     f52:	mov	r2, r0
     f54:	add	r0, sp, #4
     f56:	bl	7fe <File::write(unsigned char const*, unsigned int)>
  //  eeprom_write_block(store, 0, ns*sizeof(store[0]));  

    File configFile;
    char text[32];
    configFile=sdx[0].open(CONFIG_FILE,FILE_WRITE_BEGIN);
      for(int ii=0; ii<ns; ii++)
     f5a:	adds	r4, #1
     f5c:	b.n	f3a <storeConfig(unsigned short*, int)+0x4a>
      { sprintf(text,"%10d\r\n",(int) store[ii]); configFile.write((uint8_t*)text,strlen(text)); }
    configFile.close();
     f5e:	add	r0, sp, #4
     f60:	bl	d98 <File::close()>

void storeConfig(uint16_t *store, int ns)
{ 
  //  eeprom_write_block(store, 0, ns*sizeof(store[0]));  

    File configFile;
     f64:	add	r0, sp, #4
     f66:	bl	9e0 <File::~File()>
    configFile=sdx[0].open(CONFIG_FILE,FILE_WRITE_BEGIN);
      for(int ii=0; ii<ns; ii++)
      { sprintf(text,"%10d\r\n",(int) store[ii]); configFile.write((uint8_t*)text,strlen(text)); }
    configFile.close();
  
}
     f6a:	add	sp, #56	; 0x38
     f6c:	pop	{r4, r5, r6, pc}
     f6e:	nop
     f70:	.word	0x00011ce0
     f74:	.word	0x00011d60
     f78:	.word	0x1fff2468
     f7c:	.word	0x00011d6c

00000f80 <saveParameters()>:
    configFile.close();
}

void saveParameters(void)
{
  store[0]= 1;
     f80:	ldr	r0, [pc, #16]	; (f94 <saveParameters()+0x14>)
     f82:	movs	r3, #1
     f84:	strh	r3, [r0, #0]
  store[2]= t_acq;
     f86:	ldr	r3, [pc, #16]	; (f98 <saveParameters()+0x18>)

  storeConfig(store, 16);
     f88:	movs	r1, #16
}

void saveParameters(void)
{
  store[0]= 1;
  store[2]= t_acq;
     f8a:	ldr	r3, [r3, #0]
     f8c:	strh	r3, [r0, #4]

  storeConfig(store, 16);
     f8e:	b.w	ef0 <storeConfig(unsigned short*, int)>
     f92:	nop
     f94:	.word	0x1fff21f2
     f98:	.word	0x1fff0f38

00000f9c <printMenu()>:
  }
}


void printMenu(void)
{
     f9c:	push	{r4, lr}
  Serial.println("\n Menu");
     f9e:	ldr	r4, [pc, #144]	; (1030 <printMenu()+0x94>)
     fa0:	ldr	r1, [pc, #144]	; (1034 <printMenu()+0x98>)
     fa2:	mov	r0, r4
     fa4:	bl	6a4 <Print::println(char const*)>
  Serial.println(" ':h'  : print help");
     fa8:	ldr	r1, [pc, #140]	; (1038 <printMenu()+0x9c>)
     faa:	mov	r0, r4
     fac:	bl	6a4 <Print::println(char const*)>
  Serial.println(" ':s'  : start acquisition");
     fb0:	ldr	r1, [pc, #136]	; (103c <printMenu()+0xa0>)
     fb2:	mov	r0, r4
     fb4:	bl	6a4 <Print::println(char const*)>
  Serial.println(" ':e'  : stop acquisition");
     fb8:	ldr	r1, [pc, #132]	; (1040 <printMenu()+0xa4>)
     fba:	mov	r0, r4
     fbc:	bl	6a4 <Print::println(char const*)>
  Serial.println(" ':w'  : write parameters to microSD card");
     fc0:	ldr	r1, [pc, #128]	; (1044 <printMenu()+0xa8>)
     fc2:	mov	r0, r4
     fc4:	bl	6a4 <Print::println(char const*)>
  Serial.println(" ':l'  : list disks");
     fc8:	ldr	r1, [pc, #124]	; (1048 <printMenu()+0xac>)
     fca:	mov	r0, r4
     fcc:	bl	6a4 <Print::println(char const*)>
  Serial.println(" ':r'  : reset MTP");
     fd0:	ldr	r1, [pc, #120]	; (104c <printMenu()+0xb0>)
     fd2:	mov	r0, r4
     fd4:	bl	6a4 <Print::println(char const*)>
  Serial.println(" ':b'  : reboot CPU");
     fd8:	ldr	r1, [pc, #116]	; (1050 <printMenu()+0xb4>)
     fda:	mov	r0, r4
     fdc:	bl	6a4 <Print::println(char const*)>
//  Serial.println(" ':d'  : dump Index List (testing)");
  Serial.println();
     fe0:	mov	r0, r4
     fe2:	bl	9998 <Print::println()>
  Serial.println(" '?p'  : show all parameters");
     fe6:	ldr	r1, [pc, #108]	; (1054 <printMenu()+0xb8>)
     fe8:	mov	r0, r4
     fea:	bl	6a4 <Print::println(char const*)>
  Serial.println(" '?d'  : get date");
     fee:	ldr	r1, [pc, #104]	; (1058 <printMenu()+0xbc>)
     ff0:	mov	r0, r4
     ff2:	bl	6a4 <Print::println(char const*)>
  Serial.println(" '?t'  : get time");
     ff6:	ldr	r1, [pc, #100]	; (105c <printMenu()+0xc0>)
     ff8:	mov	r0, r4
     ffa:	bl	6a4 <Print::println(char const*)>
  Serial.println(" '?a'  : get file duration (s)");
     ffe:	ldr	r1, [pc, #96]	; (1060 <printMenu()+0xc4>)
    1000:	mov	r0, r4
    1002:	bl	6a4 <Print::println(char const*)>
  Serial.println();
    1006:	mov	r0, r4
    1008:	bl	9998 <Print::println()>
  Serial.println(" '!d yyyy/mm/dd<cr>'  : set date");
    100c:	ldr	r1, [pc, #84]	; (1064 <printMenu()+0xc8>)
    100e:	mov	r0, r4
    1010:	bl	6a4 <Print::println(char const*)>
  Serial.println(" '!t hh:mm:ss<cr>'    : set time");
    1014:	ldr	r1, [pc, #80]	; (1068 <printMenu()+0xcc>)
    1016:	mov	r0, r4
    1018:	bl	6a4 <Print::println(char const*)>
  Serial.println(" '!a val<cr>'  : set file duration (s)");
    101c:	mov	r0, r4
    101e:	ldr	r1, [pc, #76]	; (106c <printMenu()+0xd0>)
    1020:	bl	6a4 <Print::println(char const*)>
  Serial.println();
    1024:	mov	r0, r4
}
    1026:	ldmia.w	sp!, {r4, lr}
  Serial.println(" '?a'  : get file duration (s)");
  Serial.println();
  Serial.println(" '!d yyyy/mm/dd<cr>'  : set date");
  Serial.println(" '!t hh:mm:ss<cr>'    : set time");
  Serial.println(" '!a val<cr>'  : set file duration (s)");
  Serial.println();
    102a:	b.w	9998 <Print::println()>
    102e:	nop
    1030:	.word	0x1fff1368
    1034:	.word	0x00011d73
    1038:	.word	0x00011d7a
    103c:	.word	0x00011d8e
    1040:	.word	0x00011da9
    1044:	.word	0x00011dc3
    1048:	.word	0x00011ded
    104c:	.word	0x00011e01
    1050:	.word	0x00011e14
    1054:	.word	0x00011e28
    1058:	.word	0x00011e45
    105c:	.word	0x00011e57
    1060:	.word	0x00011e69
    1064:	.word	0x00011e88
    1068:	.word	0x00011ea9
    106c:	.word	0x00011eca

00001070 <printMenuEntries()>:
}

void printMenuEntries(void)
{
    1070:	push	{r0, r1, r2, r3, r4, lr}
    tmElements_t tm;
    breakTime(rtc_get(), tm);

  Serial.println("CVAS_V3 Version: " __DATE__  " " __TIME__ );
    1072:	ldr	r4, [pc, #96]	; (10d4 <printMenuEntries()+0x64>)
}

void printMenuEntries(void)
{
    tmElements_t tm;
    breakTime(rtc_get(), tm);
    1074:	bl	8d04 <rtc_get>
    1078:	add	r1, sp, #8
    107a:	bl	1354 <breakTime(unsigned long, tmElements_t&)>

  Serial.println("CVAS_V3 Version: " __DATE__  " " __TIME__ );
    107e:	ldr	r1, [pc, #88]	; (10d8 <printMenuEntries()+0x68>)
    1080:	mov	r0, r4
    1082:	bl	6a4 <Print::println(char const*)>
  Serial.printf("Teensy: %d: %06x\n",teensy,SerNum);
    1086:	ldr	r3, [pc, #84]	; (10dc <printMenuEntries()+0x6c>)
    1088:	ldr	r1, [pc, #84]	; (10e0 <printMenuEntries()+0x70>)
    108a:	ldr	r3, [r3, #0]
    108c:	movs	r2, #36	; 0x24
    108e:	mov	r0, r4
    1090:	bl	99b8 <Print::printf(char const*, ...)>
  Serial.printf("Date d = %04d/%02d/%02d\n",tmYearToCalendar(tm.Year), tm.Month, tm.Day); 
    1094:	ldrb.w	r2, [sp, #14]
    1098:	ldrb.w	r1, [sp, #12]
    109c:	ldrb.w	r3, [sp, #13]
    10a0:	str	r1, [sp, #0]
    10a2:	addw	r2, r2, #1970	; 0x7b2
    10a6:	ldr	r1, [pc, #60]	; (10e4 <printMenuEntries()+0x74>)
    10a8:	mov	r0, r4
    10aa:	bl	99b8 <Print::printf(char const*, ...)>
  Serial.printf("Time t = %02d:%02d:%02d\n",tm.Hour, tm.Minute, tm.Second); 
    10ae:	ldrb.w	r1, [sp, #8]
    10b2:	ldrb.w	r3, [sp, #9]
    10b6:	ldrb.w	r2, [sp, #10]
    10ba:	str	r1, [sp, #0]
    10bc:	mov	r0, r4
    10be:	ldr	r1, [pc, #40]	; (10e8 <printMenuEntries()+0x78>)
    10c0:	bl	99b8 <Print::printf(char const*, ...)>
  Serial.printf("T_acq a = %d\n",t_acq); 
    10c4:	ldr	r3, [pc, #36]	; (10ec <printMenuEntries()+0x7c>)
    10c6:	ldr	r1, [pc, #40]	; (10f0 <printMenuEntries()+0x80>)
    10c8:	ldr	r2, [r3, #0]
    10ca:	mov	r0, r4
    10cc:	bl	99b8 <Print::printf(char const*, ...)>
}
    10d0:	add	sp, #16
    10d2:	pop	{r4, pc}
    10d4:	.word	0x1fff1368
    10d8:	.word	0x00011ef1
    10dc:	.word	0x1fff7eb8
    10e0:	.word	0x00011f17
    10e4:	.word	0x00011f29
    10e8:	.word	0x00011f42
    10ec:	.word	0x1fff0f38
    10f0:	.word	0x00011f5b

000010f4 <menuGetInt(int*)>:

int menuGetInt(int *val)
{ char buffer[40];
    10f4:	push	{r4, lr}
    10f6:	mov	r4, r0
    10f8:	sub	sp, #40	; 0x28
				if (elapsed > 750) break;
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    10fa:	bl	8990 <usb_serial_available>
  while(!Serial.available());
    10fe:	cmp	r0, #0
    1100:	beq.n	10fa <menuGetInt(int*)+0x6>
  int count = Serial.readBytesUntil('\r',buffer,40);
    1102:	mov	r2, sp
    1104:	movs	r3, #40	; 0x28
    1106:	movs	r1, #13
    1108:	ldr	r0, [pc, #28]	; (1128 <menuGetInt(int*)+0x34>)
    110a:	bl	9bbc <Stream::readBytesUntil(char, char*, unsigned int)>
  buffer[count]=0;
    110e:	add	r3, sp, #40	; 0x28
    1110:	add	r0, r3
    1112:	movs	r3, #0
    1114:	strb.w	r3, [r0, #-40]
//  Serial.println(buffer);
  return sscanf(buffer,"%d",val);
    1118:	mov	r2, r4
    111a:	ldr	r1, [pc, #16]	; (112c <menuGetInt(int*)+0x38>)
    111c:	mov	r0, sp
    111e:	bl	b6a4 <sscanf>
}
    1122:	add	sp, #40	; 0x28
    1124:	pop	{r4, pc}
    1126:	nop
    1128:	.word	0x1fff1368
    112c:	.word	0x00012014

00001130 <menuGet3Int(int*, int*, int*)>:

int menuGet3Int(int *val1, int *val2, int *val3)
{ char buffer[40];
    1130:	push	{r4, r5, r6, lr}
    1132:	mov	r4, r0
    1134:	sub	sp, #64	; 0x40
    1136:	mov	r5, r1
    1138:	mov	r6, r2
    113a:	bl	8990 <usb_serial_available>
  while(!Serial.available());
    113e:	cmp	r0, #0
    1140:	beq.n	113a <menuGet3Int(int*, int*, int*)+0xa>
  int count = Serial.readBytesUntil('\r',buffer,40);
    1142:	add	r2, sp, #24
    1144:	movs	r3, #40	; 0x28
    1146:	movs	r1, #13
    1148:	ldr	r0, [pc, #40]	; (1174 <menuGet3Int(int*, int*, int*)+0x44>)
    114a:	bl	9bbc <Stream::readBytesUntil(char, char*, unsigned int)>
  buffer[count]=0;
    114e:	add	r3, sp, #64	; 0x40
    1150:	add	r0, r3
    1152:	movs	r3, #0
    1154:	strb.w	r3, [r0, #-40]
//  Serial.println(buffer);
  char c1,c2;
  return sscanf(buffer,"%d%c%d%c%d",val1,&c1,val2,&c2,val3);
    1158:	add.w	r3, sp, #23
    115c:	str	r3, [sp, #4]
    115e:	str	r6, [sp, #8]
    1160:	str	r5, [sp, #0]
    1162:	add.w	r3, sp, #22
    1166:	mov	r2, r4
    1168:	ldr	r1, [pc, #12]	; (1178 <menuGet3Int(int*, int*, int*)+0x48>)
    116a:	add	r0, sp, #24
    116c:	bl	b6a4 <sscanf>
}
    1170:	add	sp, #64	; 0x40
    1172:	pop	{r4, r5, r6, pc}
    1174:	.word	0x1fff1368
    1178:	.word	0x00011f69

0000117c <menu()>:
#if defined (KINETISK) 
#define CPU_RESTART 
#endif

int16_t menu(void)
{
    117c:	push	{r4, lr}
    117e:	sub	sp, #32
    1180:	bl	8990 <usb_serial_available>
  if(!Serial.available()) return 0;
    1184:	cmp	r0, #0
    1186:	beq.w	1304 <menu()+0x188>
        virtual int read() { return usb_serial_getchar(); }
    118a:	bl	890c <usb_serial_getchar>

  char ch=Serial.read();
    118e:	uxtb	r0, r0
  if(ch==':')
    1190:	cmp	r0, #58	; 0x3a
    1192:	bne.n	1214 <menu()+0x98>
				if (elapsed > 750) break;
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    1194:	bl	8990 <usb_serial_available>
  { while(!Serial.available()) ; ch=Serial.read();
    1198:	cmp	r0, #0
    119a:	beq.n	1194 <menu()+0x18>
        virtual int read() { return usb_serial_getchar(); }
    119c:	bl	890c <usb_serial_getchar>
    11a0:	uxtb	r0, r0

    if(ch=='s') { Serial.print("\n"); Serial.print("start"); return  +1;} // start acq
    11a2:	cmp	r0, #115	; 0x73
    11a4:	bne.n	11ba <menu()+0x3e>
	virtual int availableForWrite(void)		{ return 0; }
	virtual void flush()				{ }
	size_t write(const char *buffer, size_t size)	{ return write((const uint8_t *)buffer, size); }
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
    11a6:	ldr	r1, [pc, #356]	; (130c <menu()+0x190>)
    11a8:	ldr	r0, [pc, #356]	; (1310 <menu()+0x194>)
    11aa:	bl	a40 <Print::write(char const*)>
    11ae:	ldr	r1, [pc, #356]	; (1314 <menu()+0x198>)
    11b0:	ldr	r0, [pc, #348]	; (1310 <menu()+0x194>)
    11b2:	bl	a40 <Print::write(char const*)>
    11b6:	movs	r0, #1
    11b8:	b.n	1306 <menu()+0x18a>
    else if(ch=='e') { Serial.print("\n"); Serial.print("stop");  return  -1;} // end acq
    11ba:	cmp	r0, #101	; 0x65
    11bc:	bne.n	11d4 <menu()+0x58>
    11be:	ldr	r1, [pc, #332]	; (130c <menu()+0x190>)
    11c0:	ldr	r0, [pc, #332]	; (1310 <menu()+0x194>)
    11c2:	bl	a40 <Print::write(char const*)>
    11c6:	ldr	r1, [pc, #336]	; (1318 <menu()+0x19c>)
    11c8:	ldr	r0, [pc, #324]	; (1310 <menu()+0x194>)
    11ca:	bl	a40 <Print::write(char const*)>
    11ce:	mov.w	r0, #4294967295
    11d2:	b.n	1306 <menu()+0x18a>
    else if(ch=='h') { printMenu(); return 0;} 
    11d4:	cmp	r0, #104	; 0x68
    11d6:	bne.n	11de <menu()+0x62>
    11d8:	bl	f9c <printMenu()>
    11dc:	b.n	1304 <menu()+0x188>
    else if(ch=='w') { saveParameters(); return 0;} 
    11de:	cmp	r0, #119	; 0x77
    11e0:	bne.n	11e8 <menu()+0x6c>
    11e2:	bl	f80 <saveParameters()>
    11e6:	b.n	1304 <menu()+0x188>
    else if(ch=='l') { listDisks(); return 0;} 
    11e8:	cmp	r0, #108	; 0x6c
    11ea:	bne.n	11f2 <menu()+0x76>
    11ec:	bl	1c44 <listDisks()>
    11f0:	b.n	1304 <menu()+0x188>
    else if(ch=='b') { Serial.print("\n"); Serial.print("rebooting CPU"); Serial.flush(); delay(100); CPU_RESTART; return 0;} 
    11f2:	cmp	r0, #98	; 0x62
    11f4:	bne.w	1304 <menu()+0x188>
    11f8:	ldr	r1, [pc, #272]	; (130c <menu()+0x190>)
    11fa:	ldr	r0, [pc, #276]	; (1310 <menu()+0x194>)
    11fc:	bl	a40 <Print::write(char const*)>
    1200:	ldr	r1, [pc, #280]	; (131c <menu()+0x1a0>)
    1202:	ldr	r0, [pc, #268]	; (1310 <menu()+0x194>)
    1204:	bl	a40 <Print::write(char const*)>
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
    1208:	bl	8b1c <usb_serial_flush_output>
    120c:	movs	r0, #100	; 0x64
    120e:	bl	8dd4 <delay>
    1212:	b.n	1304 <menu()+0x188>
  }
  else if(ch=='?') // get info
    1214:	cmp	r0, #63	; 0x3f
    1216:	bne.n	1282 <menu()+0x106>
				if (elapsed > 750) break;
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    1218:	bl	8990 <usb_serial_available>
  {
    while(!Serial.available()) ; ch=Serial.read();
    121c:	cmp	r0, #0
    121e:	beq.n	1218 <menu()+0x9c>
        virtual int read() { return usb_serial_getchar(); }
    1220:	bl	890c <usb_serial_getchar>
    1224:	uxtb	r4, r0

    tmElements_t tm;
    breakTime(rtc_get(), tm);
    1226:	bl	8d04 <rtc_get>
    122a:	add	r1, sp, #24
    122c:	bl	1354 <breakTime(unsigned long, tmElements_t&)>

    if(ch=='p') { printMenuEntries(); return 0;} 
    1230:	cmp	r4, #112	; 0x70
    1232:	bne.n	123a <menu()+0xbe>
    1234:	bl	1070 <printMenuEntries()>
    1238:	b.n	1304 <menu()+0x188>
    else if(ch=='d') { Serial.printf("%04d/%02d/%02d\n",tmYearToCalendar(tm.Year), tm.Month, tm.Day); return  0;} // display date
    123a:	cmp	r4, #100	; 0x64
    123c:	bne.n	1254 <menu()+0xd8>
    123e:	ldrb.w	r2, [sp, #30]
    1242:	ldrb.w	r1, [sp, #28]
    1246:	str	r1, [sp, #0]
    1248:	ldrb.w	r3, [sp, #29]
    124c:	ldr	r1, [pc, #208]	; (1320 <menu()+0x1a4>)
    124e:	addw	r2, r2, #1970	; 0x7b2
    1252:	b.n	1268 <menu()+0xec>
    else if(ch=='t') { Serial.printf("%02d:%02d:%02d\n",tm.Hour, tm.Minute, tm.Second); return  0;} // display time
    1254:	cmp	r4, #116	; 0x74
    1256:	bne.n	1270 <menu()+0xf4>
    1258:	ldrb.w	r1, [sp, #24]
    125c:	str	r1, [sp, #0]
    125e:	ldrb.w	r3, [sp, #25]
    1262:	ldrb.w	r2, [sp, #26]
    1266:	ldr	r1, [pc, #188]	; (1324 <menu()+0x1a8>)
    1268:	ldr	r0, [pc, #164]	; (1310 <menu()+0x194>)
    126a:	bl	99b8 <Print::printf(char const*, ...)>
    126e:	b.n	1304 <menu()+0x188>
    else if(ch=='a') { Serial.printf("%d\n",t_acq); return  0;} // file size
    1270:	cmp	r4, #97	; 0x61
    1272:	bne.n	1304 <menu()+0x188>
    1274:	ldr	r3, [pc, #176]	; (1328 <menu()+0x1ac>)
    1276:	ldr	r1, [pc, #180]	; (132c <menu()+0x1b0>)
    1278:	ldr	r2, [r3, #0]
    127a:	ldr	r0, [pc, #148]	; (1310 <menu()+0x194>)
    127c:	bl	99b8 <Print::printf(char const*, ...)>
    1280:	b.n	1304 <menu()+0x188>
  }
  else if(ch=='!') // set 
    1282:	cmp	r0, #33	; 0x21
    1284:	bne.n	1304 <menu()+0x188>
				if (elapsed > 750) break;
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    1286:	bl	8990 <usb_serial_available>
  { 
    while(!Serial.available()) ;
    128a:	cmp	r0, #0
    128c:	beq.n	1286 <menu()+0x10a>
        virtual int read() { return usb_serial_getchar(); }
    128e:	bl	890c <usb_serial_getchar>
    ch=Serial.read();
    1292:	uxtb	r0, r0
    if(ch=='d') // set date
    1294:	cmp	r0, #100	; 0x64
    1296:	bne.n	12c4 <menu()+0x148>
    { int year,month,day;
      menuGet3Int(&year,&month,&day);
    1298:	add	r2, sp, #20
    129a:	add	r1, sp, #16
    129c:	add	r0, sp, #12
    129e:	bl	1130 <menuGet3Int(int*, int*, int*)>
      tmElements_t tm;
      breakTime(rtc_get(), tm);
    12a2:	bl	8d04 <rtc_get>
    12a6:	add	r1, sp, #24
    12a8:	bl	1354 <breakTime(unsigned long, tmElements_t&)>

      setRTCTime(tm.Hour, tm.Minute, tm.Second, day, month, year);
    12ac:	ldr	r3, [sp, #12]
    12ae:	str	r3, [sp, #4]
    12b0:	ldr	r3, [sp, #16]
    12b2:	str	r3, [sp, #0]
    12b4:	ldrb.w	r2, [sp, #24]
    12b8:	ldrb.w	r1, [sp, #25]
    12bc:	ldrb.w	r0, [sp, #26]
    12c0:	ldr	r3, [sp, #20]
    12c2:	b.n	12f4 <menu()+0x178>
      return  0;
    } 
    else if(ch=='t') // set time
    12c4:	cmp	r0, #116	; 0x74
    12c6:	bne.n	12fa <menu()+0x17e>
    { int hour,minutes,seconds;
      menuGet3Int(&hour,&minutes,&seconds);
    12c8:	add	r2, sp, #20
    12ca:	add	r1, sp, #16
    12cc:	add	r0, sp, #12
    12ce:	bl	1130 <menuGet3Int(int*, int*, int*)>

      tmElements_t tm;
      breakTime(rtc_get(), tm);
    12d2:	bl	8d04 <rtc_get>
    12d6:	add	r1, sp, #24
    12d8:	bl	1354 <breakTime(unsigned long, tmElements_t&)>
      setRTCTime(hour, minutes, seconds, tm.Day, tm.Month, tmYearToCalendar(tm.Year));
    12dc:	ldrb.w	r2, [sp, #30]
    12e0:	ldrb.w	r3, [sp, #28]
    12e4:	addw	r2, r2, #1970	; 0x7b2
    12e8:	str	r2, [sp, #4]
    12ea:	ldrb.w	r2, [sp, #29]
    12ee:	str	r2, [sp, #0]
    12f0:	add	r0, sp, #12
    12f2:	ldmia	r0, {r0, r1, r2}
    12f4:	bl	1540 <setRTCTime(int, int, int, int, int, int)>
    12f8:	b.n	1304 <menu()+0x188>
      return  0;
    } 
    else if(ch=='a') { menuGetInt(&t_acq); return  0;} // file size
    12fa:	cmp	r0, #97	; 0x61
    12fc:	bne.n	1304 <menu()+0x188>
    12fe:	ldr	r0, [pc, #40]	; (1328 <menu()+0x1ac>)
    1300:	bl	10f4 <menuGetInt(int*)>
    1304:	movs	r0, #0
  }
  return 0;
}
    1306:	add	sp, #32
    1308:	pop	{r4, pc}
    130a:	nop
    130c:	.word	0x00012540
    1310:	.word	0x1fff1368
    1314:	.word	0x00011f74
    1318:	.word	0x00011f7a
    131c:	.word	0x00011f7f
    1320:	.word	0x00011f32
    1324:	.word	0x00011f4b
    1328:	.word	0x1fff0f38
    132c:	.word	0x00011f65

00001330 <newHour()>:
    return 1;
}

int32_t hour_ = 0;
int16_t newHour(void)
{   uint32_t tx=rtc_get();
    1330:	push	{r3, lr}
    1332:	bl	8d04 <rtc_get>
    int32_t h_ = (int32_t) tx/SECS_PER_HOUR;  // use hours since 1970 as measures
    1336:	mov.w	r3, #3600	; 0xe10
    133a:	udiv	r0, r0, r3
    if(hour_== h_) return 0;
    133e:	ldr	r3, [pc, #16]	; (1350 <newHour()+0x20>)
    1340:	ldr	r2, [r3, #0]
    1342:	cmp	r0, r2
    hour_ = h_;
    1344:	itte	ne
    1346:	strne	r0, [r3, #0]
    return 1;
    1348:	movne	r0, #1

int32_t hour_ = 0;
int16_t newHour(void)
{   uint32_t tx=rtc_get();
    int32_t h_ = (int32_t) tx/SECS_PER_HOUR;  // use hours since 1970 as measures
    if(hour_== h_) return 0;
    134a:	moveq	r0, #0
    hour_ = h_;
    return 1;
}
    134c:	pop	{r3, pc}
    134e:	nop
    1350:	.word	0x1fff2214

00001354 <breakTime(unsigned long, tmElements_t&)>:
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    1354:	movs	r3, #60	; 0x3c
/* functions to convert to and from system time */
/* These are for interfacing with time services and are not normally needed in a sketch */

static  const uint8_t monthDays[]={31,28,31,30,31,30,31,31,30,31,30,31}; // API starts months from 1, this array starts from 0
 
void breakTime(uint32_t timeInput, tmElements_t &tm){
    1356:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    135a:	udiv	r4, r0, r3
    135e:	mls	r2, r3, r4, r0
    1362:	strb	r2, [r1, #0]
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
    1364:	udiv	r2, r4, r3
    1368:	mls	r3, r3, r2, r4
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    136c:	movs	r4, #24
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
    136e:	strb	r3, [r1, #1]
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    1370:	mov.w	r3, #3600	; 0xe10
    1374:	udiv	r3, r0, r3
    1378:	udiv	r2, r3, r4
    137c:	mls	r3, r4, r2, r3
    1380:	strb	r3, [r1, #2]
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    1382:	movs	r2, #7
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
  time /= 24; // now it is days
    1384:	ldr	r3, [pc, #240]	; (1478 <breakTime(unsigned long, tmElements_t&)+0x124>)
    1386:	udiv	r0, r0, r3
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    138a:	adds	r3, r0, #4
    138c:	udiv	r2, r3, r2
    1390:	rsb	r2, r2, r2, lsl #3
    1394:	subs	r3, r3, r2
    1396:	adds	r3, #1
    1398:	movs	r4, #0
    139a:	strb	r3, [r1, #3]
  
  year = 0;  
  days = 0;
    139c:	mov	r2, r4
  while((unsigned)(days += (LEAP_YEAR(year) ? 366 : 365)) <= time) {
    139e:	movw	r8, #365	; 0x16d
    13a2:	mov.w	lr, #100	; 0x64
    13a6:	mov.w	ip, #400	; 0x190
    13aa:	uxtb	r6, r4
    13ac:	addw	r3, r6, #1970	; 0x7b2
    13b0:	ands.w	r7, r3, #3
    13b4:	bne.n	13d4 <breakTime(unsigned long, tmElements_t&)+0x80>
    13b6:	sdiv	r5, r3, lr
    13ba:	mls	r5, lr, r5, r3
    13be:	cbnz	r5, 13da <breakTime(unsigned long, tmElements_t&)+0x86>
    13c0:	sdiv	r5, r3, ip
    13c4:	mls	r5, ip, r5, r3
    13c8:	cmp	r5, #0
    13ca:	ite	ne
    13cc:	movne	r5, r8
    13ce:	moveq.w	r5, #366	; 0x16e
    13d2:	b.n	13de <breakTime(unsigned long, tmElements_t&)+0x8a>
    13d4:	movw	r5, #365	; 0x16d
    13d8:	b.n	13de <breakTime(unsigned long, tmElements_t&)+0x8a>
    13da:	mov.w	r5, #366	; 0x16e
    13de:	add	r2, r5
    13e0:	cmp	r0, r2
    13e2:	add.w	r4, r4, #1
    13e6:	bcs.n	13aa <breakTime(unsigned long, tmElements_t&)+0x56>
    year++;
  }
  tm.Year = year; // year is offset from 1970 
    13e8:	strb	r6, [r1, #6]
  
  days -= LEAP_YEAR(year) ? 366 : 365;
    13ea:	cbnz	r7, 1412 <breakTime(unsigned long, tmElements_t&)+0xbe>
    13ec:	movs	r5, #100	; 0x64
    13ee:	sdiv	r4, r3, r5
    13f2:	mls	r4, r5, r4, r3
    13f6:	cbnz	r4, 1418 <breakTime(unsigned long, tmElements_t&)+0xc4>
    13f8:	mov.w	r5, #400	; 0x190
    13fc:	sdiv	r4, r3, r5
    1400:	mls	r4, r5, r4, r3
    1404:	cmp	r4, #0
    1406:	movw	r4, #365	; 0x16d
    140a:	it	eq
    140c:	moveq.w	r4, #366	; 0x16e
    1410:	b.n	141c <breakTime(unsigned long, tmElements_t&)+0xc8>
    1412:	movw	r4, #365	; 0x16d
    1416:	b.n	141c <breakTime(unsigned long, tmElements_t&)+0xc8>
    1418:	mov.w	r4, #366	; 0x16e
  time  -= days; // now it is days in this year, starting at 0
    141c:	subs	r2, r2, r4
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
    141e:	movs	r6, #100	; 0x64
    1420:	mov.w	r4, #400	; 0x190
        monthLength=29;
      } else {
        monthLength=28;
      }
    } else {
      monthLength = monthDays[month];
    1424:	ldr.w	lr, [pc, #84]	; 147c <breakTime(unsigned long, tmElements_t&)+0x128>
    year++;
  }
  tm.Year = year; // year is offset from 1970 
  
  days -= LEAP_YEAR(year) ? 366 : 365;
  time  -= days; // now it is days in this year, starting at 0
    1428:	subs	r0, r0, r2
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
    142a:	sdiv	r2, r3, r6
    142e:	mls	r6, r6, r2, r3
    1432:	sdiv	r2, r3, r4
    1436:	mls	r3, r4, r2, r3
    143a:	movs	r2, #0
  
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
    143c:	cmp	r2, #1
    143e:	uxtb	r5, r2
    1440:	bne.n	1450 <breakTime(unsigned long, tmElements_t&)+0xfc>
      if (LEAP_YEAR(year)) {
    1442:	cbnz	r7, 1456 <breakTime(unsigned long, tmElements_t&)+0x102>
    1444:	cbnz	r6, 145a <breakTime(unsigned long, tmElements_t&)+0x106>
        monthLength=29;
    1446:	cmp	r3, #0
    1448:	ite	ne
    144a:	movne	r4, #28
    144c:	moveq	r4, #29
    144e:	b.n	145c <breakTime(unsigned long, tmElements_t&)+0x108>
      } else {
        monthLength=28;
      }
    } else {
      monthLength = monthDays[month];
    1450:	ldrb.w	r4, [r2, lr]
    1454:	b.n	145c <breakTime(unsigned long, tmElements_t&)+0x108>
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
        monthLength=29;
      } else {
        monthLength=28;
    1456:	movs	r4, #28
    1458:	b.n	145c <breakTime(unsigned long, tmElements_t&)+0x108>
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
        monthLength=29;
    145a:	movs	r4, #29
      }
    } else {
      monthLength = monthDays[month];
    }
    
    if (time >= monthLength) {
    145c:	cmp	r4, r0
    145e:	bhi.n	146c <breakTime(unsigned long, tmElements_t&)+0x118>
    1460:	adds	r2, #1
  time  -= days; // now it is days in this year, starting at 0
  
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    1462:	cmp	r2, #12
    } else {
      monthLength = monthDays[month];
    }
    
    if (time >= monthLength) {
      time -= monthLength;
    1464:	sub.w	r0, r0, r4
  time  -= days; // now it is days in this year, starting at 0
  
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    1468:	bne.n	143c <breakTime(unsigned long, tmElements_t&)+0xe8>
    146a:	mov	r5, r2
      time -= monthLength;
    } else {
        break;
    }
  }
  tm.Month = month + 1;  // jan is month 1  
    146c:	adds	r5, #1
  tm.Day = time + 1;     // day of month
    146e:	adds	r0, #1
      time -= monthLength;
    } else {
        break;
    }
  }
  tm.Month = month + 1;  // jan is month 1  
    1470:	strb	r5, [r1, #5]
  tm.Day = time + 1;     // day of month
    1472:	strb	r0, [r1, #4]
    1474:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    1478:	.word	0x00015180
    147c:	.word	0x00011f8d

00001480 <makeTime(tmElements_t const&)>:
}

uint32_t makeTime(const tmElements_t &tm){   
    1480:	push	{r4, r5, r6, r7, lr}
  
  int i;
  uint32_t seconds;

  // seconds from 1970 till 1 jan 00:00:00 of the given year
  seconds= tm.Year*(SECS_PER_DAY * 365);
    1482:	ldr	r3, [pc, #176]	; (1534 <makeTime(tmElements_t const&)+0xb4>)
    1484:	ldrb	r2, [r0, #6]
    1486:	movw	r1, #1970	; 0x7b2
    148a:	muls	r3, r2
  for (i = 0; i < tm.Year; i++) {
    if (LEAP_YEAR(i)) {
    148c:	movs	r5, #100	; 0x64
    148e:	mov.w	r6, #400	; 0x190
  int i;
  uint32_t seconds;

  // seconds from 1970 till 1 jan 00:00:00 of the given year
  seconds= tm.Year*(SECS_PER_DAY * 365);
  for (i = 0; i < tm.Year; i++) {
    1492:	subw	r4, r1, #1970	; 0x7b2
    1496:	cmp	r2, r4
    1498:	ble.n	14be <makeTime(tmElements_t const&)+0x3e>
    if (LEAP_YEAR(i)) {
    149a:	lsls	r4, r1, #30
    149c:	bne.n	14ba <makeTime(tmElements_t const&)+0x3a>
    149e:	sdiv	r4, r1, r5
    14a2:	mls	r4, r5, r4, r1
    14a6:	cbnz	r4, 14b2 <makeTime(tmElements_t const&)+0x32>
    14a8:	sdiv	r4, r1, r6
    14ac:	mls	r4, r6, r4, r1
    14b0:	cbnz	r4, 14ba <makeTime(tmElements_t const&)+0x3a>
      seconds += SECS_PER_DAY;   // add extra days for leap years
    14b2:	add.w	r3, r3, #86016	; 0x15000
    14b6:	add.w	r3, r3, #384	; 0x180
    14ba:	adds	r1, #1
  int i;
  uint32_t seconds;

  // seconds from 1970 till 1 jan 00:00:00 of the given year
  seconds= tm.Year*(SECS_PER_DAY * 365);
  for (i = 0; i < tm.Year; i++) {
    14bc:	b.n	1492 <makeTime(tmElements_t const&)+0x12>
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    if ( (i == 2) && LEAP_YEAR(tm.Year)) { 
    14be:	addw	r2, r2, #1970	; 0x7b2
    14c2:	movs	r4, #100	; 0x64
    14c4:	mov.w	r5, #400	; 0x190
      seconds += SECS_PER_DAY;   // add extra days for leap years
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    14c8:	ldrb	r6, [r0, #5]
    if ( (i == 2) && LEAP_YEAR(tm.Year)) { 
      seconds += SECS_PER_DAY * 29;
    } else {
      seconds += SECS_PER_DAY * monthDays[i-1];  //monthDay array starts from 0
    14ca:	ldr	r7, [pc, #108]	; (1538 <makeTime(tmElements_t const&)+0xb8>)
    14cc:	ldr.w	lr, [pc, #108]	; 153c <makeTime(tmElements_t const&)+0xbc>
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    if ( (i == 2) && LEAP_YEAR(tm.Year)) { 
    14d0:	sdiv	r1, r2, r4
    14d4:	mls	r4, r4, r1, r2
    14d8:	sdiv	r1, r2, r5
    14dc:	mls	r5, r5, r1, r2
    14e0:	movs	r1, #1
    14e2:	and.w	r2, r2, #3
      seconds += SECS_PER_DAY;   // add extra days for leap years
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    14e6:	cmp	r6, r1
    14e8:	ble.n	150e <makeTime(tmElements_t const&)+0x8e>
    if ( (i == 2) && LEAP_YEAR(tm.Year)) { 
    14ea:	cmp	r1, #2
    14ec:	bne.n	14fe <makeTime(tmElements_t const&)+0x7e>
    14ee:	cbnz	r2, 14fe <makeTime(tmElements_t const&)+0x7e>
    14f0:	cbnz	r4, 14f4 <makeTime(tmElements_t const&)+0x74>
    14f2:	cbnz	r5, 14fe <makeTime(tmElements_t const&)+0x7e>
      seconds += SECS_PER_DAY * 29;
    14f4:	add.w	r3, r3, #2490368	; 0x260000
    14f8:	add.w	r3, r3, #15232	; 0x3b80
    14fc:	b.n	150a <makeTime(tmElements_t const&)+0x8a>
    } else {
      seconds += SECS_PER_DAY * monthDays[i-1];  //monthDay array starts from 0
    14fe:	add.w	ip, r7, r1
    1502:	ldrb.w	ip, [ip, #-1]
    1506:	mla	r3, lr, ip, r3
      seconds += SECS_PER_DAY;   // add extra days for leap years
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    150a:	adds	r1, #1
    150c:	b.n	14e6 <makeTime(tmElements_t const&)+0x66>
  }
  seconds+= (tm.Day-1) * SECS_PER_DAY;
  seconds+= tm.Hour * SECS_PER_HOUR;
  seconds+= tm.Minute * SECS_PER_MIN;
  seconds+= tm.Second;
  return seconds; 
    150e:	ldrb	r2, [r0, #1]
    1510:	ldrb	r1, [r0, #2]
    1512:	rsb	r2, r2, r2, lsl #4
    1516:	mov.w	r4, #3600	; 0xe10
    151a:	lsls	r2, r2, #2
    151c:	mla	r2, r4, r1, r2
    1520:	ldrb	r1, [r0, #0]
    1522:	add	r2, r1
    1524:	ldrb	r1, [r0, #4]
    1526:	ldr	r0, [pc, #20]	; (153c <makeTime(tmElements_t const&)+0xbc>)
    1528:	subs	r1, #1
    152a:	mla	r0, r0, r1, r2
}
    152e:	add	r0, r3
    1530:	pop	{r4, r5, r6, r7, pc}
    1532:	nop
    1534:	.word	0x01e13380
    1538:	.word	0x00011f8d
    153c:	.word	0x00015180

00001540 <setRTCTime(int, int, int, int, int, int)>:

extern "C" void rtc_set(uint32_t tt);

void setRTCTime(int hr,int min,int sec,int dy, int mnth, int yr){
    1540:	push	{r0, r1, r4, lr}
    1542:	ldr	r4, [sp, #20]
  
  tmElements_t tm;
  tm.Year = yr;
  tm.Month = mnth;
  tm.Day = dy;
  tm.Hour = hr;
    1544:	strb.w	r0, [sp, #2]
extern "C" void rtc_set(uint32_t tt);

void setRTCTime(int hr,int min,int sec,int dy, int mnth, int yr){
 // year can be given as full four digit year or two digts (2010 or 10 for 2010);  
 // it is converted to years since 1970
  if( yr > 99)
    1548:	cmp	r4, #99	; 0x63
  tm.Year = yr;
  tm.Month = mnth;
  tm.Day = dy;
  tm.Hour = hr;
  tm.Minute = min;
  tm.Second = sec;
    154a:	add	r0, sp, #8

void setRTCTime(int hr,int min,int sec,int dy, int mnth, int yr){
 // year can be given as full four digit year or two digts (2010 or 10 for 2010);  
 // it is converted to years since 1970
  if( yr > 99)
      yr = yr - 1970;
    154c:	ite	gt
    154e:	subwgt	r4, r4, #1970	; 0x7b2
  else
      yr += 30;  
    1552:	addle	r4, #30
  
  tmElements_t tm;
  tm.Year = yr;
    1554:	strb.w	r4, [sp, #6]
  tm.Month = mnth;
  tm.Day = dy;
  tm.Hour = hr;
  tm.Minute = min;
  tm.Second = sec;
    1558:	strb.w	r2, [r0, #-8]!
  else
      yr += 30;  
  
  tmElements_t tm;
  tm.Year = yr;
  tm.Month = mnth;
    155c:	ldr	r4, [sp, #16]
  tm.Day = dy;
    155e:	strb.w	r3, [sp, #4]
  tm.Hour = hr;
  tm.Minute = min;
    1562:	strb.w	r1, [sp, #1]
  else
      yr += 30;  
  
  tmElements_t tm;
  tm.Year = yr;
  tm.Month = mnth;
    1566:	strb.w	r4, [sp, #5]
  tm.Day = dy;
  tm.Hour = hr;
  tm.Minute = min;
  tm.Second = sec;

  uint32_t tt = makeTime(tm);
    156a:	bl	1480 <makeTime(tmElements_t const&)>
  rtc_set(tt); // for RTC
    156e:	bl	8d10 <rtc_set>
}
    1572:	add	sp, #8
    1574:	pop	{r4, pc}

00001576 <BlockDeviceInterface::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)>:
   * \param[out] dst Pointer to the location that will receive the data.
   * \param[in] callback Function to be called with each sector's data
   * \param[in] context Pointer to be passed to the callback function
   * \return true for success or false for failure.
   */
  virtual bool readSectorsCallback(uint32_t sector, uint8_t* dst, size_t ns,
    1576:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    157a:	ldr	r5, [sp, #32]
    157c:	mov	r7, r0
    157e:	mov	r6, r2
    1580:	add.w	r9, r3, r1
    1584:	mov	r4, r1
   void (*callback)(uint32_t sector, uint8_t *buf, void *context), void *context) {
     for (size_t i = 0; i < ns; i++) {
    1586:	cmp	r4, r9
    1588:	beq.n	15a8 <BlockDeviceInterface::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x32>
       if (!readSector(sector + i, dst)) return false;
    158a:	ldr	r3, [r7, #0]
    158c:	mov	r2, r6
    158e:	ldr	r3, [r3, #12]
    1590:	mov	r1, r4
    1592:	mov	r0, r7
    1594:	blx	r3
    1596:	add.w	r8, r4, #1
    159a:	cbz	r0, 15aa <BlockDeviceInterface::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x34>
       callback(sector + i, dst, context);
    159c:	mov	r0, r4
    159e:	ldr	r2, [sp, #36]	; 0x24
    15a0:	mov	r1, r6
    15a2:	blx	r5
   * \param[in] context Pointer to be passed to the callback function
   * \return true for success or false for failure.
   */
  virtual bool readSectorsCallback(uint32_t sector, uint8_t* dst, size_t ns,
   void (*callback)(uint32_t sector, uint8_t *buf, void *context), void *context) {
     for (size_t i = 0; i < ns; i++) {
    15a4:	mov	r4, r8
    15a6:	b.n	1586 <BlockDeviceInterface::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x10>
       if (!readSector(sector + i, dst)) return false;
       callback(sector + i, dst, context);
     }
     return true;
    15a8:	movs	r0, #1
  }
    15aa:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

000015ae <BlockDeviceInterface::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)>:
   * \param[in] ns Number of sectors to be written.
   * \param[in] callback Function to be called for each sector's data
   * \param[in] context Context to pass to callback function
   * \return true for success or false for failure.
   */
  virtual bool writeSectorsCallback(uint32_t sector, size_t ns,
    15ae:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    15b2:	mov	r5, r0
    15b4:	mov	r7, r3
    15b6:	add.w	r8, r2, r1
    15ba:	mov	r4, r1
   const uint8_t * (*callback)(uint32_t sector, void *context), void *context) {
     for (size_t i = 0; i < ns; i++) {
    15bc:	cmp	r4, r8
    15be:	beq.n	15dc <BlockDeviceInterface::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x2e>
       if (!writeSector(sector + i, callback(sector + i, context))) return false;
    15c0:	ldr	r3, [r5, #0]
    15c2:	ldr	r1, [sp, #24]
    15c4:	ldr	r6, [r3, #32]
    15c6:	mov	r0, r4
    15c8:	blx	r7
    15ca:	mov	r1, r4
    15cc:	mov	r2, r0
    15ce:	mov	r0, r5
    15d0:	blx	r6
    15d2:	adds	r4, #1
    15d4:	cmp	r0, #0
    15d6:	bne.n	15bc <BlockDeviceInterface::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0xe>
    15d8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     }
    return true;
    15dc:	movs	r0, #1
  }
    15de:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000015e2 <SdCardInterface::status()>:
   * \return The number of 512 byte data sectors in the card
   *         or zero if an error occurs.
   */
  virtual uint32_t sectorCount() = 0;
  /** \return card status. */
  virtual uint32_t status() {return 0XFFFFFFFF;}
    15e2:	mov.w	r0, #4294967295
    15e6:	bx	lr

000015e8 <MySpiClass::activate()>:
    public:
        // Initialize the SPI bus.
        void begin(SdSpiConfig config) {  (void) config; SPI.begin(); }

        // Activate SPI hardware with correct speed and mode.
        void activate() { if(doTransactions) SPI.beginTransaction(m_spiSettings); }
    15e8:	ldrb	r3, [r0, #8]
    15ea:	push	{r4, r5, lr}
    15ec:	cmp	r3, #0
    15ee:	beq.n	1664 <MySpiClass::activate()+0x7c>

	// Before using SPI.transfer() or asserting chip select pins,
	// this function is used to gain exclusive access to the SPI bus
	// and configure the correct settings.
	void beginTransaction(SPISettings settings) {
		if (interruptMasksUsed) {
    15f0:	ldr	r3, [pc, #116]	; (1668 <MySpiClass::activate()+0x80>)
    15f2:	ldr	r2, [r0, #4]
    15f4:	ldrb	r1, [r3, #11]
    15f6:	cmp	r1, #0
    15f8:	beq.n	164c <MySpiClass::activate()+0x64>
			__disable_irq();
    15fa:	cpsid	i
			if (interruptMasksUsed & 0x01) {
    15fc:	ldrb	r1, [r3, #11]
    15fe:	lsls	r1, r1, #31
    1600:	bpl.n	160e <MySpiClass::activate()+0x26>
				interruptSave[0] = NVIC_ICER0 & interruptMask[0];
    1602:	ldr	r0, [pc, #104]	; (166c <MySpiClass::activate()+0x84>)
    1604:	ldr	r1, [r3, #12]
    1606:	ldr	r4, [r0, #0]
    1608:	ands	r1, r4
    160a:	str	r1, [r3, #28]
				NVIC_ICER0 = interruptSave[0];
    160c:	str	r1, [r0, #0]
			}
			#if NVIC_NUM_INTERRUPTS > 32
			if (interruptMasksUsed & 0x02) {
    160e:	ldrb	r1, [r3, #11]
    1610:	ldr	r4, [pc, #84]	; (1668 <MySpiClass::activate()+0x80>)
    1612:	lsls	r5, r1, #30
    1614:	bpl.n	1622 <MySpiClass::activate()+0x3a>
				interruptSave[1] = NVIC_ICER1 & interruptMask[1];
    1616:	ldr	r0, [pc, #88]	; (1670 <MySpiClass::activate()+0x88>)
    1618:	ldr	r1, [r4, #16]
    161a:	ldr	r5, [r0, #0]
    161c:	ands	r1, r5
    161e:	str	r1, [r4, #32]
				NVIC_ICER1 = interruptSave[1];
    1620:	str	r1, [r0, #0]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 64 && defined(NVIC_ISER2)
			if (interruptMasksUsed & 0x04) {
    1622:	ldrb	r1, [r3, #11]
    1624:	ldr	r4, [pc, #64]	; (1668 <MySpiClass::activate()+0x80>)
    1626:	lsls	r0, r1, #29
    1628:	bpl.n	1636 <MySpiClass::activate()+0x4e>
				interruptSave[2] = NVIC_ICER2 & interruptMask[2];
    162a:	ldr	r0, [pc, #72]	; (1674 <MySpiClass::activate()+0x8c>)
    162c:	ldr	r1, [r4, #20]
    162e:	ldr	r5, [r0, #0]
    1630:	ands	r1, r5
    1632:	str	r1, [r4, #36]	; 0x24
				NVIC_ICER2 = interruptSave[2];
    1634:	str	r1, [r0, #0]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 96 && defined(NVIC_ISER3)
			if (interruptMasksUsed & 0x08) {
    1636:	ldrb	r1, [r3, #11]
    1638:	ldr	r4, [pc, #44]	; (1668 <MySpiClass::activate()+0x80>)
    163a:	lsls	r1, r1, #28
    163c:	bpl.n	164a <MySpiClass::activate()+0x62>
				interruptSave[3] = NVIC_ICER3 & interruptMask[3];
    163e:	ldr	r0, [pc, #56]	; (1678 <MySpiClass::activate()+0x90>)
    1640:	ldr	r1, [r4, #24]
    1642:	ldr	r5, [r0, #0]
    1644:	ands	r1, r5
    1646:	str	r1, [r4, #40]	; 0x28
				NVIC_ICER3 = interruptSave[3];
    1648:	str	r1, [r0, #0]
			}
			#endif
			__enable_irq();
    164a:	cpsie	i
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    164c:	ldr	r3, [r3, #0]
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 1;
		#endif
		if (port().CTAR0 != settings.ctar) {
    164e:	ldr	r1, [r3, #12]
    1650:	cmp	r1, r2
    1652:	beq.n	1664 <MySpiClass::activate()+0x7c>
			port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x3F);
    1654:	ldr	r1, [pc, #36]	; (167c <MySpiClass::activate()+0x94>)
    1656:	str	r1, [r3, #0]
			port().CTAR0 = settings.ctar;
    1658:	str	r2, [r3, #12]
			port().CTAR1 = settings.ctar| SPI_CTAR_FMSZ(8);
    165a:	orr.w	r2, r2, #1073741824	; 0x40000000
    165e:	str	r2, [r3, #16]
			port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x3F);
    1660:	ldr	r2, [pc, #28]	; (1680 <MySpiClass::activate()+0x98>)
    1662:	str	r2, [r3, #0]
    1664:	pop	{r4, r5, pc}
    1666:	nop
    1668:	.word	0x1fff0f64
    166c:	.word	0xe000e180
    1670:	.word	0xe000e184
    1674:	.word	0xe000e188
    1678:	.word	0xe000e18c
    167c:	.word	0x003f4001
    1680:	.word	0x803f0000

00001684 <MySpiClass::send(unsigned char)>:

        // Receive a byte.
        uint8_t receive() { return SPI.transfer(0XFF); }

        // Send a byte.
        void send(uint8_t data) { SPI.transfer(data); }
    1684:	ldr	r3, [pc, #20]	; (169c <MySpiClass::send(unsigned char)+0x18>)
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    1686:	ldr	r3, [r3, #0]
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    1688:	mov.w	r2, #2147483648	; 0x80000000
    168c:	str	r2, [r3, #44]	; 0x2c
		port().PUSHR = data;
    168e:	str	r1, [r3, #52]	; 0x34
		while (!(port().SR & SPI_SR_TCF)) ; // wait
    1690:	ldr	r2, [r3, #44]	; 0x2c
    1692:	cmp	r2, #0
    1694:	bge.n	1690 <MySpiClass::send(unsigned char)+0xc>
		return port().POPR;
    1696:	ldr	r3, [r3, #56]	; 0x38
    1698:	bx	lr
    169a:	nop
    169c:	.word	0x1fff0f64

000016a0 <__tcf_0>:
    const char *sd_str[]={"sdio",   "sd1","sd2","sd3","sd4","sd5","sd6"};
    const int cs[] = {BUILTIN_SDCARD,  34,   33,   35,   36,   37,  38 };

    const int nsd = sizeof(cs)/sizeof(int);

    SDClass sdx[nsd];
    16a0:	bx	lr

000016a2 <dateTime(unsigned short*, unsigned short*, unsigned char*)>:
    uint32_t diskSpace[nsd];
    uint32_t clusterSize[nsd];

// Call back for file timestamps.  Only called for file create and sync(). needed by SDFat-beta
void dateTime(uint16_t* date, uint16_t* time, uint8_t* ms10) 
{       
    16a2:	push	{r0, r1, r4, r5, r6, lr}
    16a4:	mov	r5, r2
    16a6:	mov	r4, r1
    16a8:	mov	r6, r0
    tmElements_t tm;
    breakTime(rtc_get(), tm);
    16aa:	bl	8d04 <rtc_get>
    16ae:	mov	r1, sp
    16b0:	bl	1354 <breakTime(unsigned long, tmElements_t&)>
 * \param[in] day [1,31]
 *
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
    16b4:	ldrb.w	r3, [sp, #6]

    *date = FS_DATE(tmYearToCalendar(tm.Year),tm.Month, tm.Day);
    16b8:	ldrb.w	r2, [sp, #5]
    16bc:	ldrb.w	r1, [sp, #4]
    16c0:	subs	r3, #10
    16c2:	uxth	r3, r3
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
    16c4:	cmp	r3, #127	; 0x7f
    16c6:	bhi.n	16dc <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x3a>
 *
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
    16c8:	cmp	r2, #12
    16ca:	bhi.n	16dc <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x3a>
    16cc:	cmp	r1, #31
    16ce:	bhi.n	16dc <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x3a>
         year << 9 | month << 5 | day;
    16d0:	orr.w	r1, r1, r2, lsl #5
    16d4:	orr.w	r3, r1, r3, lsl #9
    16d8:	uxth	r3, r3
    16da:	b.n	16de <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x3c>
    16dc:	movs	r3, #0
    16de:	strh	r3, [r6, #0]
    *time = FS_TIME(tm.Hour, tm.Minute, tm.Second);
    16e0:	ldrb.w	r3, [sp, #2]
    16e4:	ldrb.w	r1, [sp, #1]
    16e8:	ldrb.w	r2, [sp]
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
    16ec:	cmp	r3, #23
    16ee:	bhi.n	1706 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x64>
 * \param[in] second [0,59]
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
    16f0:	cmp	r1, #59	; 0x3b
    16f2:	bhi.n	1706 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x64>
    16f4:	cmp	r2, #59	; 0x3b
    16f6:	bhi.n	1706 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x64>
         hour << 11 | minute << 5 | second >> 1;
    16f8:	lsls	r1, r1, #5
    16fa:	orr.w	r3, r1, r3, lsl #11
    16fe:	orr.w	r3, r3, r2, lsr #1
    1702:	uxth	r3, r3
    1704:	b.n	1708 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x66>
    1706:	movs	r3, #0
    *ms10 = tm.Second & 1 ? 100 : 0;
    1708:	ands.w	r2, r2, #1
    170c:	it	ne
    170e:	movne	r2, #100	; 0x64
{       
    tmElements_t tm;
    breakTime(rtc_get(), tm);

    *date = FS_DATE(tmYearToCalendar(tm.Year),tm.Month, tm.Day);
    *time = FS_TIME(tm.Hour, tm.Minute, tm.Second);
    1710:	strh	r3, [r4, #0]
    *ms10 = tm.Second & 1 ? 100 : 0;
    1712:	strb	r2, [r5, #0]
}
    1714:	add	sp, #8
    1716:	pop	{r4, r5, r6, pc}

00001718 <MySpiClass::send(unsigned char const*, unsigned int)>:
        { memset(buf, 0XFF, count); SPI.transfer(buf, count); return 0; }

        // Send multiple bytes.
        // Replace this function if your board has multiple byte send.
        void send(const uint8_t* buf, size_t count) 
        {  SPI.transfer((void *)buf, (void *) dummy_buffer, count); }
    1718:	mov	r3, r2
    171a:	ldr	r0, [pc, #8]	; (1724 <MySpiClass::send(unsigned char const*, unsigned int)+0xc>)
    171c:	ldr	r2, [pc, #8]	; (1728 <MySpiClass::send(unsigned char const*, unsigned int)+0x10>)
    171e:	b.w	2288 <SPIClass::transfer(void const*, void*, unsigned int)>
    1722:	nop
    1724:	.word	0x1fff0f64
    1728:	.word	0x1fff46a8

0000172c <MySpiClass::receive(unsigned char*, unsigned int)>:
        // Send a byte.
        void send(uint8_t data) { SPI.transfer(data); }

        // Receive multiple bytes.  
        // Replace this function if your board has multiple byte receive.
        uint8_t receive(uint8_t* buf, size_t count) 
    172c:	push	{r3, r4, r5, lr}
    172e:	mov	r4, r1
    1730:	mov	r5, r2
        { memset(buf, 0XFF, count); SPI.transfer(buf, count); return 0; }
    1732:	movs	r1, #255	; 0xff
    1734:	mov	r0, r4
    1736:	bl	88c8 <memset>
		port().PUSHR = data | SPI_PUSHR_CTAS(1);
		while (!(port().SR & SPI_SR_TCF)) ; // wait
		return port().POPR;
	}

	void inline transfer(void *buf, size_t count) {transfer(buf, buf, count);}
    173a:	mov	r3, r5
    173c:	mov	r2, r4
    173e:	mov	r1, r4
    1740:	ldr	r0, [pc, #8]	; (174c <MySpiClass::receive(unsigned char*, unsigned int)+0x20>)
    1742:	bl	2288 <SPIClass::transfer(void const*, void*, unsigned int)>
    1746:	movs	r0, #0
    1748:	pop	{r3, r4, r5, pc}
    174a:	nop
    174c:	.word	0x1fff0f64

00001750 <MySpiClass::begin(SdSpiConfig)>:
     * 
     */

    public:
        // Initialize the SPI bus.
        void begin(SdSpiConfig config) {  (void) config; SPI.begin(); }
    1750:	sub	sp, #16
    1752:	add	r0, sp, #16
    1754:	stmdb	r0, {r1, r2, r3}
    1758:	ldr	r0, [pc, #4]	; (1760 <MySpiClass::begin(SdSpiConfig)+0x10>)
    175a:	add	sp, #16
    175c:	b.w	2210 <SPIClass::begin()>
    1760:	.word	0x1fff0f64

00001764 <File::dec_refcount() [clone .isra.23]>:
	size_t write(long n) { return write((uint8_t)n); }
	size_t write(unsigned int n) { return write((uint8_t)n); }
	size_t write(int n) { return write((uint8_t)n); }
	using Print::write;
private:
	void dec_refcount() {
    1764:	push	{r4, lr}
    1766:	mov	r4, r0
		if (--(f->refcount) == 0) {
    1768:	ldr	r0, [r0, #0]
    176a:	ldr	r3, [r0, #4]
    176c:	subs	r3, #1
    176e:	str	r3, [r0, #4]
    1770:	cbnz	r3, 1782 <File::dec_refcount() [clone .isra.23]+0x1e>
			f->close();
    1772:	ldr	r3, [r0, #0]
    1774:	ldr	r3, [r3, #44]	; 0x2c
    1776:	blx	r3
			delete f;
    1778:	ldr	r0, [r4, #0]
    177a:	cbz	r0, 1782 <File::dec_refcount() [clone .isra.23]+0x1e>
    177c:	ldr	r3, [r0, #0]
    177e:	ldr	r3, [r3, #4]
    1780:	blx	r3
		}
		f = nullptr;
    1782:	movs	r3, #0
    1784:	str	r3, [r4, #0]
    1786:	pop	{r4, pc}

00001788 <MySpiClass::deactivate()>:

        // Activate SPI hardware with correct speed and mode.
        void activate() { if(doTransactions) SPI.beginTransaction(m_spiSettings); }
        // Deactivate SPI hardware.
        void deactivate() { if(doTransactions) SPI.endTransaction(); }
    1788:	ldrb	r3, [r0, #8]
    178a:	cbz	r3, 17c6 <MySpiClass::deactivate()+0x3e>
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 0;
		#endif
		if (interruptMasksUsed) {
    178c:	ldr	r3, [pc, #56]	; (17c8 <MySpiClass::deactivate()+0x40>)
    178e:	ldrb	r2, [r3, #11]
    1790:	cbz	r2, 17c6 <MySpiClass::deactivate()+0x3e>
			if (interruptMasksUsed & 0x01) {
    1792:	lsls	r0, r2, #31
				NVIC_ISER0 = interruptSave[0];
    1794:	ittt	mi
    1796:	ldrmi	r2, [pc, #52]	; (17cc <MySpiClass::deactivate()+0x44>)
    1798:	ldrmi	r1, [r3, #28]
    179a:	strmi	r1, [r2, #0]
			}
			#if NVIC_NUM_INTERRUPTS > 32
			if (interruptMasksUsed & 0x02) {
    179c:	ldrb	r2, [r3, #11]
    179e:	lsls	r1, r2, #30
				NVIC_ISER1 = interruptSave[1];
    17a0:	itttt	mi
    17a2:	ldrmi	r2, [pc, #36]	; (17c8 <MySpiClass::deactivate()+0x40>)
    17a4:	ldrmi	r1, [r2, #32]
    17a6:	ldrmi	r2, [pc, #40]	; (17d0 <MySpiClass::deactivate()+0x48>)
    17a8:	strmi	r1, [r2, #0]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 64 && defined(NVIC_ISER2)
			if (interruptMasksUsed & 0x04) {
    17aa:	ldrb	r2, [r3, #11]
    17ac:	lsls	r2, r2, #29
				NVIC_ISER2 = interruptSave[2];
    17ae:	itttt	mi
    17b0:	ldrmi	r2, [pc, #20]	; (17c8 <MySpiClass::deactivate()+0x40>)
    17b2:	ldrmi	r1, [r2, #36]	; 0x24
    17b4:	ldrmi	r2, [pc, #28]	; (17d4 <MySpiClass::deactivate()+0x4c>)
    17b6:	strmi	r1, [r2, #0]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 96 && defined(NVIC_ISER3)
			if (interruptMasksUsed & 0x08) {
    17b8:	ldrb	r3, [r3, #11]
    17ba:	lsls	r3, r3, #28
				NVIC_ISER3 = interruptSave[3];
    17bc:	itttt	mi
    17be:	ldrmi	r3, [pc, #8]	; (17c8 <MySpiClass::deactivate()+0x40>)
    17c0:	ldrmi	r2, [r3, #40]	; 0x28
    17c2:	ldrmi	r3, [pc, #20]	; (17d8 <MySpiClass::deactivate()+0x50>)
    17c4:	strmi	r2, [r3, #0]
    17c6:	bx	lr
    17c8:	.word	0x1fff0f64
    17cc:	.word	0xe000e100
    17d0:	.word	0xe000e104
    17d4:	.word	0xe000e108
    17d8:	.word	0xe000e10c

000017dc <MySpiClass::receive()>:

        // Receive a byte.
        uint8_t receive() { return SPI.transfer(0XFF); }
    17dc:	ldr	r3, [pc, #24]	; (17f8 <MySpiClass::receive()+0x1c>)
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    17de:	ldr	r3, [r3, #0]
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    17e0:	mov.w	r2, #2147483648	; 0x80000000
    17e4:	str	r2, [r3, #44]	; 0x2c
		port().PUSHR = data;
    17e6:	movs	r2, #255	; 0xff
    17e8:	str	r2, [r3, #52]	; 0x34
		while (!(port().SR & SPI_SR_TCF)) ; // wait
    17ea:	ldr	r2, [r3, #44]	; 0x2c
    17ec:	cmp	r2, #0
    17ee:	bge.n	17ea <MySpiClass::receive()+0xe>
		return port().POPR;
    17f0:	ldr	r0, [r3, #56]	; 0x38
    17f2:	uxtb	r0, r0
    17f4:	bx	lr
    17f6:	nop
    17f8:	.word	0x1fff0f64

000017fc <Print::print(char const*)>:
    17fc:	push	{r3, lr}
    17fe:	bl	a40 <Print::write(char const*)>
    1802:	pop	{r3, pc}

00001804 <Print::print(unsigned long)>:

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
	size_t print(unsigned int n)			{ return printNumber(n, 10, 0); }
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
    1804:	movs	r3, #0
    1806:	movs	r2, #10
    1808:	b.w	99d2 <Print::printNumber(unsigned long, unsigned char, unsigned char)>

0000180c <Print::println(unsigned long)>:

	size_t println(uint8_t b)			{ return print(b) + println(); }
	size_t println(int n)				{ return print(n) + println(); }
	size_t println(unsigned int n)			{ return print(n) + println(); }
	size_t println(long n)				{ return print(n) + println(); }
	size_t println(unsigned long n)			{ return print(n) + println(); }
    180c:	push	{r3, r4, r5, lr}
    180e:	mov	r5, r0
    1810:	bl	1804 <Print::print(unsigned long)>
    1814:	mov	r4, r0
    1816:	mov	r0, r5
    1818:	bl	9998 <Print::println()>
    181c:	add	r0, r4
    181e:	pop	{r3, r4, r5, pc}

00001820 <FsVolume::freeClusterCount() const>:
  uint8_t fatType() const {
    return m_fVol ? m_fVol->fatType() :
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    1820:	mov	r3, r0
    return m_fVol ? m_fVol->freeClusterCount() :
    1822:	ldr.w	r0, [r0, #1152]	; 0x480
           m_xVol ? m_xVol->freeClusterCount() : 0;
    1826:	cbz	r0, 182c <FsVolume::freeClusterCount() const+0xc>
    return m_fVol ? m_fVol->fatType() :
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    return m_fVol ? m_fVol->freeClusterCount() :
    1828:	b.w	6410 <FatPartition::freeClusterCount()>
           m_xVol ? m_xVol->freeClusterCount() : 0;
    182c:	ldr.w	r0, [r3, #1156]	; 0x484
    1830:	cbz	r0, 1836 <FsVolume::freeClusterCount() const+0x16>
    1832:	b.w	4334 <ExFatPartition::freeClusterCount()>
  }
    1836:	bx	lr

00001838 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)>:
	}
	SPISettings() {
		init_AlwaysInline(4000000, MSBFIRST, SPI_MODE0);
	}
private:
	void init_MightInline(uint32_t clock, uint8_t bitOrder, uint8_t dataMode) {
    1838:	push	{r4, r5, r6, r7, lr}
		init_AlwaysInline(clock, bitOrder, dataMode);
	}
	void init_AlwaysInline(uint32_t clock, uint8_t bitOrder, uint8_t dataMode)
	  __attribute__((__always_inline__)) {
		uint32_t t, c = SPI_CTAR_FMSZ(7);
		if (bitOrder == LSBFIRST) c |= SPI_CTAR_LSBFE;
    183a:	cmp	r2, #0
				t = SPI_CTAR_PBR(1) | SPI_CTAR_BR(8) | SPI_CTAR_CSSCK(7);
			}
		} else {
			for (uint32_t i=0; i<23; i++) {
				t = ctar_clock_table[i];
				if (clock >= F_BUS / ctar_div_table[i]) break;
    183c:	ldr	r6, [pc, #76]	; (188c <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x54>)
    183e:	ldr	r7, [pc, #80]	; (1890 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x58>)
		init_AlwaysInline(clock, bitOrder, dataMode);
	}
	void init_AlwaysInline(uint32_t clock, uint8_t bitOrder, uint8_t dataMode)
	  __attribute__((__always_inline__)) {
		uint32_t t, c = SPI_CTAR_FMSZ(7);
		if (bitOrder == LSBFIRST) c |= SPI_CTAR_LSBFE;
    1840:	ite	ne
    1842:	movne.w	r4, #939524096	; 0x38000000
    1846:	moveq.w	r4, #956301312	; 0x39000000
				t = SPI_CTAR_PBR(2) | SPI_CTAR_BR(7) | SPI_CTAR_CSSCK(6);
			} else {	 /* F_BUS / 768 */
				t = SPI_CTAR_PBR(1) | SPI_CTAR_BR(8) | SPI_CTAR_CSSCK(7);
			}
		} else {
			for (uint32_t i=0; i<23; i++) {
    184a:	movs	r2, #0
				t = ctar_clock_table[i];
				if (clock >= F_BUS / ctar_div_table[i]) break;
    184c:	ldrh.w	r5, [r6, r2, lsl #1]
    1850:	sdiv	r5, r7, r5
    1854:	cmp	r1, r5
    1856:	bcc.n	1862 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x2a>
			}
		}
		if (dataMode & 0x08) {
    1858:	lsls	r1, r3, #28
    185a:	bpl.n	186c <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x34>
			c |= SPI_CTAR_CPOL;
    185c:	orr.w	r4, r4, #67108864	; 0x4000000
    1860:	b.n	186c <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x34>
				t = SPI_CTAR_PBR(2) | SPI_CTAR_BR(7) | SPI_CTAR_CSSCK(6);
			} else {	 /* F_BUS / 768 */
				t = SPI_CTAR_PBR(1) | SPI_CTAR_BR(8) | SPI_CTAR_CSSCK(7);
			}
		} else {
			for (uint32_t i=0; i<23; i++) {
    1862:	adds	r5, r2, #1
    1864:	cmp	r5, #23
    1866:	beq.n	1858 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x20>
    1868:	mov	r2, r5
    186a:	b.n	184c <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x14>
				t = ctar_clock_table[i];
    186c:	ldr	r1, [pc, #36]	; (1894 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x5c>)
			}
		}
		if (dataMode & 0x08) {
			c |= SPI_CTAR_CPOL;
		}
		if (dataMode & 0x04) {
    186e:	lsls	r3, r3, #29
			} else {	 /* F_BUS / 768 */
				t = SPI_CTAR_PBR(1) | SPI_CTAR_BR(8) | SPI_CTAR_CSSCK(7);
			}
		} else {
			for (uint32_t i=0; i<23; i++) {
				t = ctar_clock_table[i];
    1870:	ldr.w	r2, [r1, r2, lsl #2]
			}
		}
		if (dataMode & 0x08) {
			c |= SPI_CTAR_CPOL;
		}
		if (dataMode & 0x04) {
    1874:	bpl.n	1886 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x4e>
			c |= SPI_CTAR_CPHA;
			t = (t & 0xFFFF0FFF) | ((t & 0xF000) >> 4);
    1876:	bic.w	r3, r2, #61440	; 0xf000
    187a:	lsrs	r2, r2, #4
    187c:	and.w	r2, r2, #3840	; 0xf00
		}
		if (dataMode & 0x08) {
			c |= SPI_CTAR_CPOL;
		}
		if (dataMode & 0x04) {
			c |= SPI_CTAR_CPHA;
    1880:	orr.w	r4, r4, #33554432	; 0x2000000
			t = (t & 0xFFFF0FFF) | ((t & 0xF000) >> 4);
    1884:	orrs	r2, r3
		}
		ctar = c | t;
    1886:	orrs	r2, r4
    1888:	str	r2, [r0, #0]
    188a:	pop	{r4, r5, r6, r7, pc}
    188c:	.word	0x000120be
    1890:	.word	0x02dc6c00
    1894:	.word	0x00012180

00001898 <SPISettings::SPISettings(unsigned long, unsigned char, unsigned char)>:
#define SPI_HAS_NOTUSINGINTERRUPT 1
#define SPI_ATOMIC_VERSION 1

class SPISettings {
public:
	SPISettings(uint32_t clock, uint8_t bitOrder, uint8_t dataMode) {
    1898:	push	{r4, lr}
    189a:	mov	r4, r0
		if (__builtin_constant_p(clock)) {
			init_AlwaysInline(clock, bitOrder, dataMode);
		} else {
			init_MightInline(clock, bitOrder, dataMode);
    189c:	bl	1838 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)>
		}
	}
    18a0:	mov	r0, r4
    18a2:	pop	{r4, pc}

000018a4 <MySpiClass::setSckSpeed(unsigned long)>:
        // Replace this function if your board has multiple byte send.
        void send(const uint8_t* buf, size_t count) 
        {  SPI.transfer((void *)buf, (void *) dummy_buffer, count); }

        // Save SPISettings for new max SCK frequency
        void setSckSpeed(uint32_t maxSck) {  m_spiSettings = SPISettings(maxSck, MSBFIRST, SPI_MODE0); }
    18a4:	push	{r0, r1, r4, lr}
    18a6:	movs	r3, #0
    18a8:	mov	r4, r0
    18aa:	movs	r2, #1
    18ac:	add	r0, sp, #4
    18ae:	bl	1898 <SPISettings::SPISettings(unsigned long, unsigned char, unsigned char)>
    18b2:	ldr	r3, [sp, #4]
    18b4:	str	r3, [r4, #4]
    18b6:	add	sp, #8
    18b8:	pop	{r4, pc}
    18ba:	Address 0x000018ba is out of bounds.


000018bc <getCount()>:

    };

    Data rawData(data_buffer);

    uint16_t getCount () { return rawData.getCount(); }
    18bc:	ldr	r2, [pc, #16]	; (18d0 <getCount()+0x14>)
    18be:	ldrh	r3, [r2, #0]
    18c0:	ldrh	r0, [r2, #2]
            {  
                /**
                 * @brief get number of data blocks in storage
                 * 
                 */
                if(front_ >= rear_) return front_ - rear_; return front_+ MAXBUF -rear_; 
    18c2:	cmp	r3, r0
    18c4:	it	cc
    18c6:	addcc	r3, #10
    18c8:	subs	r0, r3, r0
    18ca:	uxth	r0, r0

    };

    Data rawData(data_buffer);

    uint16_t getCount () { return rawData.getCount(); }
    18cc:	bx	lr
    18ce:	nop
    18d0:	.word	0x1fff4634

000018d4 <pushData(unsigned long*)>:
    uint16_t pushData(uint32_t * src){ return rawData.push(src);}
    18d4:	push	{r3, r4, r5, lr}
            { 
                /** 
                 * @brief push data to storage
                 * @param src is pointer to data block
                 */
                uint16_t f =front_ + 1;
    18d6:	ldr	r5, [pc, #44]	; (1904 <pushData(unsigned long*)+0x30>)
    18d8:	ldrh	r4, [r5, #0]
                if(f >= MAXBUF) f=0;
                if(f == rear_) return 0;
    18da:	ldrh	r3, [r5, #2]
            { 
                /** 
                 * @brief push data to storage
                 * @param src is pointer to data block
                 */
                uint16_t f =front_ + 1;
    18dc:	adds	r4, #1
    18de:	uxth	r4, r4
                if(f >= MAXBUF) f=0;
    18e0:	cmp	r4, #10
    18e2:	it	cs
    18e4:	movcs	r4, #0
                if(f == rear_) return 0;
    18e6:	cmp	r3, r4
    };

    Data rawData(data_buffer);

    uint16_t getCount () { return rawData.getCount(); }
    uint16_t pushData(uint32_t * src){ return rawData.push(src);}
    18e8:	mov	r1, r0
                 * @brief push data to storage
                 * @param src is pointer to data block
                 */
                uint16_t f =front_ + 1;
                if(f >= MAXBUF) f=0;
                if(f == rear_) return 0;
    18ea:	beq.n	1900 <pushData(unsigned long*)+0x2c>

                uint32_t *ptr= data_buffer+f*NBUF_ACQ;
                memcpy(ptr,src,NBUF_ACQ*4);
    18ec:	ldr	r0, [r5, #4]
    18ee:	mov.w	r2, #1024	; 0x400
    18f2:	add.w	r0, r0, r4, lsl #10
    18f6:	bl	8720 <memcpy>
                front_ = f;
    18fa:	strh	r4, [r5, #0]
                return 1;
    18fc:	movs	r0, #1
    18fe:	pop	{r3, r4, r5, pc}
                 * @brief push data to storage
                 * @param src is pointer to data block
                 */
                uint16_t f =front_ + 1;
                if(f >= MAXBUF) f=0;
                if(f == rear_) return 0;
    1900:	movs	r0, #0
    };

    Data rawData(data_buffer);

    uint16_t getCount () { return rawData.getCount(); }
    uint16_t pushData(uint32_t * src){ return rawData.push(src);}
    1902:	pop	{r3, r4, r5, pc}
    1904:	.word	0x1fff4634

00001908 <pullData(unsigned long*, unsigned long)>:
    uint16_t pullData(uint32_t * dst, uint32_t ndbl) {return rawData.pull(dst,ndbl);}
    1908:	push	{r4, r5, r6, lr}
                /** 
                 * @brief pull data from storage
                 * @param dst is pointer to data blocks
                 * @param ndbl is number of data blocks
                 */
                uint16_t r = (rear_/ndbl) ;
    190a:	ldr	r6, [pc, #60]	; (1948 <pullData(unsigned long*, unsigned long)+0x40>)
    190c:	ldrh	r4, [r6, #2]
                if(r == (front_/ndbl)) return 0;
    190e:	ldrh	r3, [r6, #0]
                /** 
                 * @brief pull data from storage
                 * @param dst is pointer to data blocks
                 * @param ndbl is number of data blocks
                 */
                uint16_t r = (rear_/ndbl) ;
    1910:	udiv	r4, r4, r1
                if(r == (front_/ndbl)) return 0;
    1914:	udiv	r3, r3, r1
    1918:	cmp	r4, r3

    Data rawData(data_buffer);

    uint16_t getCount () { return rawData.getCount(); }
    uint16_t pushData(uint32_t * src){ return rawData.push(src);}
    uint16_t pullData(uint32_t * dst, uint32_t ndbl) {return rawData.pull(dst,ndbl);}
    191a:	mov	r5, r1
                 * @brief pull data from storage
                 * @param dst is pointer to data blocks
                 * @param ndbl is number of data blocks
                 */
                uint16_t r = (rear_/ndbl) ;
                if(r == (front_/ndbl)) return 0;
    191c:	beq.n	1944 <pullData(unsigned long*, unsigned long)+0x3c>
    191e:	lsls	r2, r1, #10

                uint32_t *ptr= data_buffer + r*ndbl*NBUF_ACQ;
                memcpy(dst,ptr,ndbl*NBUF_ACQ*4);
    1920:	ldr	r1, [r6, #4]
    1922:	mla	r1, r2, r4, r1
    1926:	bl	8720 <memcpy>
                if(++r >= (MAXBUF/ndbl)) r=0;
    192a:	adds	r1, r4, #1
    192c:	uxth	r1, r1
    192e:	movs	r3, #10
    1930:	udiv	r3, r3, r5
    1934:	cmp	r1, r3
    1936:	it	cs
    1938:	movcs	r1, #0
                rear_ = r*ndbl;
    193a:	smulbb	r1, r5, r1
    193e:	strh	r1, [r6, #2]
                return 1;
    1940:	movs	r0, #1
    1942:	pop	{r4, r5, r6, pc}
                 * @brief pull data from storage
                 * @param dst is pointer to data blocks
                 * @param ndbl is number of data blocks
                 */
                uint16_t r = (rear_/ndbl) ;
                if(r == (front_/ndbl)) return 0;
    1944:	movs	r0, #0

    Data rawData(data_buffer);

    uint16_t getCount () { return rawData.getCount(); }
    uint16_t pushData(uint32_t * src){ return rawData.push(src);}
    uint16_t pullData(uint32_t * dst, uint32_t ndbl) {return rawData.pull(dst,ndbl);}
    1946:	pop	{r4, r5, r6, pc}
    1948:	.word	0x1fff4634

0000194c <sdCsInit(unsigned char)>:
};
MySpiClass mySpi;

void doTransactions(bool val) {mySpi.doTransactions=val;}

void sdCsInit(SdCsPin_t pin) { pinMode(pin, OUTPUT); digitalWriteFast(pin, HIGH);}
    194c:	push	{r4, lr}
    194e:	movs	r1, #1
    1950:	mov	r4, r0
    1952:	bl	8d34 <pinMode>
			}
			#endif
		}
	} else {
		if (val) {
			*portSetRegister(pin) = digitalPinToBitMask(pin);
    1956:	ldr	r3, [pc, #12]	; (1964 <sdCsInit(unsigned char)+0x18>)
    1958:	ldr.w	r3, [r3, r4, lsl #3]
    195c:	movs	r2, #1
    195e:	strb.w	r2, [r3, #128]	; 0x80
    1962:	pop	{r4, pc}
    1964:	.word	0x00012620

00001968 <sdCsWrite(unsigned char, bool)>:
void sdCsWrite(SdCsPin_t pin, bool level) { digitalWriteFast(pin, level); }
    1968:	ldr	r2, [pc, #20]	; (1980 <sdCsWrite(unsigned char, bool)+0x18>)
    196a:	movs	r3, #1
    196c:	ldr.w	r2, [r2, r0, lsl #3]
				CORE_PIN63_PORTCLEAR = CORE_PIN63_BITMASK;
			}
			#endif
		}
	} else {
		if (val) {
    1970:	cbz	r1, 1978 <sdCsWrite(unsigned char, bool)+0x10>
			*portSetRegister(pin) = digitalPinToBitMask(pin);
    1972:	strb.w	r3, [r2, #128]	; 0x80
    1976:	bx	lr
		} else {
			*portClearRegister(pin) = digitalPinToBitMask(pin);
    1978:	strb.w	r3, [r2, #256]	; 0x100
    197c:	bx	lr
    197e:	nop
    1980:	.word	0x00012620

00001984 <storage_configure()>:
    *time = FS_TIME(tm.Hour, tm.Minute, tm.Second);
    *ms10 = tm.Second & 1 ? 100 : 0;
}

void storage_configure()
{
    1984:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
      SPI.setMISO(SD_MISO);
      SPI.setSCK(SD_SCK);
    #endif

    // Set Time callback
    FsDateTime::callback = dateTime;
    1988:	ldr	r3, [pc, #636]	; (1c08 <storage_configure()+0x284>)
    198a:	ldr	r2, [pc, #640]	; (1c0c <storage_configure()+0x288>)
    198c:	ldr	r4, [pc, #640]	; (1c10 <storage_configure()+0x28c>)
    198e:	str	r2, [r3, #0]
    *time = FS_TIME(tm.Hour, tm.Minute, tm.Second);
    *ms10 = tm.Second & 1 ? 100 : 0;
}

void storage_configure()
{
    1990:	sub	sp, #60	; 0x3c
    #endif

    // Set Time callback
    FsDateTime::callback = dateTime;

    for(int ii=0; ii<nsd; ii++)
    1992:	movs	r6, #0
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    1994:	mov	r1, r6
    1996:	ldr	r0, [pc, #636]	; (1c14 <storage_configure()+0x290>)
    1998:	bl	9a48 <Print::print(long)>
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }

	size_t println(uint8_t b)			{ return print(b) + println(); }
	size_t println(int n)				{ return print(n) + println(); }
    199c:	ldr	r0, [pc, #628]	; (1c14 <storage_configure()+0x290>)
    199e:	bl	9998 <Print::println()>
    { Serial.println(ii);

      uint16_t status=0;
      if(cs[ii] == BUILTIN_SDCARD)
    19a2:	ldr	r3, [pc, #628]	; (1c18 <storage_configure()+0x294>)
    19a4:	ldr.w	r7, [r3, r6, lsl #2]
    19a8:	cmp	r7, #254	; 0xfe
    19aa:	mov.w	r5, r6, lsl #2
    19ae:	bne.n	19e8 <storage_configure()+0x64>
    19b0:	mov.w	r8, #0
    19b4:	add.w	sl, r4, #4
    19b8:	addw	fp, r4, #1172	; 0x494
   *
   * \param[in] sdioConfig SDIO configuration.
   * \return true for success or false for failure.
   */
  bool begin(SdioConfig sdioConfig) {
    spiConfigBackupPin = 255;
    19bc:	movs	r3, #255	; 0xff
    sdioConfigBackup = sdioConfig;
    19be:	movs	r1, #0
   * \param[in] config SDIO configuration.
   * \return generic card pointer or nullptr if SDIO is not supported.
   */
  SdCard* newCard(SdioConfig config) {
#if HAS_SDIO_CLASS
    m_sdioCard.begin(config);
    19c0:	mov	r0, fp
   *
   * \param[in] sdioConfig SDIO configuration.
   * \return true for success or false for failure.
   */
  bool begin(SdioConfig sdioConfig) {
    spiConfigBackupPin = 255;
    19c2:	strb.w	r3, [r4, #1204]	; 0x4b4
    sdioConfigBackup = sdioConfig;
    19c6:	strb.w	r1, [r4, #1216]	; 0x4c0
    19ca:	uxth.w	r9, r8
    19ce:	bl	80dc <SdioCard::begin(SdioConfig)>
   *
   * \param[in] sdioConfig SDIO configuration.
   * \return true for success or false for failure.
   */
  bool cardBegin(SdioConfig sdioConfig) {
    m_card = m_cardFactory.newCard(sdioConfig);
    19d2:	str.w	fp, [r4, #1168]	; 0x490
    return m_card && !m_card->errorCode();
    19d6:	cmp.w	fp, #0
    19da:	beq.n	1ad8 <storage_configure()+0x154>
    19dc:	mov	r0, fp
    19de:	bl	78c8 <SdioCard::errorCode() const>
    19e2:	cmp	r0, #0
    19e4:	bne.n	1ad8 <storage_configure()+0x154>
    19e6:	b.n	1ac2 <storage_configure()+0x13e>
            else
            {
                Serial.println("No sdio storage"); 
            }
      }
      else if(cs[ii]<BUILTIN_SDCARD)
    19e8:	cmp	r7, #253	; 0xfd
    19ea:	bgt.w	1bf4 <storage_configure()+0x270>
      { 
            sdCsInit(cs[ii]);
    19ee:	uxtb.w	r8, r7
    19f2:	mov	r0, r8
    19f4:	bl	194c <sdCsInit(unsigned char)>
            delay(100);
    19f8:	movs	r0, #100	; 0x64
    19fa:	bl	8dd4 <delay>
    19fe:	mov.w	fp, #0
   * \return true for success or false for failure.
   */
  bool begin(SdSpiConfig spiConfig) {
    spiConfigBackupPin = spiConfig.csPin;
    spiConfigBackupOptions = spiConfig.options;
    spiConfigBackupClock = spiConfig.maxSck;
    1a02:	ldr	r2, [pc, #536]	; (1c1c <storage_configure()+0x298>)
    1a04:	str.w	r2, [r4, #1208]	; 0x4b8
    spiConfigBackupPort = spiConfig.spiPort;
    1a08:	ldr	r2, [pc, #532]	; (1c20 <storage_configure()+0x29c>)
    1a0a:	str.w	r2, [r4, #1212]	; 0x4bc
    1a0e:	adds	r3, r4, #4
    1a10:	ldr	r2, [pc, #520]	; (1c1c <storage_configure()+0x298>)
    1a12:	str	r2, [sp, #24]
    1a14:	str	r3, [sp, #8]
    1a16:	ldr	r2, [pc, #520]	; (1c20 <storage_configure()+0x29c>)
    1a18:	str	r2, [sp, #28]
   * \param[in] spiConfig SPI configuration.
   * \return true for success or false for failure.
   */
  bool begin(SdSpiConfig spiConfig) {
    spiConfigBackupPin = spiConfig.csPin;
    spiConfigBackupOptions = spiConfig.options;
    1a1a:	movs	r3, #0
    1a1c:	strb.w	r3, [sp, #21]
    1a20:	strb.w	r8, [sp, #20]
    1a24:	add	r2, sp, #20
    1a26:	ldmia	r2, {r0, r1, r2}
    1a28:	add.w	lr, sp, #32
    1a2c:	stmia.w	lr, {r0, r1, r2}
    1a30:	strb.w	r3, [r4, #1205]	; 0x4b5
    1a34:	strb.w	r3, [sp, #33]	; 0x21
    1a38:	ldr	r3, [pc, #480]	; (1c1c <storage_configure()+0x298>)
    1a3a:	str	r3, [sp, #36]	; 0x24
    1a3c:	ldr	r3, [pc, #480]	; (1c20 <storage_configure()+0x29c>)
    1a3e:	str	r3, [sp, #40]	; 0x28
    1a40:	strb.w	r8, [sp, #32]
    1a44:	ldmia.w	lr, {r0, r1, r2}
    1a48:	add	r3, sp, #44	; 0x2c
    1a4a:	stmia.w	r3, {r0, r1, r2}
    1a4e:	add.w	r9, r4, #1184	; 0x4a0
   *
   * \param[in] config SPI configuration.
   * \return generic card pointer.
   */
  SdCard* newCard(SdSpiConfig config) {
    m_spiCard.begin(config);
    1a52:	ldmia	r3, {r1, r2, r3}
    1a54:	mov	r0, r9
   *
   * \param[in] spiConfig SPI configuration.
   * \return true for success or false for failure.
   */
  bool begin(SdSpiConfig spiConfig) {
    spiConfigBackupPin = spiConfig.csPin;
    1a56:	strb.w	r8, [r4, #1204]	; 0x4b4
    1a5a:	uxth.w	sl, fp
    1a5e:	bl	7238 <SdSpiCard::begin(SdSpiConfig)>
   *
   * \param[in] spiConfig SPI configuration.
   * \return true for success or false for failure.
   */
  bool cardBegin(SdSpiConfig spiConfig) {
    m_card = m_cardFactory.newCard(spiConfig);
    1a62:	str.w	r9, [r4, #1168]	; 0x490
    return m_card && !m_card->errorCode();
    1a66:	cmp.w	r9, #0
    1a6a:	bne.n	1a78 <storage_configure()+0xf4>
            uint16_t tries=0;
            while(!sdx[ii].sdfs.begin(SdSpiConfig(cs[ii], SHARED_SPI, SPI_SPEED, &mySpi)) && tries<10)
    1a6c:	cmp.w	sl, #9
    1a70:	ite	hi
    1a72:	movhi	r3, #0
    1a74:	movls	r3, #1
    1a76:	b.n	1a90 <storage_configure()+0x10c>
    1a78:	ldrb.w	r3, [r4, #1199]	; 0x4af
    1a7c:	cmp	r3, #0
    1a7e:	bne.n	1a6c <storage_configure()+0xe8>
  bool begin(SdSpiConfig spiConfig) {
    spiConfigBackupPin = spiConfig.csPin;
    spiConfigBackupOptions = spiConfig.options;
    spiConfigBackupClock = spiConfig.maxSck;
    spiConfigBackupPort = spiConfig.spiPort;
    return cardBegin(spiConfig) && Vol::begin(m_card);
    1a80:	mov	r1, r9
    1a82:	adds	r0, r4, #4
    1a84:	str	r3, [sp, #8]
    1a86:	bl	6e04 <FsVolume::begin(BlockDeviceInterface*)>
    1a8a:	ldr	r3, [sp, #8]
    1a8c:	cmp	r0, #0
    1a8e:	beq.n	1a6c <storage_configure()+0xe8>
    1a90:	add.w	r9, fp, #1
    1a94:	cbz	r3, 1ab2 <storage_configure()+0x12e>
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    1a96:	mov	r1, sl
    1a98:	ldr	r0, [pc, #376]	; (1c14 <storage_configure()+0x290>)
    1a9a:	bl	9a48 <Print::print(long)>
            { Serial.print(tries); Serial.print(" "); tries++; delay(1000); } 
    1a9e:	ldr	r1, [pc, #388]	; (1c24 <storage_configure()+0x2a0>)
    1aa0:	ldr	r0, [pc, #368]	; (1c14 <storage_configure()+0x290>)
    1aa2:	bl	17fc <Print::print(char const*)>
    1aa6:	mov.w	r0, #1000	; 0x3e8
    1aaa:	bl	8dd4 <delay>
      else if(cs[ii]<BUILTIN_SDCARD)
      { 
            sdCsInit(cs[ii]);
            delay(100);
            uint16_t tries=0;
            while(!sdx[ii].sdfs.begin(SdSpiConfig(cs[ii], SHARED_SPI, SPI_SPEED, &mySpi)) && tries<10)
    1aae:	mov	fp, r9
    1ab0:	b.n	1a02 <storage_configure()+0x7e>
            { Serial.print(tries); Serial.print(" "); tries++; delay(1000); } 

            if(tries<10) 
    1ab2:	cmp.w	sl, #9
    1ab6:	bls.n	1afc <storage_configure()+0x178>
            {
                status=1;
            }
            else
            {
                Serial.println("No spi storage");
    1ab8:	ldr	r1, [pc, #364]	; (1c28 <storage_configure()+0x2a4>)
    1aba:	ldr	r0, [pc, #344]	; (1c14 <storage_configure()+0x290>)
    1abc:	bl	6a4 <Print::println(char const*)>
    1ac0:	b.n	1bf4 <storage_configure()+0x270>
   * \return true for success or false for failure.
   */
  bool begin(SdioConfig sdioConfig) {
    spiConfigBackupPin = 255;
    sdioConfigBackup = sdioConfig;
    return cardBegin(sdioConfig) && Vol::begin(m_card);
    1ac2:	ldr.w	r1, [r4, #1168]	; 0x490
    1ac6:	mov	r0, sl
    1ac8:	bl	6e04 <FsVolume::begin(BlockDeviceInterface*)>
    1acc:	cbz	r0, 1ad8 <storage_configure()+0x154>
      {
            uint16_t tries=0;
            while(!sdx[ii].sdfs.begin(SdioConfig(FIFO_SDIO)) && tries<10)
            { Serial.print(tries); Serial.print(" "); tries++; delay(1000); } 

            if(tries<10) 
    1ace:	cmp.w	r9, #10
    1ad2:	bne.n	1afc <storage_configure()+0x178>
            {
                status=1;
            }
            else
            {
                Serial.println("No sdio storage"); 
    1ad4:	ldr	r1, [pc, #340]	; (1c2c <storage_configure()+0x2a8>)
    1ad6:	b.n	1aba <storage_configure()+0x136>

      uint16_t status=0;
      if(cs[ii] == BUILTIN_SDCARD)
      {
            uint16_t tries=0;
            while(!sdx[ii].sdfs.begin(SdioConfig(FIFO_SDIO)) && tries<10)
    1ad8:	cmp.w	r8, #10
    1adc:	beq.n	1ace <storage_configure()+0x14a>
    1ade:	mov	r1, r8
    1ae0:	ldr	r0, [pc, #304]	; (1c14 <storage_configure()+0x290>)
    1ae2:	bl	9a48 <Print::print(long)>
            { Serial.print(tries); Serial.print(" "); tries++; delay(1000); } 
    1ae6:	ldr	r1, [pc, #316]	; (1c24 <storage_configure()+0x2a0>)
    1ae8:	ldr	r0, [pc, #296]	; (1c14 <storage_configure()+0x290>)
    1aea:	bl	17fc <Print::print(char const*)>
    1aee:	mov.w	r0, #1000	; 0x3e8
    1af2:	bl	8dd4 <delay>
    1af6:	add.w	r8, r8, #1

      uint16_t status=0;
      if(cs[ii] == BUILTIN_SDCARD)
      {
            uint16_t tries=0;
            while(!sdx[ii].sdfs.begin(SdioConfig(FIFO_SDIO)) && tries<10)
    1afa:	b.n	19b8 <storage_configure()+0x34>
                Serial.println("No spi storage");
            }
      }
      if (status)
      {
            uint64_t totalSize = sdx[ii].totalSize();
    1afc:	ldr	r3, [r4, #0]
    1afe:	mov	r0, r4
    1b00:	ldr	r3, [r3, #28]
    1b02:	blx	r3
            uint64_t usedSize  = sdx[ii].usedSize();
    1b04:	ldr	r3, [r4, #0]
                Serial.println("No spi storage");
            }
      }
      if (status)
      {
            uint64_t totalSize = sdx[ii].totalSize();
    1b06:	mov	r8, r0
            uint64_t usedSize  = sdx[ii].usedSize();
    1b08:	ldr	r3, [r3, #24]
    1b0a:	mov	r0, r4
                Serial.println("No spi storage");
            }
      }
      if (status)
      {
            uint64_t totalSize = sdx[ii].totalSize();
    1b0c:	mov	r9, r1
            uint64_t usedSize  = sdx[ii].usedSize();
    1b0e:	blx	r3

            Serial.printf("Storage %d %d %s ",ii,cs[ii],sd_str[ii]); 
    1b10:	ldr	r3, [pc, #284]	; (1c30 <storage_configure()+0x2ac>)
    1b12:	ldr	r3, [r5, r3]
    1b14:	str	r3, [sp, #0]
            }
      }
      if (status)
      {
            uint64_t totalSize = sdx[ii].totalSize();
            uint64_t usedSize  = sdx[ii].usedSize();
    1b16:	strd	r0, r1, [sp, #8]

            Serial.printf("Storage %d %d %s ",ii,cs[ii],sd_str[ii]); 
    1b1a:	mov	r3, r7
    1b1c:	ldr	r1, [pc, #276]	; (1c34 <storage_configure()+0x2b0>)
    1b1e:	ldr	r0, [pc, #244]	; (1c14 <storage_configure()+0x290>)
	size_t print(unsigned int n)			{ return printNumber(n, 10, 0); }
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
	size_t print(int64_t n);
	size_t print(uint64_t n)			{ return printNumber64(n, 10, 0); }
    1b20:	movs	r7, #10
    1b22:	mov	r2, r6
    1b24:	mov.w	sl, #0
    1b28:	bl	99b8 <Print::printf(char const*, ...)>
    1b2c:	mov	r2, r8
    1b2e:	mov	r3, r9
    1b30:	stmia.w	sp, {r7, sl}
    1b34:	ldr	r0, [pc, #220]	; (1c14 <storage_configure()+0x290>)
    1b36:	bl	9a58 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)>
            Serial.print(totalSize); Serial.print(" "); Serial.println(usedSize);
    1b3a:	ldr	r1, [pc, #232]	; (1c24 <storage_configure()+0x2a0>)
    1b3c:	ldr	r0, [pc, #212]	; (1c14 <storage_configure()+0x290>)
    1b3e:	bl	17fc <Print::print(char const*)>
    1b42:	ldrd	r2, r3, [sp, #8]
    1b46:	stmia.w	sp, {r7, sl}
    1b4a:	ldr	r0, [pc, #200]	; (1c14 <storage_configure()+0x290>)
    1b4c:	bl	9a58 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)>
	size_t println(int n)				{ return print(n) + println(); }
	size_t println(unsigned int n)			{ return print(n) + println(); }
	size_t println(long n)				{ return print(n) + println(); }
	size_t println(unsigned long n)			{ return print(n) + println(); }
	size_t println(int64_t n)			{ return print(n) + println(); }
	size_t println(uint64_t n)			{ return print(n) + println(); }
    1b50:	ldr	r0, [pc, #192]	; (1c14 <storage_configure()+0x290>)
    1b52:	bl	9998 <Print::println()>
  }
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
    1b56:	ldr.w	r3, [r4, #1156]	; 0x484
    1b5a:	adds	r7, r4, #4
           m_xVol ? m_xVol->clusterCount() : 0;
    1b5c:	cbz	r3, 1b64 <storage_configure()+0x1e0>
  uint8_t* cacheClear() {
    return m_cache.clear();
  }
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_lastCluster - 1;
    1b5e:	ldr	r1, [r3, #28]
    1b60:	subs	r1, #1
    1b62:	b.n	1b6e <storage_configure()+0x1ea>
    1b64:	ldr.w	r1, [r4, #1160]	; 0x488
    1b68:	cbz	r1, 1b6e <storage_configure()+0x1ea>
    1b6a:	ldr.w	r1, [r1, #1072]	; 0x430

            Serial.print(sdx[ii].sdfs.clusterCount()); Serial.print(" "); 
    1b6e:	ldr	r0, [pc, #164]	; (1c14 <storage_configure()+0x290>)
    1b70:	bl	1804 <Print::print(unsigned long)>
    1b74:	ldr	r1, [pc, #172]	; (1c24 <storage_configure()+0x2a0>)
    1b76:	ldr	r0, [pc, #156]	; (1c14 <storage_configure()+0x290>)
    1b78:	bl	17fc <Print::print(char const*)>
            Serial.print(sdx[ii].sdfs.freeClusterCount()); Serial.print(" ");
    1b7c:	mov	r0, r7
    1b7e:	bl	1820 <FsVolume::freeClusterCount() const>
    1b82:	mov	r1, r0
    1b84:	ldr	r0, [pc, #140]	; (1c14 <storage_configure()+0x290>)
    1b86:	bl	1804 <Print::print(unsigned long)>
    1b8a:	ldr	r1, [pc, #152]	; (1c24 <storage_configure()+0x2a0>)
    1b8c:	ldr	r0, [pc, #132]	; (1c14 <storage_configure()+0x290>)
    1b8e:	bl	17fc <Print::print(char const*)>
#ifndef DOXYGEN_SHOULD_SKIP_THIS
  uint32_t __attribute__((error("use sectorsPerCluster()"))) blocksPerCluster();
#endif  // DOXYGEN_SHOULD_SKIP_THIS
  /** \return the number of bytes in a cluster. */
  uint32_t bytesPerCluster() const {
    return m_fVol ? m_fVol->bytesPerCluster() :
    1b92:	ldr.w	r3, [r4, #1156]	; 0x484
           m_xVol ? m_xVol->bytesPerCluster() : 0;
    1b96:	cbz	r3, 1ba6 <storage_configure()+0x222>
    1b98:	ldrb	r1, [r3, #6]
    1b9a:	mov.w	r3, #512	; 0x200
    1b9e:	lsl.w	r1, r3, r1
    1ba2:	uxth	r1, r1
    1ba4:	b.n	1bb0 <storage_configure()+0x22c>
    1ba6:	ldr.w	r1, [r4, #1160]	; 0x488
    1baa:	cbz	r1, 1bb0 <storage_configure()+0x22c>
    1bac:	ldr.w	r1, [r1, #1084]	; 0x43c

            clusterSize[ii] = sdx[ii].sdfs.bytesPerCluster()/512; // count sectors
    1bb0:	ldr	r3, [pc, #132]	; (1c38 <storage_configure()+0x2b4>)
            Serial.println(clusterSize[ii]) ;Serial.print(" ");
    1bb2:	ldr	r0, [pc, #96]	; (1c14 <storage_configure()+0x290>)
            Serial.print(totalSize); Serial.print(" "); Serial.println(usedSize);

            Serial.print(sdx[ii].sdfs.clusterCount()); Serial.print(" "); 
            Serial.print(sdx[ii].sdfs.freeClusterCount()); Serial.print(" ");

            clusterSize[ii] = sdx[ii].sdfs.bytesPerCluster()/512; // count sectors
    1bb4:	lsrs	r1, r1, #9
    1bb6:	str	r1, [r5, r3]
            Serial.println(clusterSize[ii]) ;Serial.print(" ");
    1bb8:	bl	180c <Print::println(unsigned long)>
    1bbc:	ldr	r1, [pc, #100]	; (1c24 <storage_configure()+0x2a0>)
    1bbe:	ldr	r0, [pc, #84]	; (1c14 <storage_configure()+0x290>)
    1bc0:	bl	17fc <Print::print(char const*)>

            diskSpace[ii]=diskSize[ii]=sdx[ii].sdfs.freeClusterCount();
    1bc4:	mov	r0, r7
    1bc6:	bl	1820 <FsVolume::freeClusterCount() const>
    1bca:	ldr	r3, [pc, #112]	; (1c3c <storage_configure()+0x2b8>)
    1bcc:	str	r0, [r5, r3]
    1bce:	ldr	r3, [pc, #112]	; (1c40 <storage_configure()+0x2bc>)
    1bd0:	mov	r1, r0
    1bd2:	str	r0, [r5, r3]
            Serial.println(diskSize[ii]) ;Serial.print(" ");
    1bd4:	ldr	r0, [pc, #60]	; (1c14 <storage_configure()+0x290>)
    1bd6:	bl	180c <Print::println(unsigned long)>
    1bda:	ldr	r1, [pc, #72]	; (1c24 <storage_configure()+0x2a0>)
    1bdc:	ldr	r0, [pc, #52]	; (1c14 <storage_configure()+0x290>)
    1bde:	bl	17fc <Print::print(char const*)>
    #endif

    // Set Time callback
    FsDateTime::callback = dateTime;

    for(int ii=0; ii<nsd; ii++)
    1be2:	adds	r6, #1
    1be4:	cmp	r6, #7
    1be6:	add.w	r4, r4, #1224	; 0x4c8
    1bea:	bne.w	1994 <storage_configure()+0x10>
            diskSize[ii]=0;
            diskSpace[ii]=0;
            clusterSize[ii]=1;
      }
    }
}
    1bee:	add	sp, #60	; 0x3c
    1bf0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            diskSpace[ii]=diskSize[ii]=sdx[ii].sdfs.freeClusterCount();
            Serial.println(diskSize[ii]) ;Serial.print(" ");
      }
      else
      {
            diskSize[ii]=0;
    1bf4:	ldr	r2, [pc, #68]	; (1c3c <storage_configure()+0x2b8>)
    1bf6:	movs	r3, #0
    1bf8:	str	r3, [r5, r2]
            diskSpace[ii]=0;
    1bfa:	ldr	r2, [pc, #68]	; (1c40 <storage_configure()+0x2bc>)
    1bfc:	str	r3, [r5, r2]
            clusterSize[ii]=1;
    1bfe:	ldr	r3, [pc, #56]	; (1c38 <storage_configure()+0x2b4>)
    1c00:	movs	r2, #1
    1c02:	str	r2, [r5, r3]
    1c04:	b.n	1be2 <storage_configure()+0x25e>
    1c06:	nop
    1c08:	.word	0x1fff8418
    1c0c:	.word	0x000016a3
    1c10:	.word	0x1fff2468
    1c14:	.word	0x1fff1368
    1c18:	.word	0x00011fc4
    1c1c:	.word	0x01f78a40
    1c20:	.word	0x1fff4ea8
    1c24:	.word	0x00012018
    1c28:	.word	0x00011ff0
    1c2c:	.word	0x00011fe0
    1c30:	.word	0x1fff0f44
    1c34:	.word	0x00011fff
    1c38:	.word	0x1fff463c
    1c3c:	.word	0x1fff2238
    1c40:	.word	0x1fff221c

00001c44 <listDisks()>:
      }
    }
}

void listDisks(void)
{
    1c44:	push	{r0, r1, r2, r4, r5, lr}
    for(int ii=0;ii<nsd;ii++)
    {
        Serial.print("\n"); 
        Serial.printf("Storage %d %d %s ",ii,cs[ii],sd_str[ii]);
    1c46:	ldr	r5, [pc, #84]	; (1c9c <listDisks()+0x58>)
    }
}

void listDisks(void)
{
    for(int ii=0;ii<nsd;ii++)
    1c48:	movs	r4, #0
    {
        Serial.print("\n"); 
    1c4a:	ldr	r1, [pc, #84]	; (1ca0 <listDisks()+0x5c>)
    1c4c:	ldr	r0, [pc, #84]	; (1ca4 <listDisks()+0x60>)
    1c4e:	bl	17fc <Print::print(char const*)>
        Serial.printf("Storage %d %d %s ",ii,cs[ii],sd_str[ii]);
    1c52:	ldr	r3, [pc, #84]	; (1ca8 <listDisks()+0x64>)
    1c54:	ldr	r1, [pc, #84]	; (1cac <listDisks()+0x68>)
    1c56:	ldr.w	r3, [r3, r4, lsl #2]
    1c5a:	str	r3, [sp, #0]
    1c5c:	mov	r2, r4
    1c5e:	ldr.w	r3, [r5, r4, lsl #2]
    1c62:	ldr	r0, [pc, #64]	; (1ca4 <listDisks()+0x60>)
    1c64:	bl	99b8 <Print::printf(char const*, ...)>
        Serial.printf("%d %d",sdx[ii].sdfs.freeClusterCount(),diskSize[ii]);
    1c68:	ldr	r0, [pc, #68]	; (1cb0 <listDisks()+0x6c>)
    1c6a:	mov.w	r3, #1224	; 0x4c8
    1c6e:	mla	r0, r3, r4, r0
    1c72:	adds	r0, #4
    1c74:	bl	1820 <FsVolume::freeClusterCount() const>
    1c78:	ldr	r3, [pc, #56]	; (1cb4 <listDisks()+0x70>)
    1c7a:	ldr	r1, [pc, #60]	; (1cb8 <listDisks()+0x74>)
    1c7c:	ldr.w	r3, [r3, r4, lsl #2]
    1c80:	mov	r2, r0
    }
}

void listDisks(void)
{
    for(int ii=0;ii<nsd;ii++)
    1c82:	adds	r4, #1
    {
        Serial.print("\n"); 
        Serial.printf("Storage %d %d %s ",ii,cs[ii],sd_str[ii]);
        Serial.printf("%d %d",sdx[ii].sdfs.freeClusterCount(),diskSize[ii]);
    1c84:	ldr	r0, [pc, #28]	; (1ca4 <listDisks()+0x60>)
    1c86:	bl	99b8 <Print::printf(char const*, ...)>
    }
}

void listDisks(void)
{
    for(int ii=0;ii<nsd;ii++)
    1c8a:	cmp	r4, #7
    1c8c:	bne.n	1c4a <listDisks()+0x6>
    {
        Serial.print("\n"); 
        Serial.printf("Storage %d %d %s ",ii,cs[ii],sd_str[ii]);
        Serial.printf("%d %d",sdx[ii].sdfs.freeClusterCount(),diskSize[ii]);
    }
    Serial.print("\n"); 
    1c8e:	ldr	r1, [pc, #16]	; (1ca0 <listDisks()+0x5c>)
    1c90:	ldr	r0, [pc, #16]	; (1ca4 <listDisks()+0x60>)
    1c92:	bl	17fc <Print::print(char const*)>
}
    1c96:	add	sp, #12
    1c98:	pop	{r4, r5, pc}
    1c9a:	nop
    1c9c:	.word	0x00011fc4
    1ca0:	.word	0x00012540
    1ca4:	.word	0x1fff1368
    1ca8:	.word	0x1fff0f44
    1cac:	.word	0x00011fff
    1cb0:	.word	0x1fff2468
    1cb4:	.word	0x1fff2238
    1cb8:	.word	0x00012011

00001cbc <checkReboot()>:
{
    int ii=0;
    while((ii<nsd) && (diskSpace[ii]<MIN_SPACE)) ii++;
    if(ii<nsd) CPU_RESTART;
    return -1;
}
    1cbc:	mov.w	r0, #4294967295
    1cc0:	bx	lr
    1cc2:	Address 0x00001cc2 is out of bounds.


00001cc4 <saveData(short)>:
    return 1;
}

/* main data filing routine */
int16_t saveData(int16_t status)
{   static char dirName[80];
    1cc4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    static char fileName[80];
    static char header[512];
    static int dirFlag=0;

    if(status<CLOSED) return status; // we are stopped: don't do anything
    1cc8:	subs	r4, r0, #0
    return 1;
}

/* main data filing routine */
int16_t saveData(int16_t status)
{   static char dirName[80];
    1cca:	sub	sp, #84	; 0x54
    static char fileName[80];
    static char header[512];
    static int dirFlag=0;

    if(status<CLOSED) return status; // we are stopped: don't do anything
    1ccc:	blt.w	1e8a <saveData(short)+0x1c6>

    //fetch data from circular buffer
    if(pullData(diskBuffer,NDBL))
    1cd0:	movs	r1, #2
    1cd2:	ldr	r0, [pc, #672]	; (1f74 <saveData(short)+0x2b0>)
    1cd4:	bl	1908 <pullData(unsigned long*, unsigned long)>
    1cd8:	cmp	r0, #0
    1cda:	beq.n	1dd4 <saveData(short)+0x110>
    {   disk_count++;
    1cdc:	ldr	r2, [pc, #664]	; (1f78 <saveData(short)+0x2b4>)
    1cde:	ldr	r3, [r2, #0]
    1ce0:	adds	r3, #1
    1ce2:	str	r3, [r2, #0]
        if(status==CLOSED) // file closed: should open
    1ce4:	cbnz	r4, 1d28 <saveData(short)+0x64>
        bool doTransactions=true;

};
MySpiClass mySpi;

void doTransactions(bool val) {mySpi.doTransactions=val;}
    1ce6:	ldr	r3, [pc, #660]	; (1f7c <saveData(short)+0x2b8>)

static SDClass *checkDiskSpace(void)
{   static int isd_ = nsd;

    doTransactions(true);
    while((isd<nsd) && ((diskSize[isd]==0) 
    1ce8:	ldr	r7, [pc, #660]	; (1f80 <saveData(short)+0x2bc>)
    1cea:	ldr.w	r9, [pc, #744]	; 1fd4 <saveData(short)+0x310>
        bool doTransactions=true;

};
MySpiClass mySpi;

void doTransactions(bool val) {mySpi.doTransactions=val;}
    1cee:	movs	r2, #1
    1cf0:	strb	r2, [r3, #8]
    1cf2:	mov	r8, r3
    1cf4:	mov	r5, r7

static SDClass *checkDiskSpace(void)
{   static int isd_ = nsd;

    doTransactions(true);
    while((isd<nsd) && ((diskSize[isd]==0) 
    1cf6:	ldr	r4, [r7, #0]
    1cf8:	ldr	r6, [pc, #644]	; (1f80 <saveData(short)+0x2bc>)
    1cfa:	cmp	r4, #6
    1cfc:	bgt.n	1dfc <saveData(short)+0x138>
    1cfe:	ldr.w	r3, [r9, r4, lsl #2]
    1d02:	cmp	r3, #0
    1d04:	beq.w	1e8e <saveData(short)+0x1ca>
            || ((diskSpace[isd]=sdx[isd].sdfs.freeClusterCount()) < MIN_SPACE) )) isd++;
    1d08:	ldr	r0, [pc, #632]	; (1f84 <saveData(short)+0x2c0>)
    1d0a:	mov.w	r3, #1224	; 0x4c8
    1d0e:	mla	r0, r3, r4, r0
    1d12:	adds	r0, #4
    1d14:	bl	1820 <FsVolume::freeClusterCount() const>
    1d18:	ldr	r3, [pc, #620]	; (1f88 <saveData(short)+0x2c4>)
    1d1a:	cmp.w	r0, #153600	; 0x25800
    1d1e:	str.w	r0, [r3, r4, lsl #2]
    1d22:	bcc.w	1e8e <saveData(short)+0x1ca>
    1d26:	b.n	1dfc <saveData(short)+0x138>
            {
               return MUST_REBOOT; // if file open fails: don't do anything
            }
        }
        //
        if(status==OPENED) // file is open: write first record (header)
    1d28:	cmp	r4, #1
    1d2a:	bne.n	1dba <saveData(short)+0xf6>
     * @param header is pointer to header
     * 
     */
    #define MAGIC "WMXZ"
    tmElements_t tm;
    breakTime(rtc_get(), tm);
    1d2c:	bl	8d04 <rtc_get>
    1d30:	add	r1, sp, #24
    1d32:	bl	1354 <breakTime(unsigned long, tmElements_t&)>

    int nd=sprintf(header,"%s%04d%02d%02d_%02d%02d%02d",
            MAGIC,tmYearToCalendar(tm.Year),tm.Month,tm.Day,tm.Hour,tm.Minute,tm.Second);
    1d36:	ldrb.w	r2, [sp, #24]
    1d3a:	str	r2, [sp, #16]
    1d3c:	ldrb.w	r2, [sp, #25]
    1d40:	str	r2, [sp, #12]
    1d42:	ldrb.w	r2, [sp, #26]
    1d46:	ldr	r5, [pc, #580]	; (1f8c <saveData(short)+0x2c8>)
    1d48:	ldrb.w	r3, [sp, #30]
    1d4c:	str	r2, [sp, #8]
    1d4e:	ldrb.w	r2, [sp, #28]
    1d52:	str	r2, [sp, #4]
    1d54:	ldrb.w	r2, [sp, #29]
    1d58:	str	r2, [sp, #0]
    1d5a:	addw	r3, r3, #1970	; 0x7b2
    1d5e:	ldr	r2, [pc, #560]	; (1f90 <saveData(short)+0x2cc>)
    1d60:	ldr	r1, [pc, #560]	; (1f94 <saveData(short)+0x2d0>)
    1d62:	mov	r0, r5
    1d64:	bl	b658 <sprintf>
    char *ptr = header+(nd+1);
    1d68:	adds	r0, #1

    int32_t *iptr = (int32_t *) ptr;
    iptr[0] = 4;                    // SW version
    1d6a:	movs	r2, #4
    1d6c:	str	r2, [r5, r0]
    iptr[1] = (int32_t)SerNum;      // serial number
    1d6e:	ldr	r2, [pc, #552]	; (1f98 <saveData(short)+0x2d4>)
    tmElements_t tm;
    breakTime(rtc_get(), tm);

    int nd=sprintf(header,"%s%04d%02d%02d_%02d%02d%02d",
            MAGIC,tmYearToCalendar(tm.Year),tm.Month,tm.Day,tm.Hour,tm.Minute,tm.Second);
    char *ptr = header+(nd+1);
    1d70:	adds	r3, r5, r0

    int32_t *iptr = (int32_t *) ptr;
    iptr[0] = 4;                    // SW version
    iptr[1] = (int32_t)SerNum;      // serial number
    1d72:	ldr	r2, [r2, #0]
    1d74:	str	r2, [r3, #4]
    iptr[2] = FSAMP;
    1d76:	movw	r2, #48000	; 0xbb80
    1d7a:	str	r2, [r3, #8]
    iptr[3] = NCHAN_ACQ;
    iptr[4] = t_acq;
    1d7c:	ldr	r2, [pc, #540]	; (1f9c <saveData(short)+0x2d8>)
    1d7e:	ldr	r2, [r2, #0]
    1d80:	str	r2, [r3, #16]

    int32_t *iptr = (int32_t *) ptr;
    iptr[0] = 4;                    // SW version
    iptr[1] = (int32_t)SerNum;      // serial number
    iptr[2] = FSAMP;
    iptr[3] = NCHAN_ACQ;
    1d82:	movs	r4, #2
    iptr[4] = t_acq;
    iptr[5] = 0;
    1d84:	movs	r2, #0

    int32_t *iptr = (int32_t *) ptr;
    iptr[0] = 4;                    // SW version
    iptr[1] = (int32_t)SerNum;      // serial number
    iptr[2] = FSAMP;
    iptr[3] = NCHAN_ACQ;
    1d86:	str	r4, [r3, #12]
    iptr[4] = t_acq;
    iptr[5] = 0;
    1d88:	str	r2, [r3, #20]

    uint32_t *uptr = (uint32_t*) header;
    uptr[127] = 0x55555555;
    1d8a:	movs	r3, #85	; 0x55
    1d8c:	strb.w	r3, [r5, #508]	; 0x1fc
    1d90:	strb.w	r3, [r5, #509]	; 0x1fd
    1d94:	strb.w	r3, [r5, #510]	; 0x1fe
    1d98:	strb.w	r3, [r5, #511]	; 0x1ff
    1d9c:	ldr	r3, [pc, #512]	; (1fa0 <saveData(short)+0x2dc>)
    1d9e:	ldr	r0, [r3, #16]
	virtual size_t write(const uint8_t *buf, size_t size) {
		return (f) ? f->write((void*)buf, size) : 0;
	}

	size_t write(const void *buf, size_t size) {
		return (f) ? f->write(buf, size) : 0;
    1da0:	cbnz	r0, 1da8 <saveData(short)+0xe4>
                file = msd->open(fileName, FILE_WRITE_BEGIN); 
                if(file) 
                    status = OPENED; 
                else 
                {   Serial.println("Failing open file");
                    return MUST_REBOOT; 
    1da2:	mvn.w	r0, #1
    1da6:	b.n	20b2 <saveData(short)+0x3ee>
    1da8:	ldr	r3, [r0, #0]
    1daa:	mov.w	r2, #512	; 0x200
    1dae:	ldr	r3, [r3, #12]
    1db0:	mov	r1, r5
    1db2:	blx	r3
            }
        }
        //
        if(status==OPENED) // file is open: write first record (header)
        {   makeHeader(header);
            if(file.write((const void*)header,512) < 512) return MUST_REBOOT; else status=2;
    1db4:	cmp.w	r0, #512	; 0x200
    1db8:	bcc.n	1da2 <saveData(short)+0xde>
    1dba:	ldr	r3, [pc, #484]	; (1fa0 <saveData(short)+0x2dc>)
    1dbc:	ldr	r0, [r3, #16]
    1dbe:	cmp	r0, #0
    1dc0:	beq.n	1da2 <saveData(short)+0xde>
    1dc2:	ldr	r3, [r0, #0]
    1dc4:	ldr	r1, [pc, #428]	; (1f74 <saveData(short)+0x2b0>)
    1dc6:	ldr	r3, [r3, #12]
    1dc8:	mov.w	r2, #2048	; 0x800
    1dcc:	blx	r3
        }
        //
        if(status>=RUNNING) // file is open, header written: store data records
        {   
            if(file.write((const void *)diskBuffer,4*MAX_DISK_BUFFER) < 4*MAX_DISK_BUFFER) return MUST_REBOOT;
    1dce:	cmp.w	r0, #2048	; 0x800
    1dd2:	bcc.n	1da2 <saveData(short)+0xde>
        }
    }
    // following is done independent of data availability
    if(status==DOCLOSE) // should close file
    1dd4:	cmp	r4, #3
    1dd6:	bne.n	1de6 <saveData(short)+0x122>
    {
        // writes are done, so enable again transaction activations
        file.flush();
    1dd8:	ldr	r0, [pc, #452]	; (1fa0 <saveData(short)+0x2dc>)
    1dda:	bl	826 <File::flush()>
        file.close();
    1dde:	ldr	r0, [pc, #448]	; (1fa0 <saveData(short)+0x2dc>)
    1de0:	bl	d98 <File::close()>
    1de4:	b.n	1e86 <saveData(short)+0x1c2>
        status = CLOSED;
    }
    if(status==MUSTSTOP) // should close file and stop
    1de6:	cmp	r4, #4
    1de8:	bne.n	1e8a <saveData(short)+0x1c6>
    {   
        file.flush();
    1dea:	ldr	r0, [pc, #436]	; (1fa0 <saveData(short)+0x2dc>)
    1dec:	bl	826 <File::flush()>
        file.close();
    1df0:	ldr	r0, [pc, #428]	; (1fa0 <saveData(short)+0x2dc>)
    1df2:	bl	d98 <File::close()>
        status = STOPPED;
    1df6:	mov.w	r0, #4294967295
    1dfa:	b.n	20b2 <saveData(short)+0x3ee>
        bool doTransactions=true;

};
MySpiClass mySpi;

void doTransactions(bool val) {mySpi.doTransactions=val;}
    1dfc:	movs	r3, #0
    1dfe:	strb.w	r3, [r8, #8]

    doTransactions(true);
    while((isd<nsd) && ((diskSize[isd]==0) 
            || ((diskSpace[isd]=sdx[isd].sdfs.freeClusterCount()) < MIN_SPACE) )) isd++;
    doTransactions(false);
    if(isd<nsd) 
    1e02:	ldr	r3, [r6, #0]
    1e04:	ldr	r4, [pc, #376]	; (1f80 <saveData(short)+0x2bc>)
    1e06:	cmp	r3, #6
    1e08:	bgt.n	1e44 <saveData(short)+0x180>
    {   sdx[isd].sdfs.chvol();
    1e0a:	ldr	r5, [pc, #376]	; (1f84 <saveData(short)+0x2c0>)
    bool chdir(const char* path) {
    return m_fVol ? m_fVol->chdir(path) :
           m_xVol ? m_xVol->chdir(path) : false;
  }
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
    1e0c:	ldr	r2, [pc, #404]	; (1fa4 <saveData(short)+0x2e0>)
        Serial.println(); Serial.print(isd);
    1e0e:	ldr	r0, [pc, #408]	; (1fa8 <saveData(short)+0x2e4>)
    doTransactions(true);
    while((isd<nsd) && ((diskSize[isd]==0) 
            || ((diskSpace[isd]=sdx[isd].sdfs.freeClusterCount()) < MIN_SPACE) )) isd++;
    doTransactions(false);
    if(isd<nsd) 
    {   sdx[isd].sdfs.chvol();
    1e10:	mov.w	r7, #1224	; 0x4c8
    1e14:	mla	r3, r7, r3, r5
    1e18:	adds	r3, #4
    1e1a:	str	r3, [r2, #0]
        Serial.println(); Serial.print(isd);
    1e1c:	bl	9998 <Print::println()>
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    1e20:	ldr	r1, [r4, #0]
    1e22:	ldr	r0, [pc, #388]	; (1fa8 <saveData(short)+0x2e4>)
    1e24:	bl	9a48 <Print::print(long)>
        Serial.print(": "); Serial.print(sdx[isd].sdfs.freeClusterCount());
    1e28:	ldr	r1, [pc, #384]	; (1fac <saveData(short)+0x2e8>)
    1e2a:	ldr	r0, [pc, #380]	; (1fa8 <saveData(short)+0x2e4>)
    1e2c:	bl	17fc <Print::print(char const*)>
    1e30:	ldr	r0, [r4, #0]
    1e32:	mla	r0, r7, r0, r5
    1e36:	adds	r0, #4
    1e38:	bl	1820 <FsVolume::freeClusterCount() const>
    1e3c:	mov	r1, r0
    1e3e:	ldr	r0, [pc, #360]	; (1fa8 <saveData(short)+0x2e4>)
    1e40:	bl	1804 <Print::print(unsigned long)>
    }
    //
    if(isd != isd_) hour_=0; // set hour_ to zero to trigger creation of directories in new disk
    1e44:	ldr	r2, [pc, #360]	; (1fb0 <saveData(short)+0x2ec>)
    1e46:	ldr	r3, [r6, #0]
    1e48:	ldr	r1, [r2, #0]
    isd_=isd;
    1e4a:	str	r3, [r2, #0]
    {   sdx[isd].sdfs.chvol();
        Serial.println(); Serial.print(isd);
        Serial.print(": "); Serial.print(sdx[isd].sdfs.freeClusterCount());
    }
    //
    if(isd != isd_) hour_=0; // set hour_ to zero to trigger creation of directories in new disk
    1e4c:	cmp	r3, r1
    1e4e:	it	ne
    1e50:	ldrne	r1, [pc, #352]	; (1fb4 <saveData(short)+0x2f0>)
    //fetch data from circular buffer
    if(pullData(diskBuffer,NDBL))
    {   disk_count++;
        if(status==CLOSED) // file closed: should open
        {   //doTransactions(true);
            if(!(msd=checkDiskSpace())) return MUST_REBOOT;
    1e52:	ldr	r5, [pc, #356]	; (1fb8 <saveData(short)+0x2f4>)
    {   sdx[isd].sdfs.chvol();
        Serial.println(); Serial.print(isd);
        Serial.print(": "); Serial.print(sdx[isd].sdfs.freeClusterCount());
    }
    //
    if(isd != isd_) hour_=0; // set hour_ to zero to trigger creation of directories in new disk
    1e54:	itt	ne
    1e56:	movne	r0, #0
    1e58:	strne	r0, [r1, #0]
    isd_=isd;
    if(isd==nsd) return (SDClass *) 0; else return &sdx[isd];
    1e5a:	cmp	r3, #7
    1e5c:	ittte	ne
    1e5e:	ldrne	r2, [pc, #292]	; (1f84 <saveData(short)+0x2c0>)
    1e60:	movne.w	r1, #1224	; 0x4c8
    1e64:	mlane	r3, r1, r3, r2
    1e68:	moveq	r3, #0
    //fetch data from circular buffer
    if(pullData(diskBuffer,NDBL))
    {   disk_count++;
        if(status==CLOSED) // file closed: should open
        {   //doTransactions(true);
            if(!(msd=checkDiskSpace())) return MUST_REBOOT;
    1e6a:	str	r3, [r5, #0]
    1e6c:	cmp	r3, #0
    1e6e:	beq.n	1da2 <saveData(short)+0xde>
            //
            if(newDirectory(dirName,dirFlag)) 
    1e70:	ldr	r4, [pc, #328]	; (1fbc <saveData(short)+0x2f8>)
    1e72:	ldr	r7, [r4, #0]
    isd_=isd;
    if(isd==nsd) return (SDClass *) 0; else return &sdx[isd];
}

static int16_t newDirectory(char *dirName, int dirFlag)
{ if(newHour())
    1e74:	bl	1330 <newHour()>
    1e78:	cbnz	r0, 1e96 <saveData(short)+0x1d2>
            if(newDirectory(dirName,dirFlag)) 
            {   if(!msd->sdfs.exists(dirName) && !msd->sdfs.mkdir(dirName)) dirFlag++;          
                if(!msd->sdfs.chdir(dirName)) dirFlag++; else dirFlag=0;
            }
            //
            if(dirFlag>5) return MUST_REBOOT;   // too many directory errors
    1e7a:	ldr	r3, [r4, #0]
    1e7c:	cmp	r3, #5
    1e7e:	bgt.n	1da2 <saveData(short)+0xde>
            if(dirFlag>0) return CLOSED;        // create new directory with different name
    1e80:	cmp	r3, #0
    1e82:	ble.w	2022 <saveData(short)+0x35e>
    1e86:	movs	r0, #0
    1e88:	b.n	20b2 <saveData(short)+0x3ee>
    1e8a:	mov	r0, r4
    1e8c:	b.n	20b2 <saveData(short)+0x3ee>
static SDClass *checkDiskSpace(void)
{   static int isd_ = nsd;

    doTransactions(true);
    while((isd<nsd) && ((diskSize[isd]==0) 
            || ((diskSpace[isd]=sdx[isd].sdfs.freeClusterCount()) < MIN_SPACE) )) isd++;
    1e8e:	ldr	r3, [r5, #0]
    1e90:	adds	r3, #1
    1e92:	str	r3, [r5, #0]
    1e94:	b.n	1cf6 <saveData(short)+0x32>

static int16_t newDirectory(char *dirName, int dirFlag)
{ if(newHour())
    {   
        tmElements_t tm;
        breakTime(rtc_get(), tm);
    1e96:	bl	8d04 <rtc_get>
    1e9a:	add	r1, sp, #24
    1e9c:	bl	1354 <breakTime(unsigned long, tmElements_t&)>
    1ea0:	ldr	r2, [pc, #244]	; (1f98 <saveData(short)+0x2d4>)
    1ea2:	ldrb.w	lr, [sp, #26]
    1ea6:	ldrb.w	r0, [sp, #28]
    1eaa:	ldrb.w	r1, [sp, #29]
    1eae:	ldrb.w	r3, [sp, #30]
        if(!dirFlag)
    1eb2:	cbnz	r7, 1ed0 <saveData(short)+0x20c>
        {
            sprintf(dirName, "/%s%06x_%04d%02d%02d/%02d/", 
                          DirPrefix,(unsigned int)SerNum,
                                  tmYearToCalendar(tm.Year),tm.Month, tm.Day, tm.Hour);
    1eb4:	addw	r3, r3, #1970	; 0x7b2
    1eb8:	str	r0, [sp, #8]
    1eba:	str	r1, [sp, #4]
    1ebc:	str.w	lr, [sp, #12]
    1ec0:	str	r3, [sp, #0]
    1ec2:	ldr	r3, [r2, #0]
    1ec4:	ldr	r1, [pc, #248]	; (1fc0 <saveData(short)+0x2fc>)
    1ec6:	ldr	r2, [pc, #252]	; (1fc4 <saveData(short)+0x300>)
    1ec8:	ldr	r0, [pc, #252]	; (1fc8 <saveData(short)+0x304>)
    1eca:	bl	b658 <sprintf>
    1ece:	b.n	1eec <saveData(short)+0x228>
        }
        else
        {
            sprintf(dirName, "/%s%06x_%04d%02d%02d/%02d_%02d/", 
                          DirPrefix,(unsigned int)SerNum,
                                  tmYearToCalendar(tm.Year),tm.Month, tm.Day, tm.Hour,dirFlag);
    1ed0:	addw	r3, r3, #1970	; 0x7b2
    1ed4:	str	r0, [sp, #8]
    1ed6:	str	r1, [sp, #4]
    1ed8:	str	r7, [sp, #16]
    1eda:	str.w	lr, [sp, #12]
    1ede:	str	r3, [sp, #0]
    1ee0:	ldr	r3, [r2, #0]
    1ee2:	ldr	r1, [pc, #232]	; (1fcc <saveData(short)+0x308>)
    1ee4:	ldr	r2, [pc, #220]	; (1fc4 <saveData(short)+0x300>)
    1ee6:	ldr	r0, [pc, #224]	; (1fc8 <saveData(short)+0x304>)
    1ee8:	bl	b658 <sprintf>
        }

        //
        Serial.print("\n"); Serial.print(dirName);
    1eec:	ldr	r1, [pc, #224]	; (1fd0 <saveData(short)+0x30c>)
    1eee:	ldr	r0, [pc, #184]	; (1fa8 <saveData(short)+0x2e4>)
    1ef0:	bl	17fc <Print::print(char const*)>
    1ef4:	ldr	r1, [pc, #208]	; (1fc8 <saveData(short)+0x304>)
    1ef6:	ldr	r0, [pc, #176]	; (1fa8 <saveData(short)+0x2e4>)
    1ef8:	bl	17fc <Print::print(char const*)>
        if(status==CLOSED) // file closed: should open
        {   //doTransactions(true);
            if(!(msd=checkDiskSpace())) return MUST_REBOOT;
            //
            if(newDirectory(dirName,dirFlag)) 
            {   if(!msd->sdfs.exists(dirName) && !msd->sdfs.mkdir(dirName)) dirFlag++;          
    1efc:	ldr	r3, [r5, #0]
   * \param[in] path Path of the file to be tested for.
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    return m_fVol ? m_fVol->exists(path) :
    1efe:	ldr.w	r1, [r3, #1156]	; 0x484
           m_xVol ? m_xVol->exists(path) : false;
    1f02:	cbz	r1, 1f1c <saveData(short)+0x258>
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    1f04:	movs	r3, #0
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    FatFile tmp;
    return tmp.open(this, path, O_RDONLY);
    1f06:	ldr	r2, [pc, #192]	; (1fc8 <saveData(short)+0x304>)
    1f08:	strb.w	r3, [sp, #24]
    1f0c:	add	r0, sp, #24
    1f0e:	strb.w	r3, [sp, #25]
    1f12:	strb.w	r3, [sp, #26]
    1f16:	bl	5b78 <FatFile::open(FatVolume*, char const*, int)>
    1f1a:	b.n	1f60 <saveData(short)+0x29c>
    1f1c:	ldr.w	r0, [r3, #1160]	; 0x488
    1f20:	cbnz	r0, 1f48 <saveData(short)+0x284>
    1f22:	ldr	r3, [r5, #0]
   * \param[in] pFlag Create missing parent directories if true.
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char *path, bool pFlag = true) {
    return m_fVol ? m_fVol->mkdir(path, pFlag) :
    1f24:	ldr.w	r1, [r3, #1156]	; 0x484
           m_xVol ? m_xVol->mkdir(path, pFlag) : false;
    1f28:	cbz	r1, 1f66 <saveData(short)+0x2a2>
    1f2a:	movs	r3, #0
    1f2c:	strb.w	r3, [sp, #24]
    1f30:	strb.w	r3, [sp, #25]
    1f34:	strb.w	r3, [sp, #26]
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char* path, bool pFlag = true) {
    FatFile sub;
    return sub.mkdir(vwd(), path, pFlag);
    1f38:	ldr	r2, [pc, #140]	; (1fc8 <saveData(short)+0x304>)
    1f3a:	movs	r3, #1
    1f3c:	add.w	r1, r1, #1096	; 0x448
    1f40:	add	r0, sp, #24
    1f42:	bl	5cf4 <FatFile::mkdir(FatFile*, char const*, bool)>
    1f46:	b.n	1ff2 <saveData(short)+0x32e>
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
    1f48:	strb.w	r1, [sp, #73]	; 0x49
    1f4c:	strb.w	r1, [sp, #74]	; 0x4a
    1f50:	strb.w	r1, [sp, #75]	; 0x4b
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    ExFatFile tmp;
    return tmp.open(this, path, O_RDONLY);
    1f54:	mov	r3, r1
    1f56:	ldr	r2, [pc, #112]	; (1fc8 <saveData(short)+0x304>)
    1f58:	mov	r1, r0
    1f5a:	add	r0, sp, #24
    1f5c:	bl	4032 <ExFatFile::open(ExFatVolume*, char const*, int)>
    1f60:	cmp	r0, #0
    1f62:	bne.n	1ff6 <saveData(short)+0x332>
    1f64:	b.n	1f22 <saveData(short)+0x25e>
    1f66:	ldr.w	r0, [r3, #1160]	; 0x488
    1f6a:	cbnz	r0, 1fd8 <saveData(short)+0x314>
    1f6c:	ldr	r3, [r4, #0]
    1f6e:	adds	r3, #1
    1f70:	str	r3, [r4, #0]
    1f72:	b.n	1ff6 <saveData(short)+0x332>
    1f74:	.word	0x1fff76b8
    1f78:	.word	0x1fff76b4
    1f7c:	.word	0x1fff4ea8
    1f80:	.word	0x1fff0f40
    1f84:	.word	0x1fff2468
    1f88:	.word	0x1fff221c
    1f8c:	.word	0x1fff2268
    1f90:	.word	0x0001207f
    1f94:	.word	0x00012084
    1f98:	.word	0x1fff7eb8
    1f9c:	.word	0x1fff0f38
    1fa0:	.word	0x1fff2254
    1fa4:	.word	0x1fff8424
    1fa8:	.word	0x1fff1368
    1fac:	.word	0x00012017
    1fb0:	.word	0x1fff0f3c
    1fb4:	.word	0x1fff2214
    1fb8:	.word	0x1fff2218
    1fbc:	.word	0x1fff4630
    1fc0:	.word	0x0001201c
    1fc4:	.word	0x0001201a
    1fc8:	.word	0x1fff4658
    1fcc:	.word	0x00012037
    1fd0:	.word	0x00012540
    1fd4:	.word	0x1fff2238
    1fd8:	strb.w	r1, [sp, #73]	; 0x49
    1fdc:	strb.w	r1, [sp, #74]	; 0x4a
    1fe0:	strb.w	r1, [sp, #75]	; 0x4b
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char* path, bool pFlag = true) {
    ExFatFile sub;
    return sub.mkdir(vwd(), path, pFlag);
    1fe4:	movs	r3, #1
    1fe6:	add.w	r1, r0, #1096	; 0x448
    1fea:	ldr	r2, [pc, #204]	; (20b8 <saveData(short)+0x3f4>)
    1fec:	add	r0, sp, #24
    1fee:	bl	48d4 <ExFatFile::mkdir(ExFatFile*, char const*, bool)>
    1ff2:	cmp	r0, #0
    1ff4:	beq.n	1f6c <saveData(short)+0x2a8>
                if(!msd->sdfs.chdir(dirName)) dirFlag++; else dirFlag=0;
    1ff6:	ldr	r3, [r5, #0]
   * Set volume working directory.
   * \param[in] path Path for volume working directory.
   * \return true for success or false for failure.
   */
    bool chdir(const char* path) {
    return m_fVol ? m_fVol->chdir(path) :
    1ff8:	ldr.w	r0, [r3, #1156]	; 0x484
           m_xVol ? m_xVol->chdir(path) : false;
    1ffc:	cbz	r0, 2006 <saveData(short)+0x342>
    1ffe:	ldr	r1, [pc, #184]	; (20b8 <saveData(short)+0x3f4>)
    2000:	bl	6574 <FatVolume::chdir(char const*)>
    2004:	b.n	2018 <saveData(short)+0x354>
    2006:	ldr.w	r0, [r3, #1160]	; 0x488
    200a:	cbnz	r0, 2012 <saveData(short)+0x34e>
    200c:	ldr	r3, [r4, #0]
    200e:	adds	r3, #1
    2010:	b.n	201e <saveData(short)+0x35a>
    2012:	ldr	r1, [pc, #164]	; (20b8 <saveData(short)+0x3f4>)
    2014:	bl	447c <ExFatVolume::chdir(char const*)>
    2018:	cmp	r0, #0
    201a:	beq.n	200c <saveData(short)+0x348>
    201c:	movs	r3, #0
    201e:	str	r3, [r4, #0]
    2020:	b.n	1e7a <saveData(short)+0x1b6>

}
static int16_t newFileName(char *fileName)
{
    tmElements_t tm;
    breakTime(rtc_get(), tm);
    2022:	bl	8d04 <rtc_get>
    2026:	add	r1, sp, #24
    2028:	bl	1354 <breakTime(unsigned long, tmElements_t&)>
	sprintf(fileName, "%s_%02d%02d%02d.bin", FilePrefix, tm.Hour, tm.Minute, tm.Second);
    202c:	ldrb.w	r2, [sp, #24]
    2030:	str	r2, [sp, #4]
    2032:	ldrb.w	r2, [sp, #25]
    2036:	ldrb.w	r3, [sp, #26]
    203a:	str	r2, [sp, #0]
    203c:	ldr	r1, [pc, #124]	; (20bc <saveData(short)+0x3f8>)
    203e:	ldr	r2, [pc, #128]	; (20c0 <saveData(short)+0x3fc>)
    2040:	ldr	r0, [pc, #128]	; (20c4 <saveData(short)+0x400>)
    2042:	bl	b658 <sprintf>
    //
    Serial.print("\n"); Serial.print(isd); Serial.print(": ");Serial.print(fileName);
    2046:	ldr	r1, [pc, #128]	; (20c8 <saveData(short)+0x404>)
    2048:	ldr	r0, [pc, #128]	; (20cc <saveData(short)+0x408>)
    204a:	bl	17fc <Print::print(char const*)>
    204e:	ldr	r1, [r6, #0]
    2050:	ldr	r0, [pc, #120]	; (20cc <saveData(short)+0x408>)
    2052:	bl	9a48 <Print::print(long)>
    2056:	ldr	r1, [pc, #120]	; (20d0 <saveData(short)+0x40c>)
    2058:	ldr	r0, [pc, #112]	; (20cc <saveData(short)+0x408>)
    205a:	bl	17fc <Print::print(char const*)>
    205e:	ldr	r1, [pc, #100]	; (20c4 <saveData(short)+0x400>)
    2060:	ldr	r0, [pc, #104]	; (20cc <saveData(short)+0x408>)
    2062:	bl	17fc <Print::print(char const*)>
            if(dirFlag>5) return MUST_REBOOT;   // too many directory errors
            if(dirFlag>0) return CLOSED;        // create new directory with different name

            if(newFileName(fileName))
            {   
                file = msd->open(fileName, FILE_WRITE_BEGIN); 
    2066:	ldr	r1, [r5, #0]
    2068:	ldr	r2, [pc, #88]	; (20c4 <saveData(short)+0x400>)
    206a:	ldr	r3, [r1, #0]
    206c:	add	r0, sp, #24
    206e:	ldr	r4, [r3, #0]
    2070:	movs	r3, #2
    2072:	blx	r4
	}
#ifdef FILE_USE_MOVE
	// Move assignment.
	File& operator = (const File&& file) {
		//Serial.println("File move assignment");
		if (file.f) file.f->refcount++;
    2074:	ldr	r3, [sp, #40]	; 0x28
    2076:	cbz	r3, 207e <saveData(short)+0x3ba>
    2078:	ldr	r2, [r3, #4]
    207a:	adds	r2, #1
    207c:	str	r2, [r3, #4]
		if (f) { dec_refcount(); /*Serial.println("File move assignment autoclose");*/ }
    207e:	ldr	r4, [pc, #84]	; (20d4 <saveData(short)+0x410>)
    2080:	ldr	r3, [r4, #16]
    2082:	cbz	r3, 208c <saveData(short)+0x3c8>
    2084:	add.w	r0, r4, #16
    2088:	bl	1764 <File::dec_refcount() [clone .isra.23]>
		f = file.f;
    208c:	ldr	r3, [sp, #40]	; 0x28
    208e:	str	r3, [r4, #16]
    2090:	add	r0, sp, #24
    2092:	bl	9e0 <File::~File()>
    2096:	ldr	r0, [r4, #16]
			f->close();
			dec_refcount();
		}
	}
	operator bool() {
		return (f) ? f->isOpen() : false;
    2098:	cbnz	r0, 20a4 <saveData(short)+0x3e0>
                if(file) 
                    status = OPENED; 
                else 
                {   Serial.println("Failing open file");
    209a:	ldr	r1, [pc, #60]	; (20d8 <saveData(short)+0x414>)
    209c:	ldr	r0, [pc, #44]	; (20cc <saveData(short)+0x408>)
    209e:	bl	6a4 <Print::println(char const*)>
    20a2:	b.n	1da2 <saveData(short)+0xde>
    20a4:	ldr	r3, [r0, #0]
    20a6:	ldr	r3, [r3, #48]	; 0x30
    20a8:	blx	r3
            if(dirFlag>0) return CLOSED;        // create new directory with different name

            if(newFileName(fileName))
            {   
                file = msd->open(fileName, FILE_WRITE_BEGIN); 
                if(file) 
    20aa:	cmp	r0, #0
    20ac:	bne.w	1d2c <saveData(short)+0x68>
    20b0:	b.n	209a <saveData(short)+0x3d6>
        file.flush();
        file.close();
        status = STOPPED;
    }
    return status;
}
    20b2:	add	sp, #84	; 0x54
    20b4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    20b8:	.word	0x1fff4658
    20bc:	.word	0x00012059
    20c0:	.word	0x00012057
    20c4:	.word	0x1fff45e0
    20c8:	.word	0x00012540
    20cc:	.word	0x1fff1368
    20d0:	.word	0x00012017
    20d4:	.word	0x1fff2254
    20d8:	.word	0x0001206d

000020dc <_GLOBAL__sub_I_data_buffer>:
    20dc:	push	{r3, r4, r5, r6, r7, lr}
            { /**
             * @brief Constructor
             * @param buffer is pointer to data store
             * 
             */
                data_buffer=buffer; front_=rear_=0;
    20de:	ldr	r3, [pc, #144]	; (2170 <_GLOBAL__sub_I_data_buffer+0x94>)
class __FlashStringHelper;

class Print
{
  public:
	constexpr Print() : write_error(0) {}
    20e0:	ldr	r0, [pc, #144]	; (2174 <_GLOBAL__sub_I_data_buffer+0x98>)
    20e2:	ldr	r2, [pc, #148]	; (2178 <_GLOBAL__sub_I_data_buffer+0x9c>)
    20e4:	str	r2, [r3, #4]
    20e6:	movs	r4, #0
    20e8:	strh	r4, [r3, #2]
    20ea:	strh	r4, [r3, #0]
    20ec:	mov.w	r3, #1000	; 0x3e8
    20f0:	strb	r4, [r0, #4]
    20f2:	str	r3, [r0, #8]
    20f4:	strb	r4, [r0, #12]
	// Explicit FileImpl constructor.  Used by libraries which provide
	// access to files stored on media.  Normally this is used within
	// functions derived from FS::open() and FileImpl::openNextFile().
	// Not normally called used from ordinary programs or libraries
	// which only access files.
	File(FileImpl *file) {
    20f6:	ldr	r3, [pc, #132]	; (217c <_GLOBAL__sub_I_data_buffer+0xa0>)

/****************************** Filing Utility *******************************************/

extern int t_acq;

File file=NULL; // is used by saveData and saveNAD
    20f8:	ldr	r2, [pc, #132]	; (2180 <_GLOBAL__sub_I_data_buffer+0xa4>)
    20fa:	ldr	r1, [pc, #136]	; (2184 <_GLOBAL__sub_I_data_buffer+0xa8>)
    20fc:	str	r3, [r0, #0]
		f = file;
    20fe:	str	r4, [r0, #16]
    2100:	bl	9cc8 <__aeabi_atexit>
// This is a simple driver based on the the standard SPI.h library.
// You can write a driver entirely independent of SPI.h.
// It can be optimized for your board or a different SPI port can be used.
// The driver must be derived from SdSpiBaseClass.
// See: SdFat/src/SpiDriver/SdSpiBaseClass.h
class MySpiClass : public SdSpiBaseClass {
    2104:	ldr	r3, [pc, #128]	; (2188 <_GLOBAL__sub_I_data_buffer+0xac>)
    2106:	ldr	r2, [pc, #132]	; (218c <_GLOBAL__sub_I_data_buffer+0xb0>)
    2108:	str	r2, [r3, #0]
    210a:	movs	r1, #1
		}
		if (dataMode & 0x04) {
			c |= SPI_CTAR_CPHA;
			t = (t & 0xFFFF0FFF) | ((t & 0xF000) >> 4);
		}
		ctar = c | t;
    210c:	ldr	r2, [pc, #128]	; (2190 <_GLOBAL__sub_I_data_buffer+0xb4>)
    210e:	str	r2, [r3, #4]
    2110:	strb	r1, [r3, #8]


class SDClass : public FS
{
public:
	SDClass() { }
    2112:	ldr.w	lr, [pc, #148]	; 21a8 <_GLOBAL__sub_I_data_buffer+0xcc>
    const char *sd_str[]={"sdio",   "sd1","sd2","sd3","sd4","sd5","sd6"};
    const int cs[] = {BUILTIN_SDCARD,  34,   33,   35,   36,   37,  38 };

    const int nsd = sizeof(cs)/sizeof(int);

    SDClass sdx[nsd];
    2116:	ldr	r3, [pc, #124]	; (2194 <_GLOBAL__sub_I_data_buffer+0xb8>)
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    2118:	ldr	r7, [pc, #124]	; (2198 <_GLOBAL__sub_I_data_buffer+0xbc>)
#else  // HAS_SDIO_CLASS
class SdSpiCard {
#endif  // HAS_SDIO_CLASS
 public:
  /** Construct an instance of SdSpiCard. */
  SdSpiCard() {}
    211a:	ldr	r6, [pc, #128]	; (219c <_GLOBAL__sub_I_data_buffer+0xc0>)
    211c:	ldr	r0, [pc, #128]	; (21a0 <_GLOBAL__sub_I_data_buffer+0xc4>)
 * \class FsVolume
 * \brief FsVolume class.
 */
class FsVolume {
 public:
  FsVolume() {}
    211e:	mov	r2, r4
    2120:	movs	r5, #41	; 0x29
    2122:	movs	r4, #255	; 0xff
    2124:	str.w	r2, [r3, #1156]	; 0x484
    2128:	str.w	r2, [r3, #1160]	; 0x488
    212c:	str.w	r7, [r3, #1172]	; 0x494
 * \class SdioConfig
 * \brief SDIO card configuration.
 */
class SdioConfig {
 public:
  SdioConfig() {}
    2130:	strb.w	r2, [r3, #1180]	; 0x49c
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    2134:	strb.w	r2, [r3, #1181]	; 0x49d
    2138:	str.w	r6, [r3, #1184]	; 0x4a0
    213c:	strb.w	r1, [r3, #1197]	; 0x4ad
    2140:	strb.w	r5, [r3, #1199]	; 0x4af
    2144:	strb.w	r2, [r3, #1202]	; 0x4b2
 * \class SdioConfig
 * \brief SDIO card configuration.
 */
class SdioConfig {
 public:
  SdioConfig() {}
    2148:	strb.w	r2, [r3, #1216]	; 0x4c0
    214c:	strb.w	r2, [r3, #1220]	; 0x4c4
    2150:	strb.w	r4, [r3, #1221]	; 0x4c5
    2154:	str.w	lr, [r3]
    2158:	add.w	r3, r3, #1224	; 0x4c8
    215c:	cmp	r3, r0
    215e:	bne.n	2124 <_GLOBAL__sub_I_data_buffer+0x48>
    2160:	ldr	r2, [pc, #28]	; (2180 <_GLOBAL__sub_I_data_buffer+0xa4>)
    2162:	ldr	r1, [pc, #64]	; (21a4 <_GLOBAL__sub_I_data_buffer+0xc8>)
    2164:	movs	r0, #0
        file.flush();
        file.close();
        status = STOPPED;
    }
    return status;
}
    2166:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    const char *sd_str[]={"sdio",   "sd1","sd2","sd3","sd4","sd5","sd6"};
    const int cs[] = {BUILTIN_SDCARD,  34,   33,   35,   36,   37,  38 };

    const int nsd = sizeof(cs)/sizeof(int);

    SDClass sdx[nsd];
    216a:	b.w	9cc8 <__aeabi_atexit>
    216e:	nop
    2170:	.word	0x1fff4634
    2174:	.word	0x1fff2254
    2178:	.word	0x1fff4eb4
    217c:	.word	0x00011ce0
    2180:	.word	0x1fff0f30
    2184:	.word	0x000009e1
    2188:	.word	0x1fff4ea8
    218c:	.word	0x00011fa4
    2190:	.word	0x38011001
    2194:	.word	0x1fff2468
    2198:	.word	0x000125c8
    219c:	.word	0x00012568
    21a0:	.word	0x1fff45e0
    21a4:	.word	0x000016a1
    21a8:	.word	0x00012268

000021ac <adc_init()>:
    21ac:	bx	lr

000021ae <adcStatus()>:
int gain=0;

#if ADC_MODEL == CS5381
    void adc_init(void) { }
    void setAGain(int8_t again) {  }
    void adcStatus(void) {  }
    21ae:	bx	lr

000021b0 <_write>:
  int _write(int file, const void *buf, size_t len) {
    // https://forum.pjrc.com/threads/28473-Quick-Guide-Using-printf()-on-Teensy-ARM
    Print *out;
  
    // Send both stdout and stderr to stdPrint
    if (file == stdout->_file || file == stderr->_file) {
    21b0:	ldr	r3, [pc, #48]	; (21e4 <_write+0x34>)
    21b2:	ldr	r3, [r3, #0]
#include "usb_serial.h"
Print *stdPrint = &Serial;

extern "C"
{
  int _write(int file, const void *buf, size_t len) {
    21b4:	push	{r4}
    // https://forum.pjrc.com/threads/28473-Quick-Guide-Using-printf()-on-Teensy-ARM
    Print *out;
  
    // Send both stdout and stderr to stdPrint
    if (file == stdout->_file || file == stderr->_file) {
    21b6:	ldr	r4, [r3, #8]
    21b8:	ldrsh.w	r4, [r4, #14]
    21bc:	cmp	r4, r0
    21be:	beq.n	21ca <_write+0x1a>
    21c0:	ldr	r3, [r3, #12]
    21c2:	ldrsh.w	r3, [r3, #14]
    21c6:	cmp	r0, r3
    21c8:	bne.n	21ce <_write+0x1e>
      out = stdPrint;
    21ca:	ldr	r3, [pc, #28]	; (21e8 <_write+0x38>)
    21cc:	ldr	r0, [r3, #0]
    } else {
      out = (Print *)file;
    }
  
    if (out == nullptr) {
    21ce:	cbz	r0, 21da <_write+0x2a>
      return len;
    }
  
    // Don't check for len == 0 for returning early, in case there's side effects
    return out->write((const uint8_t *)buf, len);
    21d0:	ldr	r3, [r0, #0]
  }
    21d2:	ldr.w	r4, [sp], #4
    if (out == nullptr) {
      return len;
    }
  
    // Don't check for len == 0 for returning early, in case there's side effects
    return out->write((const uint8_t *)buf, len);
    21d6:	ldr	r3, [r3, #4]
    21d8:	bx	r3
  }
    21da:	mov	r0, r2
    21dc:	ldr.w	r4, [sp], #4
    21e0:	bx	lr
    21e2:	nop
    21e4:	.word	0x1fff1840
    21e8:	.word	0x1fff0f60

000021ec <DMAChanneltransferCount(DMAChannel*, unsigned int) [clone .isra.9]>:

#ifndef TRANSFER_COUNT_FIXED
inline void DMAChanneltransferCount(DMAChannel * dmac, unsigned int len) {
	// note does no validation of length...
	DMABaseClass::TCD_t *tcd = dmac->TCD;
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
    21ec:	ldrh	r3, [r0, #30]
    21ee:	lsls	r3, r3, #16
		tcd->BITER = len & 0x7fff;
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
    21f0:	itttt	mi
    21f2:	ldrhmi	r3, [r0, #30]
    21f4:	ubfxmi	r1, r1, #0, #9
    21f8:	andmi.w	r3, r3, #65024	; 0xfe00
    21fc:	orrmi	r1, r3
#ifndef TRANSFER_COUNT_FIXED
inline void DMAChanneltransferCount(DMAChannel * dmac, unsigned int len) {
	// note does no validation of length...
	DMABaseClass::TCD_t *tcd = dmac->TCD;
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
		tcd->BITER = len & 0x7fff;
    21fe:	it	pl
    2200:	ubfxpl	r1, r1, #0, #15
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
    2204:	strh	r1, [r0, #30]
	}
	tcd->CITER = tcd->BITER; 
    2206:	ldrh	r3, [r0, #30]
    2208:	uxth	r3, r3
    220a:	strh	r3, [r0, #22]
    220c:	bx	lr
    220e:	Address 0x0000220e is out of bounds.


00002210 <SPIClass::begin()>:
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
	const SPI_Hardware_t & hardware() { return *(const SPI_Hardware_t *)hardware_addr; }
    2210:	ldr	r3, [r0, #4]

void SPIClass::begin()
{
	volatile uint32_t *reg;

	hardware().clock_gate_register |= hardware().clock_gate_mask;
    2212:	ldr	r1, [r3, #0]
    2214:	ldr	r2, [r3, #4]
SPIClass SPI2((uintptr_t)&KINETISK_SPI2, (uintptr_t)&SPIClass::spi2_hardware);
#endif


void SPIClass::begin()
{
    2216:	push	{r4, lr}
	volatile uint32_t *reg;

	hardware().clock_gate_register |= hardware().clock_gate_mask;
    2218:	ldr	r4, [r1, #0]
    221a:	orrs	r2, r4
    221c:	str	r2, [r1, #0]
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    221e:	ldr	r2, [r0, #0]
	port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x1F);
    2220:	ldr	r1, [pc, #84]	; (2278 <SPIClass::begin()+0x68>)
    2222:	str	r1, [r2, #0]
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
    2224:	ldr	r1, [pc, #84]	; (227c <SPIClass::begin()+0x6c>)
    2226:	str	r1, [r2, #12]
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
    2228:	add.w	r1, r1, #1073741824	; 0x40000000
    222c:	str	r1, [r2, #16]
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
    222e:	ldr	r1, [pc, #80]	; (2280 <SPIClass::begin()+0x70>)
    2230:	str	r1, [r2, #0]
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    2232:	ldrb	r1, [r0, #9]
    2234:	ldr	r2, [pc, #76]	; (2284 <SPIClass::begin()+0x74>)
    2236:	adds	r4, r3, r1
	*reg = hardware().mosi_mux[mosi_pin_index];
    2238:	adds	r1, #12
	hardware().clock_gate_register |= hardware().clock_gate_mask;
	port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x1F);
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    223a:	ldrb.w	r4, [r4, #44]	; 0x2c
	*reg = hardware().mosi_mux[mosi_pin_index];
    223e:	ldr.w	r1, [r3, r1, lsl #2]
	hardware().clock_gate_register |= hardware().clock_gate_mask;
	port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x1F);
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    2242:	add.w	r4, r2, r4, lsl #3
    2246:	ldr	r4, [r4, #4]
	*reg = hardware().mosi_mux[mosi_pin_index];
    2248:	str	r1, [r4, #0]
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    224a:	ldrb	r1, [r0, #8]
    224c:	adds	r4, r3, r1
	*reg= hardware().miso_mux[miso_pin_index];
    224e:	add.w	r1, r3, r1, lsl #2
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    2252:	ldrb	r4, [r4, #24]
	*reg= hardware().miso_mux[miso_pin_index];
    2254:	ldr	r1, [r1, #28]
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    2256:	add.w	r4, r2, r4, lsl #3
    225a:	ldr	r4, [r4, #4]
	*reg= hardware().miso_mux[miso_pin_index];
    225c:	str	r1, [r4, #0]
	reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    225e:	ldrb	r1, [r0, #10]
    2260:	adds	r0, r3, r1
	*reg = hardware().sck_mux[sck_pin_index];
    2262:	add.w	r3, r3, r1, lsl #2
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
	*reg= hardware().miso_mux[miso_pin_index];
	reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    2266:	ldrb.w	r0, [r0, #64]	; 0x40
	*reg = hardware().sck_mux[sck_pin_index];
    226a:	ldr	r3, [r3, #68]	; 0x44
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
	*reg= hardware().miso_mux[miso_pin_index];
	reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    226c:	add.w	r2, r2, r0, lsl #3
    2270:	ldr	r2, [r2, #4]
	*reg = hardware().sck_mux[sck_pin_index];
    2272:	str	r3, [r2, #0]
    2274:	pop	{r4, pc}
    2276:	nop
    2278:	.word	0x001f4001
    227c:	.word	0x38001001
    2280:	.word	0x801f0000
    2284:	.word	0x00012620

00002288 <SPIClass::transfer(void const*, void*, unsigned int)>:
		}
	}
}

void SPIClass::transfer(const void * buf, void * retbuf, size_t count)
{
    2288:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

	if (count == 0) return;
    228c:	cmp	r3, #0
    228e:	beq.w	244a <SPIClass::transfer(void const*, void*, unsigned int)+0x1c2>
    2292:	ldr	r4, [r0, #0]
    2294:	ldr	r6, [pc, #440]	; (2450 <SPIClass::transfer(void const*, void*, unsigned int)+0x1c8>)
	if (!(port().CTAR0 & SPI_CTAR_LSBFE)) {
    2296:	ldr	r5, [r4, #12]
		const uint8_t *p_write = (const uint8_t *)buf;
		uint8_t *p_read = (uint8_t *)retbuf;
		size_t count_read = count;

		// Lets clear the reader queue
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);
    2298:	str	r6, [r4, #0]

void SPIClass::transfer(const void * buf, void * retbuf, size_t count)
{

	if (count == 0) return;
	if (!(port().CTAR0 & SPI_CTAR_LSBFE)) {
    229a:	tst.w	r5, #16777216	; 0x1000000
    229e:	and.w	r5, r3, #1
    22a2:	bne.n	2380 <SPIClass::transfer(void const*, void*, unsigned int)+0xf8>
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    22a4:	cbz	r5, 22cc <SPIClass::transfer(void const*, void*, unsigned int)+0x44>
		    if (p_write) {
    22a6:	cbz	r1, 22ba <SPIClass::transfer(void const*, void*, unsigned int)+0x32>
    22a8:	adds	r5, r1, #1
    22aa:	ldrb	r1, [r1, #0]
				if (count > 1)
    22ac:	cmp	r3, #1
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    22ae:	it	ne
    22b0:	orrne.w	r1, r1, #2147483648	; 0x80000000
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
    22b4:	str	r1, [r4, #52]	; 0x34
    22b6:	mov	r1, r5
    22b8:	b.n	22c8 <SPIClass::transfer(void const*, void*, unsigned int)+0x40>
    22ba:	ldrb.w	r5, [r0, #44]	; 0x2c
			} else {
				if (count > 1)
    22be:	cmp	r3, #1
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    22c0:	it	ne
    22c2:	orrne.w	r5, r5, #2147483648	; 0x80000000
				else
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
    22c6:	str	r5, [r4, #52]	; 0x34
			}
			count--;
    22c8:	subs	r6, r3, #1
    22ca:	b.n	22ce <SPIClass::transfer(void const*, void*, unsigned int)+0x46>
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    22cc:	mov	r6, r3
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
		}

	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;
    22ce:	ldrb.w	r4, [r0, #44]	; 0x2c
    22d2:	orr.w	r4, r4, r4, lsl #8

		while (count > 0) {
    22d6:	cmp	r6, #0
    22d8:	beq.n	2358 <SPIClass::transfer(void const*, void*, unsigned int)+0xd0>
			// Push out the next byte; 
		    if (p_write) {
    22da:	cbz	r1, 22ea <SPIClass::transfer(void const*, void*, unsigned int)+0x62>
		    	w = (*p_write++) << 8;
    22dc:	mov	r5, r1
				w |= *p_write++;
    22de:	ldrb	r1, [r1, #1]
	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;

		while (count > 0) {
			// Push out the next byte; 
		    if (p_write) {
		    	w = (*p_write++) << 8;
    22e0:	ldrb.w	r4, [r5], #2
				w |= *p_write++;
    22e4:	orr.w	r4, r1, r4, lsl #8
    22e8:	mov	r1, r5
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    22ea:	ldr	r5, [r0, #4]
    22ec:	ldr	r7, [r0, #0]
    22ee:	ldrb	r5, [r5, #8]
			if (count == 2)
    22f0:	cmp	r6, #2
			// Push out the next byte; 
		    if (p_write) {
		    	w = (*p_write++) << 8;
				w |= *p_write++;
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    22f2:	add.w	r5, r5, #4294967295
    22f6:	mov.w	r5, r5, lsl #12
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
    22fa:	ite	eq
    22fc:	orreq.w	lr, r4, #268435456	; 0x10000000
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    2300:	orrne.w	lr, r4, #2415919104	; 0x90000000
			// Push out the next byte; 
		    if (p_write) {
		    	w = (*p_write++) << 8;
				w |= *p_write++;
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    2304:	uxth	r5, r5
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    2306:	str.w	lr, [r7, #52]	; 0x34
			count -= 2; // how many bytes to output.
    230a:	subs	r6, #2
    230c:	ldr.w	lr, [r0]
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
    2310:	ldr.w	r7, [lr, #44]	; 0x2c
				if (sr & 0xF0)  {
    2314:	tst.w	r7, #240	; 0xf0
    2318:	beq.n	2344 <SPIClass::transfer(void const*, void*, unsigned int)+0xbc>
					uint16_t w = port().POPR;  // Read any pending RX bytes in
					if (count_read & 1) {
    231a:	tst.w	r3, #1
			count -= 2; // how many bytes to output.
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
				if (sr & 0xF0)  {
					uint16_t w = port().POPR;  // Read any pending RX bytes in
    231e:	ldr.w	ip, [lr, #56]	; 0x38
					if (count_read & 1) {
    2322:	beq.n	2330 <SPIClass::transfer(void const*, void*, unsigned int)+0xa8>
						if (p_read) {
    2324:	cbz	r2, 232c <SPIClass::transfer(void const*, void*, unsigned int)+0xa4>
							*p_read++ = w;  // Read any pending RX bytes in
    2326:	strb.w	ip, [r2]
    232a:	adds	r2, #1
						} 
						count_read--;
    232c:	subs	r3, #1
    232e:	b.n	2344 <SPIClass::transfer(void const*, void*, unsigned int)+0xbc>
					} else {
						if (p_read) {
    2330:	cbz	r2, 2342 <SPIClass::transfer(void const*, void*, unsigned int)+0xba>
							*p_read++ = w >> 8;
    2332:	mov	lr, r2
    2334:	mov.w	r8, ip, asr #8
    2338:	strb.w	r8, [lr], #2
							*p_read++ = (w & 0xff);
    233c:	strb.w	ip, [r2, #1]
    2340:	mov	r2, lr
						}
						count_read -= 2;
    2342:	subs	r3, #2
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    2344:	and.w	r7, r7, #61440	; 0xf000
    2348:	cmp	r7, r5
    234a:	bhi.n	230c <SPIClass::transfer(void const*, void*, unsigned int)+0x84>
    234c:	b.n	22d6 <SPIClass::transfer(void const*, void*, unsigned int)+0x4e>
    234e:	ldr	r1, [r0, #0]

		}

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
			sr = port().SR;
    2350:	ldr	r4, [r1, #44]	; 0x2c
			if (sr & 0xF0)  {
    2352:	tst.w	r4, #240	; 0xf0
    2356:	bne.n	235e <SPIClass::transfer(void const*, void*, unsigned int)+0xd6>
			} while ((sr & (15 << 12)) > queue_full_status_mask);

		}

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
    2358:	cmp	r3, #0
    235a:	bne.n	234e <SPIClass::transfer(void const*, void*, unsigned int)+0xc6>
    235c:	b.n	244a <SPIClass::transfer(void const*, void*, unsigned int)+0x1c2>
			sr = port().SR;
			if (sr & 0xF0)  {
				uint16_t w = port().POPR;  // Read any pending RX bytes in
    235e:	ldr	r4, [r1, #56]	; 0x38
				if (count_read & 1) {
    2360:	lsls	r1, r3, #31
    2362:	bpl.n	236e <SPIClass::transfer(void const*, void*, unsigned int)+0xe6>
					if (p_read)
    2364:	cbz	r2, 236a <SPIClass::transfer(void const*, void*, unsigned int)+0xe2>
						*p_read++ = w;  // Read any pending RX bytes in
    2366:	strb	r4, [r2, #0]
    2368:	adds	r2, #1
					count_read--;
    236a:	subs	r3, #1
    236c:	b.n	2358 <SPIClass::transfer(void const*, void*, unsigned int)+0xd0>
				} else {
					if (p_read) {
    236e:	cbz	r2, 237c <SPIClass::transfer(void const*, void*, unsigned int)+0xf4>
						*p_read++ = w >> 8;
    2370:	mov	r1, r2
    2372:	asrs	r5, r4, #8
    2374:	strb.w	r5, [r1], #2
						*p_read++ = (w & 0xff);
    2378:	strb	r4, [r2, #1]
    237a:	mov	r2, r1
					}
					count_read -= 2;
    237c:	subs	r3, #2
    237e:	b.n	2358 <SPIClass::transfer(void const*, void*, unsigned int)+0xd0>
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    2380:	cbz	r5, 23a8 <SPIClass::transfer(void const*, void*, unsigned int)+0x120>
		    if (p_write) {
    2382:	cbz	r1, 2396 <SPIClass::transfer(void const*, void*, unsigned int)+0x10e>
    2384:	adds	r5, r1, #1
    2386:	ldrb	r1, [r1, #0]
				if (count > 1)
    2388:	cmp	r3, #1
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    238a:	it	ne
    238c:	orrne.w	r1, r1, #2147483648	; 0x80000000
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
    2390:	str	r1, [r4, #52]	; 0x34
    2392:	mov	r1, r5
    2394:	b.n	23a4 <SPIClass::transfer(void const*, void*, unsigned int)+0x11c>
    2396:	ldrb.w	r5, [r0, #44]	; 0x2c
			} else {
				if (count > 1)
    239a:	cmp	r3, #1
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    239c:	it	ne
    239e:	orrne.w	r5, r5, #2147483648	; 0x80000000
				else
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
    23a2:	str	r5, [r4, #52]	; 0x34
			}
			count--;
    23a4:	subs	r6, r3, #1
    23a6:	b.n	23aa <SPIClass::transfer(void const*, void*, unsigned int)+0x122>
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    23a8:	mov	r6, r3
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
		}

	    uint16_t w = _transferWriteFill;
    23aa:	ldrb.w	r7, [r0, #44]	; 0x2c

		while (count > 0) {
    23ae:	cmp	r6, #0
    23b0:	beq.n	2422 <SPIClass::transfer(void const*, void*, unsigned int)+0x19a>
			// Push out the next byte; 
		    if (p_write) {
    23b2:	cbz	r1, 23be <SPIClass::transfer(void const*, void*, unsigned int)+0x136>
				w = *p_write++;
		    	w |= ((*p_write++) << 8);
    23b4:	ldrb	r7, [r1, #1]
    23b6:	ldrb	r4, [r1, #0]
    23b8:	adds	r1, #2
    23ba:	orr.w	r7, r4, r7, lsl #8
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    23be:	ldr	r4, [r0, #4]
    23c0:	ldr	r5, [r0, #0]
    23c2:	ldrb	r4, [r4, #8]
			if (count == 2)
    23c4:	cmp	r6, #2
			// Push out the next byte; 
		    if (p_write) {
				w = *p_write++;
		    	w |= ((*p_write++) << 8);
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    23c6:	add.w	r4, r4, #4294967295
    23ca:	mov.w	r4, r4, lsl #12
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
    23ce:	ite	eq
    23d0:	orreq.w	lr, r7, #268435456	; 0x10000000
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    23d4:	orrne.w	lr, r7, #2415919104	; 0x90000000
			// Push out the next byte; 
		    if (p_write) {
				w = *p_write++;
		    	w |= ((*p_write++) << 8);
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    23d8:	uxth	r4, r4
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    23da:	str.w	lr, [r5, #52]	; 0x34
			count -= 2; // how many bytes to output.
    23de:	subs	r6, #2
    23e0:	ldr	r5, [r0, #0]
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
    23e2:	ldr.w	lr, [r5, #44]	; 0x2c
				if (sr & 0xF0)  {
    23e6:	tst.w	lr, #240	; 0xf0
    23ea:	beq.n	240e <SPIClass::transfer(void const*, void*, unsigned int)+0x186>
					uint16_t w = port().POPR;  // Read any pending RX bytes in
					if (count_read & 1) {
    23ec:	tst.w	r3, #1
			count -= 2; // how many bytes to output.
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
				if (sr & 0xF0)  {
					uint16_t w = port().POPR;  // Read any pending RX bytes in
    23f0:	ldr	r5, [r5, #56]	; 0x38
					if (count_read & 1) {
    23f2:	beq.n	23fe <SPIClass::transfer(void const*, void*, unsigned int)+0x176>
						if (p_read) {
    23f4:	cbz	r2, 23fa <SPIClass::transfer(void const*, void*, unsigned int)+0x172>
							*p_read++ = w;  // Read any pending RX bytes in
    23f6:	strb	r5, [r2, #0]
    23f8:	adds	r2, #1
						} 
						count_read--;
    23fa:	subs	r3, #1
    23fc:	b.n	240e <SPIClass::transfer(void const*, void*, unsigned int)+0x186>
					} else {
						if (p_read) {
    23fe:	cbz	r2, 240c <SPIClass::transfer(void const*, void*, unsigned int)+0x184>
							*p_read++ = (w & 0xff);
    2400:	mov	ip, r2
    2402:	strb.w	r5, [ip], #2
							*p_read++ = w >> 8;
    2406:	asrs	r5, r5, #8
    2408:	strb	r5, [r2, #1]
    240a:	mov	r2, ip
						}
						count_read -= 2;
    240c:	subs	r3, #2
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    240e:	and.w	lr, lr, #61440	; 0xf000
    2412:	cmp	lr, r4
    2414:	bhi.n	23e0 <SPIClass::transfer(void const*, void*, unsigned int)+0x158>
    2416:	b.n	23ae <SPIClass::transfer(void const*, void*, unsigned int)+0x126>
    2418:	ldr	r1, [r0, #0]

		}

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
			sr = port().SR;
    241a:	ldr	r4, [r1, #44]	; 0x2c
			if (sr & 0xF0)  {
    241c:	tst.w	r4, #240	; 0xf0
    2420:	bne.n	2428 <SPIClass::transfer(void const*, void*, unsigned int)+0x1a0>
			} while ((sr & (15 << 12)) > queue_full_status_mask);

		}

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
    2422:	cmp	r3, #0
    2424:	bne.n	2418 <SPIClass::transfer(void const*, void*, unsigned int)+0x190>
    2426:	b.n	244a <SPIClass::transfer(void const*, void*, unsigned int)+0x1c2>
			sr = port().SR;
			if (sr & 0xF0)  {
				uint16_t w = port().POPR;  // Read any pending RX bytes in
				if (count_read & 1) {
    2428:	lsls	r4, r3, #31

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
			sr = port().SR;
			if (sr & 0xF0)  {
				uint16_t w = port().POPR;  // Read any pending RX bytes in
    242a:	ldr	r1, [r1, #56]	; 0x38
				if (count_read & 1) {
    242c:	bpl.n	2438 <SPIClass::transfer(void const*, void*, unsigned int)+0x1b0>
					if (p_read)
    242e:	cbz	r2, 2434 <SPIClass::transfer(void const*, void*, unsigned int)+0x1ac>
						*p_read++ = w;  // Read any pending RX bytes in
    2430:	strb	r1, [r2, #0]
    2432:	adds	r2, #1
					count_read--;
    2434:	subs	r3, #1
    2436:	b.n	2422 <SPIClass::transfer(void const*, void*, unsigned int)+0x19a>
				} else {
					if (p_read) {
    2438:	cbz	r2, 2446 <SPIClass::transfer(void const*, void*, unsigned int)+0x1be>
						*p_read++ = (w & 0xff);
    243a:	mov	r4, r2
    243c:	strb.w	r1, [r4], #2
						*p_read++ = w >> 8;
    2440:	asrs	r1, r1, #8
    2442:	strb	r1, [r2, #1]
    2444:	mov	r2, r4
					}
					count_read -= 2;
    2446:	subs	r3, #2
    2448:	b.n	2422 <SPIClass::transfer(void const*, void*, unsigned int)+0x19a>
    244a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    244e:	nop
    2450:	.word	0x801f0400

00002454 <SPIClass::dma_rxisr()>:


//-------------------------------------------------------------------------
// DMA RX ISR
//-------------------------------------------------------------------------
void SPIClass::dma_rxisr(void) {
    2454:	push	{r4, r5, r6, lr}
    2456:	ldr	r3, [r0, #56]	; 0x38
    2458:	ldrb	r2, [r3, #4]
	void detachInterrupt(void) {
		NVIC_DISABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void clearInterrupt(void) {
		DMA_CINT = channel;
    245a:	ldr	r3, [pc, #192]	; (251c <SPIClass::dma_rxisr()+0xc8>)
    245c:	strb	r2, [r3, #0]
    245e:	ldr	r3, [r0, #52]	; 0x34
    2460:	ldrb	r2, [r3, #4]
	bool complete(void) {
		if (TCD->CSR & DMA_TCD_CSR_DONE) return true;
		return false;
	}
	void clearComplete(void) {
		DMA_CDNE = channel;
    2462:	ldr	r3, [pc, #188]	; (2520 <SPIClass::dma_rxisr()+0xcc>)
    2464:	strb	r2, [r3, #0]
    2466:	ldr	r2, [r0, #56]	; 0x38
    2468:	ldrb	r2, [r2, #4]
    246a:	strb	r2, [r3, #0]
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
	if (_dma_count_remaining) {
    246c:	ldr	r2, [r0, #48]	; 0x30


//-------------------------------------------------------------------------
// DMA RX ISR
//-------------------------------------------------------------------------
void SPIClass::dma_rxisr(void) {
    246e:	mov	r4, r0
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
	if (_dma_count_remaining) {
    2470:	cmp	r2, #0
    2472:	beq.n	24f4 <SPIClass::dma_rxisr()+0xa0>
		// What do I need to do to start it back up again...
		// We will use the BITR/CITR from RX as TX may have prefed some stuff
		if (_dma_count_remaining > hardware().max_dma_count) {
    2474:	ldr	r3, [r0, #4]
    2476:	ldr	r1, [r3, #12]
    2478:	cmp	r2, r1
    247a:	bls.n	2484 <SPIClass::dma_rxisr()+0x30>
			_dma_count_remaining -= hardware().max_dma_count;
    247c:	subs	r2, r2, r1
    247e:	str	r2, [r0, #48]	; 0x30
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
    2480:	movs	r1, #1
    2482:	b.n	24a6 <SPIClass::dma_rxisr()+0x52>
    2484:	ldr	r3, [r0, #52]	; 0x34
		// What do I need to do to start it back up again...
		// We will use the BITR/CITR from RX as TX may have prefed some stuff
		if (_dma_count_remaining > hardware().max_dma_count) {
			_dma_count_remaining -= hardware().max_dma_count;
		} else {
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining-1);
    2486:	subs	r1, r2, #1
    2488:	ldr	r0, [r3, #0]
    248a:	bl	21ec <DMAChanneltransferCount(DMAChannel*, unsigned int) [clone .isra.9]>
    248e:	ldr	r3, [r4, #56]	; 0x38
			DMAChanneltransferCount(_dmaRX, _dma_count_remaining);
    2490:	ldr	r1, [r4, #48]	; 0x30
    2492:	ldr	r0, [r3, #0]
    2494:	bl	21ec <DMAChanneltransferCount(DMAChannel*, unsigned int) [clone .isra.9]>
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
    2498:	ldr	r1, [r4, #48]	; 0x30
		} else {
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining-1);
			DMAChanneltransferCount(_dmaRX, _dma_count_remaining);
			if (_dma_count_remaining == 1) should_reenable_tx = false;

			_dma_count_remaining = 0;
    249a:	movs	r3, #0
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
    249c:	adds.w	r1, r1, #4294967295
    24a0:	it	ne
    24a2:	movne	r1, #1
		} else {
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining-1);
			DMAChanneltransferCount(_dmaRX, _dma_count_remaining);
			if (_dma_count_remaining == 1) should_reenable_tx = false;

			_dma_count_remaining = 0;
    24a4:	str	r3, [r4, #48]	; 0x30
		}
		// In some cases we need to again start the TX manually to get it to work...
		if (_dmaTX->TCD->SADDR == &_transferWriteFill) {
    24a6:	ldr	r3, [r4, #52]	; 0x34
    24a8:	ldr	r3, [r3, #0]
    24aa:	ldr	r0, [r3, #0]
    24ac:	add.w	r2, r4, #44	; 0x2c
    24b0:	cmp	r0, r2
    24b2:	ldr	r2, [r4, #0]
    24b4:	bne.n	24c2 <SPIClass::dma_rxisr()+0x6e>
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
    24b6:	ldr	r3, [r2, #12]
    24b8:	ldrb.w	r3, [r4, #44]	; 0x2c
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
    24bc:	orr.w	r3, r3, #2147483648	; 0x80000000
    24c0:	b.n	24e0 <SPIClass::dma_rxisr()+0x8c>
			} else  {
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			}
		} else {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
    24c2:	ldr	r0, [r2, #12]
    24c4:	tst.w	r0, #1073741824	; 0x40000000
				// 16 bit mode
				uint16_t w = *((uint16_t*)_dmaTX->TCD->SADDR);
    24c8:	ldr	r0, [r3, #0]
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 2;
    24ca:	itete	ne
    24cc:	ldrne	r5, [r3, #0]
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			} else  {
				uint8_t w = *((uint8_t*)_dmaTX->TCD->SADDR);
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 1;
    24ce:	ldreq	r5, [r3, #0]
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			}
		} else {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
				// 16 bit mode
				uint16_t w = *((uint16_t*)_dmaTX->TCD->SADDR);
    24d0:	ldrhne	r0, [r0, #0]
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 2;
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			} else  {
				uint8_t w = *((uint8_t*)_dmaTX->TCD->SADDR);
    24d2:	ldrbeq	r0, [r0, #0]
			}
		} else {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
				// 16 bit mode
				uint16_t w = *((uint16_t*)_dmaTX->TCD->SADDR);
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 2;
    24d4:	ite	ne
    24d6:	addne	r5, #2
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			} else  {
				uint8_t w = *((uint8_t*)_dmaTX->TCD->SADDR);
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 1;
    24d8:	addeq	r5, #1
    24da:	str	r5, [r3, #0]
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
    24dc:	orr.w	r3, r0, #2147483648	; 0x80000000
    24e0:	str	r3, [r2, #52]	; 0x34
    24e2:	ldr	r3, [r4, #56]	; 0x38
    24e4:	ldrb	r2, [r3, #4]
	/***************************************/
	/**    Enable / Disable               **/
	/***************************************/

	void enable(void) {
		DMA_SERQ = channel;
    24e6:	ldr	r3, [pc, #60]	; (2524 <SPIClass::dma_rxisr()+0xd0>)
    24e8:	strb	r2, [r3, #0]
			}
		}
		_dmaRX->enable();
		if (should_reenable_tx)
    24ea:	cbz	r1, 2518 <SPIClass::dma_rxisr()+0xc4>
    24ec:	ldr	r2, [r4, #52]	; 0x34
    24ee:	ldrb	r2, [r2, #4]
    24f0:	strb	r2, [r3, #0]
    24f2:	pop	{r4, r5, r6, pc}
    24f4:	ldr	r3, [r0, #0]
			_dmaTX->enable();
	} else {

		port().RSER = 0;
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
    24f6:	ldr	r1, [pc, #48]	; (2528 <SPIClass::dma_rxisr()+0xd4>)
		_dmaRX->enable();
		if (should_reenable_tx)
			_dmaTX->enable();
	} else {

		port().RSER = 0;
    24f8:	str	r2, [r3, #48]	; 0x30
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
    24fa:	str	r1, [r3, #44]	; 0x2c
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits
    24fc:	ldr	r1, [r3, #12]
    24fe:	bic.w	r1, r1, #1073741824	; 0x40000000
    2502:	str	r1, [r3, #12]

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
    2504:	movs	r3, #3
    2506:	strb.w	r3, [r0, #45]	; 0x2d
		_dma_event_responder->triggerEvent();
    250a:	ldr	r0, [r0, #60]	; 0x3c
    250c:	ldr	r3, [r0, #0]
    250e:	mov	r1, r2
    2510:	ldr	r3, [r3, #0]

	}
}
    2512:	ldmia.w	sp!, {r4, r5, r6, lr}
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
		_dma_event_responder->triggerEvent();
    2516:	bx	r3
    2518:	pop	{r4, r5, r6, pc}
    251a:	nop
    251c:	.word	0x4000801f
    2520:	.word	0x4000801c
    2524:	.word	0x4000801b
    2528:	.word	0xff0f0000

0000252c <_spi_dma_rxISR0()>:
};
SPIClass SPI((uintptr_t)&KINETISK_SPI0, (uintptr_t)&SPIClass::spi0_hardware);

#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
#ifdef SPI_HAS_TRANSFER_ASYNC
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
    252c:	push	{r3, lr}
    252e:	ldr	r0, [pc, #8]	; (2538 <_spi_dma_rxISR0()+0xc>)
    2530:	bl	2454 <SPIClass::dma_rxisr()>
    2534:	pop	{r3, pc}
    2536:	nop
    2538:	.word	0x1fff0f64

0000253c <DMAChannel::~DMAChannel()>:
	}
	DMAChannel & operator = (const DMASetting &rhs) {
		copy_tcd(TCD, rhs.TCD);
		return *this;
	}
	~DMAChannel() {
    253c:	push	{r4, lr}
    253e:	mov	r4, r0
		release();
    2540:	bl	98b0 <DMAChannel::release()>
	}
    2544:	mov	r0, r4
    2546:	pop	{r4, pc}

00002548 <_GLOBAL__sub_I__ZN14AudioOutputPWM21update_responsibilityE>:
audio_block_t * AudioOutputPWM::block_2nd = NULL;
uint32_t  AudioOutputPWM::block_offset = 0;
uint8_t AudioOutputPWM::interrupt_count = 0;

DMAMEM uint32_t pwm_dma_buffer[AUDIO_BLOCK_SAMPLES*2];
DMAChannel AudioOutputPWM::dma(false);
    2548:	ldr	r2, [pc, #8]	; (2554 <_GLOBAL__sub_I__ZN14AudioOutputPWM21update_responsibilityE+0xc>)
    254a:	ldr	r1, [pc, #12]	; (2558 <_GLOBAL__sub_I__ZN14AudioOutputPWM21update_responsibilityE+0x10>)
    254c:	ldr	r0, [pc, #12]	; (255c <_GLOBAL__sub_I__ZN14AudioOutputPWM21update_responsibilityE+0x14>)
    254e:	b.w	9cc8 <__aeabi_atexit>
    2552:	nop
    2554:	.word	0x1fff0f30
    2558:	.word	0x0000253d
    255c:	.word	0x1fff7ebc

00002560 <_GLOBAL__sub_I__ZN13AudioInputI2S10block_leftE>:
DMAMEM __attribute__((aligned(32))) static uint32_t i2s_rx_buffer[AUDIO_BLOCK_SAMPLES];
audio_block_t * AudioInputI2S::block_left = NULL;
audio_block_t * AudioInputI2S::block_right = NULL;
uint16_t AudioInputI2S::block_offset = 0;
bool AudioInputI2S::update_responsibility = false;
DMAChannel AudioInputI2S::dma(false);
    2560:	ldr	r2, [pc, #8]	; (256c <_GLOBAL__sub_I__ZN13AudioInputI2S10block_leftE+0xc>)
    2562:	ldr	r1, [pc, #12]	; (2570 <_GLOBAL__sub_I__ZN13AudioInputI2S10block_leftE+0x10>)
    2564:	ldr	r0, [pc, #12]	; (2574 <_GLOBAL__sub_I__ZN13AudioInputI2S10block_leftE+0x14>)
    2566:	b.w	9cc8 <__aeabi_atexit>
    256a:	nop
    256c:	.word	0x1fff0f30
    2570:	.word	0x0000253d
    2574:	.word	0x1fff7ec4

00002578 <_GLOBAL__sub_I__ZN17AudioOutputPT821114block_left_1stE>:
#if defined(AUDIO_PT8211_OVERSAMPLING)
DMAMEM __attribute__((aligned(32))) static uint32_t i2s_tx_buffer[AUDIO_BLOCK_SAMPLES*4];
#else
DMAMEM __attribute__((aligned(32))) static uint32_t i2s_tx_buffer[AUDIO_BLOCK_SAMPLES];
#endif
DMAChannel AudioOutputPT8211::dma(false);
    2578:	ldr	r2, [pc, #8]	; (2584 <_GLOBAL__sub_I__ZN17AudioOutputPT821114block_left_1stE+0xc>)
    257a:	ldr	r1, [pc, #12]	; (2588 <_GLOBAL__sub_I__ZN17AudioOutputPT821114block_left_1stE+0x10>)
    257c:	ldr	r0, [pc, #12]	; (258c <_GLOBAL__sub_I__ZN17AudioOutputPT821114block_left_1stE+0x14>)
    257e:	b.w	9cc8 <__aeabi_atexit>
    2582:	nop
    2584:	.word	0x1fff0f30
    2588:	.word	0x0000253d
    258c:	.word	0x1fff7ecc

00002590 <_GLOBAL__sub_I__ZN15AudioOutputADAT13block_ch1_1stE>:
bool AudioOutputADAT::update_responsibility = false;
//uint32_t  AudioOutputADAT::vucp = VUCP_VALID;

DMAMEM __attribute__((aligned(32))) static uint32_t ADAT_tx_buffer[AUDIO_BLOCK_SAMPLES * 8]; //4 KB, AUDIO_BLOCK_SAMPLES is usually 128

DMAChannel AudioOutputADAT::dma(false);
    2590:	ldr	r2, [pc, #8]	; (259c <_GLOBAL__sub_I__ZN15AudioOutputADAT13block_ch1_1stE+0xc>)
    2592:	ldr	r1, [pc, #12]	; (25a0 <_GLOBAL__sub_I__ZN15AudioOutputADAT13block_ch1_1stE+0x10>)
    2594:	ldr	r0, [pc, #12]	; (25a4 <_GLOBAL__sub_I__ZN15AudioOutputADAT13block_ch1_1stE+0x14>)
    2596:	b.w	9cc8 <__aeabi_atexit>
    259a:	nop
    259c:	.word	0x1fff0f30
    25a0:	.word	0x0000253d
    25a4:	.word	0x1fff7ed4

000025a8 <_GLOBAL__sub_I__ZN16AudioInputAnalog10block_leftE>:
uint16_t AudioInputAnalog::block_offset = 0;
int32_t AudioInputAnalog::hpf_y1 = 0;
int32_t AudioInputAnalog::hpf_x1 = 0;

bool AudioInputAnalog::update_responsibility = false;
DMAChannel AudioInputAnalog::dma(false);
    25a8:	ldr	r2, [pc, #8]	; (25b4 <_GLOBAL__sub_I__ZN16AudioInputAnalog10block_leftE+0xc>)
    25aa:	ldr	r1, [pc, #12]	; (25b8 <_GLOBAL__sub_I__ZN16AudioInputAnalog10block_leftE+0x10>)
    25ac:	ldr	r0, [pc, #12]	; (25bc <_GLOBAL__sub_I__ZN16AudioInputAnalog10block_leftE+0x14>)
    25ae:	b.w	9cc8 <__aeabi_atexit>
    25b2:	nop
    25b4:	.word	0x1fff0f30
    25b8:	.word	0x0000253d
    25bc:	.word	0x1fff7edc

000025c0 <_GLOBAL__sub_I__ZN17AudioOutputAnalog14block_left_1stE>:

DMAMEM __attribute__((aligned(32))) static uint16_t dac_buffer[AUDIO_BLOCK_SAMPLES*2];
audio_block_t * AudioOutputAnalog::block_left_1st = NULL;
audio_block_t * AudioOutputAnalog::block_left_2nd = NULL;
bool AudioOutputAnalog::update_responsibility = false;
DMAChannel AudioOutputAnalog::dma(false);
    25c0:	ldr	r2, [pc, #8]	; (25cc <_GLOBAL__sub_I__ZN17AudioOutputAnalog14block_left_1stE+0xc>)
    25c2:	ldr	r1, [pc, #12]	; (25d0 <_GLOBAL__sub_I__ZN17AudioOutputAnalog14block_left_1stE+0x10>)
    25c4:	ldr	r0, [pc, #12]	; (25d4 <_GLOBAL__sub_I__ZN17AudioOutputAnalog14block_left_1stE+0x14>)
    25c6:	b.w	9cc8 <__aeabi_atexit>
    25ca:	nop
    25cc:	.word	0x1fff0f30
    25d0:	.word	0x0000253d
    25d4:	.word	0x1fff7ee4

000025d8 <_GLOBAL__sub_I__ZN22AudioInputAnalogStereo10block_leftE>:
        while (1) {
                if ((ADC1_SC1A & ADC_SC1_COCO)) {
                        return ADC1_RA;
                }
        }
}
    25d8:	push	{r3, r4, r5, lr}
uint16_t AudioInputAnalogStereo::offset_left = 0;
uint16_t AudioInputAnalogStereo::offset_right = 0;
int32_t AudioInputAnalogStereo::hpf_y1[2] = { 0, 0 };
int32_t AudioInputAnalogStereo::hpf_x1[2] = { 0, 0 };
bool AudioInputAnalogStereo::update_responsibility = false;
DMAChannel AudioInputAnalogStereo::dma0(false);
    25da:	ldr	r5, [pc, #28]	; (25f8 <_GLOBAL__sub_I__ZN22AudioInputAnalogStereo10block_leftE+0x20>)
    25dc:	ldr	r4, [pc, #28]	; (25fc <_GLOBAL__sub_I__ZN22AudioInputAnalogStereo10block_leftE+0x24>)
    25de:	ldr	r0, [pc, #32]	; (2600 <_GLOBAL__sub_I__ZN22AudioInputAnalogStereo10block_leftE+0x28>)
    25e0:	mov	r2, r5
    25e2:	mov	r1, r4
    25e4:	bl	9cc8 <__aeabi_atexit>
DMAChannel AudioInputAnalogStereo::dma1(false);
    25e8:	mov	r2, r5
    25ea:	mov	r1, r4
    25ec:	ldr	r0, [pc, #20]	; (2604 <_GLOBAL__sub_I__ZN22AudioInputAnalogStereo10block_leftE+0x2c>)
        while (1) {
                if ((ADC1_SC1A & ADC_SC1_COCO)) {
                        return ADC1_RA;
                }
        }
}
    25ee:	ldmia.w	sp!, {r3, r4, r5, lr}
uint16_t AudioInputAnalogStereo::offset_right = 0;
int32_t AudioInputAnalogStereo::hpf_y1[2] = { 0, 0 };
int32_t AudioInputAnalogStereo::hpf_x1[2] = { 0, 0 };
bool AudioInputAnalogStereo::update_responsibility = false;
DMAChannel AudioInputAnalogStereo::dma0(false);
DMAChannel AudioInputAnalogStereo::dma1(false);
    25f2:	b.w	9cc8 <__aeabi_atexit>
    25f6:	nop
    25f8:	.word	0x1fff0f30
    25fc:	.word	0x0000253d
    2600:	.word	0x1fff7eec
    2604:	.word	0x1fff7ef4

00002608 <_GLOBAL__sub_I__ZN17AudioInputI2SQuad9block_ch1E>:
audio_block_t * AudioInputI2SQuad::block_ch2 = NULL;
audio_block_t * AudioInputI2SQuad::block_ch3 = NULL;
audio_block_t * AudioInputI2SQuad::block_ch4 = NULL;
uint16_t AudioInputI2SQuad::block_offset = 0;
bool AudioInputI2SQuad::update_responsibility = false;
DMAChannel AudioInputI2SQuad::dma(false);
    2608:	ldr	r2, [pc, #8]	; (2614 <_GLOBAL__sub_I__ZN17AudioInputI2SQuad9block_ch1E+0xc>)
    260a:	ldr	r1, [pc, #12]	; (2618 <_GLOBAL__sub_I__ZN17AudioInputI2SQuad9block_ch1E+0x10>)
    260c:	ldr	r0, [pc, #12]	; (261c <_GLOBAL__sub_I__ZN17AudioInputI2SQuad9block_ch1E+0x14>)
    260e:	b.w	9cc8 <__aeabi_atexit>
    2612:	nop
    2614:	.word	0x1fff0f30
    2618:	.word	0x0000253d
    261c:	.word	0x1fff7efc

00002620 <_GLOBAL__sub_I__ZN23AudioOutputAnalogStereo14block_left_1stE>:
audio_block_t * AudioOutputAnalogStereo::block_left_2nd = NULL;
audio_block_t * AudioOutputAnalogStereo::block_right_1st = NULL;
audio_block_t * AudioOutputAnalogStereo::block_right_2nd = NULL;
audio_block_t AudioOutputAnalogStereo::block_silent;
bool AudioOutputAnalogStereo::update_responsibility = false;
DMAChannel AudioOutputAnalogStereo::dma(false);
    2620:	ldr	r2, [pc, #8]	; (262c <_GLOBAL__sub_I__ZN23AudioOutputAnalogStereo14block_left_1stE+0xc>)
    2622:	ldr	r1, [pc, #12]	; (2630 <_GLOBAL__sub_I__ZN23AudioOutputAnalogStereo14block_left_1stE+0x10>)
    2624:	ldr	r0, [pc, #12]	; (2634 <_GLOBAL__sub_I__ZN23AudioOutputAnalogStereo14block_left_1stE+0x14>)
    2626:	b.w	9cc8 <__aeabi_atexit>
    262a:	nop
    262c:	.word	0x1fff0f30
    2630:	.word	0x0000253d
    2634:	.word	0x1fff7f04

00002638 <_GLOBAL__sub_I__ZN18AudioOutputI2SQuad13block_ch1_1stE>:
uint16_t  AudioOutputI2SQuad::ch2_offset = 0;
uint16_t  AudioOutputI2SQuad::ch3_offset = 0;
uint16_t  AudioOutputI2SQuad::ch4_offset = 0;
bool AudioOutputI2SQuad::update_responsibility = false;
DMAMEM __attribute__((aligned(32))) static uint32_t i2s_tx_buffer[AUDIO_BLOCK_SAMPLES*2];
DMAChannel AudioOutputI2SQuad::dma(false);
    2638:	ldr	r2, [pc, #8]	; (2644 <_GLOBAL__sub_I__ZN18AudioOutputI2SQuad13block_ch1_1stE+0xc>)
    263a:	ldr	r1, [pc, #12]	; (2648 <_GLOBAL__sub_I__ZN18AudioOutputI2SQuad13block_ch1_1stE+0x10>)
    263c:	ldr	r0, [pc, #12]	; (264c <_GLOBAL__sub_I__ZN18AudioOutputI2SQuad13block_ch1_1stE+0x14>)
    263e:	b.w	9cc8 <__aeabi_atexit>
    2642:	nop
    2644:	.word	0x1fff0f30
    2648:	.word	0x0000253d
    264c:	.word	0x1fff7f0c

00002650 <_GLOBAL__sub_I__ZN16AudioInputI2SOct9block_ch1E>:
audio_block_t * AudioInputI2SOct::block_ch6 = NULL;
audio_block_t * AudioInputI2SOct::block_ch7 = NULL;
audio_block_t * AudioInputI2SOct::block_ch8 = NULL;
uint16_t AudioInputI2SOct::block_offset = 0;
bool AudioInputI2SOct::update_responsibility = false;
DMAChannel AudioInputI2SOct::dma(false);
    2650:	ldr	r2, [pc, #8]	; (265c <_GLOBAL__sub_I__ZN16AudioInputI2SOct9block_ch1E+0xc>)
    2652:	ldr	r1, [pc, #12]	; (2660 <_GLOBAL__sub_I__ZN16AudioInputI2SOct9block_ch1E+0x10>)
    2654:	ldr	r0, [pc, #12]	; (2664 <_GLOBAL__sub_I__ZN16AudioInputI2SOct9block_ch1E+0x14>)
    2656:	b.w	9cc8 <__aeabi_atexit>
    265a:	nop
    265c:	.word	0x1fff0f30
    2660:	.word	0x0000253d
    2664:	.word	0x1fff7f14

00002668 <_GLOBAL__sub_I__ZN14AudioOutputTDM11block_inputE>:
audio_block_t * AudioOutputTDM::block_input[16] = {
	nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr,
	nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr
};
bool AudioOutputTDM::update_responsibility = false;
DMAChannel AudioOutputTDM::dma(false);
    2668:	ldr	r2, [pc, #8]	; (2674 <_GLOBAL__sub_I__ZN14AudioOutputTDM11block_inputE+0xc>)
    266a:	ldr	r1, [pc, #12]	; (2678 <_GLOBAL__sub_I__ZN14AudioOutputTDM11block_inputE+0x10>)
    266c:	ldr	r0, [pc, #12]	; (267c <_GLOBAL__sub_I__ZN14AudioOutputTDM11block_inputE+0x14>)
    266e:	b.w	9cc8 <__aeabi_atexit>
    2672:	nop
    2674:	.word	0x1fff0f30
    2678:	.word	0x0000253d
    267c:	.word	0x1fff7f1c

00002680 <_GLOBAL__sub_I__ZN13AudioInputTDM14block_incomingE>:
audio_block_t * AudioInputTDM::block_incoming[16] = {
	nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr,
	nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr
};
bool AudioInputTDM::update_responsibility = false;
DMAChannel AudioInputTDM::dma(false);
    2680:	ldr	r2, [pc, #8]	; (268c <_GLOBAL__sub_I__ZN13AudioInputTDM14block_incomingE+0xc>)
    2682:	ldr	r1, [pc, #12]	; (2690 <_GLOBAL__sub_I__ZN13AudioInputTDM14block_incomingE+0x10>)
    2684:	ldr	r0, [pc, #12]	; (2694 <_GLOBAL__sub_I__ZN13AudioInputTDM14block_incomingE+0x14>)
    2686:	b.w	9cc8 <__aeabi_atexit>
    268a:	nop
    268c:	.word	0x1fff0f30
    2690:	.word	0x0000253d
    2694:	.word	0x1fff7f24

00002698 <_GLOBAL__sub_I__ZN16AudioInputI2SHex9block_ch1E>:
audio_block_t * AudioInputI2SHex::block_ch4 = NULL;
audio_block_t * AudioInputI2SHex::block_ch5 = NULL;
audio_block_t * AudioInputI2SHex::block_ch6 = NULL;
uint16_t AudioInputI2SHex::block_offset = 0;
bool AudioInputI2SHex::update_responsibility = false;
DMAChannel AudioInputI2SHex::dma(false);
    2698:	ldr	r2, [pc, #8]	; (26a4 <_GLOBAL__sub_I__ZN16AudioInputI2SHex9block_ch1E+0xc>)
    269a:	ldr	r1, [pc, #12]	; (26a8 <_GLOBAL__sub_I__ZN16AudioInputI2SHex9block_ch1E+0x10>)
    269c:	ldr	r0, [pc, #12]	; (26ac <_GLOBAL__sub_I__ZN16AudioInputI2SHex9block_ch1E+0x14>)
    269e:	b.w	9cc8 <__aeabi_atexit>
    26a2:	nop
    26a4:	.word	0x1fff0f30
    26a8:	.word	0x0000253d
    26ac:	.word	0x1fff7f2c

000026b0 <_GLOBAL__sub_I__ZN13AudioInputPDM10block_leftE>:
#if defined(__IMXRT1062__) || defined(KINETISK)
DMAMEM __attribute__((aligned(32))) static uint32_t pdm_buffer[AUDIO_BLOCK_SAMPLES*4];
static uint32_t leftover[14];
audio_block_t * AudioInputPDM::block_left = NULL;
bool AudioInputPDM::update_responsibility = false;
DMAChannel AudioInputPDM::dma(false);
    26b0:	ldr	r2, [pc, #8]	; (26bc <_GLOBAL__sub_I__ZN13AudioInputPDM10block_leftE+0xc>)
    26b2:	ldr	r1, [pc, #12]	; (26c0 <_GLOBAL__sub_I__ZN13AudioInputPDM10block_leftE+0x10>)
    26b4:	ldr	r0, [pc, #12]	; (26c4 <_GLOBAL__sub_I__ZN13AudioInputPDM10block_leftE+0x14>)
    26b6:	b.w	9cc8 <__aeabi_atexit>
    26ba:	nop
    26bc:	.word	0x1fff0f30
    26c0:	.word	0x0000253d
    26c4:	.word	0x1fff7f34

000026c8 <_GLOBAL__sub_I__ZN14AudioOutputI2S14block_left_1stE>:
audio_block_t * AudioOutputI2S::block_left_2nd = NULL;
audio_block_t * AudioOutputI2S::block_right_2nd = NULL;
uint16_t  AudioOutputI2S::block_left_offset = 0;
uint16_t  AudioOutputI2S::block_right_offset = 0;
bool AudioOutputI2S::update_responsibility = false;
DMAChannel AudioOutputI2S::dma(false);
    26c8:	ldr	r2, [pc, #8]	; (26d4 <_GLOBAL__sub_I__ZN14AudioOutputI2S14block_left_1stE+0xc>)
    26ca:	ldr	r1, [pc, #12]	; (26d8 <_GLOBAL__sub_I__ZN14AudioOutputI2S14block_left_1stE+0x10>)
    26cc:	ldr	r0, [pc, #12]	; (26dc <_GLOBAL__sub_I__ZN14AudioOutputI2S14block_left_1stE+0x14>)
    26ce:	b.w	9cc8 <__aeabi_atexit>
    26d2:	nop
    26d4:	.word	0x1fff0f30
    26d8:	.word	0x0000253d
    26dc:	.word	0x1fff7f3c

000026e0 <_GLOBAL__sub_I__ZN16AudioOutputSPDIF14block_left_1stE>:
audio_block_t * AudioOutputSPDIF::block_left_2nd = NULL;
audio_block_t * AudioOutputSPDIF::block_right_2nd = NULL;
uint16_t  AudioOutputSPDIF::block_left_offset = 0;
uint16_t  AudioOutputSPDIF::block_right_offset = 0;
bool AudioOutputSPDIF::update_responsibility = false;
DMAChannel AudioOutputSPDIF::dma(false);
    26e0:	ldr	r2, [pc, #8]	; (26ec <_GLOBAL__sub_I__ZN16AudioOutputSPDIF14block_left_1stE+0xc>)
    26e2:	ldr	r1, [pc, #12]	; (26f0 <_GLOBAL__sub_I__ZN16AudioOutputSPDIF14block_left_1stE+0x10>)
    26e4:	ldr	r0, [pc, #12]	; (26f4 <_GLOBAL__sub_I__ZN16AudioOutputSPDIF14block_left_1stE+0x14>)
    26e6:	b.w	9cc8 <__aeabi_atexit>
    26ea:	nop
    26ec:	.word	0x1fff0f30
    26f0:	.word	0x0000253d
    26f4:	.word	0x1fff7f44

000026f8 <TwoWire::available()>:
	}
	uint8_t requestFrom(uint8_t addr, uint8_t qty, uint32_t iaddr, uint8_t n, uint8_t stop);
	virtual size_t write(uint8_t data);
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
    26f8:	ldrb.w	r2, [r0, #161]	; 0xa1
    26fc:	ldrb.w	r0, [r0, #160]	; 0xa0
	}
    2700:	subs	r0, r2, r0
    2702:	bx	lr

00002704 <TwoWire::read()>:
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    2704:	ldrb.w	r3, [r0, #160]	; 0xa0
    2708:	ldrb.w	r2, [r0, #161]	; 0xa1
    270c:	cmp	r2, r3
		return rxBuffer[rxBufferIndex++];
    270e:	itttt	hi
    2710:	addhi	r2, r3, #1
    2712:	addhi	r3, r3, r0
    2714:	strbhi.w	r2, [r0, #160]	; 0xa0
    2718:	ldrbhi	r0, [r3, #24]
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    271a:	it	ls
    271c:	movls.w	r0, #4294967295
		return rxBuffer[rxBufferIndex++];
	}
    2720:	bx	lr

00002722 <TwoWire::peek()>:
	virtual int peek(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    2722:	ldrb.w	r3, [r0, #160]	; 0xa0
    2726:	ldrb.w	r2, [r0, #161]	; 0xa1
    272a:	cmp	r2, r3
		return rxBuffer[rxBufferIndex];
    272c:	itte	hi
    272e:	addhi	r3, r3, r0
    2730:	ldrbhi	r0, [r3, #24]
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
		return rxBuffer[rxBufferIndex++];
	}
	virtual int peek(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    2732:	movls.w	r0, #4294967295
		return rxBuffer[rxBufferIndex];
	}
    2736:	bx	lr

00002738 <TwoWire::flush()>:
	virtual void flush(void) {
    2738:	bx	lr

0000273a <TwoWire::write(unsigned char)>:
//  I2C0_C2      // I2C Control Register 2
//  I2C0_FLT     // I2C Programmable Input Glitch Filter register

size_t TwoWire::write(uint8_t data)
{
	if (transmitting || slave_mode) {
    273a:	ldrh.w	r3, [r0, #302]	; 0x12e
    273e:	cbz	r3, 274c <TwoWire::write(unsigned char)+0x12>
		if (txBufferLength >= BUFFER_LENGTH+1) {
    2740:	ldrb.w	r3, [r0, #301]	; 0x12d
    2744:	cmp	r3, #136	; 0x88
    2746:	bls.n	2750 <TwoWire::write(unsigned char)+0x16>
	// format warnings are too pedantic - disable until newer toolchain offers better...
	// https://forum.pjrc.com/threads/62473?p=256873&viewfull=1#post256873
	int printf(const char *format, ...) /*__attribute__ ((format (printf, 2, 3)))*/;
	int printf(const __FlashStringHelper *format, ...);
  protected:
	void setWriteError(int err = 1) { write_error = err; }
    2748:	movs	r3, #1
    274a:	strb	r3, [r0, #4]
			setWriteError();
			return 0;
    274c:	movs	r0, #0
    274e:	bx	lr
		}
		txBuffer[txBufferLength++] = data;
    2750:	adds	r2, r3, #1
    2752:	add	r3, r0
    2754:	strb.w	r2, [r0, #301]	; 0x12d
    2758:	strb.w	r1, [r3, #163]	; 0xa3
		return 1;
    275c:	movs	r0, #1
    275e:	bx	lr

00002760 <TwoWire::write(unsigned char const*, unsigned int)>:
	}
	return 0;
}

size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
    2760:	push	{r3, r4, r5, lr}
    2762:	mov	r4, r0
	if (transmitting || slave_mode) {
    2764:	ldrh.w	r0, [r0, #302]	; 0x12e
	}
	return 0;
}

size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
    2768:	mov	r5, r2
	if (transmitting || slave_mode) {
    276a:	cbz	r0, 2796 <TwoWire::write(unsigned char const*, unsigned int)+0x36>
		size_t avail = BUFFER_LENGTH+1 - txBufferLength;
    276c:	ldrb.w	r3, [r4, #301]	; 0x12d
    2770:	rsb	r2, r3, #137	; 0x89
		if (quantity > avail) {
    2774:	cmp	r5, r2
    2776:	ittt	hi
    2778:	movhi	r0, #1
    277a:	movhi	r5, r2
    277c:	strbhi	r0, [r4, #4]
			quantity = avail;
			setWriteError();
		}
		memcpy(txBuffer + txBufferLength, data, quantity);
    277e:	add.w	r0, r4, #163	; 0xa3
    2782:	add	r0, r3
    2784:	mov	r2, r5
    2786:	bl	8720 <memcpy>
		txBufferLength += quantity;
    278a:	ldrb.w	r3, [r4, #301]	; 0x12d
    278e:	add	r3, r5
    2790:	strb.w	r3, [r4, #301]	; 0x12d
    2794:	mov	r0, r5
		return quantity;
	}
	return 0;
}
    2796:	pop	{r3, r4, r5, pc}

00002798 <TwoWire::isr()>:
	hardware.clock_gate_register &= ~hardware.clock_gate_mask;
}


void TwoWire::isr(void)
{
    2798:	push	{r3, r4, r5, lr}
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    279a:	ldr	r2, [r0, #16]
	uint8_t status, c1, data;
	static uint8_t receiving=0;

	status = port().S;
    279c:	ldrb	r5, [r2, #3]
    279e:	uxtb	r5, r5
	//serial_print(".");
	if (status & I2C_S_ARBL) {
    27a0:	tst.w	r5, #16
	hardware.clock_gate_register &= ~hardware.clock_gate_mask;
}


void TwoWire::isr(void)
{
    27a4:	mov	r4, r0
    27a6:	and.w	r3, r5, #64	; 0x40
	uint8_t status, c1, data;
	static uint8_t receiving=0;

	status = port().S;
	//serial_print(".");
	if (status & I2C_S_ARBL) {
    27aa:	bne.n	27b4 <TwoWire::isr()+0x1c>


		}
		if (!(status & I2C_S_IAAS)) return;
	}
	if (status & I2C_S_IAAS) {
    27ac:	and.w	r1, r3, #255	; 0xff
    27b0:	cbnz	r3, 27be <TwoWire::isr()+0x26>
    27b2:	b.n	280c <TwoWire::isr()+0x74>

	status = port().S;
	//serial_print(".");
	if (status & I2C_S_ARBL) {
		// Arbitration Lost
		port().S = I2C_S_ARBL;
    27b4:	movs	r1, #16
    27b6:	strb	r1, [r2, #3]
		if (receiving && rxBufferLength > 0) {
			// TODO: does this detect the STOP condition in slave receive mode?


		}
		if (!(status & I2C_S_IAAS)) return;
    27b8:	cmp	r3, #0
    27ba:	bne.n	27ac <TwoWire::isr()+0x14>
    27bc:	pop	{r3, r4, r5, pc}
	}
	if (status & I2C_S_IAAS) {
		//serial_print("\n");
		// Addressed As A Slave
		if (status & I2C_S_SRW) {
    27be:	and.w	r5, r5, #4
    27c2:	and.w	r2, r5, #255	; 0xff
    27c6:	ldr	r3, [pc, #224]	; (28a8 <TwoWire::isr()+0x110>)
    27c8:	cbz	r5, 2800 <TwoWire::isr()+0x68>
			//serial_print("T");
			// Begin Slave Transmit
			receiving = 0;
    27ca:	movs	r2, #0
    27cc:	strb	r2, [r3, #0]
			txBufferLength = 0;
			if (user_onRequest != NULL) {
    27ce:	ldr.w	r3, [r4, #308]	; 0x134
		// Addressed As A Slave
		if (status & I2C_S_SRW) {
			//serial_print("T");
			// Begin Slave Transmit
			receiving = 0;
			txBufferLength = 0;
    27d2:	strb.w	r2, [r4, #301]	; 0x12d
			if (user_onRequest != NULL) {
    27d6:	cbz	r3, 27da <TwoWire::isr()+0x42>
				user_onRequest();
    27d8:	blx	r3
			}
			if (txBufferLength == 0) {
    27da:	ldrb.w	r3, [r4, #301]	; 0x12d
    27de:	cbnz	r3, 27ea <TwoWire::isr()+0x52>
				// is this correct, transmitting a single zero
				// when we should send nothing?  Arduino's AVR
				// implementation does this, but is it ok?
				txBufferLength = 1;
    27e0:	movs	r2, #1
    27e2:	strb.w	r2, [r4, #301]	; 0x12d
				txBuffer[0] = 0;
    27e6:	strb.w	r3, [r4, #163]	; 0xa3
    27ea:	ldr	r3, [r4, #16]
			}
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE | I2C_C1_TX;
    27ec:	movs	r2, #208	; 0xd0
    27ee:	strb	r2, [r3, #2]
    27f0:	ldr	r3, [r4, #16]
			port().D = txBuffer[0];
    27f2:	ldrb.w	r2, [r4, #163]	; 0xa3
    27f6:	strb	r2, [r3, #4]
			txBufferIndex = 1;
    27f8:	movs	r3, #1
    27fa:	strb.w	r3, [r4, #300]	; 0x12c
    27fe:	b.n	289e <TwoWire::isr()+0x106>
		} else {
			// Begin Slave Receive
			//serial_print("R");
			receiving = 1;
    2800:	movs	r1, #1
    2802:	strb	r1, [r3, #0]
			rxBufferLength = 0;
    2804:	strb.w	r2, [r4, #161]	; 0xa1
    2808:	ldr	r3, [r4, #16]
    280a:	b.n	286a <TwoWire::isr()+0xd2>
    280c:	ldr	r2, [r4, #16]
		}
		port().S = I2C_S_IICIF;
		return;
	}
	#if defined(WIRE_HAS_STOP_INTERRUPT)
	c1 = port().FLT;
    280e:	ldrb	r3, [r2, #6]
    2810:	uxtb	r3, r3
	if ((c1 & I2C_FLT_STOPF) && (c1 & I2C_FLT_STOPIE)) {
    2812:	and.w	r0, r3, #96	; 0x60
    2816:	cmp	r0, #96	; 0x60
    2818:	bne.n	2830 <TwoWire::isr()+0x98>
		port().FLT = c1 & ~I2C_FLT_STOPIE;
    281a:	and.w	r3, r3, #223	; 0xdf
    281e:	strb	r3, [r2, #6]
		if (user_onReceive != NULL) {
    2820:	ldr.w	r3, [r4, #312]	; 0x138
    2824:	cbz	r3, 2830 <TwoWire::isr()+0x98>
			rxBufferIndex = 0;
    2826:	strb.w	r1, [r4, #160]	; 0xa0
			user_onReceive(rxBufferLength);
    282a:	ldrb.w	r0, [r4, #161]	; 0xa1
    282e:	blx	r3
    2830:	ldr	r3, [r4, #16]
		}
	}
	#endif
	c1 = port().C1;
    2832:	ldrb	r2, [r3, #2]
	if (c1 & I2C_C1_TX) {
    2834:	and.w	r2, r2, #16
    2838:	and.w	r1, r2, #255	; 0xff
    283c:	cbz	r2, 2874 <TwoWire::isr()+0xdc>
		// Continue Slave Transmit
		//serial_print("t");
		if ((status & I2C_S_RXAK) == 0) {
    283e:	ands.w	r5, r5, #1
    2842:	bne.n	286a <TwoWire::isr()+0xd2>
			//serial_print(".");
			// Master ACK'd previous byte
			if (txBufferIndex < txBufferLength) {
    2844:	ldrb.w	r2, [r4, #300]	; 0x12c
    2848:	ldrb.w	r1, [r4, #301]	; 0x12d
    284c:	cmp	r1, r2
				port().D = txBuffer[txBufferIndex++];
    284e:	itttt	hi
    2850:	addhi	r1, r2, #1
    2852:	addhi	r2, r2, r4
    2854:	strbhi.w	r1, [r4, #300]	; 0x12c
    2858:	ldrbhi.w	r2, [r2, #163]	; 0xa3
    285c:	ite	hi
    285e:	strbhi	r2, [r3, #4]
			} else {
				port().D = 0;
    2860:	strbls	r5, [r3, #4]
    2862:	ldr	r3, [r4, #16]
			}
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE | I2C_C1_TX;
    2864:	movs	r2, #208	; 0xd0
    2866:	strb	r2, [r3, #2]
    2868:	b.n	289e <TwoWire::isr()+0x106>
		} else {
			//serial_print("*");
			// Master did not ACK previous byte
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE;
    286a:	movs	r2, #192	; 0xc0
    286c:	strb	r2, [r3, #2]
    286e:	ldr	r3, [r4, #16]
			data = port().D;
    2870:	ldrb	r3, [r3, #4]
    2872:	b.n	289e <TwoWire::isr()+0x106>
		}
	} else {
		// Continue Slave Receive
		irqcount = 0;
    2874:	strb.w	r1, [r4, #304]	; 0x130
		#ifdef WIRE_HAS_STOP_INTERRUPT
		port().FLT |= I2C_FLT_STOPIE;
    2878:	ldrb	r2, [r3, #6]
    287a:	orr.w	r2, r2, #32
    287e:	strb	r2, [r3, #6]
    2880:	ldr	r3, [r4, #16]
			attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr1, RISING);
		}
		#endif
		#endif // WIRE_HAS_STOP_INTERRUPT
		//digitalWriteFast(4, HIGH);
		data = port().D;
    2882:	ldrb	r2, [r3, #4]
		//serial_phex(data);
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
    2884:	ldrb.w	r3, [r4, #161]	; 0xa1
    2888:	cmp	r3, #135	; 0x87
			attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr1, RISING);
		}
		#endif
		#endif // WIRE_HAS_STOP_INTERRUPT
		//digitalWriteFast(4, HIGH);
		data = port().D;
    288a:	uxtb	r2, r2
		//serial_phex(data);
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
    288c:	bhi.n	289e <TwoWire::isr()+0x106>
    288e:	ldr	r1, [pc, #24]	; (28a8 <TwoWire::isr()+0x110>)
    2890:	ldrb	r1, [r1, #0]
    2892:	cbz	r1, 289e <TwoWire::isr()+0x106>
			rxBuffer[rxBufferLength++] = data;
    2894:	adds	r1, r3, #1
    2896:	add	r3, r4
    2898:	strb.w	r1, [r4, #161]	; 0xa1
    289c:	strb	r2, [r3, #24]
    289e:	ldr	r3, [r4, #16]
		}
		//digitalWriteFast(4, LOW);
	}
	port().S = I2C_S_IICIF;
    28a0:	movs	r2, #2
    28a2:	strb	r2, [r3, #3]
    28a4:	pop	{r3, r4, r5, pc}
    28a6:	nop
    28a8:	.word	0x1fff7f4c

000028ac <i2c0_isr>:
#define MAKE_CONST(x) (__builtin_constant_p(x) ? (x) : (x))

#ifdef WIRE_IMPLEMENT_WIRE
constexpr uintptr_t i2c0_addr = uintptr_t(MAKE_CONST(&KINETIS_I2C0));
TwoWire Wire(i2c0_addr, TwoWire::i2c0_hardware);
void i2c0_isr(void) { Wire.isr(); }
    28ac:	ldr	r0, [pc, #4]	; (28b4 <i2c0_isr+0x8>)
    28ae:	b.w	2798 <TwoWire::isr()>
    28b2:	nop
    28b4:	.word	0x1fff10e0

000028b8 <i2c1_isr>:
#endif
#ifdef WIRE_IMPLEMENT_WIRE1
constexpr uintptr_t i2c1_addr = uintptr_t(MAKE_CONST(&KINETIS_I2C1));
TwoWire Wire1(i2c1_addr, TwoWire::i2c1_hardware);
void i2c1_isr(void) { Wire1.isr(); }
    28b8:	ldr	r0, [pc, #4]	; (28c0 <i2c1_isr+0x8>)
    28ba:	b.w	2798 <TwoWire::isr()>
    28be:	nop
    28c0:	.word	0x1fff121c

000028c4 <i2c2_isr>:
#endif
#ifdef WIRE_IMPLEMENT_WIRE2
constexpr uintptr_t i2c2_addr = uintptr_t(MAKE_CONST(&KINETIS_I2C2));
TwoWire Wire2(i2c2_addr, TwoWire::i2c2_hardware);
void i2c2_isr(void) { Wire2.isr(); }
    28c4:	ldr	r0, [pc, #4]	; (28cc <i2c2_isr+0x8>)
    28c6:	b.w	2798 <TwoWire::isr()>
    28ca:	nop
    28cc:	.word	0x1fff0fa4

000028d0 <SDClass::~SDClass()>:
	char *filename;
};



class SDClass : public FS
    28d0:	bx	lr

000028d2 <SDClass::exists(char const*)>:
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
		SDFAT_FILE file = sdfs.open(filepath, flags);
		if (file) return File(new SDFile(file));
		return File();
	}
	bool exists(const char *filepath) {
    28d2:	push	{lr}
    28d4:	mov	r2, r1
   * \param[in] path Path of the file to be tested for.
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    return m_fVol ? m_fVol->exists(path) :
    28d6:	ldr.w	r1, [r0, #1156]	; 0x484
    28da:	sub	sp, #60	; 0x3c
           m_xVol ? m_xVol->exists(path) : false;
    28dc:	cbz	r1, 28f4 <SDClass::exists(char const*)+0x22>
    28de:	movs	r3, #0
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    FatFile tmp;
    return tmp.open(this, path, O_RDONLY);
    28e0:	mov	r0, sp
    28e2:	strb.w	r3, [sp]
    28e6:	strb.w	r3, [sp, #1]
    28ea:	strb.w	r3, [sp, #2]
    28ee:	bl	5b78 <FatFile::open(FatVolume*, char const*, int)>
    28f2:	b.n	2910 <SDClass::exists(char const*)+0x3e>
    28f4:	ldr.w	r0, [r0, #1160]	; 0x488
    28f8:	cbz	r0, 2910 <SDClass::exists(char const*)+0x3e>
    28fa:	strb.w	r1, [sp, #49]	; 0x31
    28fe:	strb.w	r1, [sp, #50]	; 0x32
    2902:	strb.w	r1, [sp, #51]	; 0x33
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    ExFatFile tmp;
    return tmp.open(this, path, O_RDONLY);
    2906:	mov	r3, r1
    2908:	mov	r1, r0
    290a:	mov	r0, sp
    290c:	bl	4032 <ExFatFile::open(ExFatVolume*, char const*, int)>
		return sdfs.exists(filepath);
	}
    2910:	add	sp, #60	; 0x3c
    2912:	ldr.w	pc, [sp], #4

00002916 <SDClass::rmdir(char const*)>:
		return sdfs.rename(oldfilepath, newfilepath);
	}
	bool remove(const char *filepath) {
		return sdfs.remove(filepath);
	}
	bool rmdir(const char *filepath) {
    2916:	push	{lr}
    2918:	mov	r2, r1
   * The subdirectory file will be removed only if it is empty.
   *
   * \return true for success or false for failure.
   */
  bool rmdir(const char *path) {
    return m_fVol ? m_fVol->rmdir(path) :
    291a:	ldr.w	r1, [r0, #1156]	; 0x484
    291e:	sub	sp, #60	; 0x3c
           m_xVol ? m_xVol->rmdir(path) : false;
    2920:	cbz	r1, 2940 <SDClass::rmdir(char const*)+0x2a>
    2922:	movs	r3, #0
   *
   * \return true for success or false for failure.
   */
  bool rmdir(const char* path) {
    FatFile sub;
    return sub.open(this, path, O_RDONLY) && sub.rmdir();
    2924:	mov	r0, sp
    2926:	strb.w	r3, [sp]
    292a:	strb.w	r3, [sp, #1]
    292e:	strb.w	r3, [sp, #2]
    2932:	bl	5b78 <FatFile::open(FatVolume*, char const*, int)>
    2936:	cbz	r0, 2964 <SDClass::rmdir(char const*)+0x4e>
    2938:	mov	r0, sp
    293a:	bl	59f0 <FatFile::rmdir()>
    293e:	b.n	2964 <SDClass::rmdir(char const*)+0x4e>
    2940:	ldr.w	r0, [r0, #1160]	; 0x488
    2944:	cbz	r0, 2964 <SDClass::rmdir(char const*)+0x4e>
    2946:	strb.w	r1, [sp, #49]	; 0x31
    294a:	strb.w	r1, [sp, #50]	; 0x32
    294e:	strb.w	r1, [sp, #51]	; 0x33
   *
   * \return true for success or false for failure.
   */
  bool rmdir(const char* path) {
    ExFatFile sub;
    return sub.open(this, path, O_RDONLY) && sub.rmdir();
    2952:	mov	r3, r1
    2954:	mov	r1, r0
    2956:	mov	r0, sp
    2958:	bl	4032 <ExFatFile::open(ExFatVolume*, char const*, int)>
    295c:	cbz	r0, 2964 <SDClass::rmdir(char const*)+0x4e>
    295e:	mov	r0, sp
    2960:	bl	463c <ExFatFile::rmdir()>
		return sdfs.rmdir(filepath);
	}
    2964:	add	sp, #60	; 0x3c
    2966:	ldr.w	pc, [sp], #4

0000296a <SDClass::remove(char const*)>:
		return sdfs.mkdir(filepath);
	}
	bool rename(const char *oldfilepath, const char *newfilepath) {
		return sdfs.rename(oldfilepath, newfilepath);
	}
	bool remove(const char *filepath) {
    296a:	push	{lr}
    296c:	mov	r2, r1
  * \param[in] path A path with a valid 8.3 DOS name for the file.
  *
   * \return true for success or false for failure.
  */
  bool remove(const char *path) {
    return m_fVol ? m_fVol->remove(path) :
    296e:	ldr.w	r1, [r0, #1156]	; 0x484
    2972:	sub	sp, #60	; 0x3c
           m_xVol ? m_xVol->remove(path) : false;
    2974:	cbz	r1, 2996 <SDClass::remove(char const*)+0x2c>
    2976:	movs	r3, #0
    2978:	strb.w	r3, [sp]
    297c:	strb.w	r3, [sp, #1]
    2980:	strb.w	r3, [sp, #2]
   *
   * \return true for success or false for failure.
   */
  bool remove(const char* path) {
    FatFile tmp;
    return tmp.open(this, path, O_WRONLY) && tmp.remove();
    2984:	mov	r0, sp
    2986:	movs	r3, #1
    2988:	bl	5b78 <FatFile::open(FatVolume*, char const*, int)>
    298c:	cbz	r0, 29ba <SDClass::remove(char const*)+0x50>
    298e:	mov	r0, sp
    2990:	bl	6bec <FatFile::remove()>
    2994:	b.n	29ba <SDClass::remove(char const*)+0x50>
    2996:	ldr.w	r0, [r0, #1160]	; 0x488
    299a:	cbz	r0, 29ba <SDClass::remove(char const*)+0x50>
    299c:	strb.w	r1, [sp, #49]	; 0x31
    29a0:	strb.w	r1, [sp, #50]	; 0x32
    29a4:	strb.w	r1, [sp, #51]	; 0x33
   *
   * \return true for success or false for failure.
   */
  bool remove(const char* path) {
    ExFatFile tmp;
    return tmp.open(this, path, O_WRONLY) && tmp.remove();
    29a8:	movs	r3, #1
    29aa:	mov	r1, r0
    29ac:	mov	r0, sp
    29ae:	bl	4032 <ExFatFile::open(ExFatVolume*, char const*, int)>
    29b2:	cbz	r0, 29ba <SDClass::remove(char const*)+0x50>
    29b4:	mov	r0, sp
    29b6:	bl	45b6 <ExFatFile::remove()>
		return sdfs.remove(filepath);
	}
    29ba:	add	sp, #60	; 0x3c
    29bc:	ldr.w	pc, [sp], #4

000029c0 <SDClass::mkdir(char const*)>:
		return File();
	}
	bool exists(const char *filepath) {
		return sdfs.exists(filepath);
	}
	bool mkdir(const char *filepath) {
    29c0:	push	{r4, lr}
   * \param[in] pFlag Create missing parent directories if true.
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char *path, bool pFlag = true) {
    return m_fVol ? m_fVol->mkdir(path, pFlag) :
    29c2:	ldr.w	r4, [r0, #1156]	; 0x484
    29c6:	sub	sp, #56	; 0x38
    29c8:	mov	r2, r1
           m_xVol ? m_xVol->mkdir(path, pFlag) : false;
    29ca:	cbz	r4, 29e8 <SDClass::mkdir(char const*)+0x28>
    29cc:	movs	r3, #0
    29ce:	strb.w	r3, [sp]
    29d2:	strb.w	r3, [sp, #1]
    29d6:	strb.w	r3, [sp, #2]
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char* path, bool pFlag = true) {
    FatFile sub;
    return sub.mkdir(vwd(), path, pFlag);
    29da:	add.w	r1, r4, #1096	; 0x448
    29de:	movs	r3, #1
    29e0:	mov	r0, sp
    29e2:	bl	5cf4 <FatFile::mkdir(FatFile*, char const*, bool)>
    29e6:	b.n	2a0a <SDClass::mkdir(char const*)+0x4a>
    29e8:	ldr.w	r1, [r0, #1160]	; 0x488
    29ec:	cbz	r1, 2a08 <SDClass::mkdir(char const*)+0x48>
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char* path, bool pFlag = true) {
    ExFatFile sub;
    return sub.mkdir(vwd(), path, pFlag);
    29ee:	movs	r3, #1
    29f0:	add.w	r1, r1, #1096	; 0x448
    29f4:	mov	r0, sp
    29f6:	strb.w	r4, [sp, #49]	; 0x31
    29fa:	strb.w	r4, [sp, #50]	; 0x32
    29fe:	strb.w	r4, [sp, #51]	; 0x33
    2a02:	bl	48d4 <ExFatFile::mkdir(ExFatFile*, char const*, bool)>
    2a06:	b.n	2a0a <SDClass::mkdir(char const*)+0x4a>
    2a08:	mov	r0, r1
		return sdfs.mkdir(filepath);
	}
    2a0a:	add	sp, #56	; 0x38
    2a0c:	pop	{r4, pc}

00002a0e <SDClass::rename(char const*, char const*)>:
	bool rename(const char *oldfilepath, const char *newfilepath) {
    2a0e:	push	{r4, r5, lr}
   * a file object that was opened before the rename() call.
   *
   * \return true for success or false for failure.
   */
  bool rename(const char *oldPath, const char *newPath) {
    return m_fVol ? m_fVol->rename(oldPath, newPath) :
    2a10:	ldr.w	r3, [r0, #1156]	; 0x484
    2a14:	sub	sp, #60	; 0x3c
    2a16:	mov	r5, r2
           m_xVol ? m_xVol->rename(oldPath, newPath) : false;
    2a18:	cbz	r3, 2a46 <SDClass::rename(char const*, char const*)+0x38>
    2a1a:	movs	r2, #0
#endif  // ENABLE_ARDUINO_STRING

 private:
  friend FatFile;
  static FatVolume* cwv() {return m_cwv;}
  FatFile* vwd() {return &m_vwd;}
    2a1c:	add.w	r4, r3, #1096	; 0x448
    2a20:	strb.w	r2, [sp]
    2a24:	strb.w	r2, [sp, #1]
    2a28:	strb.w	r2, [sp, #2]
   *
   * \return true for success or false for failure.
   */
  bool rename(const char *oldPath, const char *newPath) {
    FatFile file;
    return file.open(vwd(), oldPath, O_RDONLY) && file.rename(vwd(), newPath);
    2a2c:	mov	r3, r2
    2a2e:	mov	r0, sp
    2a30:	mov	r2, r1
    2a32:	mov	r1, r4
    2a34:	bl	5ad0 <FatFile::open(FatFile*, char const*, int)>
    2a38:	cbz	r0, 2a72 <SDClass::rename(char const*, char const*)+0x64>
    2a3a:	mov	r2, r5
    2a3c:	mov	r1, r4
    2a3e:	mov	r0, sp
    2a40:	bl	5d9e <FatFile::rename(FatFile*, char const*)>
    2a44:	b.n	2a72 <SDClass::rename(char const*, char const*)+0x64>
    2a46:	ldr.w	r0, [r0, #1160]	; 0x488
    2a4a:	cbz	r0, 2a72 <SDClass::rename(char const*, char const*)+0x64>
#endif  // ENABLE_ARDUINO_STRING

 private:
  friend ExFatFile;
  static ExFatVolume* cwv() {return m_cwv;}
  ExFatFile* vwd() {return &m_vwd;}
    2a4c:	add.w	r4, r0, #1096	; 0x448
   *
   * \return true for success or false for failure.
   */
  bool rename(const char* oldPath, const char* newPath) {
    ExFatFile file;
    return file.open(vwd(), oldPath, O_RDONLY) && file.rename(vwd(), newPath);
    2a50:	mov	r2, r1
    2a52:	mov	r0, sp
    2a54:	mov	r1, r4
    2a56:	strb.w	r3, [sp, #49]	; 0x31
    2a5a:	strb.w	r3, [sp, #50]	; 0x32
    2a5e:	strb.w	r3, [sp, #51]	; 0x33
    2a62:	bl	3f78 <ExFatFile::open(ExFatFile*, char const*, int)>
    2a66:	cbz	r0, 2a72 <SDClass::rename(char const*, char const*)+0x64>
    2a68:	mov	r2, r5
    2a6a:	mov	r1, r4
    2a6c:	mov	r0, sp
    2a6e:	bl	4992 <ExFatFile::rename(ExFatFile*, char const*)>
		return sdfs.rename(oldfilepath, newfilepath);
	}
    2a72:	add	sp, #60	; 0x3c
    2a74:	pop	{r4, r5, pc}

00002a76 <FsVolume::bytesPerCluster() const>:
#ifndef DOXYGEN_SHOULD_SKIP_THIS
  uint32_t __attribute__((error("use sectorsPerCluster()"))) blocksPerCluster();
#endif  // DOXYGEN_SHOULD_SKIP_THIS
  /** \return the number of bytes in a cluster. */
  uint32_t bytesPerCluster() const {
    return m_fVol ? m_fVol->bytesPerCluster() :
    2a76:	ldr.w	r3, [r0, #1152]	; 0x480
           m_xVol ? m_xVol->bytesPerCluster() : 0;
    2a7a:	cbz	r3, 2a8a <FsVolume::bytesPerCluster() const+0x14>
    2a7c:	ldrb	r0, [r3, #6]
    2a7e:	mov.w	r3, #512	; 0x200
    2a82:	lsl.w	r0, r3, r0
    2a86:	uxth	r0, r0
    2a88:	bx	lr
    2a8a:	ldr.w	r0, [r0, #1156]	; 0x484
    2a8e:	cbz	r0, 2a94 <FsVolume::bytesPerCluster() const+0x1e>
    2a90:	ldr.w	r0, [r0, #1084]	; 0x43c
  }
    2a94:	bx	lr

00002a96 <SDClass::totalSize()>:
	}
	uint64_t usedSize() {
		return (uint64_t)(sdfs.clusterCount() - sdfs.freeClusterCount())
		  * (uint64_t)sdfs.bytesPerCluster();
	}
	uint64_t totalSize() {
    2a96:	mov	r3, r0
    2a98:	push	{r4, lr}
  }
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
    2a9a:	ldr.w	r2, [r3, #1156]	; 0x484
		return (uint64_t)sdfs.clusterCount() * (uint64_t)sdfs.bytesPerCluster();
    2a9e:	adds	r0, #4
           m_xVol ? m_xVol->clusterCount() : 0;
    2aa0:	cbz	r2, 2aa8 <SDClass::totalSize()+0x12>
    2aa2:	ldr	r4, [r2, #28]
    2aa4:	subs	r4, #1
    2aa6:	b.n	2ab2 <SDClass::totalSize()+0x1c>
    2aa8:	ldr.w	r4, [r3, #1160]	; 0x488
    2aac:	cbz	r4, 2ab2 <SDClass::totalSize()+0x1c>
    2aae:	ldr.w	r4, [r4, #1072]	; 0x430
    2ab2:	bl	2a76 <FsVolume::bytesPerCluster() const>
	}
    2ab6:	umull	r0, r1, r4, r0
    2aba:	pop	{r4, pc}

00002abc <SDClass::usedSize()>:
		return sdfs.remove(filepath);
	}
	bool rmdir(const char *filepath) {
		return sdfs.rmdir(filepath);
	}
	uint64_t usedSize() {
    2abc:	push	{r3, r4, r5, lr}
    2abe:	mov	r3, r0
		return (uint64_t)(sdfs.clusterCount() - sdfs.freeClusterCount())
    2ac0:	adds	r5, r0, #4
  }
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
    2ac2:	ldr.w	r0, [r0, #1156]	; 0x484
           m_xVol ? m_xVol->clusterCount() : 0;
    2ac6:	cbz	r0, 2ad2 <SDClass::usedSize()+0x16>
    2ac8:	ldr	r4, [r0, #28]
    2aca:	subs	r4, #1
    return m_fVol ? m_fVol->fatType() :
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    return m_fVol ? m_fVol->freeClusterCount() :
    2acc:	bl	6410 <FatPartition::freeClusterCount()>
    2ad0:	b.n	2ae4 <SDClass::usedSize()+0x28>
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
           m_xVol ? m_xVol->clusterCount() : 0;
    2ad2:	ldr.w	r0, [r3, #1160]	; 0x488
    2ad6:	cbz	r0, 2ae2 <SDClass::usedSize()+0x26>
    2ad8:	ldr.w	r4, [r0, #1072]	; 0x430
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    return m_fVol ? m_fVol->freeClusterCount() :
           m_xVol ? m_xVol->freeClusterCount() : 0;
    2adc:	bl	4334 <ExFatPartition::freeClusterCount()>
    2ae0:	b.n	2ae4 <SDClass::usedSize()+0x28>
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
           m_xVol ? m_xVol->clusterCount() : 0;
    2ae2:	mov	r4, r0
    2ae4:	subs	r4, r4, r0
		  * (uint64_t)sdfs.bytesPerCluster();
    2ae6:	mov	r0, r5
    2ae8:	bl	2a76 <FsVolume::bytesPerCluster() const>
	}
    2aec:	umull	r0, r1, r4, r0
    2af0:	pop	{r3, r4, r5, pc}

00002af2 <SdBase<FsVolume>::begin(SdioConfig)>:
  /** Initialize SD card and file system for SDIO mode.
   *
   * \param[in] sdioConfig SDIO configuration.
   * \return true for success or false for failure.
   */
  bool begin(SdioConfig sdioConfig) {
    2af2:	push	{r3, r4, r5, lr}
   * \param[in] config SDIO configuration.
   * \return generic card pointer or nullptr if SDIO is not supported.
   */
  SdCard* newCard(SdioConfig config) {
#if HAS_SDIO_CLASS
    m_sdioCard.begin(config);
    2af4:	add.w	r5, r0, #1168	; 0x490
    2af8:	mov	r4, r0
    spiConfigBackupPin = 255;
    2afa:	movs	r3, #255	; 0xff
    2afc:	strb.w	r3, [r0, #1200]	; 0x4b0
    sdioConfigBackup = sdioConfig;
    2b00:	strb.w	r1, [r0, #1212]	; 0x4bc
    2b04:	mov	r0, r5
    2b06:	bl	80dc <SdioCard::begin(SdioConfig)>
   *
   * \param[in] sdioConfig SDIO configuration.
   * \return true for success or false for failure.
   */
  bool cardBegin(SdioConfig sdioConfig) {
    m_card = m_cardFactory.newCard(sdioConfig);
    2b0a:	str.w	r5, [r4, #1164]	; 0x48c
    return m_card && !m_card->errorCode();
    2b0e:	mov	r0, r5
    2b10:	bl	78c8 <SdioCard::errorCode() const>
    2b14:	cbnz	r0, 2b24 <SdBase<FsVolume>::begin(SdioConfig)+0x32>
   * \return true for success or false for failure.
   */
  bool begin(SdioConfig sdioConfig) {
    spiConfigBackupPin = 255;
    sdioConfigBackup = sdioConfig;
    return cardBegin(sdioConfig) && Vol::begin(m_card);
    2b16:	ldr.w	r1, [r4, #1164]	; 0x48c
    2b1a:	mov	r0, r4
  }
    2b1c:	ldmia.w	sp!, {r3, r4, r5, lr}
   * \return true for success or false for failure.
   */
  bool begin(SdioConfig sdioConfig) {
    spiConfigBackupPin = 255;
    sdioConfigBackup = sdioConfig;
    return cardBegin(sdioConfig) && Vol::begin(m_card);
    2b20:	b.w	6e04 <FsVolume::begin(BlockDeviceInterface*)>
  }
    2b24:	movs	r0, #0
    2b26:	pop	{r3, r4, r5, pc}

00002b28 <SdBase<FsVolume>::cardBegin(SdSpiConfig)>:
  /** Initialize SD card in SPI mode.
   *
   * \param[in] spiConfig SPI configuration.
   * \return true for success or false for failure.
   */
  bool cardBegin(SdSpiConfig spiConfig) {
    2b28:	push	{r4, r5, r6, lr}
    2b2a:	sub	sp, #32
    2b2c:	mov	r6, r0
    2b2e:	add	r0, sp, #4
    2b30:	stmia.w	r0, {r1, r2, r3}
    2b34:	ldmia	r0, {r0, r1, r2}
    2b36:	add	r5, sp, #20
    2b38:	stmia.w	r5, {r0, r1, r3}
   *
   * \param[in] config SPI configuration.
   * \return generic card pointer.
   */
  SdCard* newCard(SdSpiConfig config) {
    m_spiCard.begin(config);
    2b3c:	addw	r4, r6, #1180	; 0x49c
    2b40:	ldmia.w	r5, {r1, r2, r3}
    2b44:	mov	r0, r4
    2b46:	bl	7238 <SdSpiCard::begin(SdSpiConfig)>
    m_card = m_cardFactory.newCard(spiConfig);
    2b4a:	str.w	r4, [r6, #1164]	; 0x48c
    return m_card && !m_card->errorCode();
    2b4e:	cbz	r4, 2b5c <SdBase<FsVolume>::cardBegin(SdSpiConfig)+0x34>
    2b50:	ldrb.w	r0, [r6, #1195]	; 0x4ab
    2b54:	clz	r0, r0
    2b58:	lsrs	r0, r0, #5
    2b5a:	b.n	2b5e <SdBase<FsVolume>::cardBegin(SdSpiConfig)+0x36>
    2b5c:	mov	r0, r4
  }
    2b5e:	add	sp, #32
    2b60:	pop	{r4, r5, r6, pc}

00002b62 <SdBase<FsVolume>::restart()>:
    sdioConfigBackup = sdioConfig;
    return cardBegin(sdioConfig) && Vol::begin(m_card);
  }
  //----------------------------------------------------------------------------
  /** Restart library with same config, used after media removed and replaced */
  bool restart() {
    2b62:	push	{r4, r5, lr}
    if (spiConfigBackupPin == 255) {
    2b64:	ldrb.w	r3, [r0, #1200]	; 0x4b0
    2b68:	cmp	r3, #255	; 0xff
    sdioConfigBackup = sdioConfig;
    return cardBegin(sdioConfig) && Vol::begin(m_card);
  }
  //----------------------------------------------------------------------------
  /** Restart library with same config, used after media removed and replaced */
  bool restart() {
    2b6a:	sub	sp, #20
    2b6c:	mov	r4, r0
    if (spiConfigBackupPin == 255) {
    2b6e:	bne.n	2b7a <SdBase<FsVolume>::restart()+0x18>
      return begin(sdioConfigBackup);
    2b70:	ldrb.w	r1, [r0, #1212]	; 0x4bc
    2b74:	bl	2af2 <SdBase<FsVolume>::begin(SdioConfig)>
    2b78:	b.n	2bae <SdBase<FsVolume>::restart()+0x4c>
    } else {
      SdSpiConfig spiConfig(spiConfigBackupPin, spiConfigBackupOptions,
                            spiConfigBackupClock, spiConfigBackupPort);
    2b7a:	ldr.w	r1, [r0, #1204]	; 0x4b4
    2b7e:	ldr.w	r2, [r0, #1208]	; 0x4b8
    2b82:	ldrb.w	r5, [r0, #1201]	; 0x4b1
    2b86:	strb.w	r3, [sp, #4]
    2b8a:	strb.w	r5, [sp, #5]
    2b8e:	str	r1, [sp, #8]
    2b90:	str	r2, [sp, #12]
  bool begin(SdSpiConfig spiConfig) {
    spiConfigBackupPin = spiConfig.csPin;
    spiConfigBackupOptions = spiConfig.options;
    spiConfigBackupClock = spiConfig.maxSck;
    spiConfigBackupPort = spiConfig.spiPort;
    return cardBegin(spiConfig) && Vol::begin(m_card);
    2b92:	add	r3, sp, #16
    2b94:	ldmdb	r3, {r1, r2, r3}
    2b98:	bl	2b28 <SdBase<FsVolume>::cardBegin(SdSpiConfig)>
    2b9c:	cbz	r0, 2bae <SdBase<FsVolume>::restart()+0x4c>
    2b9e:	ldr.w	r1, [r4, #1164]	; 0x48c
    2ba2:	mov	r0, r4
    } else {
      SdSpiConfig spiConfig(spiConfigBackupPin, spiConfigBackupOptions,
                            spiConfigBackupClock, spiConfigBackupPort);
      return begin(spiConfig);
    }
  }
    2ba4:	add	sp, #20
    2ba6:	ldmia.w	sp!, {r4, r5, lr}
  bool begin(SdSpiConfig spiConfig) {
    spiConfigBackupPin = spiConfig.csPin;
    spiConfigBackupOptions = spiConfig.options;
    spiConfigBackupClock = spiConfig.maxSck;
    spiConfigBackupPort = spiConfig.spiPort;
    return cardBegin(spiConfig) && Vol::begin(m_card);
    2baa:	b.w	6e04 <FsVolume::begin(BlockDeviceInterface*)>
    } else {
      SdSpiConfig spiConfig(spiConfigBackupPin, spiConfigBackupOptions,
                            spiConfigBackupClock, spiConfigBackupPort);
      return begin(spiConfig);
    }
  }
    2bae:	add	sp, #20
    2bb0:	pop	{r4, r5, pc}

00002bb2 <SDClass::format(int, char, Print&)>:
	}
}
#endif

bool SDClass::format(int type, char progressChar, Print& pr)
{
    2bb2:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    2bb6:	ldr.w	r4, [r0, #1168]	; 0x490
    2bba:	sub	sp, #48	; 0x30
    2bbc:	mov	r6, r0
    2bbe:	mov	r7, r3
	SdCard *card = sdfs.card();
	if (!card) return false; // no SD card
    2bc0:	cbnz	r4, 2bc6 <SDClass::format(int, char, Print&)+0x14>
    2bc2:	movs	r0, #0
    2bc4:	b.n	2c10 <SDClass::format(int, char, Print&)+0x5e>
	uint32_t sectors = card->sectorCount();
    2bc6:	ldr	r3, [r4, #0]
    2bc8:	mov	r0, r4
    2bca:	ldr	r3, [r3, #24]
    2bcc:	blx	r3
	if (sectors <= 12288) return false; // card too small
    2bce:	cmp.w	r0, #12288	; 0x3000

bool SDClass::format(int type, char progressChar, Print& pr)
{
	SdCard *card = sdfs.card();
	if (!card) return false; // no SD card
	uint32_t sectors = card->sectorCount();
    2bd2:	mov	r8, r0
	if (sectors <= 12288) return false; // card too small
    2bd4:	bls.n	2bc2 <SDClass::format(int, char, Print&)+0x10>
	uint8_t *buf = (uint8_t *)malloc(512);
    2bd6:	mov.w	r0, #512	; 0x200
    2bda:	bl	aabc <malloc>
	if (!buf) return false; // unable to allocate memory
    2bde:	mov	r5, r0
    2be0:	cmp	r0, #0
    2be2:	beq.n	2bc2 <SDClass::format(int, char, Print&)+0x10>
	bool ret;
	if (sectors > 67108864) {
    2be4:	cmp.w	r8, #67108864	; 0x4000000
#ifdef __arm__
		ExFatFormatter exFatFormatter;
		ret = exFatFormatter.format(card, buf, &pr);
    2be8:	mov	r2, r0
    2bea:	mov	r3, r7
    2bec:	mov	r1, r4
    2bee:	add	r0, sp, #4
	uint32_t sectors = card->sectorCount();
	if (sectors <= 12288) return false; // card too small
	uint8_t *buf = (uint8_t *)malloc(512);
	if (!buf) return false; // unable to allocate memory
	bool ret;
	if (sectors > 67108864) {
    2bf0:	bls.n	2bf8 <SDClass::format(int, char, Print&)+0x46>
#ifdef __arm__
		ExFatFormatter exFatFormatter;
		ret = exFatFormatter.format(card, buf, &pr);
    2bf2:	bl	32c4 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)>
    2bf6:	b.n	2bfc <SDClass::format(int, char, Print&)+0x4a>
#else
		ret = false;
#endif
	} else {
		FatFormatter fatFormatter;
		ret = fatFormatter.format(card, buf, &pr);
    2bf8:	bl	524c <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)>
    2bfc:	mov	r4, r0
	}
	free(buf);
    2bfe:	mov	r0, r5
    2c00:	bl	aacc <free>
	if (ret) {
    2c04:	cmp	r4, #0
    2c06:	beq.n	2bc2 <SDClass::format(int, char, Print&)+0x10>
		// TODO: Is begin() really necessary?  Is a quicker way possible?
		sdfs.restart(); // TODO: is sdfs.volumeBegin() enough??
    2c08:	adds	r0, r6, #4
    2c0a:	bl	2b62 <SdBase<FsVolume>::restart()>
    2c0e:	movs	r0, #1
	}
	return ret;
}
    2c10:	add	sp, #48	; 0x30
    2c12:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00002c16 <SDClass::mediaPresent()>:
	}
	return false;
}

bool SDClass::mediaPresent()
{
    2c16:	push	{r4, r5, lr}
    2c18:	ldr.w	r4, [r0, #1168]	; 0x490
    2c1c:	sub	sp, #20
    2c1e:	mov	r5, r0
	//Serial.print("mediaPresent: ");
	bool ret;
	SdCard *card = sdfs.card();
	if (card) {
    2c20:	cbz	r4, 2c60 <SDClass::mediaPresent()+0x4a>
		if (cardPreviouslyPresent) {
    2c22:	ldrb.w	r3, [r0, #1220]	; 0x4c4
    2c26:	cbz	r3, 2c58 <SDClass::mediaPresent()+0x42>
			#ifdef BUILTIN_SDCARD
			uint32_t s;
			if (csPin_ == BUILTIN_SDCARD) {
    2c28:	ldrb.w	r3, [r0, #1221]	; 0x4c5
    2c2c:	cmp	r3, #254	; 0xfe
    2c2e:	beq.n	2c3c <SDClass::mediaPresent()+0x26>
			const uint32_t s = 0xFFFFFFFF;
			#endif
			if (s == 0xFFFFFFFF) {
				// SPI doesn't have 32 bit status, read CID register
				cid_t cid;
				ret = card->readCID(&cid);
    2c30:	ldr	r3, [r4, #0]
    2c32:	mov	r1, sp
    2c34:	ldr	r3, [r3, #56]	; 0x38
    2c36:	mov	r0, r4
    2c38:	blx	r3
    2c3a:	b.n	2c62 <SDClass::mediaPresent()+0x4c>
		if (cardPreviouslyPresent) {
			#ifdef BUILTIN_SDCARD
			uint32_t s;
			if (csPin_ == BUILTIN_SDCARD) {
				#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
				card->syncDevice();
    2c3c:	ldr	r3, [r4, #0]
    2c3e:	mov	r0, r4
    2c40:	ldr	r3, [r3, #28]
    2c42:	blx	r3
				#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
				s = card->status();
    2c44:	ldr	r3, [r4, #0]
    2c46:	mov	r0, r4
    2c48:	ldr	r3, [r3, #68]	; 0x44
    2c4a:	blx	r3
			} else s = 0xFFFFFFFF;
			#else
			const uint32_t s = 0xFFFFFFFF;
			#endif
			if (s == 0xFFFFFFFF) {
    2c4c:	adds	r3, r0, #1
    2c4e:	beq.n	2c30 <SDClass::mediaPresent()+0x1a>
				// SPI doesn't have 32 bit status, read CID register
				cid_t cid;
				ret = card->readCID(&cid);
				//Serial.print(ret ? "CID=ok" : "CID=unreadable");
			} else if (s == 0) {
    2c50:	adds	r0, #0
    2c52:	it	ne
    2c54:	movne	r0, #1
    2c56:	b.n	2c62 <SDClass::mediaPresent()+0x4c>
			if ((csPin_ == BUILTIN_SDCARD) && !digitalReadFast(_SD_DAT3))
				ret = false;
			else
			#endif
			{
				ret = sdfs.restart();
    2c58:	adds	r0, #4
    2c5a:	bl	2b62 <SdBase<FsVolume>::restart()>
    2c5e:	b.n	2c62 <SDClass::mediaPresent()+0x4c>
			}
			//Serial.print(ret ? "begin ok" : "begin nope");
		}
	} else {
		//Serial.print("no card");
		ret = false;
    2c60:	mov	r0, r4
	}
	//Serial.println();
	cardPreviouslyPresent = ret;
    2c62:	strb.w	r0, [r5, #1220]	; 0x4c4
	return ret;
}
    2c66:	add	sp, #20
    2c68:	pop	{r4, r5, pc}
    2c6a:	Address 0x00002c6a is out of bounds.


00002c6c <_GLOBAL__sub_I_SD>:


class SDClass : public FS
{
public:
	SDClass() { }
    2c6c:	ldr	r0, [pc, #72]	; (2cb8 <_GLOBAL__sub_I_SD+0x4c>)
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    2c6e:	ldr	r2, [pc, #76]	; (2cbc <_GLOBAL__sub_I_SD+0x50>)
    2c70:	str.w	r2, [r0, #1172]	; 0x494
    2c74:	ldr	r2, [pc, #72]	; (2cc0 <_GLOBAL__sub_I_SD+0x54>)
    2c76:	ldr	r3, [pc, #76]	; (2cc4 <_GLOBAL__sub_I_SD+0x58>)
    2c78:	str.w	r2, [r0, #1184]	; 0x4a0
    2c7c:	movs	r2, #1
    2c7e:	str	r3, [r0, #0]
    2c80:	strb.w	r2, [r0, #1197]	; 0x4ad
 * \class FsVolume
 * \brief FsVolume class.
 */
class FsVolume {
 public:
  FsVolume() {}
    2c84:	movs	r3, #0
    2c86:	movs	r2, #41	; 0x29
    2c88:	str.w	r3, [r0, #1156]	; 0x484
    2c8c:	str.w	r3, [r0, #1160]	; 0x488
 * \class SdioConfig
 * \brief SDIO card configuration.
 */
class SdioConfig {
 public:
  SdioConfig() {}
    2c90:	strb.w	r3, [r0, #1180]	; 0x49c
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    2c94:	strb.w	r3, [r0, #1181]	; 0x49d
    2c98:	strb.w	r2, [r0, #1199]	; 0x4af
    2c9c:	strb.w	r3, [r0, #1202]	; 0x4b2
 * \class SdioConfig
 * \brief SDIO card configuration.
 */
class SdioConfig {
 public:
  SdioConfig() {}
    2ca0:	strb.w	r3, [r0, #1216]	; 0x4c0
    2ca4:	strb.w	r3, [r0, #1220]	; 0x4c4
 */

#include <Arduino.h>
#include <SD.h>

SDClass SD;
    2ca8:	ldr	r2, [pc, #28]	; (2cc8 <_GLOBAL__sub_I_SD+0x5c>)
    2caa:	ldr	r1, [pc, #32]	; (2ccc <_GLOBAL__sub_I_SD+0x60>)
    2cac:	movs	r3, #255	; 0xff
    2cae:	strb.w	r3, [r0, #1221]	; 0x4c5
    2cb2:	b.w	9cc8 <__aeabi_atexit>
    2cb6:	nop
    2cb8:	.word	0x1fff7f50
    2cbc:	.word	0x000125c8
    2cc0:	.word	0x00012568
    2cc4:	.word	0x00012268
    2cc8:	.word	0x1fff0f30
    2ccc:	.word	0x000028d1

00002cd0 <FsUtf::cpToMb(unsigned long, char*, char*)>:
#include "FsUtf.h"
namespace FsUtf {
  //----------------------------------------------------------------------------
  char* cpToMb(uint32_t cp, char* str, char* end) {
    size_t n = end - str;
    if (cp < 0X80) {
    2cd0:	cmp	r0, #127	; 0x7f
 */
#include "FsUtf.h"
namespace FsUtf {
  //----------------------------------------------------------------------------
  char* cpToMb(uint32_t cp, char* str, char* end) {
    size_t n = end - str;
    2cd2:	sub.w	r2, r2, r1
    if (cp < 0X80) {
    2cd6:	bhi.n	2ce2 <FsUtf::cpToMb(unsigned long, char*, char*)+0x12>
      if (n < 1) goto fail;
    2cd8:	cmp	r2, #0
    2cda:	beq.n	2d5c <FsUtf::cpToMb(unsigned long, char*, char*)+0x8c>
      *(str++) = static_cast<uint8_t>(cp);
    2cdc:	strb	r0, [r1, #0]
    2cde:	adds	r0, r1, #1
    2ce0:	bx	lr
    } else if (cp < 0X800) {
    2ce2:	cmp.w	r0, #2048	; 0x800
    2ce6:	bcs.n	2d04 <FsUtf::cpToMb(unsigned long, char*, char*)+0x34>
      if (n < 2) goto fail;
    2ce8:	cmp	r2, #1
    2cea:	bls.n	2d60 <FsUtf::cpToMb(unsigned long, char*, char*)+0x90>
      *(str++) = static_cast<uint8_t>((cp >> 6)          | 0XC0);
    2cec:	lsrs	r3, r0, #6
    2cee:	mov	r2, r1
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    2cf0:	and.w	r0, r0, #63	; 0x3f
    if (cp < 0X80) {
      if (n < 1) goto fail;
      *(str++) = static_cast<uint8_t>(cp);
    } else if (cp < 0X800) {
      if (n < 2) goto fail;
      *(str++) = static_cast<uint8_t>((cp >> 6)          | 0XC0);
    2cf4:	orn	r3, r3, #63	; 0x3f
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    2cf8:	orn	r0, r0, #127	; 0x7f
    if (cp < 0X80) {
      if (n < 1) goto fail;
      *(str++) = static_cast<uint8_t>(cp);
    } else if (cp < 0X800) {
      if (n < 2) goto fail;
      *(str++) = static_cast<uint8_t>((cp >> 6)          | 0XC0);
    2cfc:	strb.w	r3, [r2], #2
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    2d00:	strb	r0, [r1, #1]
    2d02:	b.n	2d5c <FsUtf::cpToMb(unsigned long, char*, char*)+0x8c>
    } else if (cp < 0X10000) {
    2d04:	cmp.w	r0, #65536	; 0x10000
    2d08:	bcs.n	2d2e <FsUtf::cpToMb(unsigned long, char*, char*)+0x5e>
      if (n < 3) goto fail;
    2d0a:	cmp	r2, #2
    2d0c:	bls.n	2d60 <FsUtf::cpToMb(unsigned long, char*, char*)+0x90>
      *(str++) = static_cast<uint8_t>((cp >> 12)         | 0XE0);
    2d0e:	lsrs	r3, r0, #12
    2d10:	orn	r3, r3, #31
    2d14:	strb	r3, [r1, #0]
      *(str++) = static_cast<uint8_t>(((cp >> 6) & 0X3F) | 0X80);
    2d16:	ubfx	r3, r0, #6, #6
    2d1a:	orn	r3, r3, #127	; 0x7f
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    2d1e:	and.w	r0, r0, #63	; 0x3f
      *(str++) = static_cast<uint8_t>((cp >> 6)          | 0XC0);
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    } else if (cp < 0X10000) {
      if (n < 3) goto fail;
      *(str++) = static_cast<uint8_t>((cp >> 12)         | 0XE0);
      *(str++) = static_cast<uint8_t>(((cp >> 6) & 0X3F) | 0X80);
    2d22:	strb	r3, [r1, #1]
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    2d24:	orn	r3, r0, #127	; 0x7f
    2d28:	strb	r3, [r1, #2]
    2d2a:	adds	r0, r1, #3
    2d2c:	bx	lr
    } else {
       if (n < 4) goto fail;
    2d2e:	cmp	r2, #3
    2d30:	bls.n	2d60 <FsUtf::cpToMb(unsigned long, char*, char*)+0x90>
      *(str++) = static_cast<uint8_t>((cp >> 18)         | 0XF0);
    2d32:	lsrs	r3, r0, #18
    2d34:	orn	r3, r3, #15
    2d38:	strb	r3, [r1, #0]
      *(str++) = static_cast<uint8_t>(((cp >> 12) & 0X3F)| 0X80);
    2d3a:	ubfx	r3, r0, #12, #6
    2d3e:	orn	r3, r3, #127	; 0x7f
    2d42:	strb	r3, [r1, #1]
      *(str++) = static_cast<uint8_t>(((cp >> 6) & 0X3F) | 0X80);
    2d44:	ubfx	r3, r0, #6, #6
    2d48:	orn	r3, r3, #127	; 0x7f
    2d4c:	strb	r3, [r1, #2]
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    2d4e:	and.w	r3, r0, #63	; 0x3f
    2d52:	orn	r3, r3, #127	; 0x7f
    2d56:	strb	r3, [r1, #3]
    2d58:	adds	r0, r1, #4
    2d5a:	bx	lr
    }
    return str;

   fail:
    return nullptr;
    2d5c:	mov	r0, r2
    2d5e:	bx	lr
    2d60:	movs	r0, #0
  }
    2d62:	bx	lr

00002d64 <FsUtf::mbToCp(char const*, char const*, unsigned long*)>:
  //----------------------------------------------------------------------------
  // to do?  improve error check
  const char* mbToCp(const char* str, const char* end, uint32_t* rtn) {
    size_t n;
    uint32_t cp;
    if (str >= end) {
    2d64:	cmp	r0, r1
   fail:
    return nullptr;
  }
  //----------------------------------------------------------------------------
  // to do?  improve error check
  const char* mbToCp(const char* str, const char* end, uint32_t* rtn) {
    2d66:	push	{r4, r5, lr}
    size_t n;
    uint32_t cp;
    if (str >= end) {
    2d68:	bcs.n	2dd8 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x74>
      return nullptr;
    }
    uint8_t ch = str[0];
    2d6a:	ldrb	r3, [r0, #0]
    if ((ch & 0X80) == 0) {
    2d6c:	lsls	r4, r3, #24
    2d6e:	bmi.n	2d76 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x12>
      *rtn = ch;
    2d70:	str	r3, [r2, #0]
      return str + 1;
    2d72:	adds	r4, r0, #1
    2d74:	b.n	2dde <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x7a>
    }
    if ((ch & 0XE0) == 0XC0) {
    2d76:	and.w	r4, r3, #224	; 0xe0
    2d7a:	cmp	r4, #192	; 0xc0
    2d7c:	bne.n	2d86 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x22>
      cp = ch & 0X1F;
    2d7e:	and.w	r3, r3, #31
      n = 2;
    2d82:	movs	r4, #2
    2d84:	b.n	2da4 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x40>
    } else if ((ch & 0XF0) == 0XE0) {
    2d86:	and.w	r4, r3, #240	; 0xf0
    2d8a:	cmp	r4, #224	; 0xe0
    2d8c:	bne.n	2d96 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x32>
      cp = ch & 0X0F;
    2d8e:	and.w	r3, r3, #15
      n = 3;
    2d92:	movs	r4, #3
    2d94:	b.n	2da4 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x40>
    } else if ((ch & 0XF8) == 0XF0) {
    2d96:	and.w	r4, r3, #248	; 0xf8
    2d9a:	cmp	r4, #240	; 0xf0
    2d9c:	bne.n	2dd8 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x74>
      cp = ch & 0X07;
    2d9e:	and.w	r3, r3, #7
      n = 4;
    2da2:	movs	r4, #4
    } else {
      return nullptr;
    }
    if ((str + n) > end) {
    2da4:	add	r4, r0
    2da6:	cmp	r1, r4
    2da8:	bcc.n	2dd8 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x74>
    2daa:	adds	r0, #1
      return nullptr;
    }
    for (size_t i = 1; i < n; i++) {
      ch = str[i];
    2dac:	ldrb.w	r1, [r0], #1
      if ((ch & 0XC0) != 0X80) {
    2db0:	and.w	r5, r1, #192	; 0xc0
    2db4:	cmp	r5, #128	; 0x80
    2db6:	bne.n	2dd8 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x74>
        return nullptr;
      }
      cp <<= 6;
      cp |= ch & 0X3F;
    2db8:	and.w	r1, r1, #63	; 0x3f
      return nullptr;
    }
    if ((str + n) > end) {
      return nullptr;
    }
    for (size_t i = 1; i < n; i++) {
    2dbc:	cmp	r0, r4
      ch = str[i];
      if ((ch & 0XC0) != 0X80) {
        return nullptr;
      }
      cp <<= 6;
      cp |= ch & 0X3F;
    2dbe:	orr.w	r3, r1, r3, lsl #6
      return nullptr;
    }
    if ((str + n) > end) {
      return nullptr;
    }
    for (size_t i = 1; i < n; i++) {
    2dc2:	bne.n	2dac <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x48>
      }
      cp <<= 6;
      cp |= ch & 0X3F;
    }
    // Don't allow over long as ASCII.
    if (cp < 0X80 || !isValidCp(cp)) {
    2dc4:	ldr	r1, [pc, #28]	; (2de4 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x80>)
    2dc6:	sub.w	r0, r3, #128	; 0x80
    2dca:	cmp	r0, r1
    2dcc:	bhi.n	2dd8 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x74>
  /** Check for a valid code point.
   * \param[in] cp code point.
   * \return true if valid else false.
   */
  inline bool isValidCp(uint32_t cp) {
    return cp <= 0x10FFFF && (cp < 0XD800 || cp > 0XDFFF);
    2dce:	sub.w	r1, r3, #55296	; 0xd800
    2dd2:	cmp.w	r1, #2048	; 0x800
    2dd6:	bcs.n	2ddc <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x78>
  // to do?  improve error check
  const char* mbToCp(const char* str, const char* end, uint32_t* rtn) {
    size_t n;
    uint32_t cp;
    if (str >= end) {
      return nullptr;
    2dd8:	movs	r4, #0
    2dda:	b.n	2dde <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x7a>
    }
    // Don't allow over long as ASCII.
    if (cp < 0X80 || !isValidCp(cp)) {
      return nullptr;
    }
    *rtn = cp;
    2ddc:	str	r3, [r2, #0]
    return str + n;
  }
    2dde:	mov	r0, r4
    2de0:	pop	{r4, r5, pc}
    2de2:	nop
    2de4:	.word	0x0010ff7f

00002de8 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)>:
#include "FsGetPartitionInfo.h"
namespace FsGetPartitionInfo {
  static const uint8_t mbdpGuid[16] PROGMEM = {0xA2, 0xA0, 0xD0, 0xEB, 0xE5, 0xB9, 0x33, 0x44, 0x87, 0xC0, 0x68, 0xB6, 0xB7, 0x26, 0x99, 0xC7};

  voltype_t getPartitionInfo(BlockDeviceInterface *blockDev, uint8_t part, uint8_t *secBuf,
      uint32_t *pfirstLBA, uint32_t *psectorCount, uint32_t *pmbrLBA, uint8_t *pmbrPart) {
    2de8:	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2dec:	add	r6, sp, #48	; 0x30
    2dee:	mov	r5, r0
    2df0:	mov	r4, r2
    2df2:	mov	sl, r3
    2df4:	ldmia.w	r6, {r6, r7, r8}
    uint32_t firstLBA;
    uint32_t sectorCount;
    MbrSector_t *mbr;
    MbrPart_t *mp;

    if (!part || !pfirstLBA) return INVALID_VOL; // won't handle this here.
    2df8:	str	r1, [sp, #4]
    2dfa:	cbnz	r1, 2e00 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x18>
    2dfc:	movs	r0, #0
    2dfe:	b.n	2f88 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x1a0>
    2e00:	cmp.w	sl, #0
    2e04:	beq.n	2dfc <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
    part--; // zero base it.

    if (!blockDev->readSector(0, secBuf)) return INVALID_VOL;
    2e06:	ldr	r3, [r0, #0]
    2e08:	movs	r1, #0
    2e0a:	ldr	r3, [r3, #12]
    2e0c:	blx	r3
    2e0e:	cmp	r0, #0
    2e10:	beq.n	2dfc <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
    uint32_t sectorCount;
    MbrSector_t *mbr;
    MbrPart_t *mp;

    if (!part || !pfirstLBA) return INVALID_VOL; // won't handle this here.
    part--; // zero base it.
    2e12:	ldr	r3, [sp, #4]
    2e14:	add.w	r9, r3, #4294967295
    if (!blockDev->readSector(0, secBuf)) return INVALID_VOL;
    mbr = reinterpret_cast<MbrSector_t*>(secBuf);

    // First check for GPT vs MBR
    mp = &mbr->part[0];
    if (mp->type == 0xee) {
    2e18:	ldrb.w	r3, [r4, #450]	; 0x1c2
    2e1c:	cmp	r3, #238	; 0xee
    uint32_t sectorCount;
    MbrSector_t *mbr;
    MbrPart_t *mp;

    if (!part || !pfirstLBA) return INVALID_VOL; // won't handle this here.
    part--; // zero base it.
    2e1e:	uxtb.w	r9, r9
    if (!blockDev->readSector(0, secBuf)) return INVALID_VOL;
    mbr = reinterpret_cast<MbrSector_t*>(secBuf);

    // First check for GPT vs MBR
    mp = &mbr->part[0];
    if (mp->type == 0xee) {
    2e22:	bne.n	2ea4 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0xbc>
      // This is a GPT initialized Disk assume validation done earlier.
      if (!blockDev->readSector(1, secBuf)) return INVALID_VOL; 
    2e24:	ldr	r3, [r5, #0]
    2e26:	mov	r2, r4
    2e28:	ldr	r3, [r3, #12]
    2e2a:	movs	r1, #1
    2e2c:	mov	r0, r5
    2e2e:	blx	r3
    2e30:	cmp	r0, #0
    2e32:	beq.n	2dfc <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      GPTPartitionHeader_t* gptph = reinterpret_cast<GPTPartitionHeader_t*>(secBuf);
      // Lets do a little validation of this data.
      if (!gptph || (memcmp(gptph->signature, F("EFI PART"), 8) != 0))  return INVALID_VOL;
    2e34:	movs	r2, #8
    2e36:	ldr	r1, [pc, #344]	; (2f90 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x1a8>)
    2e38:	mov	r0, r4
    2e3a:	bl	b120 <memcmp>
    2e3e:	cmp	r0, #0
    2e40:	bne.n	2dfc <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      uint32_t numberPartitions = getLe32(gptph->numberPartitions);
      if (part > numberPartitions)  return INVALID_VOL;
    2e42:	ldr	r3, [r4, #80]	; 0x50
    2e44:	cmp	r9, r3
    2e46:	bhi.n	2dfc <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>

      // We will overload the mbr part to give clue where GPT data is stored for this volume
      uint32_t mbrLBA = 2 + (part >> 2);
    2e48:	mov.w	r1, r9, asr #2
    2e4c:	adds	r1, #2
      uint8_t mbrPart = part & 0x3;
    2e4e:	and.w	r9, r9, #3
      if (pmbrLBA) *pmbrLBA = mbrLBA;
    2e52:	cbz	r7, 2e56 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x6e>
    2e54:	str	r1, [r7, #0]
      if (pmbrPart) *pmbrPart =mbrPart;
    2e56:	cmp.w	r8, #0
    2e5a:	beq.n	2e60 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x78>
    2e5c:	strb.w	r9, [r8]
      if (!blockDev->readSector(mbrLBA, secBuf)) return INVALID_VOL; 
    2e60:	ldr	r3, [r5, #0]
    2e62:	mov	r2, r4
    2e64:	ldr	r3, [r3, #12]
    2e66:	mov	r0, r5
    2e68:	blx	r3
    2e6a:	cmp	r0, #0
    2e6c:	beq.n	2dfc <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      GPTPartitionEntrySector_t *gptes = reinterpret_cast<GPTPartitionEntrySector_t*>(secBuf);
      GPTPartitionEntryItem_t *gptei = &gptes->items[mbrPart];

      // Mow extract the data...
      firstLBA = getLe64(gptei->firstLBA);
    2e6e:	mov.w	r0, r9, lsl #7
    2e72:	add.w	r3, r0, #32
    2e76:	ldr	r2, [r4, r3]
      sectorCount = 1 + getLe64(gptei->lastLBA) - getLe64(gptei->firstLBA);
    2e78:	add.w	r3, r0, #40	; 0x28
    2e7c:	ldr	r3, [r4, r3]
    2e7e:	adds	r3, #1
    2e80:	subs	r3, r3, r2
      if ((firstLBA == 0) && (sectorCount == 1)) return INVALID_VOL;
    2e82:	cbnz	r2, 2e88 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0xa0>
    2e84:	cmp	r3, #1
    2e86:	beq.n	2dfc <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      
      *pfirstLBA = firstLBA;
    2e88:	str.w	r2, [sl]
      if (psectorCount) *psectorCount = sectorCount;
    2e8c:	cbz	r6, 2e90 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0xa8>
    2e8e:	str	r3, [r6, #0]

      if (memcmp((uint8_t *)gptei->partitionTypeGUID, mbdpGuid, 16) != 0) return OTHER_VOL;
    2e90:	movs	r2, #16
    2e92:	ldr	r1, [pc, #256]	; (2f94 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x1ac>)
    2e94:	add	r0, r4
    2e96:	bl	b120 <memcmp>
    2e9a:	cmp	r0, #0
    2e9c:	ite	eq
    2e9e:	moveq	r0, #3
    2ea0:	movne	r0, #4
    2ea2:	b.n	2f88 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x1a0>
    }
    // So we are now looking a MBR type setups. 
    // Extended support we need to walk through the partitions to see if there is an extended partition
    // that we need to walk into. 
    // short cut:
    if (part < 4) {
    2ea4:	cmp.w	r9, #3
    2ea8:	bhi.n	2eea <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x102>
      // try quick way through
      mp = &mbr->part[part];
      if (((mp->boot == 0) || (mp->boot == 0X80)) && (mp->type != 0) && (mp->type != 0xf)) {
    2eaa:	add.w	r3, r4, r9, lsl #4
    2eae:	ldrb.w	r2, [r3, #446]	; 0x1be
    2eb2:	lsls	r2, r2, #25
    2eb4:	bne.n	2eea <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x102>
    2eb6:	ldrb.w	r3, [r3, #450]	; 0x1c2
    2eba:	cbz	r3, 2eea <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x102>
    2ebc:	cmp	r3, #15
    2ebe:	beq.n	2eea <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x102>
        *pfirstLBA = getLe32(mp->relativeSectors);
    2ec0:	add.w	r3, r9, #28
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    2ec4:	add.w	r4, r4, r3, lsl #4
    2ec8:	ldr.w	r3, [r4, #6]
    2ecc:	str.w	r3, [sl]
        if (psectorCount) *psectorCount = getLe32(mp->totalSectors);
    2ed0:	cbz	r6, 2ed8 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0xf0>
    2ed2:	ldr.w	r3, [r4, #10]
    2ed6:	str	r3, [r6, #0]
        if (pmbrLBA) *pmbrLBA = 0;
    2ed8:	cbz	r7, 2ede <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0xf6>
    2eda:	movs	r3, #0
    2edc:	str	r3, [r7, #0]
        if (pmbrPart) *pmbrPart = part; // zero based. 
    2ede:	cmp.w	r8, #0
    2ee2:	beq.n	2f18 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x130>
    2ee4:	strb.w	r9, [r8]
    2ee8:	b.n	2f18 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x130>
    2eea:	mov	r1, r4
#include "FsGetPartitionInfo.h"
namespace FsGetPartitionInfo {
  static const uint8_t mbdpGuid[16] PROGMEM = {0xA2, 0xA0, 0xD0, 0xEB, 0xE5, 0xB9, 0x33, 0x44, 0x87, 0xC0, 0x68, 0xB6, 0xB7, 0x26, 0x99, 0xC7};

  voltype_t getPartitionInfo(BlockDeviceInterface *blockDev, uint8_t part, uint8_t *secBuf,
      uint32_t *pfirstLBA, uint32_t *psectorCount, uint32_t *pmbrLBA, uint8_t *pmbrPart) {
    2eec:	movs	r3, #0

    // So must be extended or invalid.
    uint8_t index_part;
    for (index_part = 0; index_part < 4; index_part++) {
      mp = &mbr->part[index_part];
      if ((mp->boot != 0 && mp->boot != 0X80) || mp->type == 0 || index_part > part) return INVALID_VOL;
    2eee:	ldrb.w	r0, [r1, #446]	; 0x1be
    2ef2:	lsls	r0, r0, #25
    2ef4:	uxtb	r2, r3
    2ef6:	bne.n	2dfc <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
    2ef8:	ldrb.w	r0, [r1, #450]	; 0x1c2
    2efc:	cmp	r0, #0
    2efe:	beq.w	2dfc <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
    2f02:	cmp	r9, r2
    2f04:	bcc.w	2dfc <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      if (mp->type == 0xf) break;
    2f08:	cmp	r0, #15
    2f0a:	beq.n	2f1c <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x134>
    2f0c:	adds	r3, #1
      }
    }  

    // So must be extended or invalid.
    uint8_t index_part;
    for (index_part = 0; index_part < 4; index_part++) {
    2f0e:	cmp	r3, #4
    2f10:	add.w	r1, r1, #16
    2f14:	bne.n	2eee <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x106>
    2f16:	b.n	2dfc <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      if (((mp->boot == 0) || (mp->boot == 0X80)) && (mp->type != 0) && (mp->type != 0xf)) {
        *pfirstLBA = getLe32(mp->relativeSectors);
        if (psectorCount) *psectorCount = getLe32(mp->totalSectors);
        if (pmbrLBA) *pmbrLBA = 0;
        if (pmbrPart) *pmbrPart = part; // zero based. 
        return MBR_VOL;
    2f18:	movs	r0, #1
    2f1a:	b.n	2f88 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x1a0>
    }  

    // So must be extended or invalid.
    uint8_t index_part;
    for (index_part = 0; index_part < 4; index_part++) {
      mp = &mbr->part[index_part];
    2f1c:	add.w	r3, r4, r3, lsl #4
    2f20:	adds	r2, #1
    2f22:	ldr.w	r9, [r3, #454]	; 0x1c6
    2f26:	uxtb.w	fp, r2
    if (index_part == 4) return INVALID_VOL; // no extended partition found. 

    // Our partition if it exists is in extended partition. 
    uint32_t next_mbr = getLe32(mp->relativeSectors);
    for(;;) {
      if (!blockDev->readSector(next_mbr, secBuf)) return INVALID_VOL;
    2f2a:	ldr	r3, [r5, #0]
    2f2c:	mov	r2, r4
    2f2e:	ldr	r3, [r3, #12]
    2f30:	mov	r1, r9
    2f32:	mov	r0, r5
    2f34:	blx	r3
    2f36:	cmp	r0, #0
    2f38:	beq.w	2dfc <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      mbr = reinterpret_cast<MbrSector_t*>(secBuf);

      if (index_part == part) break; // should be at that entry
    2f3c:	ldr	r3, [sp, #4]
    2f3e:	cmp	r3, fp
    2f40:	beq.n	2f62 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x17a>
      // else we need to see if it points to others...
      mp = &mbr->part[1];
      uint32_t  relSec = getLe32(mp->relativeSectors);
      //Serial.printf("    Check for next: type: %u start:%u\n ", mp->type, volumeStartSector);
      if ((mp->type == 5) && relSec) {
    2f42:	ldrb.w	r2, [r4, #466]	; 0x1d2
    2f46:	ldr.w	r3, [r4, #470]	; 0x1d6
    2f4a:	cmp	r2, #5
    2f4c:	bne.w	2dfc <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
    2f50:	add.w	r2, fp, #1
    2f54:	uxtb.w	fp, r2
    2f58:	cmp	r3, #0
    2f5a:	beq.w	2dfc <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
        next_mbr = next_mbr + relSec;
    2f5e:	add	r9, r3

    if (index_part == 4) return INVALID_VOL; // no extended partition found. 

    // Our partition if it exists is in extended partition. 
    uint32_t next_mbr = getLe32(mp->relativeSectors);
    for(;;) {
    2f60:	b.n	2f2a <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x142>
      } else return INVALID_VOL;
    }
   
    // If we are here than we should hopefully be at start of segment...
    mp = &mbr->part[0];
    *pfirstLBA = getLe32(mp->relativeSectors) + next_mbr;
    2f62:	ldr.w	r3, [r4, #454]	; 0x1c6
    2f66:	add	r3, r9
    2f68:	str.w	r3, [sl]
    if (psectorCount) *psectorCount = getLe32(mp->totalSectors);
    2f6c:	cbz	r6, 2f74 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x18c>
    2f6e:	ldr.w	r3, [r4, #458]	; 0x1ca
    2f72:	str	r3, [r6, #0]
    if (pmbrLBA) *pmbrLBA = next_mbr;
    2f74:	cbz	r7, 2f7a <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x192>
    2f76:	str.w	r9, [r7]
    if (pmbrPart) *pmbrPart = 0; // zero based. 
    2f7a:	cmp.w	r8, #0
    2f7e:	beq.n	2f86 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x19e>
    2f80:	movs	r3, #0
    2f82:	strb.w	r3, [r8]
    return EXT_VOL;
    2f86:	movs	r0, #2
  }
    2f88:	add	sp, #12
    2f8a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    2f8e:	nop
    2f90:	.word	0x000122a0
    2f94:	.word	0x00012290

00002f98 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)>:
  uint32_t c;
  uint8_t h;
  uint8_t s;

  uint8_t numberOfHeads;
  uint8_t sectorsPerTrack = capacityMB <= 256 ? 32 : 63;
    2f98:	cmp.w	r1, #256	; 0x100
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsStructs.h"
// bgnLba = relSector;
// endLba = relSector + partSize - 1;
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba) {
    2f9c:	push	{r4, r5, lr}
  uint32_t c;
  uint8_t h;
  uint8_t s;

  uint8_t numberOfHeads;
  uint8_t sectorsPerTrack = capacityMB <= 256 ? 32 : 63;
    2f9e:	bhi.n	2fae <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x16>
  if (capacityMB <= 16) {
    2fa0:	cmp	r1, #16
  uint32_t c;
  uint8_t h;
  uint8_t s;

  uint8_t numberOfHeads;
  uint8_t sectorsPerTrack = capacityMB <= 256 ? 32 : 63;
    2fa2:	mov.w	r4, #32
  if (capacityMB <= 16) {
    2fa6:	bls.n	2fd2 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x3a>
    numberOfHeads = 2;
  } else if (capacityMB <= 32) {
    2fa8:	cmp	r1, #32
    2faa:	bls.n	2fd6 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x3e>
    2fac:	b.n	2fb0 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x18>
  uint32_t c;
  uint8_t h;
  uint8_t s;

  uint8_t numberOfHeads;
  uint8_t sectorsPerTrack = capacityMB <= 256 ? 32 : 63;
    2fae:	movs	r4, #63	; 0x3f
  if (capacityMB <= 16) {
    numberOfHeads = 2;
  } else if (capacityMB <= 32) {
    numberOfHeads = 4;
  } else if (capacityMB <= 128) {
    2fb0:	cmp	r1, #128	; 0x80
    2fb2:	bls.n	2fda <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x42>
    numberOfHeads = 8;
  } else if (capacityMB <= 504) {
    2fb4:	cmp.w	r1, #504	; 0x1f8
    2fb8:	bls.n	2fde <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x46>
    numberOfHeads = 16;
  } else if (capacityMB <= 1008) {
    2fba:	cmp.w	r1, #1008	; 0x3f0
    2fbe:	bls.n	2fe2 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x4a>
    numberOfHeads = 32;
  } else if (capacityMB <= 2016) {
    2fc0:	cmp.w	r1, #2016	; 0x7e0
    2fc4:	bls.n	2fe6 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x4e>
    numberOfHeads = 64;
  } else if (capacityMB <= 4032) {
    2fc6:	cmp.w	r1, #4032	; 0xfc0
    numberOfHeads = 128;
  } else {
    numberOfHeads = 255;
    2fca:	ite	ls
    2fcc:	movls	r3, #128	; 0x80
    2fce:	movhi	r3, #255	; 0xff
    2fd0:	b.n	2fe8 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x50>
  uint8_t s;

  uint8_t numberOfHeads;
  uint8_t sectorsPerTrack = capacityMB <= 256 ? 32 : 63;
  if (capacityMB <= 16) {
    numberOfHeads = 2;
    2fd2:	movs	r3, #2
    2fd4:	b.n	2fe8 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x50>
  } else if (capacityMB <= 32) {
    numberOfHeads = 4;
    2fd6:	movs	r3, #4
    2fd8:	b.n	2fe8 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x50>
  } else if (capacityMB <= 128) {
    numberOfHeads = 8;
    2fda:	movs	r3, #8
    2fdc:	b.n	2fe8 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x50>
  } else if (capacityMB <= 504) {
    numberOfHeads = 16;
    2fde:	movs	r3, #16
    2fe0:	b.n	2fe8 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x50>
  } else if (capacityMB <= 1008) {
    numberOfHeads = 32;
    2fe2:	movs	r3, #32
    2fe4:	b.n	2fe8 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x50>
  } else if (capacityMB <= 2016) {
    numberOfHeads = 64;
    2fe6:	movs	r3, #64	; 0x40
  } else if (capacityMB <= 4032) {
    numberOfHeads = 128;
  } else {
    numberOfHeads = 255;
  }
  c = lba / (numberOfHeads * sectorsPerTrack);
    2fe8:	smulbb	r3, r3, r4
    2fec:	udiv	r5, r2, r3
  if (c <= 1023) {
    2ff0:	cmp.w	r5, #1024	; 0x400
    2ff4:	bcs.n	300e <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x76>
    h = (lba % (numberOfHeads * sectorsPerTrack)) / sectorsPerTrack;
    s = (lba % sectorsPerTrack) + 1;
    2ff6:	udiv	r1, r2, r4
  } else {
    numberOfHeads = 255;
  }
  c = lba / (numberOfHeads * sectorsPerTrack);
  if (c <= 1023) {
    h = (lba % (numberOfHeads * sectorsPerTrack)) / sectorsPerTrack;
    2ffa:	mls	r3, r3, r5, r2
    s = (lba % sectorsPerTrack) + 1;
    2ffe:	mls	r2, r4, r1, r2
    3002:	adds	r2, #1
  } else {
    numberOfHeads = 255;
  }
  c = lba / (numberOfHeads * sectorsPerTrack);
  if (c <= 1023) {
    h = (lba % (numberOfHeads * sectorsPerTrack)) / sectorsPerTrack;
    3004:	udiv	r3, r3, r4
    s = (lba % sectorsPerTrack) + 1;
    3008:	uxtb	r2, r2
  } else {
    numberOfHeads = 255;
  }
  c = lba / (numberOfHeads * sectorsPerTrack);
  if (c <= 1023) {
    h = (lba % (numberOfHeads * sectorsPerTrack)) / sectorsPerTrack;
    300a:	uxtb	r3, r3
    300c:	b.n	3016 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x7e>
    s = (lba % sectorsPerTrack) + 1;
  } else {
    c = 1023;
    h = 254;
    s = 63;
    300e:	movs	r2, #63	; 0x3f
  if (c <= 1023) {
    h = (lba % (numberOfHeads * sectorsPerTrack)) / sectorsPerTrack;
    s = (lba % sectorsPerTrack) + 1;
  } else {
    c = 1023;
    h = 254;
    3010:	movs	r3, #254	; 0xfe
  c = lba / (numberOfHeads * sectorsPerTrack);
  if (c <= 1023) {
    h = (lba % (numberOfHeads * sectorsPerTrack)) / sectorsPerTrack;
    s = (lba % sectorsPerTrack) + 1;
  } else {
    c = 1023;
    3012:	movw	r5, #1023	; 0x3ff
    h = 254;
    s = 63;
  }
  chs[0] = h;
    3016:	strb	r3, [r0, #0]
  chs[1] = ((c >> 2) & 0XC0) | s;
    3018:	lsrs	r3, r5, #2
    301a:	bic.w	r3, r3, #63	; 0x3f
    301e:	orrs	r2, r3
    3020:	strb	r2, [r0, #1]
  chs[2] = c;
    3022:	strb	r5, [r0, #2]
    3024:	pop	{r4, r5, pc}

00003026 <FsCache::sync()>:

 fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FsCache::sync() {
    3026:	push	{r3, r4, r5, r6, r7, lr}
  if (m_status & CACHE_STATUS_DIRTY) {
    3028:	ldrb	r3, [r0, #0]
    302a:	lsls	r2, r3, #31

 fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FsCache::sync() {
    302c:	mov	r4, r0
  if (m_status & CACHE_STATUS_DIRTY) {
    302e:	bpl.n	306c <FsCache::sync()+0x46>
    if (!m_blockDev->writeSector(m_sector, m_buffer)) {
    3030:	ldr	r0, [r0, #4]
    3032:	ldr	r1, [r4, #12]
    3034:	ldr	r3, [r0, #0]
    3036:	add.w	r6, r4, #16
    303a:	ldr	r3, [r3, #32]
    303c:	mov	r2, r6
    303e:	blx	r3
    3040:	mov	r5, r0
    3042:	cbnz	r0, 3048 <FsCache::sync()+0x22>
    m_status &= ~CACHE_STATUS_DIRTY;
  }
  return true;

 fail:
  return false;
    3044:	movs	r5, #0
    3046:	b.n	306e <FsCache::sync()+0x48>
    if (!m_blockDev->writeSector(m_sector, m_buffer)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    // mirror second FAT
    if (m_status & CACHE_STATUS_MIRROR_FAT) {
    3048:	ldrb	r3, [r4, #0]
    304a:	lsls	r3, r3, #30
    304c:	bmi.n	3058 <FsCache::sync()+0x32>
      if (!m_blockDev->writeSector(sector, m_buffer)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_status &= ~CACHE_STATUS_DIRTY;
    304e:	ldrb	r3, [r4, #0]
    3050:	bic.w	r3, r3, #1
    3054:	strb	r3, [r4, #0]
    3056:	b.n	306e <FsCache::sync()+0x48>
      goto fail;
    }
    // mirror second FAT
    if (m_status & CACHE_STATUS_MIRROR_FAT) {
      uint32_t sector = m_sector + m_mirrorOffset;
      if (!m_blockDev->writeSector(sector, m_buffer)) {
    3058:	adds	r0, r4, #4
    305a:	ldmia	r0, {r0, r1, r7}
    305c:	ldr	r3, [r0, #0]
    305e:	mov	r2, r6
    3060:	ldr	r3, [r3, #32]
    3062:	add	r1, r7
    3064:	blx	r3
    3066:	cmp	r0, #0
    3068:	bne.n	304e <FsCache::sync()+0x28>
    306a:	b.n	3044 <FsCache::sync()+0x1e>
        goto fail;
      }
    }
    m_status &= ~CACHE_STATUS_DIRTY;
  }
  return true;
    306c:	movs	r5, #1

 fail:
  return false;
}
    306e:	mov	r0, r5
    3070:	pop	{r3, r4, r5, r6, r7, pc}

00003072 <FsCache::get(unsigned long, unsigned char)>:
#define DBG_FILE "FsCache.cpp"
#include "DebugMacros.h"
#include "FsCache.h"
//------------------------------------------------------------------------------
uint8_t* FsCache::get(uint32_t sector, uint8_t option) {
  if (!m_blockDev) {
    3072:	ldr	r3, [r0, #4]
 */
#define DBG_FILE "FsCache.cpp"
#include "DebugMacros.h"
#include "FsCache.h"
//------------------------------------------------------------------------------
uint8_t* FsCache::get(uint32_t sector, uint8_t option) {
    3074:	push	{r4, r5, r6, lr}
    3076:	mov	r4, r0
    3078:	mov	r6, r1
    307a:	mov	r5, r2
  if (!m_blockDev) {
    307c:	cbnz	r3, 3082 <FsCache::get(unsigned long, unsigned char)+0x10>
  }
  m_status |= option & CACHE_STATUS_MASK;
  return m_buffer;

 fail:
  return nullptr;
    307e:	movs	r0, #0
    3080:	pop	{r4, r5, r6, pc}
uint8_t* FsCache::get(uint32_t sector, uint8_t option) {
  if (!m_blockDev) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_sector != sector) {
    3082:	ldr	r3, [r0, #12]
    3084:	cmp	r3, r1
    3086:	beq.n	30b0 <FsCache::get(unsigned long, unsigned char)+0x3e>
    if (!sync()) {
    3088:	bl	3026 <FsCache::sync()>
    308c:	cmp	r0, #0
    308e:	beq.n	307e <FsCache::get(unsigned long, unsigned char)+0xc>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(option & CACHE_OPTION_NO_READ)) {
    3090:	lsls	r3, r5, #29
    3092:	bpl.n	309c <FsCache::get(unsigned long, unsigned char)+0x2a>
      if (!m_blockDev->readSector(sector, m_buffer)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_status = 0;
    3094:	movs	r3, #0
    3096:	strb	r3, [r4, #0]
    m_sector = sector;
    3098:	str	r6, [r4, #12]
    309a:	b.n	30b0 <FsCache::get(unsigned long, unsigned char)+0x3e>
    if (!sync()) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(option & CACHE_OPTION_NO_READ)) {
      if (!m_blockDev->readSector(sector, m_buffer)) {
    309c:	ldr	r0, [r4, #4]
    309e:	ldr	r3, [r0, #0]
    30a0:	add.w	r2, r4, #16
    30a4:	ldr	r3, [r3, #12]
    30a6:	mov	r1, r6
    30a8:	blx	r3
    30aa:	cmp	r0, #0
    30ac:	bne.n	3094 <FsCache::get(unsigned long, unsigned char)+0x22>
    30ae:	b.n	307e <FsCache::get(unsigned long, unsigned char)+0xc>
      }
    }
    m_status = 0;
    m_sector = sector;
  }
  m_status |= option & CACHE_STATUS_MASK;
    30b0:	ldrb	r3, [r4, #0]
    30b2:	mov	r0, r4
    30b4:	and.w	r5, r5, #3
    30b8:	orrs	r5, r3
    30ba:	strb.w	r5, [r0], #16
  return m_buffer;

 fail:
  return nullptr;
}
    30be:	pop	{r4, r5, r6, pc}

000030c0 <toUpcase(unsigned short)>:
}
//------------------------------------------------------------------------------
uint16_t toUpcase(uint16_t chr) {
  uint16_t i, first;
  // Optimize for simple ASCII.
  if (chr < 127) {
    30c0:	cmp	r0, #126	; 0x7e
    }
  }
  return left;
}
//------------------------------------------------------------------------------
uint16_t toUpcase(uint16_t chr) {
    30c2:	push	{r4, r5, lr}
  uint16_t i, first;
  // Optimize for simple ASCII.
  if (chr < 127) {
    30c4:	bhi.n	30d4 <toUpcase(unsigned short)+0x14>
    return chr - ('a' <= chr && chr <= 'z' ? 'a' - 'A' : 0);
    30c6:	sub.w	r3, r0, #97	; 0x61
    30ca:	cmp	r3, #25
    30cc:	ite	hi
    30ce:	movhi	r3, #0
    30d0:	movls	r3, #32
    30d2:	b.n	3116 <toUpcase(unsigned short)+0x56>
    30d4:	ldr	r5, [pc, #132]	; (315c <toUpcase(unsigned short)+0x9c>)
    30d6:	movs	r4, #53	; 0x35
    30d8:	movs	r3, #0
//------------------------------------------------------------------------------
static size_t searchPair16(const pair16_t* table, size_t size, uint16_t key) {
  size_t left = 0;
  size_t right = size;
  size_t mid;
  while (right - left > 1) {
    30da:	subs	r2, r4, r3
    30dc:	cmp	r2, #1
    30de:	ldr	r1, [pc, #124]	; (315c <toUpcase(unsigned short)+0x9c>)
    30e0:	bls.n	30f4 <toUpcase(unsigned short)+0x34>
    mid = left + (right - left)/2;
    30e2:	add.w	r2, r3, r2, lsr #1
    if (readTable16(table[mid].key) <= key) {
    30e6:	ldrh.w	r1, [r5, r2, lsl #2]
    30ea:	cmp	r1, r0
static size_t searchPair16(const pair16_t* table, size_t size, uint16_t key) {
  size_t left = 0;
  size_t right = size;
  size_t mid;
  while (right - left > 1) {
    mid = left + (right - left)/2;
    30ec:	ite	hi
    30ee:	movhi	r4, r2
    30f0:	movls	r3, r2
    30f2:	b.n	30da <toUpcase(unsigned short)+0x1a>
  // Optimize for simple ASCII.
  if (chr < 127) {
    return chr - ('a' <= chr && chr <= 'z' ? 'a' - 'A' : 0);
  }
  i = searchPair16(reinterpret_cast<const pair16_t*>(mapTable), MAP_DIM, chr);
  first = readTable16(mapTable[i].base);
    30f4:	uxth	r2, r3
    30f6:	ldrh.w	r3, [r1, r2, lsl #2]
  if (first <= chr && (chr - first)  < readTable8(mapTable[i].count)) {
    30fa:	cmp	r0, r3
    30fc:	bcc.n	312a <toUpcase(unsigned short)+0x6a>
    30fe:	add.w	r2, r1, r2, lsl #2
    3102:	subs	r3, r0, r3
    3104:	ldrb	r1, [r2, #3]
    3106:	cmp	r3, r1
    3108:	bge.n	312a <toUpcase(unsigned short)+0x6a>
    int8_t off = readTable8(mapTable[i].off);
    310a:	ldrsb.w	r2, [r2, #2]
    if (off == 1) {
    310e:	cmp	r2, #1
    3110:	bne.n	311a <toUpcase(unsigned short)+0x5a>
      return chr - ((chr - first) & 1);
    3112:	and.w	r3, r3, #1
    3116:	subs	r0, r0, r3
    3118:	b.n	3126 <toUpcase(unsigned short)+0x66>
    }
    return chr + (off ? off : -0x1C60);
    311a:	cbz	r2, 3120 <toUpcase(unsigned short)+0x60>
    311c:	uxth	r2, r2
    311e:	b.n	3124 <toUpcase(unsigned short)+0x64>
    3120:	movw	r2, #58272	; 0xe3a0
    3124:	add	r0, r2
    3126:	uxth	r0, r0
    3128:	pop	{r4, r5, pc}
    312a:	ldr	r5, [pc, #52]	; (3160 <toUpcase(unsigned short)+0xa0>)
    312c:	movs	r4, #75	; 0x4b
    312e:	movs	r3, #0
//------------------------------------------------------------------------------
static size_t searchPair16(const pair16_t* table, size_t size, uint16_t key) {
  size_t left = 0;
  size_t right = size;
  size_t mid;
  while (right - left > 1) {
    3130:	subs	r2, r4, r3
    3132:	cmp	r2, #1
    3134:	ldr	r1, [pc, #40]	; (3160 <toUpcase(unsigned short)+0xa0>)
    3136:	bls.n	314a <toUpcase(unsigned short)+0x8a>
    mid = left + (right - left)/2;
    3138:	add.w	r2, r3, r2, lsr #1
    if (readTable16(table[mid].key) <= key) {
    313c:	ldrh.w	r1, [r5, r2, lsl #2]
    3140:	cmp	r1, r0
static size_t searchPair16(const pair16_t* table, size_t size, uint16_t key) {
  size_t left = 0;
  size_t right = size;
  size_t mid;
  while (right - left > 1) {
    mid = left + (right - left)/2;
    3142:	ite	hi
    3144:	movhi	r4, r2
    3146:	movls	r3, r2
    3148:	b.n	3130 <toUpcase(unsigned short)+0x70>
      return chr - ((chr - first) & 1);
    }
    return chr + (off ? off : -0x1C60);
  }
  i = searchPair16(lookupTable, LOOKUP_DIM, chr);
  if (readTable16(lookupTable[i].key) == chr) {
    314a:	uxth	r3, r3
    314c:	ldrh.w	r2, [r1, r3, lsl #2]
    3150:	cmp	r2, r0
    return readTable16(lookupTable[i].val);
    3152:	itt	eq
    3154:	addeq.w	r3, r1, r3, lsl #2
    3158:	ldrheq	r0, [r3, #2]
  }
  return chr;
}
    315a:	pop	{r4, r5, pc}
    315c:	.word	0x000123d6
    3160:	.word	0x000122aa

00003164 <FsName::get16()>:
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsName.h"
#include "FsUtf.h"
#if USE_UTF8_LONG_NAMES
uint16_t FsName::get16() {
    3164:	push	{r0, r1, r4, lr}
    3166:	mov	r4, r0
  uint16_t rtn;
  if (ls) {
    3168:	ldrh	r0, [r0, #12]
    316a:	cbz	r0, 3172 <FsName::get16()+0xe>
    rtn = ls;
    ls = 0;
    316c:	movs	r3, #0
    316e:	strh	r3, [r4, #12]
    3170:	b.n	31a8 <FsName::get16()+0x44>
  } else if (next >= end) {
    3172:	ldr	r3, [r4, #4]
    3174:	ldr	r1, [r4, #8]
    3176:	cmp	r3, r1
    3178:	bcs.n	31a8 <FsName::get16()+0x44>
    rtn = 0;
  } else {
    uint32_t cp;
    const char* ptr = FsUtf::mbToCp(next, end, &cp);
    317a:	add	r2, sp, #4
    317c:	mov	r0, r3
    317e:	bl	2d64 <FsUtf::mbToCp(char const*, char const*, unsigned long*)>
    if (!ptr) {
    3182:	cbz	r0, 31a4 <FsName::get16()+0x40>
      goto fail;
    }
    next = ptr;
    3184:	str	r0, [r4, #4]
    if (cp <= 0XFFFF) {
    3186:	ldr	r0, [sp, #4]
    3188:	cmp.w	r0, #65536	; 0x10000
      rtn = cp;
    } else {
      ls = FsUtf::lowSurrogate(cp);
    318c:	itttt	cs
    318e:	ubfxcs	r3, r0, #0, #10
  /** High surrogate for a code point.
   * \param{in} cp code point.
   * \return high surrogate.
   */
  inline uint16_t highSurrogate(uint32_t cp) {
    return (cp >> 10) + (0XD800 - (0X10000 >> 10));
    3192:	lsrcs	r0, r0, #10
    3194:	subcs.w	r3, r3, #9216	; 0x2400
    3198:	subcs.w	r0, r0, #10304	; 0x2840
    319c:	it	cs
    319e:	strhcs	r3, [r4, #12]
    31a0:	uxth	r0, r0
    31a2:	b.n	31a8 <FsName::get16()+0x44>
    }
  }
  return rtn;

 fail:
  return 0XFFFF;
    31a4:	movw	r0, #65535	; 0xffff
}
    31a8:	add	sp, #8
    31aa:	pop	{r4, pc}

000031ac <ExFatFormatter::syncUpcase()>:
  writeMsg(pr, "Format failed\r\n");
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFormatter::syncUpcase() {
  uint16_t index = m_upcaseSize & SECTOR_MASK;
    31ac:	ldr	r3, [r0, #8]
    31ae:	ubfx	r3, r3, #0, #9
 fail:
  writeMsg(pr, "Format failed\r\n");
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFormatter::syncUpcase() {
    31b2:	mov	r1, r0
  uint16_t index = m_upcaseSize & SECTOR_MASK;
  if (!index) {
    31b4:	cbz	r3, 31d0 <ExFatFormatter::syncUpcase()+0x24>
    return true;
  }
  for (size_t i = index; i < BYTES_PER_SECTOR; i++) {
    m_secBuf[i] = 0;
    31b6:	movs	r0, #0
    31b8:	ldr	r2, [r1, #16]
    31ba:	strb	r0, [r2, r3]
bool ExFatFormatter::syncUpcase() {
  uint16_t index = m_upcaseSize & SECTOR_MASK;
  if (!index) {
    return true;
  }
  for (size_t i = index; i < BYTES_PER_SECTOR; i++) {
    31bc:	adds	r3, #1
    31be:	cmp.w	r3, #512	; 0x200
    31c2:	bne.n	31b8 <ExFatFormatter::syncUpcase()+0xc>
    m_secBuf[i] = 0;
  }
  return m_dev->writeSector(m_upcaseSector, m_secBuf);
    31c4:	ldr	r0, [r1, #12]
    31c6:	ldr	r2, [r1, #16]
    31c8:	ldr	r3, [r0, #0]
    31ca:	ldr	r1, [r1, #0]
    31cc:	ldr	r3, [r3, #32]
    31ce:	bx	r3
}
    31d0:	movs	r0, #1
    31d2:	bx	lr

000031d4 <ExFatFormatter::writeUpcaseByte(unsigned char)>:
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseByte(uint8_t b) {
  uint16_t index = m_upcaseSize & SECTOR_MASK;
    31d4:	ldr	r2, [r0, #8]
    m_secBuf[i] = 0;
  }
  return m_dev->writeSector(m_upcaseSector, m_secBuf);
}
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseByte(uint8_t b) {
    31d6:	mov	r3, r0
  uint16_t index = m_upcaseSize & SECTOR_MASK;
    31d8:	ubfx	r2, r2, #0, #9
  m_secBuf[index] = b;
    31dc:	ldr	r0, [r0, #16]
    m_secBuf[i] = 0;
  }
  return m_dev->writeSector(m_upcaseSector, m_secBuf);
}
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseByte(uint8_t b) {
    31de:	push	{r4}
  uint16_t index = m_upcaseSize & SECTOR_MASK;
  m_secBuf[index] = b;
    31e0:	strb	r1, [r0, r2]
  m_upcaseChecksum = exFatChecksum(m_upcaseChecksum, b);
    31e2:	ldr	r0, [r3, #4]
    31e4:	add.w	r1, r1, r0, ror #1
    31e8:	str	r1, [r3, #4]
  m_upcaseSize++;
    31ea:	ldr	r1, [r3, #8]
    31ec:	adds	r1, #1
    31ee:	str	r1, [r3, #8]
  if (index == SECTOR_MASK) {
    31f0:	movw	r1, #511	; 0x1ff
    31f4:	cmp	r2, r1
    31f6:	bne.n	320e <ExFatFormatter::writeUpcaseByte(unsigned char)+0x3a>
    return m_dev->writeSector(m_upcaseSector++, m_secBuf);
    31f8:	ldr	r0, [r3, #12]
    31fa:	ldr	r1, [r3, #0]
    31fc:	ldr	r2, [r0, #0]
    31fe:	ldr	r4, [r2, #32]
    3200:	adds	r2, r1, #1
    3202:	str	r2, [r3, #0]
    3204:	ldr	r2, [r3, #16]
    3206:	mov	r3, r4
  }
  return true;
}
    3208:	ldr.w	r4, [sp], #4
  uint16_t index = m_upcaseSize & SECTOR_MASK;
  m_secBuf[index] = b;
  m_upcaseChecksum = exFatChecksum(m_upcaseChecksum, b);
  m_upcaseSize++;
  if (index == SECTOR_MASK) {
    return m_dev->writeSector(m_upcaseSector++, m_secBuf);
    320c:	bx	r3
  }
  return true;
}
    320e:	movs	r0, #1
    3210:	ldr.w	r4, [sp], #4
    3214:	bx	lr

00003216 <ExFatFormatter::writeUpcaseUnicode(unsigned short)>:
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseUnicode(uint16_t unicode) {
    3216:	push	{r3, r4, r5, lr}
    3218:	mov	r4, r1
  return writeUpcaseByte(unicode) && writeUpcaseByte(unicode >> 8);
    321a:	uxtb	r1, r1
    return m_dev->writeSector(m_upcaseSector++, m_secBuf);
  }
  return true;
}
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseUnicode(uint16_t unicode) {
    321c:	mov	r5, r0
  return writeUpcaseByte(unicode) && writeUpcaseByte(unicode >> 8);
    321e:	bl	31d4 <ExFatFormatter::writeUpcaseByte(unsigned char)>
    3222:	cbz	r0, 3230 <ExFatFormatter::writeUpcaseUnicode(unsigned short)+0x1a>
    3224:	lsrs	r1, r4, #8
    3226:	mov	r0, r5
}
    3228:	ldmia.w	sp!, {r3, r4, r5, lr}
  }
  return true;
}
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseUnicode(uint16_t unicode) {
  return writeUpcaseByte(unicode) && writeUpcaseByte(unicode >> 8);
    322c:	b.w	31d4 <ExFatFormatter::writeUpcaseByte(unsigned char)>
}
    3230:	pop	{r3, r4, r5, pc}

00003232 <ExFatFormatter::writeUpcase(unsigned long)>:
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcase(uint32_t sector) {
    3232:	push	{r3, r4, r5, r6, r7, lr}
  uint32_t n;
  uint32_t ns;
  uint32_t ch = 0;
  uint16_t uc;

  m_upcaseSize = 0;
    3234:	movs	r4, #0
  m_upcaseChecksum = 0;
  m_upcaseSector = sector;
    3236:	stmia.w	r0, {r1, r4}
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseUnicode(uint16_t unicode) {
  return writeUpcaseByte(unicode) && writeUpcaseByte(unicode >> 8);
}
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcase(uint32_t sector) {
    323a:	mov	r7, r0
  uint32_t n;
  uint32_t ns;
  uint32_t ch = 0;
  uint16_t uc;

  m_upcaseSize = 0;
    323c:	str	r4, [r0, #8]
  m_upcaseChecksum = 0;
  m_upcaseSector = sector;

  while (ch < 0X10000) {
    uc = toUpcase(ch);
    323e:	uxth	r0, r4
    3240:	bl	30c0 <toUpcase(unsigned short)>
    if (uc != ch) {
    3244:	cmp	r0, r4
  m_upcaseSize = 0;
  m_upcaseChecksum = 0;
  m_upcaseSector = sector;

  while (ch < 0X10000) {
    uc = toUpcase(ch);
    3246:	mov	r6, r0
    if (uc != ch) {
    3248:	beq.n	3260 <ExFatFormatter::writeUpcase(unsigned long)+0x2e>
      if (!writeUpcaseUnicode(uc)) {
    324a:	mov	r1, r0
    324c:	mov	r0, r7
    324e:	bl	3216 <ExFatFormatter::writeUpcaseUnicode(unsigned short)>
    3252:	cbz	r0, 32be <ExFatFormatter::writeUpcase(unsigned long)+0x8c>
        DBG_FAIL_MACRO;
        goto fail;
      }
      ch++;
    3254:	adds	r5, r4, #1

  m_upcaseSize = 0;
  m_upcaseChecksum = 0;
  m_upcaseSector = sector;

  while (ch < 0X10000) {
    3256:	cmp.w	r5, #65536	; 0x10000
    325a:	bcs.n	3274 <ExFatFormatter::writeUpcase(unsigned long)+0x42>
    325c:	mov	r4, r5
    325e:	b.n	323e <ExFatFormatter::writeUpcase(unsigned long)+0xc>
        DBG_FAIL_MACRO;
        goto fail;
      }
      ch++;
    } else {
      for (n = ch + 1; n < 0X10000 && n == toUpcase(n); n++) {}
    3260:	adds	r5, r4, #1
    3262:	cmp.w	r5, #65536	; 0x10000
    3266:	bcs.n	327e <ExFatFormatter::writeUpcase(unsigned long)+0x4c>
    3268:	uxth	r0, r5
    326a:	bl	30c0 <toUpcase(unsigned short)>
    326e:	cmp	r5, r0
    3270:	bne.n	327e <ExFatFormatter::writeUpcase(unsigned long)+0x4c>
    3272:	b.n	32ba <ExFatFormatter::writeUpcase(unsigned long)+0x88>
          }
        }
      }
    }
  }
  if (!syncUpcase()) {
    3274:	mov	r0, r7
  }
  return true;

 fail:
  return false;
}
    3276:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
          }
        }
      }
    }
  }
  if (!syncUpcase()) {
    327a:	b.w	31ac <ExFatFormatter::syncUpcase()>
        goto fail;
      }
      ch++;
    } else {
      for (n = ch + 1; n < 0X10000 && n == toUpcase(n); n++) {}
      ns = n - ch;
    327e:	subs	r4, r5, r4
      if (ns >= MINIMUM_UPCASE_SKIP) {
    3280:	cmp.w	r4, #512	; 0x200
    3284:	bcc.n	32a0 <ExFatFormatter::writeUpcase(unsigned long)+0x6e>
        if (!writeUpcaseUnicode(0XFFFF) || !writeUpcaseUnicode(ns)) {
    3286:	movw	r1, #65535	; 0xffff
    328a:	mov	r0, r7
    328c:	bl	3216 <ExFatFormatter::writeUpcaseUnicode(unsigned short)>
    3290:	cbz	r0, 32be <ExFatFormatter::writeUpcase(unsigned long)+0x8c>
    3292:	uxth	r1, r4
    3294:	mov	r0, r7
    3296:	bl	3216 <ExFatFormatter::writeUpcaseUnicode(unsigned short)>
    329a:	cmp	r0, #0
    329c:	bne.n	3256 <ExFatFormatter::writeUpcase(unsigned long)+0x24>
    329e:	b.n	32be <ExFatFormatter::writeUpcase(unsigned long)+0x8c>
      }
      ch++;
    } else {
      for (n = ch + 1; n < 0X10000 && n == toUpcase(n); n++) {}
      ns = n - ch;
      if (ns >= MINIMUM_UPCASE_SKIP) {
    32a0:	mov	r4, r6
          DBG_FAIL_MACRO;
          goto fail;
        }
        ch = n;
      } else {
        while (ch < n) {
    32a2:	cmp	r5, r4
    32a4:	bhi.n	32aa <ExFatFormatter::writeUpcase(unsigned long)+0x78>
    32a6:	mov	r5, r4
    32a8:	b.n	3256 <ExFatFormatter::writeUpcase(unsigned long)+0x24>
          if (!writeUpcaseUnicode(ch++)) {
    32aa:	uxth	r1, r4
    32ac:	mov	r0, r7
    32ae:	bl	3216 <ExFatFormatter::writeUpcaseUnicode(unsigned short)>
    32b2:	adds	r4, #1
    32b4:	cmp	r0, #0
    32b6:	bne.n	32a2 <ExFatFormatter::writeUpcase(unsigned long)+0x70>
    32b8:	b.n	32be <ExFatFormatter::writeUpcase(unsigned long)+0x8c>
        DBG_FAIL_MACRO;
        goto fail;
      }
      ch++;
    } else {
      for (n = ch + 1; n < 0X10000 && n == toUpcase(n); n++) {}
    32ba:	adds	r5, #1
    32bc:	b.n	3262 <ExFatFormatter::writeUpcase(unsigned long)+0x30>
  }
  return true;

 fail:
  return false;
}
    32be:	movs	r0, #0
    32c0:	pop	{r3, r4, r5, r6, r7, pc}
    32c2:	Address 0x000032c2 is out of bounds.


000032c4 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)>:
#define writeMsg(pr, str) if (pr) pr->print(F(str))
#else  // PRINT_FORMAT_PROGRESS
#define writeMsg(pr, str) if (pr) pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool ExFatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
    32c4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    32c8:	mov	r7, r3
  uint32_t volumeLength;
  uint32_t sectorCount;
  uint8_t sectorsPerClusterShift;
  uint8_t vs;

  m_dev = dev;
    32ca:	mov	r3, r0
#define writeMsg(pr, str) if (pr) pr->print(F(str))
#else  // PRINT_FORMAT_PROGRESS
#define writeMsg(pr, str) if (pr) pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool ExFatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
    32cc:	sub	sp, #28
  uint32_t volumeLength;
  uint32_t sectorCount;
  uint8_t sectorsPerClusterShift;
  uint8_t vs;

  m_dev = dev;
    32ce:	str	r1, [r3, #12]
  m_secBuf = secBuf;
    32d0:	str	r2, [r3, #16]
  sectorCount = dev->sectorCount();
    32d2:	ldr	r3, [r1, #0]
#define writeMsg(pr, str) if (pr) pr->print(F(str))
#else  // PRINT_FORMAT_PROGRESS
#define writeMsg(pr, str) if (pr) pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool ExFatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
    32d4:	str	r0, [sp, #4]
  uint8_t sectorsPerClusterShift;
  uint8_t vs;

  m_dev = dev;
  m_secBuf = secBuf;
  sectorCount = dev->sectorCount();
    32d6:	ldr	r3, [r3, #24]
    32d8:	mov	r0, r1
#define writeMsg(pr, str) if (pr) pr->print(F(str))
#else  // PRINT_FORMAT_PROGRESS
#define writeMsg(pr, str) if (pr) pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool ExFatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
    32da:	mov	r5, r1
    32dc:	mov	r4, r2
  uint8_t sectorsPerClusterShift;
  uint8_t vs;

  m_dev = dev;
  m_secBuf = secBuf;
  sectorCount = dev->sectorCount();
    32de:	blx	r3
  // Min size is 512 MB
  if (sectorCount < 0X100000) {
    32e0:	cmp.w	r0, #1048576	; 0x100000
  uint8_t sectorsPerClusterShift;
  uint8_t vs;

  m_dev = dev;
  m_secBuf = secBuf;
  sectorCount = dev->sectorCount();
    32e4:	mov	r9, r0
  // Min size is 512 MB
  if (sectorCount < 0X100000) {
    32e6:	bcs.n	32f8 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x34>
    writeMsg(pr, "Device is too small\r\n");
    32e8:	cmp	r7, #0
    32ea:	beq.w	3512 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x24e>
    32ee:	ldr	r1, [pc, #584]	; (3538 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x274>)
    32f0:	mov	r0, r7
    32f2:	bl	a40 <Print::write(char const*)>
    32f6:	b.n	350a <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x246>
    32f8:	movs	r6, #0
    32fa:	movs	r3, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Determine partition layout.
  for (m = 1, vs = 0; m && sectorCount > m; m <<= 1, vs++) {}
    32fc:	adds	r6, #1
    32fe:	uxtb	r6, r6
    3300:	cmp	r6, #32
    3302:	mov.w	r3, r3, lsl #1
    3306:	beq.n	3314 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x50>
    3308:	cmp	r9, r3
    330a:	bhi.n	32fc <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x38>
  sectorsPerClusterShift = vs < 29 ? 8 : (vs - 11)/2;
    330c:	cmp	r6, #28
    330e:	bhi.n	3314 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x50>
    3310:	movs	r3, #8
    3312:	b.n	331c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x58>
    3314:	sub.w	r8, r6, #11
    3318:	ubfx	r3, r8, #1, #8
  sectorsPerCluster = 1UL << sectorsPerClusterShift;
  fatLength = 1UL << (vs < 27 ? 13 : (vs + 1)/2);
    331c:	cmp	r6, #26
    331e:	it	hi
    3320:	addhi	r6, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Determine partition layout.
  for (m = 1, vs = 0; m && sectorCount > m; m <<= 1, vs++) {}
  sectorsPerClusterShift = vs < 29 ? 8 : (vs - 11)/2;
    3322:	str	r3, [sp, #8]
  sectorsPerCluster = 1UL << sectorsPerClusterShift;
  fatLength = 1UL << (vs < 27 ? 13 : (vs + 1)/2);
    3324:	ittte	hi
    3326:	asrhi	r6, r6, #1
    3328:	movhi	r3, #1
    332a:	lslhi	r3, r6
    332c:	movls.w	r3, #8192	; 0x2000
    3330:	str	r3, [sp, #0]
  fatOffset = fatLength;
  partitionOffset = 2*fatLength;
    3332:	ldr	r3, [sp, #0]
  clusterHeapOffset = 2*fatLength;
  clusterCount = (sectorCount - 4*fatLength) >> sectorsPerClusterShift;
  volumeLength = clusterHeapOffset + (clusterCount << sectorsPerClusterShift);
    3334:	ldr	r2, [sp, #8]
  for (m = 1, vs = 0; m && sectorCount > m; m <<= 1, vs++) {}
  sectorsPerClusterShift = vs < 29 ? 8 : (vs - 11)/2;
  sectorsPerCluster = 1UL << sectorsPerClusterShift;
  fatLength = 1UL << (vs < 27 ? 13 : (vs + 1)/2);
  fatOffset = fatLength;
  partitionOffset = 2*fatLength;
    3336:	lsls	r6, r3, #1
  clusterHeapOffset = 2*fatLength;
  clusterCount = (sectorCount - 4*fatLength) >> sectorsPerClusterShift;
    3338:	lsls	r3, r3, #2
    333a:	rsb	sl, r3, r9
    333e:	str	r3, [sp, #16]
    3340:	ldr	r3, [sp, #8]
    3342:	lsr.w	r3, sl, r3
  volumeLength = clusterHeapOffset + (clusterCount << sectorsPerClusterShift);
    3346:	lsl.w	sl, r3, r2

  // make Master Boot Record.  Use fake CHS.
  memset(secBuf, 0, BYTES_PER_SECTOR);
    334a:	movs	r1, #0
    334c:	mov.w	r2, #512	; 0x200
    3350:	mov	r0, r4
  sectorsPerCluster = 1UL << sectorsPerClusterShift;
  fatLength = 1UL << (vs < 27 ? 13 : (vs + 1)/2);
  fatOffset = fatLength;
  partitionOffset = 2*fatLength;
  clusterHeapOffset = 2*fatLength;
  clusterCount = (sectorCount - 4*fatLength) >> sectorsPerClusterShift;
    3352:	str	r3, [sp, #12]
  volumeLength = clusterHeapOffset + (clusterCount << sectorsPerClusterShift);

  // make Master Boot Record.  Use fake CHS.
  memset(secBuf, 0, BYTES_PER_SECTOR);
    3354:	bl	88c8 <memset>
  mbr = reinterpret_cast<MbrSector_t*>(secBuf);
  mbr->part->beginCHS[0] = 1;
  mbr->part->beginCHS[1] = 1;
  mbr->part->beginCHS[2] = 0;
  mbr->part->type = 7;
    3358:	movs	r3, #7
    335a:	strb.w	r3, [r4, #450]	; 0x1c2
  mbr->part->endCHS[0] = 0XFE;
    335e:	movs	r3, #254	; 0xfe
    3360:	strb.w	r3, [r4, #451]	; 0x1c3
  volumeLength = clusterHeapOffset + (clusterCount << sectorsPerClusterShift);

  // make Master Boot Record.  Use fake CHS.
  memset(secBuf, 0, BYTES_PER_SECTOR);
  mbr = reinterpret_cast<MbrSector_t*>(secBuf);
  mbr->part->beginCHS[0] = 1;
    3364:	mov.w	fp, #1
  mbr->part->beginCHS[1] = 1;
  mbr->part->beginCHS[2] = 0;
  mbr->part->type = 7;
  mbr->part->endCHS[0] = 0XFE;
  mbr->part->endCHS[1] = 0XFF;
    3368:	movs	r3, #255	; 0xff
  // make Master Boot Record.  Use fake CHS.
  memset(secBuf, 0, BYTES_PER_SECTOR);
  mbr = reinterpret_cast<MbrSector_t*>(secBuf);
  mbr->part->beginCHS[0] = 1;
  mbr->part->beginCHS[1] = 1;
  mbr->part->beginCHS[2] = 0;
    336a:	mov.w	r8, #0
  mbr->part->type = 7;
  mbr->part->endCHS[0] = 0XFE;
  mbr->part->endCHS[1] = 0XFF;
    336e:	strb.w	r3, [r4, #452]	; 0x1c4
  mbr->part->endCHS[2] = 0XFF;
    3372:	strb.w	r3, [r4, #453]	; 0x1c5
  volumeLength = clusterHeapOffset + (clusterCount << sectorsPerClusterShift);

  // make Master Boot Record.  Use fake CHS.
  memset(secBuf, 0, BYTES_PER_SECTOR);
  mbr = reinterpret_cast<MbrSector_t*>(secBuf);
  mbr->part->beginCHS[0] = 1;
    3376:	strb.w	fp, [r4, #447]	; 0x1bf
  mbr->part->beginCHS[1] = 1;
    337a:	strb.w	fp, [r4, #448]	; 0x1c0
  mbr->part->beginCHS[2] = 0;
    337e:	strb.w	r8, [r4, #449]	; 0x1c1
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    3382:	movw	r3, #43605	; 0xaa55
    3386:	strh.w	r3, [r4, #510]	; 0x1fe
  mbr->part->endCHS[1] = 0XFF;
  mbr->part->endCHS[2] = 0XFF;
  setLe32(mbr->part->relativeSectors, partitionOffset);
  setLe32(mbr->part->totalSectors, volumeLength);
  setLe16(mbr->signature, MBR_SIGNATURE);
  if (!dev->writeSector(0, secBuf)) {
    338a:	ldr	r3, [r5, #0]
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    338c:	str.w	r6, [r4, #454]	; 0x1c6
  fatLength = 1UL << (vs < 27 ? 13 : (vs + 1)/2);
  fatOffset = fatLength;
  partitionOffset = 2*fatLength;
  clusterHeapOffset = 2*fatLength;
  clusterCount = (sectorCount - 4*fatLength) >> sectorsPerClusterShift;
  volumeLength = clusterHeapOffset + (clusterCount << sectorsPerClusterShift);
    3390:	add	sl, r6
    3392:	str.w	sl, [r4, #458]	; 0x1ca
  mbr->part->endCHS[1] = 0XFF;
  mbr->part->endCHS[2] = 0XFF;
  setLe32(mbr->part->relativeSectors, partitionOffset);
  setLe32(mbr->part->totalSectors, volumeLength);
  setLe16(mbr->signature, MBR_SIGNATURE);
  if (!dev->writeSector(0, secBuf)) {
    3396:	ldr	r3, [r3, #32]
    3398:	mov	r2, r4
    339a:	mov	r1, r8
    339c:	mov	r0, r5
    339e:	blx	r3
    33a0:	cmp	r0, #0
    33a2:	beq.w	3508 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Partition Boot sector.
  memset(secBuf, 0, BYTES_PER_SECTOR);
    33a6:	mov.w	r2, #512	; 0x200
    33aa:	mov	r1, r8
    33ac:	mov	r0, r4
    33ae:	bl	88c8 <memset>
  pbs = reinterpret_cast<ExFatPbs_t*>(secBuf);
  pbs->jmpInstruction[0] = 0XEB;
    33b2:	movs	r3, #235	; 0xeb
    33b4:	strb	r3, [r4, #0]
  pbs->jmpInstruction[1] = 0X76;
    33b6:	movs	r3, #118	; 0x76
    33b8:	strb	r3, [r4, #1]
  pbs->jmpInstruction[2] = 0X90;
    33ba:	movs	r3, #144	; 0x90
    33bc:	strb	r3, [r4, #2]
  pbs->oemName[0] = 'E';
    33be:	movs	r3, #69	; 0x45
    33c0:	strb	r3, [r4, #3]
  pbs->oemName[1] = 'X';
    33c2:	movs	r3, #88	; 0x58
    33c4:	strb	r3, [r4, #4]
  pbs->oemName[2] = 'F';
    33c6:	movs	r3, #70	; 0x46
    33c8:	strb	r3, [r4, #5]
  pbs->oemName[3] = 'A';
    33ca:	movs	r3, #65	; 0x41
    33cc:	strb	r3, [r4, #6]
  pbs->oemName[4] = 'T';
    33ce:	movs	r3, #84	; 0x54
    33d0:	strb	r3, [r4, #7]
  pbs->oemName[5] = ' ';
    33d2:	movs	r3, #32
    33d4:	strb	r3, [r4, #8]
  pbs->oemName[6] = ' ';
    33d6:	strb	r3, [r4, #9]
  pbs->oemName[7] = ' ';
    33d8:	strb	r3, [r4, #10]
    33da:	ldr	r3, [sp, #0]
    33dc:	str	r3, [r4, #80]	; 0x50
    33de:	str	r3, [r4, #84]	; 0x54
    33e0:	ldr	r3, [sp, #12]
    33e2:	str	r3, [r4, #92]	; 0x5c
    33e4:	movs	r3, #4
    33e6:	str	r3, [r4, #96]	; 0x60
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    33e8:	mov.w	r3, #256	; 0x100
    33ec:	strh.w	r3, [r4, #104]	; 0x68
  setLe32(pbs->bpb.clusterCount, clusterCount);
  setLe32(pbs->bpb.rootDirectoryCluster, ROOT_CLUSTER);
  setLe32(pbs->bpb.volumeSerialNumber, sectorCount);
  setLe16(pbs->bpb.fileSystemRevision, 0X100);
  setLe16(pbs->bpb.volumeFlags, 0);
  pbs->bpb.bytesPerSectorShift = BYTES_PER_SECTOR_SHIFT;
    33f0:	movs	r3, #9
    33f2:	strb.w	r3, [r4, #108]	; 0x6c
  pbs->bpb.sectorsPerClusterShift = sectorsPerClusterShift;
    33f6:	ldrb.w	r3, [sp, #8]
    33fa:	strb.w	r3, [r4, #109]	; 0x6d
  pbs->bpb.numberOfFats = 1;
  pbs->bpb.driveSelect = 0X80;
    33fe:	movs	r3, #128	; 0x80
    3400:	strb.w	r3, [r4, #111]	; 0x6f

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    3404:	str	r6, [r4, #64]	; 0x40
    3406:	str.w	r8, [r4, #68]	; 0x44
    340a:	str.w	sl, [r4, #72]	; 0x48
    340e:	str.w	r8, [r4, #76]	; 0x4c
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    3412:	str	r6, [r4, #88]	; 0x58
    3414:	str.w	r9, [r4, #100]	; 0x64
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    3418:	strh.w	r8, [r4, #106]	; 0x6a
  setLe32(pbs->bpb.volumeSerialNumber, sectorCount);
  setLe16(pbs->bpb.fileSystemRevision, 0X100);
  setLe16(pbs->bpb.volumeFlags, 0);
  pbs->bpb.bytesPerSectorShift = BYTES_PER_SECTOR_SHIFT;
  pbs->bpb.sectorsPerClusterShift = sectorsPerClusterShift;
  pbs->bpb.numberOfFats = 1;
    341c:	strb.w	fp, [r4, #110]	; 0x6e
  pbs->bpb.driveSelect = 0X80;
  pbs->bpb.percentInUse = 0;
    3420:	strb.w	r8, [r4, #112]	; 0x70
    3424:	add.w	r3, r4, #119	; 0x77
    3428:	addw	r2, r4, #509	; 0x1fd

  // Fill boot code like official SDFormatter.
  for (size_t i = 0; i < sizeof(pbs->bootCode); i++) {
    pbs->bootCode[i] = 0XF4;
    342c:	movs	r1, #244	; 0xf4
    342e:	strb.w	r1, [r3, #1]!
  pbs->bpb.numberOfFats = 1;
  pbs->bpb.driveSelect = 0X80;
  pbs->bpb.percentInUse = 0;

  // Fill boot code like official SDFormatter.
  for (size_t i = 0; i < sizeof(pbs->bootCode); i++) {
    3432:	cmp	r3, r2
    3434:	bne.n	342e <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x16a>
    3436:	movw	r3, #43605	; 0xaa55
    pbs->bootCode[i] = 0XF4;
  }
  setLe16(pbs->signature, PBR_SIGNATURE);
  for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
    343a:	mov.w	r9, #0
    343e:	strh.w	r3, [r4, #510]	; 0x1fe
  ExFatPbs_t* pbs;
  DirUpcase_t* dup;
  DirBitmap_t* dbm;
  DirLabel_t* label;
  uint32_t bitmapSize;
  uint32_t checksum = 0;
    3442:	mov	r8, r9
  for (size_t i = 0; i < sizeof(pbs->bootCode); i++) {
    pbs->bootCode[i] = 0XF4;
  }
  setLe16(pbs->signature, PBR_SIGNATURE);
  for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
    if (i == offsetof(ExFatPbs_t, bpb.volumeFlags[0]) ||
    3444:	sub.w	r3, r9, #106	; 0x6a
    3448:	cmp	r3, #1
    344a:	bls.n	345a <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x196>
        i == offsetof(ExFatPbs_t, bpb.volumeFlags[1]) ||
    344c:	cmp.w	r9, #112	; 0x70
  uint8_t  mustBeZero2[2];
  uint8_t  unicode3[4];
} DirLfn_t;
//=============================================================================
inline uint32_t exFatChecksum(uint32_t sum, uint8_t data) {
  return (sum << 31) + (sum >> 1) + data;
    3450:	itt	ne
    3452:	ldrbne.w	r3, [r4, r9]
    3456:	addne.w	r8, r3, r8, ror #1
  // Fill boot code like official SDFormatter.
  for (size_t i = 0; i < sizeof(pbs->bootCode); i++) {
    pbs->bootCode[i] = 0XF4;
  }
  setLe16(pbs->signature, PBR_SIGNATURE);
  for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
    345a:	add.w	r9, r9, #1
    345e:	cmp.w	r9, #512	; 0x200
    3462:	bne.n	3444 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x180>
      continue;
    }
    checksum = exFatChecksum(checksum, secBuf[i]);
  }
  sector = partitionOffset;
  if (!dev->writeSector(sector, secBuf)  ||
    3464:	ldr	r3, [r5, #0]
    3466:	mov	r2, r4
    3468:	ldr	r3, [r3, #32]
    346a:	mov	r1, r6
    346c:	mov	r0, r5
    346e:	blx	r3
    3470:	cmp	r0, #0
    3472:	beq.n	3508 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
      !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
    3474:	ldr	r3, [r5, #0]
    3476:	mov	r2, r4
    3478:	ldr	r3, [r3, #32]
    347a:	add.w	r1, r6, #12
    347e:	mov	r0, r5
    3480:	blx	r3
      continue;
    }
    checksum = exFatChecksum(checksum, secBuf[i]);
  }
  sector = partitionOffset;
  if (!dev->writeSector(sector, secBuf)  ||
    3482:	cmp	r0, #0
    3484:	beq.n	3508 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
    DBG_FAIL_MACRO;
    goto fail;
  }
  sector++;
  // Write eight Extended Boot Sectors.
  memset(secBuf, 0, BYTES_PER_SECTOR);
    3486:	mov	r2, r9
    3488:	movs	r1, #0
    348a:	mov	r0, r4
    348c:	bl	88c8 <memset>
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    3490:	movw	r3, #43605	; 0xaa55
    3494:	strh.w	r3, [r4, #510]	; 0x1fe
    3498:	subs	r3, r4, #1
  if (!dev->writeSector(sector, secBuf)  ||
      !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  sector++;
    349a:	add.w	sl, r6, #1
    349e:	add.w	r9, r6, #9
    34a2:	str	r3, [sp, #20]
    34a4:	addw	fp, r4, #511	; 0x1ff
  ExFatPbs_t* pbs;
  DirUpcase_t* dup;
  DirBitmap_t* dbm;
  DirLabel_t* label;
  uint32_t bitmapSize;
  uint32_t checksum = 0;
    34a8:	ldr	r3, [sp, #20]
  uint8_t  mustBeZero2[2];
  uint8_t  unicode3[4];
} DirLfn_t;
//=============================================================================
inline uint32_t exFatChecksum(uint32_t sum, uint8_t data) {
  return (sum << 31) + (sum >> 1) + data;
    34aa:	ldrb.w	r2, [r3, #1]!
  sector++;
  // Write eight Extended Boot Sectors.
  memset(secBuf, 0, BYTES_PER_SECTOR);
  setLe16(pbs->signature, PBR_SIGNATURE);
  for (int j = 0; j < 8; j++) {
    for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
    34ae:	cmp	fp, r3
    34b0:	add.w	r8, r2, r8, ror #1
    34b4:	bne.n	34aa <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x1e6>
      checksum = exFatChecksum(checksum, secBuf[i]);
    }
    if (!dev->writeSector(sector, secBuf)  ||
    34b6:	ldr	r3, [r5, #0]
    34b8:	mov	r2, r4
    34ba:	ldr	r3, [r3, #32]
    34bc:	mov	r1, sl
    34be:	mov	r0, r5
    34c0:	blx	r3
    34c2:	cbz	r0, 3508 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
        !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
    34c4:	ldr	r3, [r5, #0]
    34c6:	mov	r2, r4
    34c8:	ldr	r3, [r3, #32]
    34ca:	add.w	r1, sl, #12
    34ce:	mov	r0, r5
    34d0:	blx	r3
  setLe16(pbs->signature, PBR_SIGNATURE);
  for (int j = 0; j < 8; j++) {
    for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
      checksum = exFatChecksum(checksum, secBuf[i]);
    }
    if (!dev->writeSector(sector, secBuf)  ||
    34d2:	cbz	r0, 3508 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
        !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    sector++;
    34d4:	add.w	sl, sl, #1
  }
  sector++;
  // Write eight Extended Boot Sectors.
  memset(secBuf, 0, BYTES_PER_SECTOR);
  setLe16(pbs->signature, PBR_SIGNATURE);
  for (int j = 0; j < 8; j++) {
    34d8:	cmp	sl, r9
    34da:	bne.n	34a8 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x1e4>
      goto fail;
    }
    sector++;
  }
  // Write OEM Parameter Sector and reserved sector.
  memset(secBuf, 0, BYTES_PER_SECTOR);
    34dc:	mov.w	r2, #512	; 0x200
    34e0:	movs	r1, #0
    34e2:	mov	r0, r4
    34e4:	bl	88c8 <memset>
    34e8:	add.w	sl, r6, #11
    34ec:	ldr	r3, [sp, #20]
    34ee:	ldrb.w	r2, [r3, #1]!
  for (int j = 0; j < 2; j++) {
    for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
    34f2:	cmp	fp, r3
    34f4:	add.w	r8, r2, r8, ror #1
    34f8:	bne.n	34ee <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x22a>
      checksum = exFatChecksum(checksum, secBuf[i]);
    }
    if (!dev->writeSector(sector, secBuf)  ||
    34fa:	ldr	r3, [r5, #0]
    34fc:	mov	r2, r4
    34fe:	ldr	r3, [r3, #32]
    3500:	mov	r1, r9
    3502:	mov	r0, r5
    3504:	blx	r3
    3506:	cbnz	r0, 3518 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x254>
  }
  writeMsg(pr, "Format done\r\n");
  return true;

 fail:
  writeMsg(pr, "Format failed\r\n");
    3508:	cbz	r7, 3512 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x24e>
    350a:	ldr	r1, [pc, #48]	; (353c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x278>)
    350c:	mov	r0, r7
    350e:	bl	a40 <Print::write(char const*)>
  return false;
    3512:	mov.w	sl, #0
    3516:	b.n	36fc <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x438>
  for (int j = 0; j < 2; j++) {
    for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
      checksum = exFatChecksum(checksum, secBuf[i]);
    }
    if (!dev->writeSector(sector, secBuf)  ||
        !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
    3518:	ldr	r3, [r5, #0]
    351a:	mov	r2, r4
    351c:	ldr	r3, [r3, #32]
    351e:	add.w	r1, r9, #12
    3522:	mov	r0, r5
    3524:	blx	r3
  memset(secBuf, 0, BYTES_PER_SECTOR);
  for (int j = 0; j < 2; j++) {
    for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
      checksum = exFatChecksum(checksum, secBuf[i]);
    }
    if (!dev->writeSector(sector, secBuf)  ||
    3526:	cmp	r0, #0
    3528:	beq.n	3508 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
        !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    sector++;
    352a:	add.w	r3, r9, #1
    }
    sector++;
  }
  // Write OEM Parameter Sector and reserved sector.
  memset(secBuf, 0, BYTES_PER_SECTOR);
  for (int j = 0; j < 2; j++) {
    352e:	cmp	r3, sl
    3530:	beq.n	3540 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x27c>
    3532:	mov	r9, r3
    3534:	b.n	34ec <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x228>
    3536:	nop
    3538:	.word	0x000124aa
    353c:	.word	0x00012503
    3540:	subs	r3, r4, #4
    3542:	add.w	r2, r4, #508	; 0x1fc
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    3546:	str.w	r8, [r3, #4]!
      goto fail;
    }
    sector++;
  }
  // Write Boot CheckSum Sector.
  for (size_t i = 0; i < BYTES_PER_SECTOR; i += 4) {
    354a:	cmp	r2, r3
    354c:	bne.n	3546 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x282>
    setLe32(secBuf + i, checksum);
  }
  if (!dev->writeSector(sector, secBuf)  ||
    354e:	ldr	r3, [r5, #0]
    3550:	mov	r2, r4
    3552:	ldr	r3, [r3, #32]
    3554:	mov	r1, sl
    3556:	mov	r0, r5
    3558:	blx	r3
    355a:	cmp	r0, #0
    355c:	beq.n	3508 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
      !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
    355e:	ldr	r3, [r5, #0]
    3560:	mov	r2, r4
    3562:	ldr	r3, [r3, #32]
    3564:	add.w	r1, r9, #13
    3568:	mov	r0, r5
    356a:	blx	r3
  }
  // Write Boot CheckSum Sector.
  for (size_t i = 0; i < BYTES_PER_SECTOR; i += 4) {
    setLe32(secBuf + i, checksum);
  }
  if (!dev->writeSector(sector, secBuf)  ||
    356c:	cmp	r0, #0
    356e:	beq.n	3508 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
      !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Initialize FAT.
  writeMsg(pr, "Writing FAT ");
    3570:	cbz	r7, 357a <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x2b6>
    3572:	ldr	r1, [pc, #400]	; (3704 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x440>)
    3574:	mov	r0, r7
    3576:	bl	a40 <Print::write(char const*)>
  sector = partitionOffset + fatOffset;
    357a:	ldr	r3, [sp, #0]
    357c:	add	r6, r3
  ns = ((clusterCount + 2)*4 + BYTES_PER_SECTOR - 1)/BYTES_PER_SECTOR;
    357e:	ldr	r3, [sp, #12]

  memset(secBuf, 0, BYTES_PER_SECTOR);
    3580:	mov.w	r2, #512	; 0x200
    goto fail;
  }
  // Initialize FAT.
  writeMsg(pr, "Writing FAT ");
  sector = partitionOffset + fatOffset;
  ns = ((clusterCount + 2)*4 + BYTES_PER_SECTOR - 1)/BYTES_PER_SECTOR;
    3584:	mov.w	r9, r3, lsl #2

  memset(secBuf, 0, BYTES_PER_SECTOR);
    3588:	movs	r1, #0
    358a:	mov	r0, r4
    358c:	bl	88c8 <memset>
    goto fail;
  }
  // Initialize FAT.
  writeMsg(pr, "Writing FAT ");
  sector = partitionOffset + fatOffset;
  ns = ((clusterCount + 2)*4 + BYTES_PER_SECTOR - 1)/BYTES_PER_SECTOR;
    3590:	addw	r9, r9, #519	; 0x207

  memset(secBuf, 0, BYTES_PER_SECTOR);
  // Allocate two reserved clusters, bitmap, upcase, and root clusters.
  secBuf[0] = 0XF8;
    3594:	movs	r3, #248	; 0xf8
    3596:	strb	r3, [r4, #0]
    goto fail;
  }
  // Initialize FAT.
  writeMsg(pr, "Writing FAT ");
  sector = partitionOffset + fatOffset;
  ns = ((clusterCount + 2)*4 + BYTES_PER_SECTOR - 1)/BYTES_PER_SECTOR;
    3598:	mov.w	sl, r9, lsr #9
    359c:	mov	r3, r4
    359e:	add.w	r2, r4, #19

  memset(secBuf, 0, BYTES_PER_SECTOR);
  // Allocate two reserved clusters, bitmap, upcase, and root clusters.
  secBuf[0] = 0XF8;
  for (size_t i = 1; i < 20; i++) {
    secBuf[i] = 0XFF;
    35a2:	movs	r1, #255	; 0xff
    35a4:	strb.w	r1, [r3, #1]!
  ns = ((clusterCount + 2)*4 + BYTES_PER_SECTOR - 1)/BYTES_PER_SECTOR;

  memset(secBuf, 0, BYTES_PER_SECTOR);
  // Allocate two reserved clusters, bitmap, upcase, and root clusters.
  secBuf[0] = 0XF8;
  for (size_t i = 1; i < 20; i++) {
    35a8:	cmp	r2, r3
    35aa:	bne.n	35a4 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x2e0>
    secBuf[i] = 0XFF;
  }
  for (uint32_t i = 0; i < ns; i++) {
    if (i%(ns/32) == 0) {
    35ac:	mov.w	r9, r9, lsr #14
    35b0:	mov.w	r8, #0
    35b4:	udiv	r3, r8, r9
    35b8:	mls	r3, r9, r3, r8
    35bc:	cbnz	r3, 35c8 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x304>
      writeMsg(pr, ".");
    35be:	cbz	r7, 35c8 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x304>
    35c0:	ldr	r1, [pc, #324]	; (3708 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x444>)
    35c2:	mov	r0, r7
    35c4:	bl	a40 <Print::write(char const*)>
    }
    if (!dev->writeSector(sector + i, secBuf)) {
    35c8:	ldr	r3, [r5, #0]
    35ca:	mov	r2, r4
    35cc:	ldr	r3, [r3, #32]
    35ce:	add.w	r1, r6, r8
    35d2:	mov	r0, r5
    35d4:	blx	r3
    35d6:	cmp	r0, #0
    35d8:	beq.n	3508 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (i == 0) {
    35da:	cmp.w	r8, #0
    35de:	bne.n	35ec <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x328>
      memset(secBuf, 0, BYTES_PER_SECTOR);
    35e0:	mov.w	r2, #512	; 0x200
    35e4:	mov	r1, r8
    35e6:	mov	r0, r4
    35e8:	bl	88c8 <memset>
  // Allocate two reserved clusters, bitmap, upcase, and root clusters.
  secBuf[0] = 0XF8;
  for (size_t i = 1; i < 20; i++) {
    secBuf[i] = 0XFF;
  }
  for (uint32_t i = 0; i < ns; i++) {
    35ec:	add.w	r8, r8, #1
    35f0:	cmp	sl, r8
    35f2:	bne.n	35b4 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x2f0>
    }
    if (i == 0) {
      memset(secBuf, 0, BYTES_PER_SECTOR);
    }
  }
  writeMsg(pr, "\r\n");
    35f4:	cbz	r7, 35fe <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x33a>
    35f6:	ldr	r1, [pc, #276]	; (370c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x448>)
    35f8:	mov	r0, r7
    35fa:	bl	a40 <Print::write(char const*)>
    goto fail;
  }
  // Determine partition layout.
  for (m = 1, vs = 0; m && sectorCount > m; m <<= 1, vs++) {}
  sectorsPerClusterShift = vs < 29 ? 8 : (vs - 11)/2;
  sectorsPerCluster = 1UL << sectorsPerClusterShift;
    35fe:	ldr	r3, [sp, #8]
    3600:	mov.w	r8, #1
    3604:	lsl.w	r8, r8, r3
    }
  }
  writeMsg(pr, "\r\n");
  // Write cluster two, bitmap.
  sector = partitionOffset + clusterHeapOffset;
  bitmapSize = (clusterCount + 7)/8;
    3608:	ldr	r3, [sp, #12]
    360a:	add.w	sl, r3, #7
    360e:	mov.w	sl, sl, lsr #3
  ns = (bitmapSize + BYTES_PER_SECTOR - 1)/BYTES_PER_SECTOR;
    3612:	addw	fp, sl, #511	; 0x1ff
    3616:	mov.w	fp, fp, lsr #9
  if (ns > sectorsPerCluster) {
    361a:	cmp	r8, fp
    361c:	bcc.w	3508 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(secBuf, 0, BYTES_PER_SECTOR);
    3620:	mov.w	r2, #512	; 0x200
    3624:	movs	r1, #0
    3626:	mov	r0, r4
    3628:	bl	88c8 <memset>
  // Allocate clusters for bitmap, upcase, and root.
  secBuf[0] = 0X7;
    362c:	movs	r3, #7
    362e:	strb	r3, [r4, #0]
  for (uint32_t i = 0; i < ns; i++) {
    3630:	mov.w	r9, #0
    if (!dev->writeSector(sector + i, secBuf)) {
    3634:	ldr	r3, [r5, #0]
    3636:	ldr	r1, [sp, #16]
    3638:	ldr	r3, [r3, #32]
    363a:	mov	r2, r4
    363c:	add	r1, r9
    363e:	mov	r0, r5
    3640:	blx	r3
    3642:	cmp	r0, #0
    3644:	beq.w	3508 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (i == 0) {
    3648:	cmp.w	r9, #0
    364c:	bne.n	3652 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x38e>
      secBuf[0] = 0;
    364e:	strb.w	r9, [r4]
    goto fail;
  }
  memset(secBuf, 0, BYTES_PER_SECTOR);
  // Allocate clusters for bitmap, upcase, and root.
  secBuf[0] = 0X7;
  for (uint32_t i = 0; i < ns; i++) {
    3652:	add.w	r9, r9, #1
    3656:	cmp	fp, r9
    3658:	bne.n	3634 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x370>
    if (i == 0) {
      secBuf[0] = 0;
    }
  }
  // Write cluster three, upcase table.
  writeMsg(pr, "Writing upcase table\r\n");
    365a:	cbz	r7, 3664 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x3a0>
    365c:	ldr	r1, [pc, #176]	; (3710 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x44c>)
    365e:	mov	r0, r7
    3660:	bl	a40 <Print::write(char const*)>
  if (!writeUpcase(partitionOffset + clusterHeapOffset + sectorsPerCluster)) {
    3664:	ldr	r3, [sp, #0]
    3666:	ldr	r0, [sp, #4]
    3668:	add	r3, r6
    366a:	add.w	r9, r3, r8
    366e:	mov	r1, r9
    3670:	bl	3232 <ExFatFormatter::writeUpcase(unsigned long)>
    3674:	cmp	r0, #0
    3676:	beq.w	3508 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_upcaseSize > BYTES_PER_SECTOR*sectorsPerCluster) {
    367a:	ldr	r3, [sp, #4]
    367c:	ldr	r3, [r3, #8]
    367e:	cmp.w	r3, r8, lsl #9
    3682:	bhi.w	3508 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Initialize first sector of root.
  writeMsg(pr, "Writing root\r\n");
    3686:	cbz	r7, 3690 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x3cc>
    3688:	ldr	r1, [pc, #136]	; (3714 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x450>)
    368a:	mov	r0, r7
    368c:	bl	a40 <Print::write(char const*)>
  ns = sectorsPerCluster;
  sector = partitionOffset + clusterHeapOffset + 2*sectorsPerCluster;
  memset(secBuf, 0, BYTES_PER_SECTOR);
    3690:	mov.w	r2, #512	; 0x200
    3694:	movs	r1, #0
    3696:	mov	r0, r4
    3698:	bl	88c8 <memset>
  label = reinterpret_cast<DirLabel_t*>(secBuf);
  label->type = EXFAT_TYPE_LABEL & 0X7F;

  // bitmap directory entry.
  dbm = reinterpret_cast<DirBitmap_t*>(secBuf + 32);
  dbm->type = EXFAT_TYPE_BITMAP;
    369c:	movs	r2, #129	; 0x81
    369e:	strb.w	r2, [r4, #32]
    36a2:	movs	r2, #2
    36a4:	str	r2, [r4, #52]	; 0x34
  setLe32(dbm->firstCluster, BITMAP_CLUSTER);
  setLe64(dbm->size, bitmapSize);

  // upcase directory entry.
  dup = reinterpret_cast<DirUpcase_t*>(secBuf +64);
  dup->type = EXFAT_TYPE_UPCASE;
    36a6:	movs	r2, #130	; 0x82
  sector = partitionOffset + clusterHeapOffset + 2*sectorsPerCluster;
  memset(secBuf, 0, BYTES_PER_SECTOR);

  // Unused Label entry.
  label = reinterpret_cast<DirLabel_t*>(secBuf);
  label->type = EXFAT_TYPE_LABEL & 0X7F;
    36a8:	movs	r3, #3
  setLe32(dbm->firstCluster, BITMAP_CLUSTER);
  setLe64(dbm->size, bitmapSize);

  // upcase directory entry.
  dup = reinterpret_cast<DirUpcase_t*>(secBuf +64);
  dup->type = EXFAT_TYPE_UPCASE;
    36aa:	strb.w	r2, [r4, #64]	; 0x40
  setLe32(dup->checksum, m_upcaseChecksum);
    36ae:	ldr	r2, [sp, #4]
  sector = partitionOffset + clusterHeapOffset + 2*sectorsPerCluster;
  memset(secBuf, 0, BYTES_PER_SECTOR);

  // Unused Label entry.
  label = reinterpret_cast<DirLabel_t*>(secBuf);
  label->type = EXFAT_TYPE_LABEL & 0X7F;
    36b0:	strb	r3, [r4, #0]
  setLe64(dbm->size, bitmapSize);

  // upcase directory entry.
  dup = reinterpret_cast<DirUpcase_t*>(secBuf +64);
  dup->type = EXFAT_TYPE_UPCASE;
  setLe32(dup->checksum, m_upcaseChecksum);
    36b2:	ldr	r2, [r2, #4]
    36b4:	str	r3, [r4, #84]	; 0x54
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    36b6:	ldr	r3, [sp, #4]
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    36b8:	str	r2, [r4, #68]	; 0x44
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    36ba:	ldr	r3, [r3, #8]
    36bc:	str.w	sl, [r4, #56]	; 0x38
    36c0:	movs	r6, #0
    goto fail;
  }
  // Initialize first sector of root.
  writeMsg(pr, "Writing root\r\n");
  ns = sectorsPerCluster;
  sector = partitionOffset + clusterHeapOffset + 2*sectorsPerCluster;
    36c2:	add	r9, r8
    36c4:	str	r3, [r4, #88]	; 0x58
    36c6:	str	r6, [r4, #92]	; 0x5c
  setLe32(dup->firstCluster, UPCASE_CLUSTER);
  setLe64(dup->size, m_upcaseSize);

  // Write root, cluster four.
  for (uint32_t i = 0; i < ns; i++) {
    if (!dev->writeSector(sector + i, secBuf)) {
    36c8:	ldr	r3, [r5, #0]
    36ca:	mov	r2, r4
    36cc:	ldr	r3, [r3, #32]
    36ce:	add.w	r1, r6, r9
    36d2:	mov	r0, r5
    36d4:	blx	r3
    36d6:	mov	sl, r0
    36d8:	cmp	r0, #0
    36da:	beq.w	3508 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (i == 0) {
    36de:	cbnz	r6, 36ec <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x428>
      memset(secBuf, 0, BYTES_PER_SECTOR);
    36e0:	mov.w	r2, #512	; 0x200
    36e4:	mov	r1, r6
    36e6:	mov	r0, r4
    36e8:	bl	88c8 <memset>
  setLe32(dup->checksum, m_upcaseChecksum);
  setLe32(dup->firstCluster, UPCASE_CLUSTER);
  setLe64(dup->size, m_upcaseSize);

  // Write root, cluster four.
  for (uint32_t i = 0; i < ns; i++) {
    36ec:	adds	r6, #1
    36ee:	cmp	r8, r6
    36f0:	bne.n	36c8 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x404>
    }
    if (i == 0) {
      memset(secBuf, 0, BYTES_PER_SECTOR);
    }
  }
  writeMsg(pr, "Format done\r\n");
    36f2:	cbz	r7, 36fc <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x438>
    36f4:	ldr	r1, [pc, #32]	; (3718 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x454>)
    36f6:	mov	r0, r7
    36f8:	bl	a40 <Print::write(char const*)>
  return true;

 fail:
  writeMsg(pr, "Format failed\r\n");
  return false;
}
    36fc:	mov	r0, sl
    36fe:	add	sp, #28
    3700:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    3704:	.word	0x000124c0
    3708:	.word	0x000124cd
    370c:	.word	0x0001253f
    3710:	.word	0x000124cf
    3714:	.word	0x000124e6
    3718:	.word	0x000124f5

0000371c <ExFatFile::cmpName(DirName_t const*, ExName_t*)>:
  hash = ((hash << 15) | (hash >> 1)) + (c & 0XFF);
  hash = ((hash << 15) | (hash >> 1)) + (c >> 8);
  return hash;
}
//------------------------------------------------------------------------------
bool ExFatFile::cmpName(const DirName_t* dirName, ExName_t* fname) {
    371c:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3720:	mov	r5, r2
    3722:	mov	r6, r1
    3724:	add.w	r8, r1, #30
  /** \return next UTF-16 unit of LFN. */
  uint16_t get16() {return atEnd() ? 0 : *next++;}
#else  // !USE_UTF8_LONG_NAMES
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
    3728:	ldrh	r3, [r5, #12]
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    372a:	ldrh.w	r4, [r6, #2]!
    372e:	cbnz	r3, 3742 <ExFatFile::cmpName(DirName_t const*, ExName_t*)+0x26>
    3730:	ldr	r2, [r5, #4]
    3732:	ldr	r3, [r5, #8]
    3734:	cmp	r2, r3
    3736:	bne.n	3742 <ExFatFile::cmpName(DirName_t const*, ExName_t*)+0x26>
  for (uint8_t i = 0; i < 15; i++) {
    uint16_t u = getLe16(dirName->unicode + 2*i);
    if (fname->atEnd()) {
      return u == 0;
    3738:	clz	r0, r4
    373c:	lsrs	r0, r0, #5
    373e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
#if USE_UTF8_LONG_NAMES
    uint16_t cp = fname->get16();
    3742:	mov	r0, r5
    3744:	bl	3164 <FsName::get16()>
    if (toUpcase(cp) != toUpcase(u)) {
    3748:	bl	30c0 <toUpcase(unsigned short)>
    374c:	mov	r7, r0
    374e:	mov	r0, r4
    3750:	bl	30c0 <toUpcase(unsigned short)>
    3754:	cmp	r7, r0
    3756:	bne.n	3762 <ExFatFile::cmpName(DirName_t const*, ExName_t*)+0x46>
  hash = ((hash << 15) | (hash >> 1)) + (c >> 8);
  return hash;
}
//------------------------------------------------------------------------------
bool ExFatFile::cmpName(const DirName_t* dirName, ExName_t* fname) {
  for (uint8_t i = 0; i < 15; i++) {
    3758:	cmp	r6, r8
    375a:	bne.n	3728 <ExFatFile::cmpName(DirName_t const*, ExName_t*)+0xc>
    if (u >= 0x7F || toUpper(c) != toUpper(u)) {
      return false;
    }
#endif  // USE_UTF8_LONG_NAMES
  }
  return true;
    375c:	movs	r0, #1
    375e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      return u == 0;
    }
#if USE_UTF8_LONG_NAMES
    uint16_t cp = fname->get16();
    if (toUpcase(cp) != toUpcase(u)) {
       return false;
    3762:	movs	r0, #0
    3764:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00003768 <ExFatFile::getName8(char*, unsigned int)>:
 fail:
  *name = 0;
  return 0;
}
//------------------------------------------------------------------------------
size_t ExFatFile::getName8(char* name, size_t count) {
    3768:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  char* str = name;
  char* ptr;
  DirName_t* dn;
  uint16_t hs = 0;
  uint32_t cp;
  if (!isOpen()) {
    376c:	ldrb.w	r3, [r0, #49]	; 0x31
 fail:
  *name = 0;
  return 0;
}
//------------------------------------------------------------------------------
size_t ExFatFile::getName8(char* name, size_t count) {
    3770:	mov	sl, r0
    3772:	mov	r9, r1
  char* str = name;
  char* ptr;
  DirName_t* dn;
  uint16_t hs = 0;
  uint32_t cp;
  if (!isOpen()) {
    3774:	cmp	r3, #0
    3776:	beq.n	3808 <ExFatFile::getName8(char*, unsigned int)+0xa0>
      } else {
        DBG_FAIL_MACRO;
        goto fail;
      }
      // Save space for zero byte.
      ptr = FsUtf::cpToMb(cp, str, end - 1);
    3778:	add.w	r8, r2, #4294967295
    377c:	mov	r5, r1
    377e:	movs	r7, #2
    3780:	movs	r4, #0
    3782:	add	r8, r1
  uint32_t cp;
  if (!isOpen()) {
      DBG_FAIL_MACRO;
      goto fail;
  }
  for (uint8_t is = 2; is <= m_setCount; is++) {
    3784:	ldrb.w	r3, [sl, #48]	; 0x30
    3788:	cmp	r3, r7
    378a:	bcc.n	37fc <ExFatFile::getName8(char*, unsigned int)+0x94>
    dn = reinterpret_cast<DirName_t*>
         (dirCache(is, FsCache::CACHE_FOR_READ));
    378c:	movs	r2, #0
    378e:	mov	r1, r7
    3790:	mov	r0, sl
    3792:	bl	387a <ExFatFile::dirCache(unsigned char, unsigned char)>
    if (!dn || dn->type != EXFAT_TYPE_NAME) {
    3796:	cbz	r0, 3808 <ExFatFile::getName8(char*, unsigned int)+0xa0>
    3798:	ldrb	r3, [r0, #0]
    379a:	cmp	r3, #193	; 0xc1
    379c:	bne.n	3808 <ExFatFile::getName8(char*, unsigned int)+0xa0>
    379e:	mov	r6, r0
    37a0:	add.w	fp, r0, #30
    37a4:	mov	r3, r4
    37a6:	ldrh.w	r4, [r6, #2]!
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (uint8_t in = 0; in < 15; in++) {
      uint16_t c = getLe16(dn->unicode + 2*in);
      if (hs) {
    37aa:	cbz	r3, 37ca <ExFatFile::getName8(char*, unsigned int)+0x62>
        if (!FsUtf::isLowSurrogate(c)) {
    37ac:	add.w	r2, r4, #9216	; 0x2400
    37b0:	uxth	r2, r2
    37b2:	cmp.w	r2, #1024	; 0x400
    37b6:	bcs.n	3808 <ExFatFile::getName8(char*, unsigned int)+0xa0>
   * \param[in] hs high surrogate.
   * \param[in] ls low surrogate.
   * \return code point.
   */
  inline uint32_t u16ToCp(uint16_t hs, uint16_t ls) {
    return 0X10000 + (((hs & 0X3FF) << 10) | (ls & 0X3FF));
    37b8:	ldr	r0, [pc, #88]	; (3814 <ExFatFile::getName8(char*, unsigned int)+0xac>)
    37ba:	lsls	r3, r3, #10
    37bc:	ands	r0, r3
    37be:	ubfx	r4, r4, #0, #10
    37c2:	orrs	r4, r0
    37c4:	add.w	r0, r4, #65536	; 0x10000
    37c8:	b.n	37e4 <ExFatFile::getName8(char*, unsigned int)+0x7c>
  /** Check for UTF-16 surrogate.
   * \param[in] c UTF-16 unit.
   * \return true if c is a surrogate else false.
   */
  inline bool isSurrogate(uint16_t c) {
    return 0XD800 <= c && c <= 0XDFFF;
    37ca:	add.w	r3, r4, #10240	; 0x2800
    37ce:	uxth	r3, r3
          DBG_FAIL_MACRO;
          goto fail;
        }
        cp = FsUtf::u16ToCp(hs, c);
        hs = 0;
      } else if (!FsUtf::isSurrogate(c)) {
    37d0:	cmp.w	r3, #2048	; 0x800
    37d4:	bcc.n	37dc <ExFatFile::getName8(char*, unsigned int)+0x74>
        if (c == 0) {
    37d6:	cbz	r4, 37fc <ExFatFile::getName8(char*, unsigned int)+0x94>
          goto done;
        }
        cp = c;
    37d8:	mov	r0, r4
    37da:	b.n	37e4 <ExFatFile::getName8(char*, unsigned int)+0x7c>
      } else if (FsUtf::isHighSurrogate(c)) {
    37dc:	cmp.w	r3, #1024	; 0x400
    37e0:	bcc.n	37f2 <ExFatFile::getName8(char*, unsigned int)+0x8a>
    37e2:	b.n	3808 <ExFatFile::getName8(char*, unsigned int)+0xa0>
      } else {
        DBG_FAIL_MACRO;
        goto fail;
      }
      // Save space for zero byte.
      ptr = FsUtf::cpToMb(cp, str, end - 1);
    37e4:	mov	r2, r8
    37e6:	mov	r1, r5
    37e8:	bl	2cd0 <FsUtf::cpToMb(unsigned long, char*, char*)>
      if (!ptr) {
    37ec:	cbz	r0, 37fc <ExFatFile::getName8(char*, unsigned int)+0x94>
    37ee:	mov	r5, r0
    37f0:	movs	r4, #0
         (dirCache(is, FsCache::CACHE_FOR_READ));
    if (!dn || dn->type != EXFAT_TYPE_NAME) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (uint8_t in = 0; in < 15; in++) {
    37f2:	cmp	fp, r6
    37f4:	bne.n	37a4 <ExFatFile::getName8(char*, unsigned int)+0x3c>
  uint32_t cp;
  if (!isOpen()) {
      DBG_FAIL_MACRO;
      goto fail;
  }
  for (uint8_t is = 2; is <= m_setCount; is++) {
    37f6:	adds	r7, #1
    37f8:	uxtb	r7, r7
    37fa:	b.n	3784 <ExFatFile::getName8(char*, unsigned int)+0x1c>
      }
      str = ptr;
    }
  }
 done:
  *str = '\0';
    37fc:	movs	r3, #0
    37fe:	strb	r3, [r5, #0]
  return str - name;
    3800:	rsb	r0, r9, r5
    3804:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

 fail:
  *name = 0;
    3808:	movs	r0, #0
    380a:	strb.w	r0, [r9]
  return 0;
}
    380e:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    3812:	nop
    3814:	.word	0x000ffc00

00003818 <ExFatFile::hashName(ExName_t*)>:
//------------------------------------------------------------------------------
bool ExFatFile::hashName(ExName_t* fname) {
    3818:	push	{r4, r5, r6, lr}
  }
  void reset() {
    next = begin;
    381a:	ldr	r3, [r1, #0]
    381c:	str	r3, [r1, #4]
    ls = 0;
    381e:	movs	r4, #0
    3820:	mov	r5, r1
    3822:	strh	r4, [r1, #12]
  uint16_t hash = 0;
  fname->reset();
#if USE_UTF8_LONG_NAMES
  fname->nameLength = 0;
    3824:	str	r4, [r1, #16]
  while (!fname->atEnd()) {
    uint16_t u = fname->get16();
    if (u == 0XFFFF) {
    3826:	movw	r6, #65535	; 0xffff
  /** \return next UTF-16 unit of LFN. */
  uint16_t get16() {return atEnd() ? 0 : *next++;}
#else  // !USE_UTF8_LONG_NAMES
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
    382a:	ldrh	r3, [r5, #12]
    382c:	cbnz	r3, 3836 <ExFatFile::hashName(ExName_t*)+0x1e>
    382e:	ldr	r2, [r5, #4]
    3830:	ldr	r3, [r5, #8]
    3832:	cmp	r2, r3
    3834:	beq.n	386a <ExFatFile::hashName(ExName_t*)+0x52>
  uint16_t hash = 0;
  fname->reset();
#if USE_UTF8_LONG_NAMES
  fname->nameLength = 0;
  while (!fname->atEnd()) {
    uint16_t u = fname->get16();
    3836:	mov	r0, r5
    3838:	bl	3164 <FsName::get16()>
    if (u == 0XFFFF) {
    383c:	cmp	r0, r6
    383e:	beq.n	3866 <ExFatFile::hashName(ExName_t*)+0x4e>
  hash = ((hash << 15) | (hash >> 1));
  return hash;
}
//------------------------------------------------------------------------------
inline uint16_t exFatHash(uint16_t u, uint16_t hash) {
  uint16_t c = toUpcase(u);
    3840:	bl	30c0 <toUpcase(unsigned short)>
    3844:	lsls	r3, r4, #15
    3846:	orr.w	r4, r3, r4, lsr #1
    384a:	uxtab	r4, r4, r0
    384e:	ubfx	r3, r4, #1, #15
    3852:	orr.w	r3, r3, r4, lsl #15
  hash = ((hash << 15) | (hash >> 1)) + (c & 0XFF);
  hash = ((hash << 15) | (hash >> 1)) + (c >> 8);
    3856:	asrs	r4, r0, #8
    3858:	uxtah	r4, r4, r3
    if (u == 0XFFFF) {
    DBG_FAIL_MACRO;
      goto fail;
    }
    hash = exFatHash(u, hash);
    fname->nameLength++;
    385c:	ldr	r3, [r5, #16]
    385e:	adds	r3, #1
}
//------------------------------------------------------------------------------
inline uint16_t exFatHash(uint16_t u, uint16_t hash) {
  uint16_t c = toUpcase(u);
  hash = ((hash << 15) | (hash >> 1)) + (c & 0XFF);
  hash = ((hash << 15) | (hash >> 1)) + (c >> 8);
    3860:	uxth	r4, r4
    if (u == 0XFFFF) {
    DBG_FAIL_MACRO;
      goto fail;
    }
    hash = exFatHash(u, hash);
    fname->nameLength++;
    3862:	str	r3, [r5, #16]
bool ExFatFile::hashName(ExName_t* fname) {
  uint16_t hash = 0;
  fname->reset();
#if USE_UTF8_LONG_NAMES
  fname->nameLength = 0;
  while (!fname->atEnd()) {
    3864:	b.n	382a <ExFatFile::hashName(ExName_t*)+0x12>
    goto fail;
  }
  return true;

 fail:
  return false;
    3866:	movs	r0, #0
    3868:	pop	{r4, r5, r6, pc}
    hash = exFatHash(c, hash);
  }
  fname->nameLength = fname->end - fname->begin;
#endif  // USE_UTF8_LONG_NAMES
  fname->nameHash = hash;
  if (!fname->nameLength || fname->nameLength > EXFAT_MAX_NAME_LENGTH) {
    386a:	ldr	r0, [r5, #16]
    char c = fname->getch();
    hash = exFatHash(c, hash);
  }
  fname->nameLength = fname->end - fname->begin;
#endif  // USE_UTF8_LONG_NAMES
  fname->nameHash = hash;
    386c:	strh	r4, [r5, #20]
  if (!fname->nameLength || fname->nameLength > EXFAT_MAX_NAME_LENGTH) {
    386e:	subs	r0, #1
    3870:	cmp	r0, #254	; 0xfe
    3872:	ite	hi
    3874:	movhi	r0, #0
    3876:	movls	r0, #1
  }
  return true;

 fail:
  return false;
}
    3878:	pop	{r4, r5, r6, pc}

0000387a <ExFatFile::dirCache(unsigned char, unsigned char)>:
#else  // USE_UTF8_LONG_NAMES
  return !(lfnReservedChar(c) || c & 0X80);
#endif  // USE_UTF8_LONG_NAMES
}
//------------------------------------------------------------------------------
uint8_t* ExFatFile::dirCache(uint8_t set, uint8_t options) {
    387a:	push	{r4, r5, r6, r7, lr}
  DirPos_t pos = m_dirPos;
    387c:	add.w	r3, r0, #36	; 0x24
#else  // USE_UTF8_LONG_NAMES
  return !(lfnReservedChar(c) || c & 0X80);
#endif  // USE_UTF8_LONG_NAMES
}
//------------------------------------------------------------------------------
uint8_t* ExFatFile::dirCache(uint8_t set, uint8_t options) {
    3880:	mov	r5, r0
    3882:	mov	r7, r1
    3884:	mov	r6, r2
  DirPos_t pos = m_dirPos;
    3886:	ldmia.w	r3, {r0, r1, r2}
#else  // USE_UTF8_LONG_NAMES
  return !(lfnReservedChar(c) || c & 0X80);
#endif  // USE_UTF8_LONG_NAMES
}
//------------------------------------------------------------------------------
uint8_t* ExFatFile::dirCache(uint8_t set, uint8_t options) {
    388a:	sub	sp, #20
  DirPos_t pos = m_dirPos;
    388c:	add	r4, sp, #4
    388e:	stmia.w	r4, {r0, r1, r2}
  if (m_vol->dirSeek(&pos, 32*set) != 1) {
    3892:	lsls	r2, r7, #5
    3894:	mov	r1, r4
    3896:	ldr	r0, [r5, #32]
    3898:	bl	4258 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)>
    389c:	cmp	r0, #1
    389e:	bne.n	38ac <ExFatFile::dirCache(unsigned char, unsigned char)+0x32>
    return nullptr;
  }
  return m_vol->dirCache(&pos, options);
    38a0:	mov	r2, r6
    38a2:	mov	r1, r4
    38a4:	ldr	r0, [r5, #32]
    38a6:	bl	41ba <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
    38aa:	b.n	38ae <ExFatFile::dirCache(unsigned char, unsigned char)+0x34>
}
//------------------------------------------------------------------------------
uint8_t* ExFatFile::dirCache(uint8_t set, uint8_t options) {
  DirPos_t pos = m_dirPos;
  if (m_vol->dirSeek(&pos, 32*set) != 1) {
    return nullptr;
    38ac:	movs	r0, #0
  }
  return m_vol->dirCache(&pos, options);
}
    38ae:	add	sp, #20
    38b0:	pop	{r4, r5, r6, r7, pc}

000038b2 <ExFatFile::close()>:
//------------------------------------------------------------------------------
bool ExFatFile::close() {
    38b2:	push	{r4, lr}
    38b4:	mov	r4, r0
  bool rtn = sync();
    38b6:	bl	4770 <ExFatFile::sync()>
  m_attributes = FILE_ATTR_CLOSED;
    38ba:	movs	r3, #0
    38bc:	strb.w	r3, [r4, #49]	; 0x31
  m_flags = 0;
    38c0:	strb.w	r3, [r4, #51]	; 0x33
  return rtn;
}
    38c4:	pop	{r4, pc}

000038c6 <ExFatFile::getCreateDateTime(unsigned short*, unsigned short*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::getCreateDateTime(uint16_t* pdate, uint16_t* ptime) {
    38c6:	push	{r3, r4, r5, lr}
    38c8:	mov	r5, r1
    38ca:	mov	r4, r2
  DirFile_t* df = reinterpret_cast<DirFile_t*>
                 (m_vol->dirCache(&m_dirPos, FsCache::CACHE_FOR_READ));
    38cc:	add.w	r1, r0, #36	; 0x24
    38d0:	movs	r2, #0
    38d2:	ldr	r0, [r0, #32]
    38d4:	bl	41ba <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
  if (!df) {
    38d8:	cbz	r0, 38e4 <ExFatFile::getCreateDateTime(unsigned short*, unsigned short*)+0x1e>
    38da:	ldrh	r3, [r0, #10]
    DBG_FAIL_MACRO;
    goto fail;
  }
  *pdate = getLe16(df->createDate);
    38dc:	strh	r3, [r5, #0]
    38de:	ldrh	r3, [r0, #8]
  *ptime = getLe16(df->createTime);
    38e0:	strh	r3, [r4, #0]
  return true;
    38e2:	movs	r0, #1

 fail:
  return false;
}
    38e4:	pop	{r3, r4, r5, pc}

000038e6 <ExFatFile::getModifyDateTime(unsigned short*, unsigned short*)>:
//------------------------------------------------------------------------------
bool ExFatFile::getModifyDateTime(uint16_t* pdate, uint16_t* ptime) {
    38e6:	push	{r3, r4, r5, lr}
    38e8:	mov	r5, r1
    38ea:	mov	r4, r2
  DirFile_t* df = reinterpret_cast<DirFile_t*>
                 (m_vol->dirCache(&m_dirPos, FsCache::CACHE_FOR_READ));
    38ec:	add.w	r1, r0, #36	; 0x24
    38f0:	movs	r2, #0
    38f2:	ldr	r0, [r0, #32]
    38f4:	bl	41ba <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
  if (!df) {
    38f8:	cbz	r0, 3904 <ExFatFile::getModifyDateTime(unsigned short*, unsigned short*)+0x1e>
    38fa:	ldrh	r3, [r0, #14]
    DBG_FAIL_MACRO;
    goto fail;
  }
  *pdate = getLe16(df->modifyDate);
    38fc:	strh	r3, [r5, #0]
    38fe:	ldrh	r3, [r0, #12]
  *ptime = getLe16(df->modifyTime);
    3900:	strh	r3, [r4, #0]
  return true;
    3902:	movs	r0, #1

 fail:
  return false;
}
    3904:	pop	{r3, r4, r5, pc}

00003906 <ExFatFile::openRoot(ExFatVolume*)>:
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openRoot(ExFatVolume* vol) {
    3906:	push	{r3, r4, r5, lr}
    3908:	mov	r5, r1
  if (isOpen()) {
    390a:	ldrb.w	r1, [r0, #49]	; 0x31
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openRoot(ExFatVolume* vol) {
    390e:	mov	r4, r0
  if (isOpen()) {
    3910:	cbnz	r1, 3928 <ExFatFile::openRoot(ExFatVolume*)+0x22>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
    3912:	movs	r2, #56	; 0x38
    3914:	bl	88c8 <memset>
  m_attributes = FILE_ATTR_ROOT;
    3918:	movs	r3, #64	; 0x40
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
    391a:	movs	r0, #1
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
  m_attributes = FILE_ATTR_ROOT;
    391c:	strb.w	r3, [r4, #49]	; 0x31
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
    3920:	strb.w	r0, [r4, #51]	; 0x33
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
  m_attributes = FILE_ATTR_ROOT;
  m_vol = vol;
    3924:	str	r5, [r4, #32]
    3926:	pop	{r3, r4, r5, pc}
  m_flags = FILE_FLAG_READ;
  return true;

 fail:
  return false;
    3928:	movs	r0, #0
}
    392a:	pop	{r3, r4, r5, pc}

0000392c <ExFatFile::parsePathName(char const*, ExName_t*, char const**)>:
//------------------------------------------------------------------------------
bool ExFatFile::parsePathName(const char* path,
                            ExName_t* fname, const char** ptr) {
    392c:	push	{r4, r5, r6, r7}
  // Skip leading spaces.
  while (*path == ' ') {
    392e:	ldrb	r4, [r1, #0]
    3930:	cmp	r4, #32
    3932:	add.w	r5, r1, #1
    3936:	bne.n	393c <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x10>
    3938:	mov	r1, r5
    393a:	b.n	392e <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x2>
}
#endif  // USE_SIMPLE_LITTLE_ENDIAN
//------------------------------------------------------------------------------
// Reserved characters for exFAT names and FAT LFN.
inline bool lfnReservedChar(uint8_t c) {
  return c < 0X20 || c == '"' || c == '*' || c == '/' || c == ':'
    393c:	ldr	r7, [pc, #100]	; (39a4 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x78>)
    path++;
  }
  fname->begin = path;
    393e:	str	r1, [r2, #0]
  fname->end = path;
    3940:	str	r1, [r2, #8]
  while (*path && !isDirSeparator(*path)) {
    3942:	mov	r5, r1
    3944:	mov	r6, r1
    3946:	ldrb.w	r4, [r5], #1
    394a:	cbz	r4, 3984 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x58>
    394c:	cmp	r4, #47	; 0x2f
    394e:	beq.n	3978 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x4c>
      || c == '<' || c == '>' || c == '?' || c == '\\'|| c == '|';
    3950:	cmp	r4, #31
    3952:	bls.n	399e <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x72>
}
#endif  // USE_SIMPLE_LITTLE_ENDIAN
//------------------------------------------------------------------------------
// Reserved characters for exFAT names and FAT LFN.
inline bool lfnReservedChar(uint8_t c) {
  return c < 0X20 || c == '"' || c == '*' || c == '/' || c == ':'
    3954:	sub.w	r1, r4, #34	; 0x22
    3958:	uxtb	r1, r1
    395a:	cmp	r1, #29
    395c:	bhi.n	3966 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x3a>
    395e:	lsr.w	r1, r7, r1
    3962:	lsls	r1, r1, #31
    3964:	bmi.n	399e <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x72>
      || c == '<' || c == '>' || c == '?' || c == '\\'|| c == '|';
    3966:	and.w	r1, r4, #191	; 0xbf
    396a:	cmp	r1, #60	; 0x3c
    396c:	beq.n	399e <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x72>
    396e:	cmp	r4, #92	; 0x5c
    3970:	bne.n	398e <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x62>
    3972:	b.n	399e <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x72>
      // Need to trim trailing dots spaces.
      fname->end = path;
    }
  }
  // Advance to next path component.
  for (; *path == ' ' || isDirSeparator(*path); path++) {}
    3974:	cmp	r4, #47	; 0x2f
    3976:	bne.n	3984 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x58>
    3978:	mov	r6, r1
    397a:	ldrb.w	r4, [r1], #1
    397e:	cmp	r4, #32
    3980:	bne.n	3974 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x48>
    3982:	b.n	3978 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x4c>
  *ptr = path;
    3984:	str	r6, [r3, #0]
  return hashName(fname);
    3986:	mov	r1, r2

 fail:
  return false;
}
    3988:	pop	{r4, r5, r6, r7}
    }
  }
  // Advance to next path component.
  for (; *path == ' ' || isDirSeparator(*path); path++) {}
  *ptr = path;
  return hashName(fname);
    398a:	b.w	3818 <ExFatFile::hashName(ExName_t*)>
    uint8_t c = *path++;
    if (!lfnLegalChar(c)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (c != '.' && c != ' ') {
    398e:	cmp	r4, #46	; 0x2e
    3990:	bne.n	3996 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x6a>
    3992:	mov	r1, r5
    3994:	b.n	3942 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x16>
    3996:	cmp	r4, #32
    3998:	beq.n	3992 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x66>
      // Need to trim trailing dots spaces.
      fname->end = path;
    399a:	str	r5, [r2, #8]
    399c:	b.n	3992 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x66>
  *ptr = path;
  return hashName(fname);

 fail:
  return false;
}
    399e:	movs	r0, #0
    39a0:	pop	{r4, r5, r6, r7}
    39a2:	bx	lr
    39a4:	.word	0x31000101

000039a8 <ExFatFile::read(void*, unsigned int)>:
  m_curPosition = curPosition;
  m_curCluster = curCluster;
  return c;
}
//------------------------------------------------------------------------------
int ExFatFile::read(void* buf, size_t count) {
    39a8:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    39ac:	ldrb.w	r3, [r0, #51]	; 0x33
  uint8_t* cache;
  uint16_t sectorOffset;
  uint32_t sector;
  uint32_t clusterOffset;

  if (!isReadable()) {
    39b0:	lsls	r7, r3, #31
  m_curPosition = curPosition;
  m_curCluster = curCluster;
  return c;
}
//------------------------------------------------------------------------------
int ExFatFile::read(void* buf, size_t count) {
    39b2:	mov	r4, r0
    39b4:	mov	r6, r1
    39b6:	mov	r5, r2
  uint8_t* cache;
  uint16_t sectorOffset;
  uint32_t sector;
  uint32_t clusterOffset;

  if (!isReadable()) {
    39b8:	bpl.n	3aaa <ExFatFile::read(void*, unsigned int)+0x102>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isContiguous() || isFile()) {
    39ba:	lsls	r0, r3, #25
    39bc:	bmi.n	39c6 <ExFatFile::read(void*, unsigned int)+0x1e>
    39be:	ldrb.w	r3, [r4, #49]	; 0x31
    39c2:	lsls	r1, r3, #28
    39c4:	bpl.n	39e0 <ExFatFile::read(void*, unsigned int)+0x38>
    if ((m_curPosition + count) > m_validLength) {
    39c6:	ldrd	r0, r1, [r4]
    39ca:	ldrd	r2, r3, [r4, #16]
    39ce:	adds.w	r8, r0, r5
    39d2:	adc.w	r9, r1, #0
    39d6:	cmp	r3, r9
    39d8:	it	eq
    39da:	cmpeq	r2, r8
    39dc:	bcs.n	39e0 <ExFatFile::read(void*, unsigned int)+0x38>
      count = toRead = m_validLength - m_curPosition;
    39de:	subs	r5, r2, r0
  m_curPosition = curPosition;
  m_curCluster = curCluster;
  return c;
}
//------------------------------------------------------------------------------
int ExFatFile::read(void* buf, size_t count) {
    39e0:	mov	r9, r5
        m_curCluster = isRoot()
                       ? m_vol->rootDirectoryCluster() : m_firstCluster;
      } else if (isContiguous()) {
        m_curCluster++;
      } else {
        fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    39e2:	add.w	sl, r4, #24
  if (isContiguous() || isFile()) {
    if ((m_curPosition + count) > m_validLength) {
      count = toRead = m_validLength - m_curPosition;
    }
  }
  while (toRead) {
    39e6:	cmp.w	r9, #0
    39ea:	beq.n	3a74 <ExFatFile::read(void*, unsigned int)+0xcc>
    clusterOffset = m_curPosition & m_vol->clusterMask();
    39ec:	ldr	r0, [r4, #32]
    39ee:	ldrd	r2, r3, [r4]
    39f2:	ldr.w	r1, [r0, #1080]	; 0x438
    39f6:	and.w	r8, r1, r2
    sectorOffset = clusterOffset & m_vol->sectorMask();
    39fa:	ubfx	fp, r8, #0, #9
    if (clusterOffset == 0) {
    39fe:	cmp.w	r8, #0
    3a02:	bne.n	3a42 <ExFatFile::read(void*, unsigned int)+0x9a>
      if (m_curPosition == 0) {
    3a04:	orrs	r3, r2
    3a06:	bne.n	3a18 <ExFatFile::read(void*, unsigned int)+0x70>
        m_curCluster = isRoot()
                       ? m_vol->rootDirectoryCluster() : m_firstCluster;
    3a08:	ldrb.w	r3, [r4, #49]	; 0x31
    3a0c:	lsls	r2, r3, #25
    3a0e:	ite	mi
    3a10:	ldrmi.w	r3, [r0, #1076]	; 0x434
    3a14:	ldrpl	r3, [r4, #28]
    3a16:	b.n	3a24 <ExFatFile::read(void*, unsigned int)+0x7c>
      } else if (isContiguous()) {
    3a18:	ldrb.w	r3, [r4, #51]	; 0x33
    3a1c:	lsls	r3, r3, #25
    3a1e:	bpl.n	3a28 <ExFatFile::read(void*, unsigned int)+0x80>
        m_curCluster++;
    3a20:	ldr	r3, [r4, #24]
    3a22:	adds	r3, #1
    3a24:	str	r3, [r4, #24]
    3a26:	b.n	3a42 <ExFatFile::read(void*, unsigned int)+0x9a>
      } else {
        fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    3a28:	mov	r2, sl
    3a2a:	ldr	r1, [r4, #24]
    3a2c:	bl	41f0 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
        if (fg < 0) {
    3a30:	cmp	r0, #0
    3a32:	blt.n	3aaa <ExFatFile::read(void*, unsigned int)+0x102>
          DBG_FAIL_MACRO;
          goto fail;
        }
        if (fg == 0) {
    3a34:	bne.n	3a42 <ExFatFile::read(void*, unsigned int)+0x9a>
          // EOF if directory.
          if (isDir()) {
    3a36:	ldrb.w	r3, [r4, #49]	; 0x31
    3a3a:	tst.w	r3, #80	; 0x50
    3a3e:	bne.n	3a74 <ExFatFile::read(void*, unsigned int)+0xcc>
    3a40:	b.n	3aaa <ExFatFile::read(void*, unsigned int)+0x102>
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
    }
    sector = m_vol->clusterStartSector(m_curCluster) +
    3a42:	ldr	r7, [r4, #32]
             (clusterOffset >> m_vol->bytesPerSectorShift());
    3a44:	ldr	r1, [r4, #24]
  bool dataCacheSync() {return m_dataCache.sync();}
  //----------------------------------------------------------------------------
  uint32_t clusterMask() const {return m_clusterMask;}
  uint32_t clusterStartSector(uint32_t cluster) {
    return m_clusterHeapStartSector +
           ((cluster - 2) << m_sectorsPerClusterShift);
    3a46:	ldrb.w	lr, [r7, #1093]	; 0x445
    3a4a:	ldr.w	r0, [r7, #1068]	; 0x42c
    3a4e:	subs	r1, #2
    3a50:	lsl.w	r1, r1, lr
    3a54:	mov.w	r2, r8, lsr #9
    3a58:	add	r1, r0
    3a5a:	add.w	r8, r1, r2
    if (sectorOffset != 0 || toRead < m_vol->bytesPerSector()
                          || sector == m_vol->dataCacheSector()) {
    3a5e:	cmp.w	fp, #0
    3a62:	bne.n	3b04 <ExFatFile::read(void*, unsigned int)+0x15c>
        }
      }
    }
    sector = m_vol->clusterStartSector(m_curCluster) +
             (clusterOffset >> m_vol->bytesPerSectorShift());
    if (sectorOffset != 0 || toRead < m_vol->bytesPerSector()
    3a64:	cmp.w	r9, #512	; 0x200
    3a68:	bcc.n	3b04 <ExFatFile::read(void*, unsigned int)+0x15c>
    3a6a:	ldr.w	r1, [r7, #540]	; 0x21c
                          || sector == m_vol->dataCacheSector()) {
    3a6e:	cmp	r8, r1
    3a70:	bne.n	3a7c <ExFatFile::read(void*, unsigned int)+0xd4>
    3a72:	b.n	3b04 <ExFatFile::read(void*, unsigned int)+0x15c>
    }
    dst += n;
    m_curPosition += n;
    toRead -= n;
  }
  return count - toRead;
    3a74:	rsb	r0, r9, r5
    3a78:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        goto fail;
      }
      uint8_t* src = cache + sectorOffset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
    3a7c:	cmp.w	r9, #1024	; 0x400
    3a80:	bcc.n	3ad8 <ExFatFile::read(void*, unsigned int)+0x130>
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
      // Limit reads to current cluster.
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
    3a82:	movs	r3, #1
    3a84:	lsl.w	r3, r3, lr
      }
      uint8_t* src = cache + sectorOffset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
    3a88:	mov.w	fp, r9, lsr #9
      // Limit reads to current cluster.
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
    3a8c:	subs	r2, r3, r2
    3a8e:	cmp	fp, r2
    3a90:	it	cs
    3a92:	movcs	fp, r2
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    3a94:	cmp	r8, r1
    3a96:	bhi.n	3abe <ExFatFile::read(void*, unsigned int)+0x116>
    3a98:	add.w	r3, fp, r8
    3a9c:	cmp	r1, r3
    3a9e:	bcs.n	3abe <ExFatFile::read(void*, unsigned int)+0x116>
   * \param[in] count Number of sectors to be read.
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool cacheSafeRead(uint32_t sector, uint8_t* dst, size_t count) {
    if (isCached(sector, count) && !sync()) {
    3aa0:	add.w	r0, r7, #528	; 0x210
    3aa4:	bl	3026 <FsCache::sync()>
    3aa8:	cbnz	r0, 3abe <ExFatFile::read(void*, unsigned int)+0x116>
    toRead -= n;
  }
  return count - toRead;

 fail:
  m_error |= READ_ERROR;
    3aaa:	ldrb.w	r3, [r4, #50]	; 0x32
    3aae:	orr.w	r3, r3, #2
    3ab2:	strb.w	r3, [r4, #50]	; 0x32
  return -1;
    3ab6:	mov.w	r0, #4294967295
    3aba:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      return false;
    }
    return m_blockDev->readSectors(sector, dst, count);
    3abe:	ldr.w	r0, [r7, #532]	; 0x214
    3ac2:	ldr	r3, [r0, #0]
    3ac4:	mov	r2, r6
    3ac6:	ldr	r7, [r3, #16]
    3ac8:	mov	r1, r8
    3aca:	mov	r3, fp
    3acc:	blx	r7
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
      if (ns > maxNs) {
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
     if (!m_vol->cacheSafeRead(sector, dst, ns)) {
    3ace:	cmp	r0, #0
    3ad0:	beq.n	3aaa <ExFatFile::read(void*, unsigned int)+0x102>
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
      if (ns > maxNs) {
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
    3ad2:	mov.w	r7, fp, lsl #9
    3ad6:	b.n	3aee <ExFatFile::read(void*, unsigned int)+0x146>
  bool cacheSafeRead(uint32_t sector, uint8_t* dst) {
    if (isCached(sector)) {
      memcpy(dst, m_buffer, 512);
      return true;
    }
    return m_blockDev->readSector(sector, dst);
    3ad8:	ldr.w	r0, [r7, #532]	; 0x214
    3adc:	ldr	r3, [r0, #0]
    3ade:	mov	r2, r6
    3ae0:	ldr	r3, [r3, #12]
    3ae2:	mov	r1, r8
    3ae4:	blx	r3
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeRead(sector, dst)) {
    3ae6:	cmp	r0, #0
    3ae8:	beq.n	3aaa <ExFatFile::read(void*, unsigned int)+0x102>
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
    3aea:	mov.w	r7, #512	; 0x200
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    m_curPosition += n;
    3aee:	ldrd	r2, r3, [r4]
    3af2:	adds	r2, r2, r7
    3af4:	adc.w	r3, r3, #0
      if (!m_vol->cacheSafeRead(sector, dst)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    3af8:	add	r6, r7
    m_curPosition += n;
    3afa:	strd	r2, r3, [r4]
    toRead -= n;
    3afe:	rsb	r9, r7, r9
  if (isContiguous() || isFile()) {
    if ((m_curPosition + count) > m_validLength) {
      count = toRead = m_validLength - m_curPosition;
    }
  }
  while (toRead) {
    3b02:	b.n	39e6 <ExFatFile::read(void*, unsigned int)+0x3e>
#endif  // USE_EXFAT_BITMAP_CACHE
  }
  void dataCacheDirty() {m_dataCache.dirty();}
  void dataCacheInvalidate() {m_dataCache.invalidate();}
  uint8_t* dataCacheGet(uint32_t sector, uint8_t option) {
    return m_dataCache.get(sector, option);
    3b04:	movs	r2, #0
    3b06:	mov	r1, r8
    3b08:	add.w	r0, r7, #528	; 0x210
    3b0c:	bl	3072 <FsCache::get(unsigned long, unsigned char)>
      if (n > toRead) {
        n = toRead;
      }
      // read sector to cache and copy data to caller
      cache = m_vol->dataCacheGet(sector, FsCache::CACHE_FOR_READ);
      if (!cache) {
    3b10:	cmp	r0, #0
    3b12:	beq.n	3aaa <ExFatFile::read(void*, unsigned int)+0x102>
    }
    sector = m_vol->clusterStartSector(m_curCluster) +
             (clusterOffset >> m_vol->bytesPerSectorShift());
    if (sectorOffset != 0 || toRead < m_vol->bytesPerSector()
                          || sector == m_vol->dataCacheSector()) {
      n = m_vol->bytesPerSector() - sectorOffset;
    3b14:	rsb	r7, fp, #512	; 0x200
    3b18:	cmp	r7, r9
    3b1a:	it	cs
    3b1c:	movcs	r7, r9
      if (!cache) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* src = cache + sectorOffset;
      memcpy(dst, src, n);
    3b1e:	add.w	r1, r0, fp
    3b22:	mov	r2, r7
    3b24:	mov	r0, r6
    3b26:	bl	8720 <memcpy>
    3b2a:	b.n	3aee <ExFatFile::read(void*, unsigned int)+0x146>

00003b2c <ExFatFile::peek()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
int ExFatFile::peek() {
    3b2c:	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   * \return For success read returns the next byte in the file as an int.
   * If an error occurs or end of file is reached -1 is returned.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
    3b2e:	movs	r2, #1
    3b30:	add.w	r1, sp, #7
    3b34:	mov	r4, r0
  uint64_t curPosition = m_curPosition;
    3b36:	ldrd	r6, r7, [r0]
  uint32_t curCluster = m_curCluster;
    3b3a:	ldr	r5, [r0, #24]
    3b3c:	bl	39a8 <ExFatFile::read(void*, unsigned int)>
    3b40:	cmp	r0, #1
    3b42:	it	eq
    3b44:	ldrbeq.w	r0, [sp, #7]
  int c = read();
  m_curPosition = curPosition;
  m_curCluster = curCluster;
    3b48:	str	r5, [r4, #24]
    3b4a:	it	ne
    3b4c:	movne.w	r0, #4294967295
//------------------------------------------------------------------------------
int ExFatFile::peek() {
  uint64_t curPosition = m_curPosition;
  uint32_t curCluster = m_curCluster;
  int c = read();
  m_curPosition = curPosition;
    3b50:	strd	r6, r7, [r4]
  m_curCluster = curCluster;
  return c;
}
    3b54:	add	sp, #12
    3b56:	pop	{r4, r5, r6, r7, pc}

00003b58 <ExFatFile::seekSet(unsigned long long)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::seekSet(uint64_t pos) {
    3b58:	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3b5c:	ldrb.w	fp, [r0, #49]	; 0x31
    3b60:	mov	r7, r3
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
    3b62:	ldr	r3, [r0, #24]
    3b64:	str	r3, [sp, #4]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::seekSet(uint64_t pos) {
    3b66:	mov	r4, r0
    3b68:	mov	r6, r2
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
  // error if file not open
  if (!isOpen()) {
    3b6a:	cmp.w	fp, #0
    3b6e:	beq.n	3c18 <ExFatFile::seekSet(unsigned long long)+0xc0>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    3b70:	ldrd	r8, r9, [r0]
    3b74:	cmp	r9, r7
    3b76:	it	eq
    3b78:	cmpeq	r8, r2
    3b7a:	beq.n	3c20 <ExFatFile::seekSet(unsigned long long)+0xc8>
    return true;
  }
  if (pos == 0) {
    3b7c:	orrs.w	r3, r6, r7
    3b80:	bne.n	3b88 <ExFatFile::seekSet(unsigned long long)+0x30>
    // set position to start of file
    m_curCluster = 0;
    3b82:	movs	r3, #0
    3b84:	str	r3, [r0, #24]
    goto done;
    3b86:	b.n	3c12 <ExFatFile::seekSet(unsigned long long)+0xba>
  }
  if (isFile()) {
    3b88:	tst.w	fp, #8
    3b8c:	beq.n	3b9a <ExFatFile::seekSet(unsigned long long)+0x42>
    if (pos > m_validLength) {
    3b8e:	ldrd	r0, r1, [r0, #16]
    3b92:	cmp	r1, r7
    3b94:	it	eq
    3b96:	cmpeq	r0, r2
    3b98:	bcc.n	3c18 <ExFatFile::seekSet(unsigned long long)+0xc0>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> m_vol->bytesPerClusterShift();
    3b9a:	ldr	r3, [r4, #32]
    3b9c:	str	r3, [sp, #0]
    3b9e:	ldrb.w	sl, [r3, #1093]	; 0x445
    3ba2:	add.w	sl, sl, #9
    3ba6:	adds.w	r0, r6, #4294967295
    3baa:	uxtb.w	sl, sl
    3bae:	mov	r2, sl
    3bb0:	adc.w	r1, r7, #4294967295
    3bb4:	bl	9cd4 <__aeabi_llsr>
  if (isContiguous()) {
    3bb8:	ldrb.w	r2, [r4, #51]	; 0x33
    3bbc:	lsls	r3, r2, #25
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> m_vol->bytesPerClusterShift();
    3bbe:	mov	r5, r0
  if (isContiguous()) {
    3bc0:	bpl.n	3bca <ExFatFile::seekSet(unsigned long long)+0x72>
    m_curCluster = m_firstCluster + nNew;
    3bc2:	ldr	r3, [r4, #28]
    3bc4:	add	r5, r3
    3bc6:	str	r5, [r4, #24]
    goto done;
    3bc8:	b.n	3c12 <ExFatFile::seekSet(unsigned long long)+0xba>
  }
  // calculate cluster index for current position
  nCur = (m_curPosition - 1) >> m_vol->bytesPerClusterShift();
    3bca:	adds.w	r0, r8, #4294967295
    3bce:	adc.w	r1, r9, #4294967295
    3bd2:	mov	r2, sl
    3bd4:	bl	9cd4 <__aeabi_llsr>
  if (nNew < nCur || m_curPosition == 0) {
    3bd8:	cmp	r5, r0
    3bda:	bcc.n	3be2 <ExFatFile::seekSet(unsigned long long)+0x8a>
    3bdc:	orrs.w	r3, r8, r9
    3be0:	bne.n	3bf8 <ExFatFile::seekSet(unsigned long long)+0xa0>
    // must follow chain from first cluster
    m_curCluster = isRoot() ? m_vol->rootDirectoryCluster() : m_firstCluster;
    3be2:	tst.w	fp, #64	; 0x40
    3be6:	itet	ne
    3be8:	ldrne	r3, [sp, #0]
    3bea:	ldreq	r3, [r4, #28]
    3bec:	ldrne.w	r3, [r3, #1076]	; 0x434
    3bf0:	str	r3, [r4, #24]
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
    3bf2:	add.w	r8, r4, #24
    3bf6:	b.n	3c0e <ExFatFile::seekSet(unsigned long long)+0xb6>
  if (nNew < nCur || m_curPosition == 0) {
    // must follow chain from first cluster
    m_curCluster = isRoot() ? m_vol->rootDirectoryCluster() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
    3bf8:	subs	r5, r5, r0
    3bfa:	b.n	3bf2 <ExFatFile::seekSet(unsigned long long)+0x9a>
  }
  while (nNew--) {
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
    3bfc:	mov	r2, r8
    3bfe:	ldr	r1, [r4, #24]
    3c00:	ldr	r0, [r4, #32]
    3c02:	bl	41f0 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
    3c06:	cmp	r0, #0
    3c08:	add.w	r5, r5, #4294967295
    3c0c:	ble.n	3c18 <ExFatFile::seekSet(unsigned long long)+0xc0>
    m_curCluster = isRoot() ? m_vol->rootDirectoryCluster() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    3c0e:	cmp	r5, #0
    3c10:	bne.n	3bfc <ExFatFile::seekSet(unsigned long long)+0xa4>
      goto fail;
    }
  }

 done:
  m_curPosition = pos;
    3c12:	strd	r6, r7, [r4]
    3c16:	b.n	3c20 <ExFatFile::seekSet(unsigned long long)+0xc8>
  return true;

 fail:
  m_curCluster = tmp;
    3c18:	ldr	r3, [sp, #4]
    3c1a:	str	r3, [r4, #24]
  return false;
    3c1c:	movs	r0, #0
    3c1e:	b.n	3c22 <ExFatFile::seekSet(unsigned long long)+0xca>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    return true;
    3c20:	movs	r0, #1
  return true;

 fail:
  m_curCluster = tmp;
  return false;
}
    3c22:	add	sp, #12
    3c24:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00003c28 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openPrivate(ExFatFile* dir, ExName_t* fname, oflag_t oflag) {
    3c28:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3c2c:	mov	sl, r3
  uint8_t freeCount = 0;
  uint8_t freeNeed = 3;
  bool inSet = false;

  // error if already open, no access mode, or no directory.
  if (isOpen() || !dir->isDir()) {
    3c2e:	ldrb.w	r3, [r0, #49]	; 0x31

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openPrivate(ExFatFile* dir, ExName_t* fname, oflag_t oflag) {
    3c32:	sub	sp, #52	; 0x34
    3c34:	mov	r4, r0
    3c36:	mov	r6, r1
    3c38:	mov	r5, r2
  uint8_t freeCount = 0;
  uint8_t freeNeed = 3;
  bool inSet = false;

  // error if already open, no access mode, or no directory.
  if (isOpen() || !dir->isDir()) {
    3c3a:	cbnz	r3, 3c9a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    3c3c:	ldrb.w	r3, [r1, #49]	; 0x31
    3c40:	tst.w	r3, #80	; 0x50
    3c44:	beq.n	3c9a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    DBG_FAIL_MACRO;
    goto fail;
  }

  switch (oflag & O_ACCMODE) {
    3c46:	and.w	r3, sl, #3
    3c4a:	cmp	r3, #1
    3c4c:	beq.w	3f54 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x32c>
    3c50:	cmp	r3, #2
    3c52:	bne.w	3f4a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x322>
      break;
    case O_WRONLY:
      modeFlags = FILE_FLAG_WRITE;
      break;
    case O_RDWR:
      modeFlags = FILE_FLAG_READ | FILE_FLAG_WRITE;
    3c56:	movs	r3, #3
      break;
    default:
      DBG_FAIL_MACRO;
      goto fail;
  }
  modeFlags |= oflag & O_APPEND ? FILE_FLAG_APPEND : 0;
    3c58:	and.w	r9, sl, #8
    3c5c:	orr.w	r9, r9, r3

  if (fname) {
    3c60:	cbz	r5, 3ca6 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x7e>
    freeNeed = 2 + (fname->nameLength + 14)/15;
    3c62:	ldr	r3, [r5, #16]
    3c64:	mov.w	r8, #15
    3c68:	adds	r3, #14
   * \return true for success or false for failure.
   */
  bool rename(ExFatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    3c6a:	movs	r2, #0
    3c6c:	udiv	r8, r3, r8
    3c70:	mov	r0, r6
    3c72:	add.w	r8, r8, #2
    3c76:	movs	r3, #0
    3c78:	uxtb.w	r8, r8
    3c7c:	bl	3b58 <ExFatFile::seekSet(unsigned long long)>
        }
        // Likely openNext call.
        DBG_WARN_MACRO;
        goto fail;
      }
      inSet = false;
    3c80:	mov.w	fp, #0
    3c84:	mov	r7, fp
    freeNeed = 2 + (fname->nameLength + 14)/15;
    dir->rewind();
  }

  while (1) {
    n = dir->read(buf, 32);
    3c86:	movs	r2, #32
    3c88:	add	r1, sp, #16
    3c8a:	mov	r0, r6
    3c8c:	bl	39a8 <ExFatFile::read(void*, unsigned int)>
    if (n == 0) {
    3c90:	cmp	r0, #0
    3c92:	beq.w	3e0e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1e6>
      goto create;
    }
    if (n != 32) {
    3c96:	cmp	r0, #32
    3c98:	beq.n	3cac <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x84>
  return sync();
#endif  // READ_ONLY

 fail:
  // close file
  m_attributes = FILE_ATTR_CLOSED;
    3c9a:	movs	r0, #0
    3c9c:	strb.w	r0, [r4, #49]	; 0x31
  m_flags = 0;
    3ca0:	strb.w	r0, [r4, #51]	; 0x33
  return false;
    3ca4:	b.n	3f6c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x344>
  DirFile_t*   dirFile;
  DirStream_t* dirStream;
  DirName_t*   dirName;
  uint8_t buf[32];
  uint8_t freeCount = 0;
  uint8_t freeNeed = 3;
    3ca6:	mov.w	r8, #3
    3caa:	b.n	3c80 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x58>
    }
    if (n != 32) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(buf[0] & 0x80)) {
    3cac:	ldrb.w	r2, [sp, #16]
    3cb0:	lsls	r1, r2, #24
    3cb2:	bmi.n	3cd8 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0xb0>
      // Unused entry.
      if (freeCount == 0) {
    3cb4:	cbnz	r7, 3cc0 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x98>
        freePos.position = dir->curPosition() - 32;
    3cb6:	ldr	r3, [r6, #0]
    3cb8:	subs	r3, #32
    3cba:	str	r3, [sp, #4]
    3cbc:	ldr	r3, [r6, #24]
    3cbe:	str	r3, [sp, #0]
        freePos.cluster = dir->curCluster();
      }
      if (freeCount < freeNeed) {
    3cc0:	cmp	r7, r8
        freeCount++;
    3cc2:	itt	cc
    3cc4:	addcc	r7, #1
    3cc6:	uxtbcc	r7, r7
      }
      if (!buf[0]) {
    3cc8:	cbz	r2, 3cd0 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0xa8>
      }
      if (fname->atEnd()) {
        goto found;
      }
    } else {
      inSet = false;
    3cca:	mov.w	fp, #0
    3cce:	b.n	3c86 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
      }
      if (freeCount < freeNeed) {
        freeCount++;
      }
      if (!buf[0]) {
        if (fname) {
    3cd0:	cmp	r5, #0
    3cd2:	bne.w	3e0e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1e6>
    3cd6:	b.n	3c9a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
        // Likely openNext call.
        DBG_WARN_MACRO;
        goto fail;
      }
      inSet = false;
    } else if (!inSet) {
    3cd8:	cmp.w	fp, #0
    3cdc:	bne.n	3d2e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x106>
      if (freeCount < freeNeed) {
        freeCount = 0;
    3cde:	cmp	r7, r8
    3ce0:	it	cc
    3ce2:	movcc	r7, #0
      }
      if (buf[0] != EXFAT_TYPE_FILE) {
    3ce4:	cmp	r2, #133	; 0x85
    3ce6:	bne.n	3c86 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
        continue;
      }
      inSet = true;
      memset(this, 0, sizeof(ExFatFile));
    3ce8:	movs	r2, #56	; 0x38
    3cea:	mov	r1, fp
    3cec:	mov	r0, r4
    3cee:	bl	88c8 <memset>
      dirFile = reinterpret_cast<DirFile_t*>(buf);
      m_setCount = dirFile->setCount;
      m_attributes = getLe16(dirFile->attributes) & FILE_ATTR_COPY;
    3cf2:	ldrb.w	r2, [sp, #20]
        continue;
      }
      inSet = true;
      memset(this, 0, sizeof(ExFatFile));
      dirFile = reinterpret_cast<DirFile_t*>(buf);
      m_setCount = dirFile->setCount;
    3cf6:	ldrb.w	r3, [sp, #17]
    3cfa:	strb.w	r3, [r4, #48]	; 0x30
      m_attributes = getLe16(dirFile->attributes) & FILE_ATTR_COPY;
    3cfe:	and.w	r3, r2, #55	; 0x37
      if (!(m_attributes & EXFAT_ATTRIB_DIRECTORY)) {
    3d02:	lsls	r2, r2, #27
        m_attributes |= FILE_ATTR_FILE;
    3d04:	it	pl
    3d06:	orrpl.w	r3, r3, #8
    3d0a:	strb.w	r3, [r4, #49]	; 0x31
    3d0e:	ldr	r3, [r6, #32]
      }
      m_vol = dir->volume();
    3d10:	str	r3, [r4, #32]
    3d12:	ldr	r3, [r6, #24]
      m_dirPos.cluster = dir->curCluster();
    3d14:	str	r3, [r4, #36]	; 0x24
      m_dirPos.position = dir->curPosition() - 32;
    3d16:	ldr	r3, [r6, #0]
    3d18:	subs	r3, #32
    3d1a:	str	r3, [r4, #40]	; 0x28
      m_dirPos.isContiguous = dir->isContiguous();
    3d1c:	ldrb.w	r3, [r6, #51]	; 0x33
    3d20:	ubfx	r3, r3, #6, #1
    3d24:	strb.w	r3, [r4, #44]	; 0x2c
        freeCount = 0;
      }
      if (buf[0] != EXFAT_TYPE_FILE) {
        continue;
      }
      inSet = true;
    3d28:	mov.w	fp, #1
    3d2c:	b.n	3c86 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
      }
      m_vol = dir->volume();
      m_dirPos.cluster = dir->curCluster();
      m_dirPos.position = dir->curPosition() - 32;
      m_dirPos.isContiguous = dir->isContiguous();
    } else if (buf[0] == EXFAT_TYPE_STREAM) {
    3d2e:	cmp	r2, #192	; 0xc0
    3d30:	bne.n	3d8a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x162>
      dirStream = reinterpret_cast<DirStream_t*>(buf);
      m_flags = modeFlags;
      if (dirStream->flags & EXFAT_FLAG_CONTIGUOUS) {
    3d32:	ldrb.w	r3, [sp, #17]
      m_dirPos.cluster = dir->curCluster();
      m_dirPos.position = dir->curPosition() - 32;
      m_dirPos.isContiguous = dir->isContiguous();
    } else if (buf[0] == EXFAT_TYPE_STREAM) {
      dirStream = reinterpret_cast<DirStream_t*>(buf);
      m_flags = modeFlags;
    3d36:	strb.w	r9, [r4, #51]	; 0x33
      if (dirStream->flags & EXFAT_FLAG_CONTIGUOUS) {
    3d3a:	lsls	r0, r3, #30
        m_flags |= FILE_FLAG_CONTIGUOUS;
    3d3c:	itt	mi
    3d3e:	orrmi.w	r3, r9, #64	; 0x40
    3d42:	strbmi.w	r3, [r4, #51]	; 0x33
      }
      m_validLength = getLe64(dirStream->validLength);
    3d46:	ldrd	r2, r3, [sp, #24]
    3d4a:	strd	r2, r3, [r4, #16]
      m_firstCluster = getLe32(dirStream->firstCluster);
    3d4e:	ldr	r3, [sp, #36]	; 0x24
    3d50:	str	r3, [r4, #28]
      m_dataLength = getLe64(dirStream->dataLength);
    3d52:	ldrd	r2, r3, [sp, #40]	; 0x28
    3d56:	strd	r2, r3, [r4, #8]
      if (!fname) {
    3d5a:	cbnz	r5, 3d64 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x13c>
    }
  }

 found:
  // Don't open if create only.
  if (oflag & O_EXCL) {
    3d5c:	tst.w	sl, #2048	; 0x800
    3d60:	bne.n	3c9a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    3d62:	b.n	3db2 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x18a>
  }
  void reset() {
    next = begin;
    3d64:	ldr	r3, [r5, #0]
    3d66:	str	r3, [r5, #4]
    ls = 0;
    3d68:	mov.w	r3, #0
    3d6c:	strh	r3, [r5, #12]
      m_dataLength = getLe64(dirStream->dataLength);
      if (!fname) {
        goto found;
      }
      fname->reset();
      if (fname->nameLength != dirStream->nameLength ||
    3d6e:	ldr	r2, [r5, #16]
    3d70:	ldrb.w	r3, [sp, #19]
    3d74:	cmp	r2, r3
    3d76:	bne.n	3cca <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0xa2>
    3d78:	ldrh.w	r2, [sp, #20]
    3d7c:	ldrh	r3, [r5, #20]
    3d7e:	subs	r1, r2, r3
    3d80:	rsbs	fp, r1, #0
    3d84:	adc.w	fp, fp, r1
    3d88:	b.n	3c86 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
          fname->nameHash != getLe16(dirStream->nameHash)) {
        inSet = false;
      }
    } else if (buf[0] == EXFAT_TYPE_NAME) {
    3d8a:	cmp	r2, #193	; 0xc1
    3d8c:	bne.n	3cca <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0xa2>
      dirName = reinterpret_cast<DirName_t*>(buf);
      if (!cmpName(dirName, fname)) {
    3d8e:	mov	r2, r5
    3d90:	add	r1, sp, #16
    3d92:	mov	r0, r4
    3d94:	bl	371c <ExFatFile::cmpName(DirName_t const*, ExName_t*)>
    3d98:	cbnz	r0, 3d9e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x176>
        inSet = false;
    3d9a:	mov	fp, r0
    3d9c:	b.n	3c86 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
  /** \return next UTF-16 unit of LFN. */
  uint16_t get16() {return atEnd() ? 0 : *next++;}
#else  // !USE_UTF8_LONG_NAMES
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
    3d9e:	ldrh	r2, [r5, #12]
    3da0:	cmp	r2, #0
    3da2:	bne.w	3c86 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
    3da6:	ldr	r1, [r5, #4]
    3da8:	ldr	r2, [r5, #8]
    3daa:	cmp	r1, r2
    3dac:	bne.w	3c86 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
    3db0:	b.n	3d5c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x134>
  if (oflag & O_EXCL) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Write, truncate, or at end is an error for a directory or read-only file.
  if ((oflag & (O_TRUNC | O_AT_END)) || (m_flags & FILE_FLAG_WRITE)) {
    3db2:	tst.w	sl, #17408	; 0x4400
    3db6:	bne.n	3dc0 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x198>
    3db8:	ldrb.w	r3, [r4, #51]	; 0x33
    3dbc:	lsls	r2, r3, #30
    3dbe:	bpl.n	3dcc <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1a4>
    if (isSubDir() || isReadOnly() || READ_ONLY) {
    3dc0:	ldrb.w	r3, [r4, #49]	; 0x31
    3dc4:	tst.w	r3, #17
    3dc8:	bne.w	3c9a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
      goto fail;
    }
  }

#if !READ_ONLY
  if (oflag & O_TRUNC) {
    3dcc:	tst.w	sl, #1024	; 0x400
    3dd0:	beq.n	3df4 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1cc>
    if (!(m_flags & FILE_FLAG_WRITE)) {
    3dd2:	ldrb.w	r3, [r4, #51]	; 0x33
    3dd6:	lsls	r3, r3, #30
    3dd8:	bpl.w	3c9a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return seekSet(length) && truncate();
    3ddc:	movs	r2, #0
    3dde:	movs	r3, #0
    3de0:	mov	r0, r4
    3de2:	bl	3b58 <ExFatFile::seekSet(unsigned long long)>
    3de6:	cmp	r0, #0
    3de8:	beq.w	3c9a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    3dec:	mov	r0, r4
    3dee:	bl	4b4a <ExFatFile::truncate()>
    3df2:	b.n	3e06 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1de>
    }
    if (!truncate(0)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if ((oflag & O_AT_END) && !seekSet(fileSize())) {
    3df4:	tst.w	sl, #16384	; 0x4000
    3df8:	beq.w	3f58 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x330>
    3dfc:	ldrd	r2, r3, [r4, #16]
    3e00:	mov	r0, r4
    3e02:	bl	3b58 <ExFatFile::seekSet(unsigned long long)>
    3e06:	cmp	r0, #0
    3e08:	beq.w	3c9a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    3e0c:	b.n	3f58 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x330>
#if READ_ONLY
  DBG_FAIL_MACRO;
  goto fail;
#else  // READ_ONLY
  // don't create unless O_CREAT and write
  if (!(oflag & O_CREAT) || !(modeFlags & FILE_FLAG_WRITE) || !fname) {
    3e0e:	tst.w	sl, #512	; 0x200
    3e12:	beq.w	3c9a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    3e16:	tst.w	r9, #2
    3e1a:	beq.w	3c9a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    3e1e:	cmp	r5, #0
    3e20:	beq.w	3c9a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    DBG_WARN_MACRO;
    goto fail;
  }
  while (freeCount < freeNeed) {
    3e24:	cmp	r7, r8
    3e26:	bcs.n	3e62 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x23a>
    n = dir->read(buf, 32);
    3e28:	movs	r2, #32
    3e2a:	add	r1, sp, #16
    3e2c:	mov	r0, r6
    3e2e:	bl	39a8 <ExFatFile::read(void*, unsigned int)>
    if (n == 0) {
    3e32:	cbnz	r0, 3e4a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x222>
      curCluster = dir->m_curCluster;
      if (!dir->addDirCluster()) {
    3e34:	mov	r0, r6
    goto fail;
  }
  while (freeCount < freeNeed) {
    n = dir->read(buf, 32);
    if (n == 0) {
      curCluster = dir->m_curCluster;
    3e36:	ldr.w	sl, [r6, #24]
      if (!dir->addDirCluster()) {
    3e3a:	bl	47ae <ExFatFile::addDirCluster()>
    3e3e:	cmp	r0, #0
    3e40:	beq.w	3c9a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
        DBG_FAIL_MACRO;
        goto fail;
      }
      dir->m_curCluster = curCluster;
    3e44:	str.w	sl, [r6, #24]
      continue;
    3e48:	b.n	3e24 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1fc>
    }
    if (n != 32) {
    3e4a:	cmp	r0, #32
    3e4c:	bne.w	3c9a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (freeCount == 0) {
    3e50:	cbnz	r7, 3e5c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x234>
      freePos.position = dir->curPosition() - 32;
    3e52:	ldr	r3, [r6, #0]
    3e54:	subs	r3, #32
    3e56:	str	r3, [sp, #4]
    3e58:	ldr	r3, [r6, #24]
    3e5a:	str	r3, [sp, #0]
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
    3e5c:	adds	r7, #1
    3e5e:	uxtb	r7, r7
    3e60:	b.n	3e24 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1fc>
  }
  freePos.isContiguous = dir->isContiguous();
  memset(this, 0, sizeof(ExFatFile));
    3e62:	movs	r2, #56	; 0x38
    3e64:	movs	r1, #0
    3e66:	mov	r0, r4
      freePos.position = dir->curPosition() - 32;
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
  }
  freePos.isContiguous = dir->isContiguous();
    3e68:	ldrb.w	r7, [r6, #51]	; 0x33
  memset(this, 0, sizeof(ExFatFile));
    3e6c:	bl	88c8 <memset>
    3e70:	ldr	r3, [r6, #32]
  m_vol = dir->volume();
    3e72:	str	r3, [r4, #32]
  m_attributes = FILE_ATTR_FILE;
    3e74:	movs	r3, #8
    3e76:	strb.w	r3, [r4, #49]	; 0x31
  m_dirPos = freePos;
    3e7a:	ldr	r3, [sp, #0]
    3e7c:	str	r3, [r4, #36]	; 0x24
      freePos.position = dir->curPosition() - 32;
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
  }
  freePos.isContiguous = dir->isContiguous();
    3e7e:	ubfx	r7, r7, #6, #1
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
  m_dirPos = freePos;
    3e82:	ldr	r3, [sp, #4]
    3e84:	strb.w	r7, [r4, #44]	; 0x2c
    3e88:	str	r3, [r4, #40]	; 0x28
  }
  void reset() {
    next = begin;
    3e8a:	ldr	r3, [r5, #0]
    3e8c:	str	r3, [r5, #4]
    ls = 0;
    3e8e:	movs	r7, #0
    }
    memset(cache, 0 , 32);
    if (i == 0) {
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
      m_setCount = freeNeed - 1;
    3e90:	add.w	sl, r8, #4294967295
    3e94:	strh	r7, [r5, #12]
    3e96:	uxtb.w	sl, sl
    3e9a:	uxtb.w	fp, r7
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
  m_dirPos = freePos;
  fname->reset();
  for (uint8_t i = 0; i < freeNeed; i++) {
    3e9e:	cmp	fp, r8
    3ea0:	bcs.n	3f42 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x31a>
    cache = dirCache(i, FsCache::CACHE_FOR_WRITE);
    3ea2:	movs	r2, #1
    3ea4:	mov	r1, fp
    3ea6:	mov	r0, r4
    3ea8:	bl	387a <ExFatFile::dirCache(unsigned char, unsigned char)>
    if (!cache || (cache[0] & 0x80)) {
    3eac:	mov	r6, r0
    3eae:	cmp	r0, #0
    3eb0:	beq.w	3c9a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    3eb4:	ldrsb.w	r2, [r0]
    3eb8:	cmp	r2, #0
    3eba:	blt.w	3c9a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
      DBG_FAIL_MACRO;
      goto fail;
    }
    memset(cache, 0 , 32);
    3ebe:	movs	r2, #32
    3ec0:	movs	r1, #0
    3ec2:	bl	88c8 <memset>
    if (i == 0) {
    3ec6:	cmp.w	fp, #0
    3eca:	bne.n	3f0a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x2e2>
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
    3ecc:	movs	r3, #133	; 0x85
    3ece:	strb	r3, [r6, #0]
      m_setCount = freeNeed - 1;
      dirFile->setCount = m_setCount;

      if (FsDateTime::callback) {
    3ed0:	ldr	r3, [pc, #160]	; (3f74 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x34c>)
    }
    memset(cache, 0 , 32);
    if (i == 0) {
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
      m_setCount = freeNeed - 1;
    3ed2:	strb.w	sl, [r4, #48]	; 0x30
      dirFile->setCount = m_setCount;
    3ed6:	strb.w	sl, [r6, #1]

      if (FsDateTime::callback) {
    3eda:	ldr	r3, [r3, #0]
    3edc:	cbz	r3, 3efe <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x2d6>
        uint16_t date, time;
        uint8_t ms10;
        FsDateTime::callback(&date, &time, &ms10);
    3ede:	add.w	r2, sp, #11
    3ee2:	add.w	r1, sp, #14
    3ee6:	add	r0, sp, #12
    3ee8:	blx	r3
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    3eea:	ldrh.w	r3, [sp, #12]
    3eee:	strh	r3, [r6, #10]
    3ef0:	ldrh.w	r3, [sp, #14]
    3ef4:	strh	r3, [r6, #8]
        setLe16(dirFile->createDate, date);
        setLe16(dirFile->createTime, time);
        dirFile->createTimeMs = ms10;
    3ef6:	ldrb.w	r3, [sp, #11]
    3efa:	strb	r3, [r6, #20]
    3efc:	b.n	3f3e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x316>
    3efe:	movw	r3, #21537	; 0x5421
    3f02:	strh	r3, [r6, #10]
    3f04:	strh	r3, [r6, #14]
    3f06:	strh	r3, [r6, #18]
    3f08:	b.n	3f3e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x316>
         setLe16(dirFile->createTime, FS_DEFAULT_TIME);
         setLe16(dirFile->modifyTime, FS_DEFAULT_TIME);
         setLe16(dirFile->accessTime, FS_DEFAULT_TIME);
       }
      }
    } else if (i == 1) {
    3f0a:	cmp.w	fp, #1
    3f0e:	bne.n	3f2a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x302>
      dirStream = reinterpret_cast<DirStream_t*>(cache);
      dirStream->type = EXFAT_TYPE_STREAM;
      dirStream->flags = EXFAT_FLAG_ALWAYS1;
      m_flags = modeFlags | FILE_FLAG_DIR_DIRTY;
    3f10:	orn	r3, r9, #127	; 0x7f
         setLe16(dirFile->accessTime, FS_DEFAULT_TIME);
       }
      }
    } else if (i == 1) {
      dirStream = reinterpret_cast<DirStream_t*>(cache);
      dirStream->type = EXFAT_TYPE_STREAM;
    3f14:	movs	r2, #192	; 0xc0
    3f16:	strb	r2, [r6, #0]
      dirStream->flags = EXFAT_FLAG_ALWAYS1;
    3f18:	strb.w	fp, [r6, #1]
      m_flags = modeFlags | FILE_FLAG_DIR_DIRTY;
    3f1c:	strb.w	r3, [r4, #51]	; 0x33
      dirStream->nameLength = fname->nameLength;
    3f20:	ldr	r3, [r5, #16]
    3f22:	strb	r3, [r6, #3]
      setLe16(dirStream->nameHash, fname->nameHash);
    3f24:	ldrh	r3, [r5, #20]
    3f26:	strh	r3, [r6, #4]
    3f28:	b.n	3f3e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x316>
    } else {
      dirName = reinterpret_cast<DirName_t*>(cache);
      dirName->type = EXFAT_TYPE_NAME;
    3f2a:	movs	r3, #193	; 0xc1
    3f2c:	strb	r3, [r6, #0]
    3f2e:	add.w	fp, r6, #30
  /** \return next UTF-16 unit of LFN. */
  uint16_t get16() {return atEnd() ? 0 : *next++;}
#else  // !USE_UTF8_LONG_NAMES
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
    3f32:	ldrh	r2, [r5, #12]
    3f34:	cbnz	r2, 3f5c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x334>
    3f36:	ldr	r1, [r5, #4]
    3f38:	ldr	r2, [r5, #8]
    3f3a:	cmp	r1, r2
    3f3c:	bne.n	3f5c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x334>
    3f3e:	adds	r7, #1
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
  m_dirPos = freePos;
  fname->reset();
  for (uint8_t i = 0; i < freeNeed; i++) {
    3f40:	b.n	3e9a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x272>
        uint16_t u = fname->get16();
        setLe16(dirName->unicode + 2*k, u);
      }
    }
  }
  return sync();
    3f42:	mov	r0, r4
    3f44:	bl	4770 <ExFatFile::sync()>
    3f48:	b.n	3f6c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x344>
  if (isOpen() || !dir->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }

  switch (oflag & O_ACCMODE) {
    3f4a:	cmp	r3, #0
    3f4c:	bne.w	3c9a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    case O_RDONLY:
      modeFlags = FILE_FLAG_READ;
    3f50:	movs	r3, #1
    3f52:	b.n	3c58 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x30>
      break;
    case O_WRONLY:
      modeFlags = FILE_FLAG_WRITE;
    3f54:	movs	r3, #2
    3f56:	b.n	3c58 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x30>
  } else if ((oflag & O_AT_END) && !seekSet(fileSize())) {
    DBG_FAIL_MACRO;
    goto fail;
  }
#endif  // !READ_ONLY
  return true;
    3f58:	movs	r0, #1
    3f5a:	b.n	3f6c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x344>
      dirName->type = EXFAT_TYPE_NAME;
      for (size_t k = 0; k < 15; k++) {
        if (fname->atEnd()) {
          break;
        }
        uint16_t u = fname->get16();
    3f5c:	mov	r0, r5
    3f5e:	bl	3164 <FsName::get16()>
    3f62:	strh.w	r0, [r6, #2]!
      dirStream->nameLength = fname->nameLength;
      setLe16(dirStream->nameHash, fname->nameHash);
    } else {
      dirName = reinterpret_cast<DirName_t*>(cache);
      dirName->type = EXFAT_TYPE_NAME;
      for (size_t k = 0; k < 15; k++) {
    3f66:	cmp	r6, fp
    3f68:	bne.n	3f32 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x30a>
    3f6a:	b.n	3f3e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x316>
 fail:
  // close file
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
    3f6c:	add	sp, #52	; 0x34
    3f6e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    3f72:	nop
    3f74:	.word	0x1fff8418

00003f78 <ExFatFile::open(ExFatFile*, char const*, int)>:
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatFile* dirFile, const char* path, oflag_t oflag) {
    3f78:	push	{r4, r5, r6, r7, lr}
    3f7a:	sub	sp, #92	; 0x5c
    3f7c:	mov	r7, r3
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
    3f7e:	movs	r3, #0
    3f80:	strb.w	r3, [sp, #81]	; 0x51
    3f84:	strb.w	r3, [sp, #82]	; 0x52
    3f88:	strb.w	r3, [sp, #83]	; 0x53
 */
/**
 * \class FsName
 * \brief Handle UTF-8 file names.
 */
class FsName {
    3f8c:	strh.w	r3, [sp, #20]
  ExFatFile tmpDir;
  ExName_t fname;
  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    3f90:	ldrb.w	r3, [r0, #49]	; 0x31
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatFile* dirFile, const char* path, oflag_t oflag) {
    3f94:	str	r2, [sp, #4]
    3f96:	mov	r5, r0
    3f98:	mov	r4, r1
  ExFatFile tmpDir;
  ExName_t fname;
  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    3f9a:	cbz	r3, 3fa0 <ExFatFile::open(ExFatFile*, char const*, int)+0x28>
    close();
  }
  return openPrivate(dirFile, &fname, oflag);

 fail:
  return false;
    3f9c:	movs	r0, #0
    3f9e:	b.n	402e <ExFatFile::open(ExFatFile*, char const*, int)+0xb6>
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatFile* dirFile, const char* path, oflag_t oflag) {
  ExFatFile tmpDir;
  ExName_t fname;
  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    3fa0:	ldrb.w	r3, [r1, #49]	; 0x31
    3fa4:	tst.w	r3, #80	; 0x50
    3fa8:	beq.n	3f9c <ExFatFile::open(ExFatFile*, char const*, int)+0x24>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    3faa:	ldrb	r3, [r2, #0]
    3fac:	cmp	r3, #47	; 0x2f
    3fae:	bne.n	3fd6 <ExFatFile::open(ExFatFile*, char const*, int)+0x5e>
    while (isDirSeparator(*path)) {
    3fb0:	ldr	r3, [sp, #4]
    3fb2:	ldrb	r2, [r3, #0]
    3fb4:	cmp	r2, #47	; 0x2f
    3fb6:	bne.n	3fbe <ExFatFile::open(ExFatFile*, char const*, int)+0x46>
      path++;
    3fb8:	adds	r3, #1
    3fba:	str	r3, [sp, #4]
  if (isOpen() || !dirFile->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    3fbc:	b.n	3fb0 <ExFatFile::open(ExFatFile*, char const*, int)+0x38>
      path++;
    }
    if (*path == 0) {
      return openRoot(dirFile->m_vol);
    3fbe:	ldr	r1, [r4, #32]
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    }
    if (*path == 0) {
    3fc0:	cbnz	r2, 3fca <ExFatFile::open(ExFatFile*, char const*, int)+0x52>
      return openRoot(dirFile->m_vol);
    3fc2:	mov	r0, r5
    3fc4:	bl	3906 <ExFatFile::openRoot(ExFatVolume*)>
    3fc8:	b.n	402e <ExFatFile::open(ExFatFile*, char const*, int)+0xb6>
    }
    if (!tmpDir.openRoot(dirFile->m_vol)) {
    3fca:	add	r0, sp, #32
    3fcc:	bl	3906 <ExFatFile::openRoot(ExFatVolume*)>
    3fd0:	cmp	r0, #0
    3fd2:	beq.n	3f9c <ExFatFile::open(ExFatFile*, char const*, int)+0x24>
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile = &tmpDir;
    3fd4:	add	r4, sp, #32
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    3fd6:	add	r3, sp, #4
    3fd8:	add	r2, sp, #8
    3fda:	ldr	r1, [sp, #4]
    3fdc:	mov	r0, r5
    3fde:	bl	392c <ExFatFile::parsePathName(char const*, ExName_t*, char const**)>
    3fe2:	cmp	r0, #0
    3fe4:	beq.n	3f9c <ExFatFile::open(ExFatFile*, char const*, int)+0x24>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (*path == 0) {
    3fe6:	ldr	r3, [sp, #4]
    3fe8:	ldrb	r3, [r3, #0]
    3fea:	cbz	r3, 4022 <ExFatFile::open(ExFatFile*, char const*, int)+0xaa>
      break;
    }
    if (!openPrivate(dirFile, &fname, O_RDONLY)) {
    3fec:	movs	r3, #0
    3fee:	add	r2, sp, #8
    3ff0:	mov	r1, r4
    3ff2:	mov	r0, r5
    3ff4:	bl	3c28 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)>
    3ff8:	cmp	r0, #0
    3ffa:	beq.n	3f9c <ExFatFile::open(ExFatFile*, char const*, int)+0x24>
      DBG_WARN_MACRO;
      goto fail;
    }
    tmpDir = *this;
    3ffc:	add	r2, sp, #32
    3ffe:	mov	r3, r5
    4000:	add.w	lr, r5, #48	; 0x30
    4004:	mov	r4, r2
    4006:	ldr	r0, [r3, #0]
    4008:	ldr	r1, [r3, #4]
    400a:	mov	r6, r2
    400c:	stmia	r6!, {r0, r1}
    400e:	adds	r3, #8
    4010:	cmp	r3, lr
    4012:	mov	r2, r6
    4014:	bne.n	4006 <ExFatFile::open(ExFatFile*, char const*, int)+0x8e>
    4016:	ldr	r0, [r3, #0]
    4018:	str	r0, [r6, #0]
    dirFile = &tmpDir;
    close();
    401a:	mov	r0, r5
    401c:	bl	38b2 <ExFatFile::close()>
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile = &tmpDir;
  }
  while (1) {
    4020:	b.n	3fd6 <ExFatFile::open(ExFatFile*, char const*, int)+0x5e>
    }
    tmpDir = *this;
    dirFile = &tmpDir;
    close();
  }
  return openPrivate(dirFile, &fname, oflag);
    4022:	mov	r3, r7
    4024:	add	r2, sp, #8
    4026:	mov	r1, r4
    4028:	mov	r0, r5
    402a:	bl	3c28 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)>

 fail:
  return false;
}
    402e:	add	sp, #92	; 0x5c
    4030:	pop	{r4, r5, r6, r7, pc}

00004032 <ExFatFile::open(ExFatVolume*, char const*, int)>:
bool ExFatFile::open(const char* path, oflag_t oflag) {
  return open(ExFatVolume::cwv(), path, oflag);
}
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
    4032:	cbz	r1, 403c <ExFatFile::open(ExFatVolume*, char const*, int)+0xa>
    4034:	add.w	r1, r1, #1096	; 0x448
    4038:	b.w	3f78 <ExFatFile::open(ExFatFile*, char const*, int)>
}
    403c:	mov	r0, r1
    403e:	bx	lr

00004040 <ExFatFile::openNext(ExFatFile*, int)>:
    DBG_FAIL_MACRO;
  }
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openNext(ExFatFile* dir, oflag_t oflag) {
    4040:	push	{r4, r5}
    4042:	mov	r3, r2
  if (isOpen() || !dir->isDir() || (dir->curPosition() & 0X1F)) {
    4044:	ldrb.w	r2, [r0, #49]	; 0x31
    4048:	cbnz	r2, 4068 <ExFatFile::openNext(ExFatFile*, int)+0x28>
    404a:	ldrb.w	r5, [r1, #49]	; 0x31
    404e:	tst.w	r5, #80	; 0x50
    4052:	beq.n	4068 <ExFatFile::openNext(ExFatFile*, int)+0x28>
    4054:	ldrd	r4, r5, [r1]
    4058:	movs	r5, #0
    405a:	and.w	r4, r4, #31
    405e:	orrs	r4, r5
    4060:	bne.n	4068 <ExFatFile::openNext(ExFatFile*, int)+0x28>
  }
  return openPrivate(dir, nullptr, oflag);

 fail:
  return false;
}
    4062:	pop	{r4, r5}
bool ExFatFile::openNext(ExFatFile* dir, oflag_t oflag) {
  if (isOpen() || !dir->isDir() || (dir->curPosition() & 0X1F)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  return openPrivate(dir, nullptr, oflag);
    4064:	b.w	3c28 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)>

 fail:
  return false;
}
    4068:	movs	r0, #0
    406a:	pop	{r4, r5}
    406c:	bx	lr

0000406e <ExFatPartition::bitmapFind(unsigned long, unsigned long)>:
#include "../common/FsStructs.h"
#include "../common/FsGetPartitionInfo.h"

//------------------------------------------------------------------------------
// return 0 if error, 1 if no space, else start cluster.
uint32_t ExFatPartition::bitmapFind(uint32_t cluster, uint32_t count) {
    406e:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4072:	mov	r8, r0
    4074:	mov	sl, r2
  uint32_t start = cluster ? cluster - 2 : m_bitmapStart;
    4076:	mov	r9, r1
    4078:	cbz	r1, 407e <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x10>
    407a:	subs	r4, r1, #2
    407c:	b.n	4082 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x14>
    407e:	ldr.w	r4, [r0, #1056]	; 0x420
  if (start >= m_clusterCount) {
    4082:	ldr.w	r3, [r8, #1072]	; 0x430
    start = 0;
    4086:	cmp	r4, r3
    4088:	it	cs
    408a:	movcs	r4, #0
  uint32_t endAlloc = start;
  uint32_t bgnAlloc = start;
  uint16_t sectorSize = 1 << m_bytesPerSectorShift;
  size_t i = (start >> 3) & (sectorSize - 1);
  uint8_t* cache;
  uint8_t mask = 1 << (start & 7);
    408c:	and.w	r7, r4, #7
    4090:	movs	r3, #1
    4092:	lsl.w	r7, r3, r7
    start = 0;
  }
  uint32_t endAlloc = start;
  uint32_t bgnAlloc = start;
  uint16_t sectorSize = 1 << m_bytesPerSectorShift;
  size_t i = (start >> 3) & (sectorSize - 1);
    4096:	ubfx	fp, r4, #3, #9
  uint8_t* cache;
  uint8_t mask = 1 << (start & 7);
    409a:	uxtb	r7, r7
  uint32_t start = cluster ? cluster - 2 : m_bitmapStart;
  if (start >= m_clusterCount) {
    start = 0;
  }
  uint32_t endAlloc = start;
  uint32_t bgnAlloc = start;
    409c:	mov	r6, r4
uint32_t ExFatPartition::bitmapFind(uint32_t cluster, uint32_t count) {
  uint32_t start = cluster ? cluster - 2 : m_bitmapStart;
  if (start >= m_clusterCount) {
    start = 0;
  }
  uint32_t endAlloc = start;
    409e:	mov	r5, r4
  bool bitmapModify(uint32_t cluster, uint32_t count, bool value);
  //----------------------------------------------------------------------------
  // Cache functions.
  uint8_t* bitmapCacheGet(uint32_t sector, uint8_t option) {
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.get(sector, option);
    40a0:	ldr.w	r1, [r8, #1068]	; 0x42c
    40a4:	movs	r2, #0
    40a6:	add.w	r1, r1, r5, lsr #12
    40aa:	mov	r0, r8
    40ac:	bl	3072 <FsCache::get(unsigned long, unsigned char)>
  uint8_t mask = 1 << (start & 7);
  while (true) {
    uint32_t sector = m_clusterHeapStartSector +
                     (endAlloc >> (m_bytesPerSectorShift + 3));
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
    40b0:	cbz	r0, 4110 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0xa2>
    40b2:	mov	r3, r7
    40b4:	mov	r1, fp
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
        endAlloc++;
        if (!(mask & cache[i])) {
    40b6:	ldrb	r7, [r0, r1]
    40b8:	tst	r7, r3
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
        endAlloc++;
    40ba:	add.w	r5, r5, #1
        if (!(mask & cache[i])) {
    40be:	bne.n	40dc <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x6e>
          if ((endAlloc - bgnAlloc) == count) {
    40c0:	subs	r2, r5, r6
    40c2:	cmp	r2, sl
    40c4:	bne.n	40de <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x70>
            if (cluster == 0 && count == 1) {
    40c6:	cmp.w	r9, #0
    40ca:	bne.n	40d6 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x68>
    40cc:	cmp.w	sl, #1
              // Start at found sector.  bitmapModify may increase this.
              m_bitmapStart = bgnAlloc;
    40d0:	it	eq
    40d2:	streq.w	r6, [r8, #1056]	; 0x420
            }
            return bgnAlloc + 2;
    40d6:	adds	r0, r6, #2
    40d8:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
        endAlloc++;
    40dc:	mov	r6, r5
            return bgnAlloc + 2;
          }
        } else {
          bgnAlloc = endAlloc;
        }
        if (endAlloc == start) {
    40de:	cmp	r4, r5
    40e0:	beq.n	410e <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0xa0>
          return 1;
        }
        if (endAlloc >= m_clusterCount) {
    40e2:	ldr.w	r2, [r8, #1072]	; 0x430
    40e6:	cmp	r5, r2
    40e8:	bcs.n	40f4 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x86>
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
    40ea:	lsls	r3, r3, #1
    40ec:	ands.w	r3, r3, #255	; 0xff
    40f0:	bne.n	40b8 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x4a>
    40f2:	b.n	40fc <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x8e>
        }
        if (endAlloc == start) {
          return 1;
        }
        if (endAlloc >= m_clusterCount) {
          endAlloc = bgnAlloc = 0;
    40f4:	movs	r6, #0
          i = sectorSize;
    40f6:	mov.w	r1, #512	; 0x200
        }
        if (endAlloc == start) {
          return 1;
        }
        if (endAlloc >= m_clusterCount) {
          endAlloc = bgnAlloc = 0;
    40fa:	mov	r5, r6
                     (endAlloc >> (m_bytesPerSectorShift + 3));
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
    40fc:	adds	r1, #1
    40fe:	movs	r3, #1
    4100:	cmp.w	r1, #512	; 0x200
          break;
        }
      }
      mask = 1;
    }
    i = 0;
    4104:	mov.w	fp, #0
          endAlloc = bgnAlloc = 0;
          i = sectorSize;
          break;
        }
      }
      mask = 1;
    4108:	mov	r7, r3
                     (endAlloc >> (m_bytesPerSectorShift + 3));
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
    410a:	bcc.n	40b6 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x48>
    410c:	b.n	40a0 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x32>
          }
        } else {
          bgnAlloc = endAlloc;
        }
        if (endAlloc == start) {
          return 1;
    410e:	movs	r0, #1
      mask = 1;
    }
    i = 0;
  }
  return 0;
}
    4110:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

00004114 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>:
//------------------------------------------------------------------------------
bool ExFatPartition::bitmapModify(uint32_t cluster,
                                  uint32_t count, bool value) {
    4114:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    4118:	mov	r7, r2
    411a:	mov	r6, r0
  uint32_t sector;
  uint32_t start = cluster - 2;
    411c:	subs	r2, r1, #2
  size_t i;
  uint8_t* cache;
  uint8_t mask;
  cluster -= 2;
  if ((start + count) > m_clusterCount) {
    411e:	ldr.w	r0, [r0, #1072]	; 0x430
    4122:	adds	r1, r2, r7
    4124:	cmp	r1, r0
  }
  return 0;
}
//------------------------------------------------------------------------------
bool ExFatPartition::bitmapModify(uint32_t cluster,
                                  uint32_t count, bool value) {
    4126:	mov	r8, r3
  uint32_t start = cluster - 2;
  size_t i;
  uint8_t* cache;
  uint8_t mask;
  cluster -= 2;
  if ((start + count) > m_clusterCount) {
    4128:	bhi.n	41ae <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x9a>
    412a:	ldr.w	r3, [r6, #1056]	; 0x420
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (value) {
    412e:	cmp.w	r8, #0
    4132:	beq.n	4148 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x34>
    if (start  <= m_bitmapStart && m_bitmapStart < (start + count)) {
    4134:	cmp	r2, r3
    4136:	bhi.n	4150 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x3c>
    4138:	cmp	r1, r3
    413a:	bls.n	4150 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x3c>
      m_bitmapStart = (start + count) < m_clusterCount ? start + count : 0;
    413c:	cmp	r1, r0
    413e:	it	cs
    4140:	movcs	r1, #0
    4142:	str.w	r1, [r6, #1056]	; 0x420
    4146:	b.n	4150 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x3c>
    }
  } else {
    if (start < m_bitmapStart) {
    4148:	cmp	r2, r3
      m_bitmapStart = start;
    414a:	it	cc
    414c:	strcc.w	r2, [r6, #1056]	; 0x420
    }
  }
  mask = 1 << (start & 7);
    4150:	and.w	r5, r2, #7
    4154:	movs	r3, #1
  sector = m_clusterHeapStartSector +
                   (start >> (m_bytesPerSectorShift + 3));
    4156:	ldr.w	r1, [r6, #1068]	; 0x42c
  } else {
    if (start < m_bitmapStart) {
      m_bitmapStart = start;
    }
  }
  mask = 1 << (start & 7);
    415a:	lsl.w	r5, r3, r5
    415e:	uxtb	r5, r5
  sector = m_clusterHeapStartSector +
                   (start >> (m_bytesPerSectorShift + 3));
    4160:	add.w	r1, r1, r2, lsr #12
  i = (start >> 3) & m_sectorMask;
    4164:	ubfx	r4, r2, #3, #9
    4168:	movs	r2, #1
    416a:	mov	r0, r6
  while (true) {
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    416c:	add.w	r9, r1, #1
    4170:	bl	3072 <FsCache::get(unsigned long, unsigned char)>
    if (!cache) {
    4174:	cbz	r0, 41ae <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x9a>
    4176:	adds	r3, r0, r4
    4178:	mov	r2, r5
    417a:	add.w	r0, r0, #512	; 0x200
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
      for (; mask; mask <<= 1) {
        if (value == static_cast<bool>(cache[i] & mask)) {
    417e:	ldrb	r1, [r3, #0]
    4180:	tst	r1, r2
    4182:	ite	ne
    4184:	movne	r4, #1
    4186:	moveq	r4, #0
    4188:	cmp	r4, r8
    418a:	beq.n	41ae <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x9a>
          DBG_FAIL_MACRO;
          goto fail;
        }
        cache[i] ^= mask;
    418c:	eors	r1, r2
        if (--count == 0) {
    418e:	subs	r7, #1
      for (; mask; mask <<= 1) {
        if (value == static_cast<bool>(cache[i] & mask)) {
          DBG_FAIL_MACRO;
          goto fail;
        }
        cache[i] ^= mask;
    4190:	strb	r1, [r3, #0]
        if (--count == 0) {
    4192:	beq.n	41b4 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0xa0>
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
      for (; mask; mask <<= 1) {
    4194:	lsls	r2, r2, #1
    4196:	ands.w	r2, r2, #255	; 0xff
    419a:	bne.n	417e <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x6a>
    419c:	adds	r3, #1
          return true;
        }
      }
      mask = 1;
    }
    i = 0;
    419e:	mov	r4, r2
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
    41a0:	cmp	r0, r3
    41a2:	mov.w	r2, #1
  mask = 1 << (start & 7);
  sector = m_clusterHeapStartSector +
                   (start >> (m_bytesPerSectorShift + 3));
  i = (start >> 3) & m_sectorMask;
  while (true) {
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    41a6:	mov	r1, r9
        cache[i] ^= mask;
        if (--count == 0) {
          return true;
        }
      }
      mask = 1;
    41a8:	mov	r5, r2
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
    41aa:	bne.n	417e <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x6a>
    41ac:	b.n	4168 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x54>
    }
    i = 0;
  }

 fail:
  return false;
    41ae:	movs	r0, #0
    41b0:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
          DBG_FAIL_MACRO;
          goto fail;
        }
        cache[i] ^= mask;
        if (--count == 0) {
          return true;
    41b4:	movs	r0, #1
    i = 0;
  }

 fail:
  return false;
}
    41b6:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

000041ba <ExFatPartition::dirCache(DirPos_t*, unsigned char)>:
    n++;
  } while (status);
  return n;
}
//------------------------------------------------------------------------------
uint8_t* ExFatPartition::dirCache(DirPos_t* pos, uint8_t options) {
    41ba:	push	{r3, r4, r5, lr}
    41bc:	mov	r5, r1
#endif  // USE_EXFAT_BITMAP_CACHE
  }
  void dataCacheDirty() {m_dataCache.dirty();}
  void dataCacheInvalidate() {m_dataCache.invalidate();}
  uint8_t* dataCacheGet(uint32_t sector, uint8_t option) {
    return m_dataCache.get(sector, option);
    41be:	ldr.w	r1, [r0, #1080]	; 0x438
    41c2:	ldr	r3, [r5, #4]
    41c4:	ands	r1, r3
    41c6:	ldr	r3, [r5, #0]
    41c8:	subs	r4, r3, #2
    41ca:	ldrb.w	r3, [r0, #1093]	; 0x445
    41ce:	lsl.w	r3, r4, r3
    41d2:	add.w	r3, r3, r1, lsr #9
    41d6:	ldr.w	r1, [r0, #1068]	; 0x42c
    41da:	add.w	r0, r0, #528	; 0x210
    41de:	add	r1, r3
    41e0:	bl	3072 <FsCache::get(unsigned long, unsigned char)>
  uint32_t sector = clusterStartSector(pos->cluster);
  sector += (m_clusterMask & pos->position) >> m_bytesPerSectorShift;
  uint8_t* cache = dataCacheGet(sector, options);
  return cache ? cache + (pos->position & m_sectorMask) : nullptr;
    41e4:	cbz	r0, 41ee <ExFatPartition::dirCache(DirPos_t*, unsigned char)+0x34>
    41e6:	ldr	r3, [r5, #4]
    41e8:	ubfx	r3, r3, #0, #9
    41ec:	add	r0, r3
}
    41ee:	pop	{r3, r4, r5, pc}

000041f0 <ExFatPartition::fatGet(unsigned long, unsigned long*)>:
  }
  return 1;
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::fatGet(uint32_t cluster, uint32_t* value) {
    41f0:	push	{r3, r4, r5, lr}
  uint8_t* cache;
  uint32_t next;
  uint32_t sector;

  if (cluster > (m_clusterCount + 1)) {
    41f2:	ldr.w	r3, [r0, #1072]	; 0x430
    41f6:	adds	r3, #1
    41f8:	cmp	r3, r1
  }
  return 1;
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::fatGet(uint32_t cluster, uint32_t* value) {
    41fa:	mov	r4, r1
    41fc:	mov	r5, r2
  uint8_t* cache;
  uint32_t next;
  uint32_t sector;

  if (cluster > (m_clusterCount + 1)) {
    41fe:	bcs.n	4206 <ExFatPartition::fatGet(unsigned long, unsigned long*)+0x16>
    DBG_FAIL_MACRO;
    return -1;
    4200:	mov.w	r0, #4294967295
    4204:	pop	{r3, r4, r5, pc}
    4206:	ldr.w	r1, [r0, #1060]	; 0x424
    420a:	movs	r2, #0
    420c:	add.w	r1, r1, r4, lsr #7
    4210:	add.w	r0, r0, #528	; 0x210
    4214:	bl	3072 <FsCache::get(unsigned long, unsigned char)>
  }
  sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));

  cache = dataCacheGet(sector, FsCache::CACHE_FOR_READ);
  if (!cache) {
    4218:	cmp	r0, #0
    421a:	beq.n	4200 <ExFatPartition::fatGet(unsigned long, unsigned long*)+0x10>
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    421c:	lsls	r4, r4, #2
    421e:	ubfx	r4, r4, #0, #9
    4222:	ldr	r0, [r0, r4]
    return -1;
  }
  next = getLe32(cache + ((cluster << 2) & m_sectorMask));
  *value = next;
    4224:	str	r0, [r5, #0]
  return next == EXFAT_EOC ? 0 : 1;
    4226:	adds	r0, #1
    4228:	it	ne
    422a:	movne	r0, #1
}
    422c:	pop	{r3, r4, r5, pc}

0000422e <ExFatPartition::chainSize(unsigned long)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
uint32_t ExFatPartition::chainSize(uint32_t cluster) {
    422e:	push	{r0, r1, r4, r5, r6, lr}
    4230:	add	r5, sp, #8
    4232:	mov	r6, r0
    4234:	str.w	r1, [r5, #-4]!
  uint32_t n = 0;
    4238:	movs	r4, #0
  int8_t status;
  do {
    status = fatGet(cluster, & cluster);
    423a:	mov	r2, r5
    423c:	ldr	r1, [sp, #4]
    423e:	mov	r0, r6
    4240:	bl	41f0 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
    if (status < 0) return 0;
    4244:	cmp	r0, #0
    4246:	blt.n	4252 <ExFatPartition::chainSize(unsigned long)+0x24>
    n++;
    4248:	add.w	r4, r4, #1
}
//------------------------------------------------------------------------------
uint32_t ExFatPartition::chainSize(uint32_t cluster) {
  uint32_t n = 0;
  int8_t status;
  do {
    424c:	bne.n	423a <ExFatPartition::chainSize(unsigned long)+0xc>
    status = fatGet(cluster, & cluster);
    if (status < 0) return 0;
    n++;
    424e:	mov	r0, r4
    4250:	b.n	4254 <ExFatPartition::chainSize(unsigned long)+0x26>
uint32_t ExFatPartition::chainSize(uint32_t cluster) {
  uint32_t n = 0;
  int8_t status;
  do {
    status = fatGet(cluster, & cluster);
    if (status < 0) return 0;
    4252:	movs	r0, #0
    n++;
  } while (status);
  return n;
}
    4254:	add	sp, #8
    4256:	pop	{r4, r5, r6, pc}

00004258 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)>:
  uint8_t* cache = dataCacheGet(sector, options);
  return cache ? cache + (pos->position & m_sectorMask) : nullptr;
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
    4258:	push	{r4, r5, r6, lr}
    425a:	mov	r5, r1
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
    425c:	ldr.w	r4, [r0, #1080]	; 0x438
    4260:	ldr	r1, [r1, #4]
    4262:	ands	r4, r1
    4264:	adds	r3, r4, r2
  pos->position += offset;
    4266:	add	r2, r1
    4268:	str	r2, [r5, #4]
  tmp >>= bytesPerClusterShift();
    426a:	ldrb.w	r4, [r0, #1093]	; 0x445
    426e:	adds	r4, #9
    4270:	uxtb	r4, r4
  uint8_t* cache = dataCacheGet(sector, options);
  return cache ? cache + (pos->position & m_sectorMask) : nullptr;
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
    4272:	mov	r6, r0
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
  pos->position += offset;
  tmp >>= bytesPerClusterShift();
    4274:	lsr.w	r4, r3, r4
  while (tmp--) {
    4278:	cbz	r4, 4298 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x40>
    if (pos->isContiguous) {
    427a:	ldrb	r3, [r5, #8]
    427c:	cbz	r3, 4288 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x30>
      pos->cluster++;
    427e:	ldr	r3, [r5, #0]
    4280:	adds	r3, #1
    4282:	str	r3, [r5, #0]
    4284:	subs	r4, #1
    4286:	b.n	4278 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x20>
    } else {
      status = fatGet(pos->cluster, &pos->cluster);
    4288:	mov	r2, r5
    428a:	ldr	r1, [r5, #0]
    428c:	mov	r0, r6
    428e:	bl	41f0 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
      if (status != 1) {
    4292:	cmp	r0, #1
    4294:	beq.n	4284 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x2c>
    4296:	pop	{r4, r5, r6, pc}
        return status;
      }
    }
  }
  return 1;
    4298:	movs	r0, #1
}
    429a:	pop	{r4, r5, r6, pc}

0000429c <ExFatPartition::fatPut(unsigned long, unsigned long)>:
}
//------------------------------------------------------------------------------
bool ExFatPartition::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t sector;
  uint8_t* cache;
  if (cluster < 2 || cluster > (m_clusterCount + 1)) {
    429c:	cmp	r1, #1
  next = getLe32(cache + ((cluster << 2) & m_sectorMask));
  *value = next;
  return next == EXFAT_EOC ? 0 : 1;
}
//------------------------------------------------------------------------------
bool ExFatPartition::fatPut(uint32_t cluster, uint32_t value) {
    429e:	push	{r3, r4, r5, lr}
    42a0:	mov	r4, r1
    42a2:	mov	r5, r2
  uint32_t sector;
  uint8_t* cache;
  if (cluster < 2 || cluster > (m_clusterCount + 1)) {
    42a4:	bhi.n	42aa <ExFatPartition::fatPut(unsigned long, unsigned long)+0xe>
  }
  setLe32(cache + ((cluster << 2) & m_sectorMask), value);
  return true;

 fail:
  return false;
    42a6:	movs	r0, #0
    42a8:	pop	{r3, r4, r5, pc}
}
//------------------------------------------------------------------------------
bool ExFatPartition::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t sector;
  uint8_t* cache;
  if (cluster < 2 || cluster > (m_clusterCount + 1)) {
    42aa:	ldr.w	r3, [r0, #1072]	; 0x430
    42ae:	adds	r3, #1
    42b0:	cmp	r1, r3
    42b2:	bhi.n	42a6 <ExFatPartition::fatPut(unsigned long, unsigned long)+0xa>
    42b4:	ldr.w	r1, [r0, #1060]	; 0x424
    42b8:	movs	r2, #1
    42ba:	add.w	r1, r1, r4, lsr #7
    42be:	add.w	r0, r0, #528	; 0x210
    42c2:	bl	3072 <FsCache::get(unsigned long, unsigned char)>
    DBG_FAIL_MACRO;
    goto fail;
  }
  sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));
  cache = dataCacheGet(sector, FsCache::CACHE_FOR_WRITE);
  if (!cache) {
    42c6:	cmp	r0, #0
    42c8:	beq.n	42a6 <ExFatPartition::fatPut(unsigned long, unsigned long)+0xa>
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    42ca:	lsls	r4, r4, #2
    42cc:	ubfx	r4, r4, #0, #9
    42d0:	str	r5, [r0, r4]
    DBG_FAIL_MACRO;
    goto fail;
  }
  setLe32(cache + ((cluster << 2) & m_sectorMask), value);
  return true;
    42d2:	movs	r0, #1

 fail:
  return false;
}
    42d4:	pop	{r3, r4, r5, pc}

000042d6 <ExFatPartition::freeChain(unsigned long)>:
//------------------------------------------------------------------------------
bool ExFatPartition::freeChain(uint32_t cluster) {
    42d6:	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    42da:	mov	r7, r0
    42dc:	mov	r4, r1
  uint32_t next;
  uint32_t start = cluster;
    42de:	mov	r6, r1
  int8_t status;
  do {
    status = fatGet(cluster, &next);
    42e0:	add	r2, sp, #4
    42e2:	mov	r1, r4
    42e4:	mov	r0, r7
    42e6:	bl	41f0 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
    if (status < 0) {
    42ea:	subs.w	r8, r0, #0
    42ee:	bge.n	42f4 <ExFatPartition::freeChain(unsigned long)+0x1e>
  } while (status);

  return true;

 fail:
  return false;
    42f0:	movs	r5, #0
    42f2:	b.n	432c <ExFatPartition::freeChain(unsigned long)+0x56>
    status = fatGet(cluster, &next);
    if (status < 0) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!fatPut(cluster, 0)) {
    42f4:	movs	r2, #0
    42f6:	mov	r1, r4
    42f8:	mov	r0, r7
    42fa:	bl	429c <ExFatPartition::fatPut(unsigned long, unsigned long)>
    42fe:	mov	r5, r0
    4300:	cmp	r0, #0
    4302:	beq.n	42f0 <ExFatPartition::freeChain(unsigned long)+0x1a>
    4304:	adds	r2, r4, #1
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (status == 0 || (cluster + 1) != next) {
    4306:	cmp.w	r8, #0
    430a:	beq.n	4312 <ExFatPartition::freeChain(unsigned long)+0x3c>
    430c:	ldr	r3, [sp, #4]
    430e:	cmp	r2, r3
    4310:	beq.n	4324 <ExFatPartition::freeChain(unsigned long)+0x4e>
      if (!bitmapModify(start, cluster - start + 1, 0)) {
    4312:	movs	r3, #0
    4314:	subs	r2, r2, r6
    4316:	mov	r1, r6
    4318:	mov	r0, r7
    431a:	bl	4114 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    431e:	cmp	r0, #0
    4320:	beq.n	42f0 <ExFatPartition::freeChain(unsigned long)+0x1a>
        DBG_FAIL_MACRO;
        goto fail;
      }
      start = next;
    4322:	ldr	r6, [sp, #4]
    }
    cluster = next;
    4324:	ldr	r4, [sp, #4]
//------------------------------------------------------------------------------
bool ExFatPartition::freeChain(uint32_t cluster) {
  uint32_t next;
  uint32_t start = cluster;
  int8_t status;
  do {
    4326:	cmp.w	r8, #0
    432a:	bne.n	42e0 <ExFatPartition::freeChain(unsigned long)+0xa>

  return true;

 fail:
  return false;
}
    432c:	mov	r0, r5
    432e:	add	sp, #8
    4330:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00004334 <ExFatPartition::freeClusterCount()>:
//------------------------------------------------------------------------------
uint32_t ExFatPartition::freeClusterCount() {
    4334:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t nc = 0;
  uint32_t sector = m_clusterHeapStartSector;
    4338:	ldr.w	r1, [r0, #1068]	; 0x42c
  uint32_t usedCount = 0;
    433c:	movs	r4, #0

 fail:
  return false;
}
//------------------------------------------------------------------------------
uint32_t ExFatPartition::freeClusterCount() {
    433e:	mov	r6, r0
  uint32_t nc = 0;
    4340:	mov	r5, r4
    4342:	add.w	r7, r0, #528	; 0x210
    4346:	movs	r2, #0
    4348:	mov	r0, r7
  uint32_t sector = m_clusterHeapStartSector;
  uint32_t usedCount = 0;
  uint8_t* cache;

  while (true) {
    cache = dataCacheGet(sector++, FsCache::CACHE_FOR_READ);
    434a:	add.w	r8, r1, #1
    434e:	bl	3072 <FsCache::get(unsigned long, unsigned char)>
    if (!cache) {
    4352:	cbz	r0, 4394 <ExFatPartition::freeClusterCount()+0x60>
    4354:	add.w	lr, r0, #4294967295
    4358:	add.w	ip, r5, #4096	; 0x1000
      return 0;
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
      if (cache[i] == 0XFF) {
    435c:	ldrb.w	r1, [lr, #1]!
    4360:	cmp	r1, #255	; 0xff
    4362:	bne.n	4368 <ExFatPartition::freeClusterCount()+0x34>
        usedCount+= 8;
    4364:	adds	r4, #8
    4366:	b.n	437c <ExFatPartition::freeClusterCount()+0x48>
      } else if (cache[i]) {
    4368:	cbz	r1, 437c <ExFatPartition::freeClusterCount()+0x48>
    436a:	movs	r2, #8
    436c:	movs	r3, #1
        for (uint8_t mask = 1; mask ; mask <<=1) {
          if ((mask & cache[i])) {
    436e:	tst	r1, r3
            usedCount++;
    4370:	it	ne
    4372:	addne	r4, #1
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
      if (cache[i] == 0XFF) {
        usedCount+= 8;
      } else if (cache[i]) {
        for (uint8_t mask = 1; mask ; mask <<=1) {
    4374:	lsls	r3, r3, #1
    4376:	subs	r2, #1
    4378:	uxtb	r3, r3
    437a:	bne.n	436e <ExFatPartition::freeClusterCount()+0x3a>
            usedCount++;
          }
        }
      }
      nc += 8;
      if (nc >= m_clusterCount) {
    437c:	ldr.w	r0, [r6, #1072]	; 0x430
          if ((mask & cache[i])) {
            usedCount++;
          }
        }
      }
      nc += 8;
    4380:	adds	r5, #8
      if (nc >= m_clusterCount) {
    4382:	cmp	r5, r0
    4384:	bcc.n	438c <ExFatPartition::freeClusterCount()+0x58>
        return m_clusterCount - usedCount;
    4386:	subs	r0, r0, r4
    4388:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  while (true) {
    cache = dataCacheGet(sector++, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
    438c:	cmp	r5, ip
  uint32_t sector = m_clusterHeapStartSector;
  uint32_t usedCount = 0;
  uint8_t* cache;

  while (true) {
    cache = dataCacheGet(sector++, FsCache::CACHE_FOR_READ);
    438e:	mov	r1, r8
    if (!cache) {
      return 0;
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
    4390:	bne.n	435c <ExFatPartition::freeClusterCount()+0x28>
    4392:	b.n	4346 <ExFatPartition::freeClusterCount()+0x12>
      if (nc >= m_clusterCount) {
        return m_clusterCount - usedCount;
      }
    }
  }
}
    4394:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00004398 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)>:
//------------------------------------------------------------------------------
bool ExFatPartition::init(BlockDevice* dev, uint8_t part) {
    4398:	push	{r4, r5, r6, r7, lr}
    439a:	mov	r4, r0
    439c:	sub	sp, #28
  MbrSector_t* mbr;
  MbrPart_t* mp;
  #endif
  BpbExFat_t* bpb;

  m_fatType = 0;
    439e:	movs	r5, #0
      }
    }
  }
}
//------------------------------------------------------------------------------
bool ExFatPartition::init(BlockDevice* dev, uint8_t part) {
    43a0:	mov	r0, r1
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    43a2:	mov.w	r3, #4294967295
    43a6:	mov	r1, r2
    43a8:	str	r3, [r4, #12]
    43aa:	str.w	r3, [r4, #540]	; 0x21c
  MbrSector_t* mbr;
  MbrPart_t* mp;
  #endif
  BpbExFat_t* bpb;

  m_fatType = 0;
    43ae:	strb.w	r5, [r4, #1092]	; 0x444
  m_blockDev = dev;
    43b2:	str.w	r0, [r4, #1088]	; 0x440
  }
  /** Initialize the cache.
   * \param[in] blockDev Block device for this cache.
   */
  void init(BlockDevice* blockDev) {
    m_blockDev = blockDev;
    43b6:	str	r0, [r4, #4]
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    43b8:	strb	r5, [r4, #0]
  }
  /** Initialize the cache.
   * \param[in] blockDev Block device for this cache.
   */
  void init(BlockDevice* blockDev) {
    m_blockDev = blockDev;
    43ba:	str.w	r0, [r4, #532]	; 0x214
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    43be:	strb.w	r5, [r4, #528]	; 0x210
  cacheInit(m_blockDev);


  #if SUPPORT_GPT_AND_EXTENDED_PATITIONS 
  cache = cacheClear(); // get buffer to use. 
  FsGetPartitionInfo::voltype_t vt = FsGetPartitionInfo::getPartitionInfo(m_blockDev, part,cache, &firstLBA);
    43c2:	str	r5, [sp, #8]
    43c4:	str	r5, [sp, #4]
    43c6:	str	r5, [sp, #0]
    43c8:	add	r3, sp, #20
    43ca:	add.w	r2, r4, #544	; 0x220
    43ce:	bl	2de8 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)>
  if ((vt == FsGetPartitionInfo::INVALID_VOL) || (vt == FsGetPartitionInfo::OTHER_VOL)) {
    43d2:	tst.w	r0, #251	; 0xfb
  uint8_t* clear() {
    if (isDirty() && !sync()) {
      return nullptr;
    }
    invalidate();
    return m_buffer;
    43d6:	add.w	r7, r4, #528	; 0x210
    43da:	bne.n	43e0 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x48>
  bitmapFind(0, 1);
  m_fatType = FAT_TYPE_EXFAT;
  return true;

 fail:
  return false;
    43dc:	movs	r0, #0
    43de:	b.n	445a <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0xc2>
  FsGetPartitionInfo::voltype_t vt = FsGetPartitionInfo::getPartitionInfo(m_blockDev, part,cache, &firstLBA);
  if ((vt == FsGetPartitionInfo::INVALID_VOL) || (vt == FsGetPartitionInfo::OTHER_VOL)) {
    DBG_FAIL_MACRO;
    goto fail;    
  }
  volStart = firstLBA;
    43e0:	ldr	r6, [sp, #20]
    43e2:	mov	r2, r5
    43e4:	mov	r1, r6
    43e6:	mov	r0, r7
    43e8:	bl	3072 <FsCache::get(unsigned long, unsigned char)>
  }
  volStart = getLe32(mp->relativeSectors);
  #endif

  cache = dataCacheGet(volStart, FsCache::CACHE_FOR_READ);
  if (!cache) {
    43ec:	mov	r5, r0
    43ee:	cmp	r0, #0
    43f0:	beq.n	43dc <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x44>
    DBG_FAIL_MACRO;
    goto fail;
  }
  pbs = reinterpret_cast<pbs_t*>(cache);
  if (strncmp(pbs->oemName, "EXFAT", 5)) {
    43f2:	ldr	r1, [pc, #108]	; (4460 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0xc8>)
    43f4:	movs	r2, #5
    43f6:	adds	r0, #3
    43f8:	bl	b7dc <strncmp>
    43fc:	mov	r1, r0
    43fe:	cmp	r0, #0
    4400:	bne.n	43dc <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x44>
    DBG_FAIL_MACRO;
    goto fail;
  }
  bpb = reinterpret_cast<BpbExFat_t*>(pbs->bpb);
  if (bpb->bytesPerSectorShift != m_bytesPerSectorShift) {
    4402:	ldrb.w	r3, [r5, #108]	; 0x6c
    4406:	cmp	r3, #9
    4408:	bne.n	43dc <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x44>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_fatStartSector = volStart + getLe32(bpb->fatOffset);
    440a:	ldr	r3, [r5, #80]	; 0x50
    440c:	add	r3, r6
    440e:	str.w	r3, [r4, #1060]	; 0x424
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    4412:	ldr	r3, [r5, #84]	; 0x54
  m_fatLength = getLe32(bpb->fatLength);
    4414:	str.w	r3, [r4, #1064]	; 0x428
  m_clusterHeapStartSector = volStart + getLe32(bpb->clusterHeapOffset);
    4418:	ldr	r3, [r5, #88]	; 0x58
    441a:	add	r6, r3
    441c:	str.w	r6, [r4, #1068]	; 0x42c
    4420:	ldr	r3, [r5, #92]	; 0x5c
  m_clusterCount = getLe32(bpb->clusterCount);
    4422:	str.w	r3, [r4, #1072]	; 0x430
    4426:	ldr	r3, [r5, #96]	; 0x60
  m_rootDirectoryCluster = getLe32(bpb->rootDirectoryCluster);
    4428:	str.w	r3, [r4, #1076]	; 0x434
  m_sectorsPerClusterShift = bpb->sectorsPerClusterShift;
    442c:	ldrb.w	r3, [r5, #109]	; 0x6d
    4430:	strb.w	r3, [r4, #1093]	; 0x445
  m_bytesPerCluster = 1UL << (m_bytesPerSectorShift + m_sectorsPerClusterShift);
    4434:	movs	r5, #1
    4436:	adds	r3, #9
    4438:	lsl.w	r3, r5, r3
    443c:	str.w	r3, [r4, #1084]	; 0x43c
  m_clusterMask = m_bytesPerCluster - 1;
    4440:	subs	r3, #1
    4442:	str.w	r3, [r4, #1080]	; 0x438
  // Set m_bitmapStart to first free cluster.
  m_bitmapStart = 0;
    4446:	str.w	r0, [r4, #1056]	; 0x420
  bitmapFind(0, 1);
    444a:	mov	r2, r5
    444c:	mov	r0, r4
    444e:	bl	406e <ExFatPartition::bitmapFind(unsigned long, unsigned long)>
  m_fatType = FAT_TYPE_EXFAT;
    4452:	movs	r3, #64	; 0x40
    4454:	strb.w	r3, [r4, #1092]	; 0x444
  return true;
    4458:	mov	r0, r5

 fail:
  return false;
}
    445a:	add	sp, #28
    445c:	pop	{r4, r5, r6, r7, pc}
    445e:	nop
    4460:	.word	0x00012513

00004464 <ExFatPartition::rootLength()>:
//------------------------------------------------------------------------------
uint32_t ExFatPartition::rootLength() {
    4464:	push	{r4, lr}
    4466:	mov	r4, r0
  uint32_t nc = chainSize(m_rootDirectoryCluster);
    4468:	ldr.w	r1, [r0, #1076]	; 0x434
    446c:	bl	422e <ExFatPartition::chainSize(unsigned long)>
  return nc << bytesPerClusterShift();
    4470:	ldrb.w	r3, [r4, #1093]	; 0x445
    4474:	adds	r3, #9
    4476:	uxtb	r3, r3
}
    4478:	lsls	r0, r3
    447a:	pop	{r4, pc}

0000447c <ExFatVolume::chdir(char const*)>:
#define DBG_FILE "ExFatVolume.cpp"
#include "../common/DebugMacros.h"
#include "ExFatVolume.h"
ExFatVolume* ExFatVolume::m_cwv = nullptr;
//-----------------------------------------------------------------------------
bool ExFatVolume::chdir(const char* path) {
    447c:	push	{r4, r5, r6, lr}
#endif  // ENABLE_ARDUINO_STRING

 private:
  friend ExFatFile;
  static ExFatVolume* cwv() {return m_cwv;}
  ExFatFile* vwd() {return &m_vwd;}
    447e:	add.w	r4, r0, #1096	; 0x448
    4482:	sub	sp, #56	; 0x38
    4484:	movs	r3, #0
  ExFatFile dir;
  if (!dir.open(vwd(), path, O_RDONLY)) {
    4486:	mov	r2, r1
    4488:	mov	r0, sp
    448a:	mov	r1, r4
    448c:	strb.w	r3, [sp, #49]	; 0x31
    4490:	strb.w	r3, [sp, #50]	; 0x32
    4494:	strb.w	r3, [sp, #51]	; 0x33
    4498:	bl	3f78 <ExFatFile::open(ExFatFile*, char const*, int)>
    449c:	mov	r5, r0
    449e:	cbz	r0, 44ca <ExFatVolume::chdir(char const*)+0x4e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!dir.isDir()) {
    44a0:	ldrb.w	r3, [sp, #49]	; 0x31
    44a4:	ands.w	r3, r3, #80	; 0x50
    44a8:	beq.n	44c8 <ExFatVolume::chdir(char const*)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_vwd = dir;
    44aa:	mov	r2, sp
    44ac:	mov	r3, r4
    44ae:	add	r6, sp, #48	; 0x30
    44b0:	mov	r4, r2
    44b2:	ldmia	r4!, {r0, r1}
    44b4:	cmp	r4, r6
    44b6:	str	r0, [r3, #0]
    44b8:	str	r1, [r3, #4]
    44ba:	mov	r2, r4
    44bc:	add.w	r3, r3, #8
    44c0:	bne.n	44b0 <ExFatVolume::chdir(char const*)+0x34>
    44c2:	ldr	r0, [r4, #0]
    44c4:	str	r0, [r3, #0]
  return true;
    44c6:	b.n	44ca <ExFatVolume::chdir(char const*)+0x4e>

 fail:
  return false;
    44c8:	mov	r5, r3
}
    44ca:	mov	r0, r5
    44cc:	add	sp, #56	; 0x38
    44ce:	pop	{r4, r5, r6, pc}

000044d0 <exFatDirChecksum(unsigned char const*, unsigned short)>:
  return false;
}
//==============================================================================
#else  // READ_ONLY
//------------------------------------------------------------------------------
static uint16_t exFatDirChecksum(const uint8_t* data, uint16_t checksum) {
    44d0:	push	{r4, lr}
  bool skip = data[0] == EXFAT_TYPE_FILE;
    44d2:	ldrb	r4, [r0, #0]
  for (size_t i = 0; i < 32; i += i == 1 && skip ? 3 : 1) {
    44d4:	movs	r3, #0
    44d6:	lsls	r2, r1, #15
    44d8:	orr.w	r1, r2, r1, lsr #1
    checksum = ((checksum << 15) | (checksum >> 1)) + data[i];
    44dc:	ldrb	r2, [r0, r3]
//==============================================================================
#else  // READ_ONLY
//------------------------------------------------------------------------------
static uint16_t exFatDirChecksum(const uint8_t* data, uint16_t checksum) {
  bool skip = data[0] == EXFAT_TYPE_FILE;
  for (size_t i = 0; i < 32; i += i == 1 && skip ? 3 : 1) {
    44de:	cmp	r3, #1
    checksum = ((checksum << 15) | (checksum >> 1)) + data[i];
    44e0:	uxtah	r1, r2, r1
    44e4:	uxth	r1, r1
//==============================================================================
#else  // READ_ONLY
//------------------------------------------------------------------------------
static uint16_t exFatDirChecksum(const uint8_t* data, uint16_t checksum) {
  bool skip = data[0] == EXFAT_TYPE_FILE;
  for (size_t i = 0; i < 32; i += i == 1 && skip ? 3 : 1) {
    44e6:	bne.n	44f2 <exFatDirChecksum(unsigned char const*, unsigned short)+0x22>
    44e8:	cmp	r4, #133	; 0x85
    44ea:	ite	ne
    44ec:	movne	r2, #1
    44ee:	moveq	r2, #3
    44f0:	b.n	44f4 <exFatDirChecksum(unsigned char const*, unsigned short)+0x24>
    44f2:	movs	r2, #1
    44f4:	add	r3, r2
    44f6:	cmp	r3, #31
    44f8:	bls.n	44d6 <exFatDirChecksum(unsigned char const*, unsigned short)+0x6>
    checksum = ((checksum << 15) | (checksum >> 1)) + data[i];
  }
  return checksum;
}
    44fa:	mov	r0, r1
    44fc:	pop	{r4, pc}

000044fe <ExFatPartition::cacheSync()>:
#if USE_EXFAT_BITMAP_CACHE
    m_bitmapCache.init(dev);
#endif  // USE_EXFAT_BITMAP_CACHE
    m_dataCache.init(dev);
  }
  bool cacheSync() {
    44fe:	push	{r4, lr}
    4500:	mov	r4, r0
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.sync() && m_dataCache.sync() && syncDevice();
    4502:	bl	3026 <FsCache::sync()>
    4506:	cbz	r0, 4520 <ExFatPartition::cacheSync()+0x22>
    4508:	add.w	r0, r4, #528	; 0x210
    450c:	bl	3026 <FsCache::sync()>
    4510:	cbz	r0, 4520 <ExFatPartition::cacheSync()+0x22>
    4512:	ldr.w	r0, [r4, #1088]	; 0x440
  bool fatPut(uint32_t cluster, uint32_t value);
  uint32_t chainSize(uint32_t cluster);
  bool freeChain(uint32_t cluster);
  uint16_t sectorMask() const {return m_sectorMask;}
  bool syncDevice() {
    return m_blockDev->syncDevice();
    4516:	ldr	r3, [r0, #0]
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.sync() && m_dataCache.sync() && syncDevice();
#else  // USE_EXFAT_BITMAP_CACHE
    return m_dataCache.sync() && syncDevice();
#endif  // USE_EXFAT_BITMAP_CACHE
  }
    4518:	ldmia.w	sp!, {r4, lr}
  bool fatPut(uint32_t cluster, uint32_t value);
  uint32_t chainSize(uint32_t cluster);
  bool freeChain(uint32_t cluster);
  uint16_t sectorMask() const {return m_sectorMask;}
  bool syncDevice() {
    return m_blockDev->syncDevice();
    451c:	ldr	r3, [r3, #28]
    451e:	bx	r3
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.sync() && m_dataCache.sync() && syncDevice();
#else  // USE_EXFAT_BITMAP_CACHE
    return m_dataCache.sync() && syncDevice();
#endif  // USE_EXFAT_BITMAP_CACHE
  }
    4520:	movs	r0, #0
    4522:	pop	{r4, pc}

00004524 <ExFatFile::addCluster()>:
//------------------------------------------------------------------------------
bool ExFatFile::addCluster() {
    4524:	push	{r3, r4, r5, r6, r7, lr}
    4526:	mov	r4, r0
  uint32_t find = m_vol->bitmapFind(m_curCluster ?  m_curCluster + 1 : 0, 1);
    4528:	ldr	r0, [r0, #32]
    452a:	ldr	r1, [r4, #24]
    452c:	cbz	r1, 4530 <ExFatFile::addCluster()+0xc>
    452e:	adds	r1, #1
    4530:	movs	r2, #1
    4532:	bl	406e <ExFatPartition::bitmapFind(unsigned long, unsigned long)>
  if (find < 2) {
    4536:	cmp	r0, #1
  }
  return checksum;
}
//------------------------------------------------------------------------------
bool ExFatFile::addCluster() {
  uint32_t find = m_vol->bitmapFind(m_curCluster ?  m_curCluster + 1 : 0, 1);
    4538:	mov	r5, r0
  if (find < 2) {
    453a:	bhi.n	4540 <ExFatFile::addCluster()+0x1c>
 done:
  m_curCluster = find;
  return true;

 fail:
  return false;
    453c:	movs	r6, #0
    453e:	b.n	45b2 <ExFatFile::addCluster()+0x8e>
  uint32_t find = m_vol->bitmapFind(m_curCluster ?  m_curCluster + 1 : 0, 1);
  if (find < 2) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!m_vol->bitmapModify(find, 1, 1)) {
    4540:	movs	r3, #1
    4542:	mov	r1, r0
    4544:	mov	r2, r3
    4546:	ldr	r0, [r4, #32]
    4548:	bl	4114 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    454c:	mov	r6, r0
    454e:	cmp	r0, #0
    4550:	beq.n	453c <ExFatFile::addCluster()+0x18>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_curCluster == 0) {
    4552:	ldr	r2, [r4, #24]
    m_flags |= FILE_FLAG_CONTIGUOUS;
    4554:	ldrb.w	r3, [r4, #51]	; 0x33
  }
  if (!m_vol->bitmapModify(find, 1, 1)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_curCluster == 0) {
    4558:	cbnz	r2, 4564 <ExFatFile::addCluster()+0x40>
    m_flags |= FILE_FLAG_CONTIGUOUS;
    455a:	orr.w	r3, r3, #64	; 0x40
    455e:	strb.w	r3, [r4, #51]	; 0x33
    goto done;
    4562:	b.n	45b0 <ExFatFile::addCluster()+0x8c>
  }
  if (isContiguous()) {
    4564:	lsls	r1, r3, #25
    4566:	bpl.n	4590 <ExFatFile::addCluster()+0x6c>
    if (find == (m_curCluster + 1)) {
    4568:	adds	r2, #1
    456a:	cmp	r5, r2
    456c:	beq.n	45b0 <ExFatFile::addCluster()+0x8c>
      goto done;
    }
    // No longer contiguous so make FAT chain.
    m_flags &= ~FILE_FLAG_CONTIGUOUS;
    456e:	bic.w	r3, r3, #64	; 0x40

    for (uint32_t c = m_firstCluster; c < m_curCluster; c++) {
    4572:	ldr	r1, [r4, #28]
  if (isContiguous()) {
    if (find == (m_curCluster + 1)) {
      goto done;
    }
    // No longer contiguous so make FAT chain.
    m_flags &= ~FILE_FLAG_CONTIGUOUS;
    4574:	strb.w	r3, [r4, #51]	; 0x33

    for (uint32_t c = m_firstCluster; c < m_curCluster; c++) {
    4578:	ldr	r3, [r4, #24]
    457a:	cmp	r1, r3
    457c:	bcs.n	4590 <ExFatFile::addCluster()+0x6c>
      if (!m_vol->fatPut(c, c + 1)) {
    457e:	adds	r7, r1, #1
    4580:	mov	r2, r7
    4582:	ldr	r0, [r4, #32]
    4584:	bl	429c <ExFatPartition::fatPut(unsigned long, unsigned long)>
    4588:	cmp	r0, #0
    458a:	beq.n	453c <ExFatFile::addCluster()+0x18>
      goto done;
    }
    // No longer contiguous so make FAT chain.
    m_flags &= ~FILE_FLAG_CONTIGUOUS;

    for (uint32_t c = m_firstCluster; c < m_curCluster; c++) {
    458c:	mov	r1, r7
    458e:	b.n	4578 <ExFatFile::addCluster()+0x54>
        goto fail;
      }
    }
  }
  // New cluster is EOC.
  if (!m_vol->fatPut(find, EXFAT_EOC)) {
    4590:	mov.w	r2, #4294967295
    4594:	mov	r1, r5
    4596:	ldr	r0, [r4, #32]
    4598:	bl	429c <ExFatPartition::fatPut(unsigned long, unsigned long)>
    459c:	cmp	r0, #0
    459e:	beq.n	453c <ExFatFile::addCluster()+0x18>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Connect new cluster to existing chain.
  if (m_curCluster) {
    45a0:	ldr	r1, [r4, #24]
    45a2:	cbz	r1, 45b0 <ExFatFile::addCluster()+0x8c>
    if (!m_vol->fatPut(m_curCluster, find)) {
    45a4:	mov	r2, r5
    45a6:	ldr	r0, [r4, #32]
    45a8:	bl	429c <ExFatPartition::fatPut(unsigned long, unsigned long)>
    45ac:	cmp	r0, #0
    45ae:	beq.n	453c <ExFatFile::addCluster()+0x18>
      goto fail;
    }
  }

 done:
  m_curCluster = find;
    45b0:	str	r5, [r4, #24]
  return true;

 fail:
  return false;
}
    45b2:	mov	r0, r6
    45b4:	pop	{r3, r4, r5, r6, r7, pc}

000045b6 <ExFatFile::remove()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::remove() {
    45b6:	push	{r4, r5, r6, lr}
    45b8:	ldrb.w	r3, [r0, #51]	; 0x33
  uint8_t* cache;
  if (!isWritable()) {
    45bc:	lsls	r2, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::remove() {
    45be:	mov	r4, r0
  uint8_t* cache;
  if (!isWritable()) {
    45c0:	bmi.n	45c6 <ExFatFile::remove()+0x10>

  // Write entry to device.
  return m_vol->cacheSync();

 fail:
  return false;
    45c2:	movs	r0, #0
    45c4:	pop	{r4, r5, r6, pc}
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster) {
    45c6:	ldr	r5, [r0, #28]
    45c8:	cbnz	r5, 45ce <ExFatFile::remove()+0x18>

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::remove() {
    45ca:	movs	r5, #0
    45cc:	b.n	4620 <ExFatFile::remove()+0x6a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster) {
    if (isContiguous()) {
    45ce:	lsls	r3, r3, #25
    45d0:	bpl.n	45fc <ExFatFile::remove()+0x46>
      uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    45d2:	ldr	r6, [r0, #32]
      if (!m_vol->bitmapModify(m_firstCluster, nc, 0)) {
    45d4:	ldrd	r0, r1, [r0, #8]
    45d8:	ldrb.w	r2, [r6, #1093]	; 0x445
    45dc:	adds.w	r0, r0, #4294967295
    45e0:	add.w	r2, r2, #9
    45e4:	uxtb	r2, r2
    45e6:	adc.w	r1, r1, #4294967295
    45ea:	bl	9cd4 <__aeabi_llsr>
    45ee:	movs	r3, #0
    45f0:	adds	r2, r0, #1
    45f2:	mov	r1, r5
    45f4:	mov	r0, r6
    45f6:	bl	4114 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    45fa:	b.n	4604 <ExFatFile::remove()+0x4e>
        DBG_FAIL_MACRO;
        goto fail;
      }
    } else {
      if (!m_vol->freeChain(m_firstCluster)) {
    45fc:	mov	r1, r5
    45fe:	ldr	r0, [r0, #32]
    4600:	bl	42d6 <ExFatPartition::freeChain(unsigned long)>
    4604:	cmp	r0, #0
    4606:	bne.n	45ca <ExFatFile::remove()+0x14>
    4608:	b.n	45c2 <ExFatFile::remove()+0xc>
      }
    }
  }

  for (uint8_t is = 0; is <= m_setCount; is++) {
    cache = dirCache(is, FsCache::CACHE_FOR_WRITE);
    460a:	movs	r2, #1
    460c:	mov	r0, r4
    460e:	bl	387a <ExFatFile::dirCache(unsigned char, unsigned char)>
    4612:	adds	r5, #1
    if (!cache) {
    4614:	cmp	r0, #0
    4616:	beq.n	45c2 <ExFatFile::remove()+0xc>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // Mark entry not used.
    cache[0] &= 0x7F;
    4618:	ldrb	r3, [r0, #0]
    461a:	and.w	r3, r3, #127	; 0x7f
    461e:	strb	r3, [r0, #0]
        goto fail;
      }
    }
  }

  for (uint8_t is = 0; is <= m_setCount; is++) {
    4620:	ldrb.w	r3, [r4, #48]	; 0x30
    4624:	uxtb	r1, r5
    4626:	cmp	r3, r1
    4628:	bcs.n	460a <ExFatFile::remove()+0x54>
    }
    // Mark entry not used.
    cache[0] &= 0x7F;
  }
  // Set this file closed.
  m_attributes = FILE_ATTR_CLOSED;
    462a:	movs	r3, #0
    462c:	strb.w	r3, [r4, #49]	; 0x31
  m_flags = 0;
    4630:	strb.w	r3, [r4, #51]	; 0x33

  // Write entry to device.
  return m_vol->cacheSync();
    4634:	ldr	r0, [r4, #32]
    4636:	bl	44fe <ExFatPartition::cacheSync()>

 fail:
  return false;
}
    463a:	pop	{r4, r5, r6, pc}

0000463c <ExFatFile::rmdir()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::rmdir() {
    463c:	push	{r4, lr}
  int n;
  uint8_t dir[32];
  // must be open subdirectory
  if (!isSubDir()) {
    463e:	ldrb.w	r3, [r0, #49]	; 0x31
    4642:	lsls	r1, r3, #27

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::rmdir() {
    4644:	sub	sp, #32
    4646:	mov	r4, r0
  int n;
  uint8_t dir[32];
  // must be open subdirectory
  if (!isSubDir()) {
    4648:	bmi.n	464e <ExFatFile::rmdir()+0x12>
  m_attributes = FILE_ATTR_FILE;
  m_flags |= FILE_FLAG_WRITE;
  return remove();

 fail:
  return false;
    464a:	movs	r0, #0
    464c:	b.n	468a <ExFatFile::rmdir()+0x4e>
   * \return true for success or false for failure.
   */
  bool rename(ExFatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    464e:	movs	r2, #0
    4650:	movs	r3, #0
    4652:	bl	3b58 <ExFatFile::seekSet(unsigned long long)>
  }
  rewind();

  // make sure directory is empty
  while (1) {
    n = read(dir, 32);
    4656:	movs	r2, #32
    4658:	mov	r1, sp
    465a:	mov	r0, r4
    465c:	bl	39a8 <ExFatFile::read(void*, unsigned int)>
    if (n == 0) {
    4660:	cbz	r0, 4672 <ExFatFile::rmdir()+0x36>
      break;
    }
    if (n != 32 || dir[0] & 0X80) {
    4662:	cmp	r0, #32
    4664:	bne.n	464a <ExFatFile::rmdir()+0xe>
    4666:	ldrb.w	r3, [sp]
    466a:	lsls	r2, r3, #24
    466c:	bmi.n	464a <ExFatFile::rmdir()+0xe>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (dir[0] == 0) {
    466e:	cmp	r3, #0
    4670:	bne.n	4656 <ExFatFile::rmdir()+0x1a>
      break;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
    4672:	movs	r3, #8
    4674:	strb.w	r3, [r4, #49]	; 0x31
  m_flags |= FILE_FLAG_WRITE;
    4678:	ldrb.w	r3, [r4, #51]	; 0x33
    467c:	orr.w	r3, r3, #2
    4680:	strb.w	r3, [r4, #51]	; 0x33
  return remove();
    4684:	mov	r0, r4
    4686:	bl	45b6 <ExFatFile::remove()>

 fail:
  return false;
}
    468a:	add	sp, #32
    468c:	pop	{r4, pc}
    468e:	Address 0x0000468e is out of bounds.


00004690 <ExFatFile::syncDir()>:
 fail:
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::syncDir() {
    4690:	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    4694:	movs	r6, #0
    }
    switch (cache[0]) {
      case EXFAT_TYPE_FILE:
        df = reinterpret_cast<DirFile_t*>(cache);
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        if (FsDateTime::callback) {
    4696:	ldr.w	r8, [pc, #212]	; 476c <ExFatFile::syncDir()+0xdc>
 fail:
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::syncDir() {
    469a:	mov	r5, r0
  DirFile_t* df;
  DirStream_t* ds;
  uint8_t* cache;
  uint16_t checksum = 0;
    469c:	mov	r7, r6

  for (uint8_t is = 0; is <= m_setCount ; is++) {
    469e:	ldrb.w	r3, [r5, #48]	; 0x30
    46a2:	uxtb	r1, r6
    46a4:	cmp	r3, r1
    46a6:	bcc.n	473e <ExFatFile::syncDir()+0xae>
    cache = dirCache(is, FsCache::CACHE_FOR_READ);
    46a8:	movs	r2, #0
    46aa:	mov	r0, r5
    46ac:	bl	387a <ExFatFile::dirCache(unsigned char, unsigned char)>
    if (!cache) {
    46b0:	mov	r4, r0
    46b2:	cmp	r0, #0
    46b4:	beq.n	4756 <ExFatFile::syncDir()+0xc6>
      DBG_FAIL_MACRO;
      goto fail;
    }
    switch (cache[0]) {
    46b6:	ldrb	r3, [r0, #0]
    46b8:	cmp	r3, #192	; 0xc0
    46ba:	beq.n	46f8 <ExFatFile::syncDir()+0x68>
    46bc:	cmp	r3, #193	; 0xc1
    46be:	beq.n	4730 <ExFatFile::syncDir()+0xa0>
    46c0:	cmp	r3, #133	; 0x85
    46c2:	bne.n	4756 <ExFatFile::syncDir()+0xc6>
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    46c4:	ldrb.w	r3, [r5, #49]	; 0x31
    46c8:	and.w	r3, r3, #55	; 0x37
    46cc:	strh	r3, [r0, #4]
      case EXFAT_TYPE_FILE:
        df = reinterpret_cast<DirFile_t*>(cache);
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        if (FsDateTime::callback) {
    46ce:	ldr.w	r3, [r8]
    46d2:	cbz	r3, 4722 <ExFatFile::syncDir()+0x92>
          uint16_t date, time;
          uint8_t ms10;
          FsDateTime::callback(&date, &time, &ms10);
    46d4:	add.w	r2, sp, #3
    46d8:	add.w	r1, sp, #6
    46dc:	add	r0, sp, #4
    46de:	blx	r3
          df->modifyTimeMs = ms10;
    46e0:	ldrb.w	r3, [sp, #3]
          setLe16(df->modifyTime, time);
    46e4:	ldrh.w	r2, [sp, #6]
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        if (FsDateTime::callback) {
          uint16_t date, time;
          uint8_t ms10;
          FsDateTime::callback(&date, &time, &ms10);
          df->modifyTimeMs = ms10;
    46e8:	strb	r3, [r4, #21]
          setLe16(df->modifyTime, time);
          setLe16(df->modifyDate, date);
    46ea:	ldrh.w	r3, [sp, #4]
    46ee:	strh	r2, [r4, #12]
    46f0:	strh	r3, [r4, #14]
    46f2:	strh	r2, [r4, #16]
    46f4:	strh	r3, [r4, #18]
    46f6:	b.n	4722 <ExFatFile::syncDir()+0x92>
        m_vol->dataCacheDirty();
        break;

      case EXFAT_TYPE_STREAM:
        ds = reinterpret_cast<DirStream_t*>(cache);
        if (isContiguous()) {
    46f8:	ldrb.w	r3, [r5, #51]	; 0x33
    46fc:	tst.w	r3, #64	; 0x40
    4700:	ldrb	r3, [r0, #1]
          ds->flags |= EXFAT_FLAG_CONTIGUOUS;
    4702:	ite	ne
    4704:	orrne.w	r3, r3, #2
        } else {
          ds->flags &= ~EXFAT_FLAG_CONTIGUOUS;
    4708:	biceq.w	r3, r3, #2
    470c:	strb	r3, [r0, #1]
        }
        setLe64(ds->validLength, m_validLength);
    470e:	ldrd	r2, r3, [r5, #16]

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    4712:	strd	r2, r3, [r0, #8]
        setLe32(ds->firstCluster, m_firstCluster);
    4716:	ldr	r3, [r5, #28]
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    4718:	str	r3, [r0, #20]
        setLe64(ds->dataLength, m_dataLength);
    471a:	ldrd	r2, r3, [r5, #8]
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    471e:	strd	r2, r3, [r0, #24]
        m_vol->dataCacheDirty();
    4722:	ldr	r2, [r5, #32]
  }
  /** Set current sector dirty. */
  void dirty() {
    m_status |= CACHE_STATUS_DIRTY;
    4724:	ldrb.w	r3, [r2, #528]	; 0x210
    4728:	orr.w	r3, r3, #1
    472c:	strb.w	r3, [r2, #528]	; 0x210
      default:
        DBG_FAIL_MACRO;
        goto fail;
        break;
    }
    checksum = exFatDirChecksum(cache, checksum);
    4730:	mov	r1, r7
    4732:	mov	r0, r4
    4734:	bl	44d0 <exFatDirChecksum(unsigned char const*, unsigned short)>
    4738:	adds	r6, #1
    473a:	mov	r7, r0
  DirFile_t* df;
  DirStream_t* ds;
  uint8_t* cache;
  uint16_t checksum = 0;

  for (uint8_t is = 0; is <= m_setCount ; is++) {
    473c:	b.n	469e <ExFatFile::syncDir()+0xe>
        break;
    }
    checksum = exFatDirChecksum(cache, checksum);
  }
  df = reinterpret_cast<DirFile_t*>
       (m_vol->dirCache(&m_dirPos, FsCache::CACHE_FOR_WRITE));
    473e:	movs	r2, #1
    4740:	add.w	r1, r5, #36	; 0x24
    4744:	ldr	r0, [r5, #32]
    4746:	bl	41ba <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
  if (!df) {
    474a:	cbz	r0, 4756 <ExFatFile::syncDir()+0xc6>
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    474c:	strh	r7, [r0, #2]
    DBG_FAIL_MACRO;
    goto fail;
  }
  setLe16(df->setChecksum, checksum);
  if (!m_vol->cacheSync()) {
    474e:	ldr	r0, [r5, #32]
    4750:	bl	44fe <ExFatPartition::cacheSync()>
    4754:	cbnz	r0, 4764 <ExFatFile::syncDir()+0xd4>
    goto fail;
  }
  return true;

 fail:
  m_error |= WRITE_ERROR;
    4756:	ldrb.w	r3, [r5, #50]	; 0x32
    475a:	orr.w	r3, r3, #1
    475e:	strb.w	r3, [r5, #50]	; 0x32
  return false;
    4762:	movs	r0, #0
}
    4764:	add	sp, #8
    4766:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    476a:	nop
    476c:	.word	0x1fff8418

00004770 <ExFatFile::sync()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::sync() {
    4770:	push	{r4, lr}
  if (!isOpen()) {
    4772:	ldrb.w	r3, [r0, #49]	; 0x31

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::sync() {
    4776:	mov	r4, r0
  if (!isOpen()) {
    4778:	cbnz	r3, 477e <ExFatFile::sync()+0xe>
    return true;
    477a:	movs	r0, #1
    477c:	pop	{r4, pc}
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    477e:	ldrb.w	r3, [r0, #51]	; 0x33
    4782:	lsls	r2, r3, #24
    4784:	bpl.n	4796 <ExFatFile::sync()+0x26>
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
    4786:	and.w	r3, r3, #127	; 0x7f
    478a:	strb.w	r3, [r0, #51]	; 0x33
  return true;

 fail:
  m_error |= WRITE_ERROR;
  return false;
}
    478e:	ldmia.w	sp!, {r4, lr}
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
    return syncDir();
    4792:	b.w	4690 <ExFatFile::syncDir()>
  }
  if (!m_vol->cacheSync()) {
    4796:	ldr	r0, [r0, #32]
    4798:	bl	44fe <ExFatPartition::cacheSync()>
    479c:	cmp	r0, #0
    479e:	bne.n	477a <ExFatFile::sync()+0xa>
    goto fail;
  }
  return true;

 fail:
  m_error |= WRITE_ERROR;
    47a0:	ldrb.w	r3, [r4, #50]	; 0x32
    47a4:	orr.w	r3, r3, #1
    47a8:	strb.w	r3, [r4, #50]	; 0x32
  return false;
}
    47ac:	pop	{r4, pc}

000047ae <ExFatFile::addDirCluster()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::addDirCluster() {
    47ae:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t sector;
  uint32_t dl = isRoot() ? m_vol->rootLength() : m_dataLength;
    47b2:	ldrb.w	r3, [r0, #49]	; 0x31

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::addDirCluster() {
    47b6:	mov	r4, r0
  uint32_t sector;
  uint32_t dl = isRoot() ? m_vol->rootLength() : m_dataLength;
    47b8:	lsls	r0, r3, #25
    47ba:	bpl.n	47c4 <ExFatFile::addDirCluster()+0x16>
    47bc:	ldr	r0, [r4, #32]
    47be:	bl	4464 <ExFatPartition::rootLength()>
    47c2:	b.n	47c6 <ExFatFile::addDirCluster()+0x18>
    47c4:	ldr	r0, [r4, #8]
    47c6:	ldr	r3, [r4, #32]
  uint8_t* cache;
  dl += m_vol->bytesPerCluster();
  if (dl >= 0X4000000) {
    47c8:	ldr.w	r3, [r3, #1084]	; 0x43c
    47cc:	add	r0, r3
    47ce:	cmp.w	r0, #67108864	; 0x4000000
    47d2:	bcs.n	4886 <ExFatFile::addDirCluster()+0xd8>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!addCluster()) {
    47d4:	mov	r0, r4
    47d6:	bl	4524 <ExFatFile::addCluster()>
    47da:	cmp	r0, #0
    47dc:	beq.n	4886 <ExFatFile::addDirCluster()+0xd8>
    DBG_FAIL_MACRO;
    goto fail;
  }
  cache =  m_vol->cacheClear();
    47de:	ldr	r5, [r4, #32]
    }
    return m_blockDev->writeSectors(sector, src, count);
  }
  /** \return Clear the cache and returns a pointer to the cache. */
  uint8_t* clear() {
    if (isDirty() && !sync()) {
    47e0:	ldrb.w	r3, [r5, #528]	; 0x210
    47e4:	lsls	r1, r3, #31
    47e6:	bpl.n	47f4 <ExFatFile::addDirCluster()+0x46>
    47e8:	add.w	r0, r5, #528	; 0x210
    47ec:	bl	3026 <FsCache::sync()>
    47f0:	cmp	r0, #0
    47f2:	beq.n	4886 <ExFatFile::addDirCluster()+0xd8>
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    47f4:	mov.w	r3, #4294967295
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    47f8:	movs	r6, #0
    m_sector = 0XFFFFFFFF;
    47fa:	str.w	r3, [r5, #540]	; 0x21c
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    47fe:	strb.w	r6, [r5, #528]	; 0x210
  uint8_t* clear() {
    if (isDirty() && !sync()) {
      return nullptr;
    }
    invalidate();
    return m_buffer;
    4802:	add.w	r5, r5, #544	; 0x220
  if (!cache) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(cache, 0, m_vol->bytesPerSector());
    4806:	mov.w	r2, #512	; 0x200
    480a:	mov	r1, r6
    480c:	mov	r0, r5
    480e:	bl	88c8 <memset>
  sector = m_vol->clusterStartSector(m_curCluster);
    4812:	ldr	r2, [r4, #32]
  bool dataCacheSync() {return m_dataCache.sync();}
  //----------------------------------------------------------------------------
  uint32_t clusterMask() const {return m_clusterMask;}
  uint32_t clusterStartSector(uint32_t cluster) {
    return m_clusterHeapStartSector +
           ((cluster - 2) << m_sectorsPerClusterShift);
    4814:	ldr	r3, [r4, #24]
    4816:	ldrb.w	r1, [r2, #1093]	; 0x445
    481a:	ldr.w	r7, [r2, #1068]	; 0x42c
    481e:	subs	r3, #2
    4820:	lsls	r3, r1
    4822:	add	r7, r3
  for (uint32_t i = 0; i < m_vol->sectorsPerCluster(); i++) {
    4824:	mov.w	r8, #1
    4828:	ldr	r3, [r4, #32]
    482a:	ldrb.w	r2, [r3, #1093]	; 0x445
    482e:	lsl.w	r2, r8, r2
    4832:	cmp	r2, r6
    4834:	bls.n	484a <ExFatFile::addDirCluster()+0x9c>
    4836:	ldr.w	r0, [r3, #1088]	; 0x440
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool writeSector(uint32_t sector, const uint8_t* src) {
    return m_blockDev->writeSector(sector, src);
    483a:	ldr	r3, [r0, #0]
    483c:	mov	r2, r5
    483e:	ldr	r3, [r3, #32]
    4840:	adds	r1, r7, r6
    4842:	blx	r3
    if (!m_vol->writeSector(sector + i, cache)) {
    4844:	cbz	r0, 4886 <ExFatFile::addDirCluster()+0xd8>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(cache, 0, m_vol->bytesPerSector());
  sector = m_vol->clusterStartSector(m_curCluster);
  for (uint32_t i = 0; i < m_vol->sectorsPerCluster(); i++) {
    4846:	adds	r6, #1
    4848:	b.n	4828 <ExFatFile::addDirCluster()+0x7a>
    if (!m_vol->writeSector(sector + i, cache)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  if (!isRoot()) {
    484a:	ldrb.w	r2, [r4, #49]	; 0x31
    484e:	lsls	r2, r2, #25
    4850:	bmi.n	487c <ExFatFile::addDirCluster()+0xce>
    m_flags |= FILE_FLAG_DIR_DIRTY;
    4852:	ldrb.w	r2, [r4, #51]	; 0x33
    4856:	orn	r2, r2, #127	; 0x7f
    m_dataLength  += m_vol->bytesPerCluster();
    485a:	ldrd	r0, r1, [r4, #8]
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  if (!isRoot()) {
    m_flags |= FILE_FLAG_DIR_DIRTY;
    485e:	strb.w	r2, [r4, #51]	; 0x33
    m_dataLength  += m_vol->bytesPerCluster();
    4862:	ldr.w	r2, [r3, #1084]	; 0x43c
    4866:	movs	r3, #0
    4868:	adds	r0, r0, r2
    486a:	adcs	r1, r3
    486c:	strd	r0, r1, [r4, #8]
    m_validLength += m_vol->bytesPerCluster();
    4870:	ldrd	r0, r1, [r4, #16]
    4874:	adds	r2, r2, r0
    4876:	adcs	r3, r1
    4878:	strd	r2, r3, [r4, #16]
  }
  return sync();
    487c:	mov	r0, r4

 fail:
  return false;
}
    487e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  if (!isRoot()) {
    m_flags |= FILE_FLAG_DIR_DIRTY;
    m_dataLength  += m_vol->bytesPerCluster();
    m_validLength += m_vol->bytesPerCluster();
  }
  return sync();
    4882:	b.w	4770 <ExFatFile::sync()>

 fail:
  return false;
}
    4886:	movs	r0, #0
    4888:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000488c <ExFatFile::mkdir(ExFatFile*, ExName_t*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, ExName_t* fname) {
    488c:	push	{r4, lr}
  if (!parent->isDir()) {
    488e:	ldrb.w	r3, [r1, #49]	; 0x31
    4892:	tst.w	r3, #80	; 0x50

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, ExName_t* fname) {
    4896:	mov	r4, r0
  if (!parent->isDir()) {
    4898:	beq.n	48d0 <ExFatFile::mkdir(ExFatFile*, ExName_t*)+0x44>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // create a normal file
  if (!openPrivate(parent, fname, O_CREAT | O_EXCL | O_RDWR)) {
    489a:	movw	r3, #2562	; 0xa02
    489e:	bl	3c28 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)>
    48a2:	cbz	r0, 48d0 <ExFatFile::mkdir(ExFatFile*, ExName_t*)+0x44>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // convert file to directory
  m_attributes = FILE_ATTR_SUBDIR;
    48a4:	movs	r3, #16
    48a6:	strb.w	r3, [r4, #49]	; 0x31

  // allocate and zero first cluster
  if (!addDirCluster()) {
    48aa:	mov	r0, r4
    48ac:	bl	47ae <ExFatFile::addDirCluster()>
    48b0:	cbz	r0, 48d0 <ExFatFile::mkdir(ExFatFile*, ExName_t*)+0x44>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_firstCluster = m_curCluster;
    48b2:	ldr	r3, [r4, #24]
    48b4:	str	r3, [r4, #28]
    48b6:	mov	r0, r4
    48b8:	movs	r3, #0
    48ba:	movs	r2, #0
    48bc:	bl	3b58 <ExFatFile::seekSet(unsigned long long)>

  // Set to start of dir
  rewind();
  m_flags = FILE_FLAG_READ | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
    48c0:	movs	r3, #193	; 0xc1
    48c2:	strb.w	r3, [r4, #51]	; 0x33
  return sync();
    48c6:	mov	r0, r4

 fail:
  return false;
}
    48c8:	ldmia.w	sp!, {r4, lr}
  m_firstCluster = m_curCluster;

  // Set to start of dir
  rewind();
  m_flags = FILE_FLAG_READ | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
  return sync();
    48cc:	b.w	4770 <ExFatFile::sync()>

 fail:
  return false;
}
    48d0:	movs	r0, #0
    48d2:	pop	{r4, pc}

000048d4 <ExFatFile::mkdir(ExFatFile*, char const*, bool)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, const char* path, bool pFlag) {
    48d4:	push	{r4, r5, r6, r7, lr}
    48d6:	sub	sp, #92	; 0x5c
    48d8:	mov	r7, r3
    48da:	movs	r3, #0
    48dc:	strh.w	r3, [sp, #20]
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
    48e0:	strb.w	r3, [sp, #81]	; 0x51
    48e4:	strb.w	r3, [sp, #82]	; 0x52
    48e8:	strb.w	r3, [sp, #83]	; 0x53
  ExName_t fname;
  ExFatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    48ec:	ldrb.w	r3, [r0, #49]	; 0x31

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, const char* path, bool pFlag) {
    48f0:	str	r2, [sp, #4]
    48f2:	mov	r5, r0
    48f4:	mov	r4, r1
  ExName_t fname;
  ExFatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    48f6:	cmp	r3, #0
    48f8:	bne.n	498c <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xb8>
    48fa:	ldrb.w	r3, [r1, #49]	; 0x31
    48fe:	tst.w	r3, #80	; 0x50
    4902:	beq.n	498c <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xb8>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    4904:	ldrb	r3, [r2, #0]
    4906:	cmp	r3, #47	; 0x2f
    4908:	bne.n	4926 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x52>
    while (isDirSeparator(*path)) {
    490a:	ldr	r3, [sp, #4]
    490c:	ldrb	r2, [r3, #0]
    490e:	cmp	r2, #47	; 0x2f
    4910:	bne.n	4918 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x44>
      path++;
    4912:	adds	r3, #1
    4914:	str	r3, [sp, #4]
  if (isOpen() || !parent->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    4916:	b.n	490a <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x36>
      path++;
    }
    if (!tmpDir.openRoot(parent->m_vol)) {
    4918:	ldr	r1, [r4, #32]
    491a:	add	r0, sp, #32
    491c:	bl	3906 <ExFatFile::openRoot(ExFatVolume*)>
    4920:	cmp	r0, #0
    4922:	beq.n	498c <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xb8>
      DBG_FAIL_MACRO;
      goto fail;
    }
    parent = &tmpDir;
    4924:	add	r4, sp, #32
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    4926:	add	r3, sp, #4
    4928:	add	r2, sp, #8
    492a:	ldr	r1, [sp, #4]
    492c:	mov	r0, r5
    492e:	bl	392c <ExFatFile::parsePathName(char const*, ExName_t*, char const**)>
    4932:	cbz	r0, 498c <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xb8>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!*path) {
    4934:	ldr	r3, [sp, #4]
    4936:	ldrb	r3, [r3, #0]
    4938:	cbz	r3, 4980 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xac>
      break;
    }
    if (!openPrivate(parent, &fname, O_RDONLY)) {
    493a:	movs	r3, #0
    493c:	add	r2, sp, #8
    493e:	mov	r1, r4
    4940:	mov	r0, r5
    4942:	bl	3c28 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)>
    4946:	cbz	r0, 496e <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x9a>
      if (!pFlag || !mkdir(parent, &fname)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    tmpDir = *this;
    4948:	add	r2, sp, #32
    494a:	mov	r3, r5
    494c:	add.w	lr, r5, #48	; 0x30
    4950:	mov	r4, r2
    4952:	ldr	r0, [r3, #0]
    4954:	ldr	r1, [r3, #4]
    4956:	mov	r6, r2
    4958:	stmia	r6!, {r0, r1}
    495a:	adds	r3, #8
    495c:	cmp	r3, lr
    495e:	mov	r2, r6
    4960:	bne.n	4952 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x7e>
    4962:	ldr	r0, [r3, #0]
    4964:	str	r0, [r6, #0]
    parent = &tmpDir;
    close();
    4966:	mov	r0, r5
    4968:	bl	38b2 <ExFatFile::close()>
      DBG_FAIL_MACRO;
      goto fail;
    }
    parent = &tmpDir;
  }
  while (1) {
    496c:	b.n	4926 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x52>
    }
    if (!*path) {
      break;
    }
    if (!openPrivate(parent, &fname, O_RDONLY)) {
      if (!pFlag || !mkdir(parent, &fname)) {
    496e:	cbz	r7, 498c <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xb8>
    4970:	add	r2, sp, #8
    4972:	mov	r1, r4
    4974:	mov	r0, r5
    4976:	bl	488c <ExFatFile::mkdir(ExFatFile*, ExName_t*)>
    497a:	cmp	r0, #0
    497c:	bne.n	4948 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x74>
    497e:	b.n	498c <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xb8>
    }
    tmpDir = *this;
    parent = &tmpDir;
    close();
  }
  return mkdir(parent, &fname);
    4980:	add	r2, sp, #8
    4982:	mov	r1, r4
    4984:	mov	r0, r5
    4986:	bl	488c <ExFatFile::mkdir(ExFatFile*, ExName_t*)>
    498a:	b.n	498e <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xba>

 fail:
  return false;
    498c:	movs	r0, #0
}
    498e:	add	sp, #92	; 0x5c
    4990:	pop	{r4, r5, r6, r7, pc}

00004992 <ExFatFile::rename(ExFatFile*, char const*)>:
//------------------------------------------------------------------------------
bool ExFatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool ExFatFile::rename(ExFatFile* dirFile, const char* newPath) {
    4992:	push	{r4, r5, r6, r7, lr}
    4994:	sub	sp, #116	; 0x74
    4996:	movs	r3, #0
    4998:	strb.w	r3, [sp, #49]	; 0x31
    499c:	strb.w	r3, [sp, #50]	; 0x32
    49a0:	strb.w	r3, [sp, #51]	; 0x33
    49a4:	strb.w	r3, [sp, #105]	; 0x69
    49a8:	strb.w	r3, [sp, #106]	; 0x6a
    49ac:	strb.w	r3, [sp, #107]	; 0x6b
  ExFatFile file;
  ExFatFile oldFile;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    49b0:	ldrb.w	r3, [r0, #49]	; 0x31
    49b4:	tst.w	r3, #24
//------------------------------------------------------------------------------
bool ExFatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool ExFatFile::rename(ExFatFile* dirFile, const char* newPath) {
    49b8:	mov	r4, r0
  ExFatFile file;
  ExFatFile oldFile;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    49ba:	bne.n	49c0 <ExFatFile::rename(ExFatFile*, char const*)+0x2e>
  oldFile.m_flags = FILE_FLAG_WRITE;
  oldFile.m_attributes = FILE_ATTR_FILE;
  return oldFile.remove();

 fail:
  return false;
    49bc:	movs	r0, #0
    49be:	b.n	4a34 <ExFatFile::rename(ExFatFile*, char const*)+0xa2>
  if (!(isFile() || isSubDir())) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Can't move file to new volume.
  if (m_vol != dirFile->m_vol) {
    49c0:	ldr	r0, [r0, #32]
    49c2:	ldr	r3, [r1, #32]
    49c4:	cmp	r0, r3
    49c6:	bne.n	49bc <ExFatFile::rename(ExFatFile*, char const*)+0x2a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!file.open(dirFile, newPath, O_CREAT | O_EXCL | O_WRONLY)) {
    49c8:	movw	r3, #2561	; 0xa01
    49cc:	mov	r0, sp
    49ce:	bl	3f78 <ExFatFile::open(ExFatFile*, char const*, int)>
    49d2:	cmp	r0, #0
    49d4:	beq.n	49bc <ExFatFile::rename(ExFatFile*, char const*)+0x2a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  oldFile = *this;
    49d6:	add	r2, sp, #56	; 0x38
    49d8:	mov	r3, r4
    49da:	add.w	r7, r4, #48	; 0x30
    49de:	mov	r6, r2
    49e0:	ldr	r0, [r3, #0]
    49e2:	ldr	r1, [r3, #4]
    49e4:	mov	r5, r2
    49e6:	stmia	r5!, {r0, r1}
    49e8:	adds	r3, #8
    49ea:	cmp	r3, r7
    49ec:	mov	r2, r5
    49ee:	bne.n	49e0 <ExFatFile::rename(ExFatFile*, char const*)+0x4e>
    49f0:	ldr	r0, [r3, #0]
    49f2:	str	r0, [r5, #0]
  m_dirPos = file.m_dirPos;
    49f4:	add	r2, sp, #36	; 0x24
    49f6:	ldmia	r2, {r0, r1, r2}
    49f8:	add.w	r3, r4, #36	; 0x24
    49fc:	stmia.w	r3, {r0, r1, r2}
  m_setCount = file.m_setCount;
    4a00:	ldrb.w	r3, [sp, #48]	; 0x30
    4a04:	strb.w	r3, [r4, #48]	; 0x30
  m_flags |= FILE_FLAG_DIR_DIRTY;
    4a08:	ldrb.w	r3, [r4, #51]	; 0x33
    4a0c:	orn	r3, r3, #127	; 0x7f
    4a10:	strb.w	r3, [r4, #51]	; 0x33
  if (!sync()) {
    4a14:	mov	r0, r4
    4a16:	bl	4770 <ExFatFile::sync()>
    4a1a:	cmp	r0, #0
    4a1c:	beq.n	49bc <ExFatFile::rename(ExFatFile*, char const*)+0x2a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
    4a1e:	movs	r3, #0
    4a20:	str	r3, [sp, #84]	; 0x54
  oldFile.m_flags = FILE_FLAG_WRITE;
    4a22:	movs	r3, #2
    4a24:	strb.w	r3, [sp, #107]	; 0x6b
  oldFile.m_attributes = FILE_ATTR_FILE;
  return oldFile.remove();
    4a28:	mov	r0, r6
    goto fail;
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
  oldFile.m_flags = FILE_FLAG_WRITE;
  oldFile.m_attributes = FILE_ATTR_FILE;
    4a2a:	movs	r3, #8
    4a2c:	strb.w	r3, [sp, #105]	; 0x69
  return oldFile.remove();
    4a30:	bl	45b6 <ExFatFile::remove()>

 fail:
  return false;
}
    4a34:	add	sp, #116	; 0x74
    4a36:	pop	{r4, r5, r6, r7, pc}

00004a38 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>:
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
    4a38:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4a3c:	mov	r4, r3
      || month > 12
      || day < 1
      || day > 31
      || hour > 23
      || minute > 59
      || second > 59) {
    4a3e:	ldrb.w	r3, [r0, #49]	; 0x31
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
    4a42:	ldrb.w	fp, [sp, #40]	; 0x28
    4a46:	ldrb.w	sl, [sp, #44]	; 0x2c
    4a4a:	ldrb.w	r5, [sp, #48]	; 0x30
    4a4e:	ldrb.w	r9, [sp, #52]	; 0x34
      || month > 12
      || day < 1
      || day > 31
      || hour > 23
      || minute > 59
      || second > 59) {
    4a52:	lsls	r3, r3, #28
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
    4a54:	mov	r6, r0
    4a56:	mov	r8, r1
      || month > 12
      || day < 1
      || day > 31
      || hour > 23
      || minute > 59
      || second > 59) {
    4a58:	bpl.n	4acc <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
  uint16_t date;
  uint16_t time;
  uint8_t ms10;

  if (!isFile()
      || year < 1980
    4a5a:	subw	r2, r2, #1980	; 0x7bc
    4a5e:	uxth	r7, r2
    4a60:	cmp	r7, #127	; 0x7f
    4a62:	bhi.n	4acc <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
      || year > 2107
      || month < 1
    4a64:	subs	r3, r4, #1
    4a66:	cmp	r3, #11
    4a68:	bhi.n	4acc <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
      || month > 12
      || day < 1
    4a6a:	add.w	r3, fp, #4294967295
    4a6e:	cmp	r3, #30
    4a70:	bhi.n	4acc <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
      || day > 31
      || hour > 23
    4a72:	cmp.w	sl, #23
    4a76:	bhi.n	4acc <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
      || minute > 59
    4a78:	cmp	r5, #59	; 0x3b
    4a7a:	bhi.n	4acc <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
      || second > 59) {
    4a7c:	cmp.w	r9, #59	; 0x3b
    4a80:	bhi.n	4acc <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // update directory entry
  if (!sync()) {
    4a82:	bl	4770 <ExFatFile::sync()>
    4a86:	cbz	r0, 4acc <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
    4a88:	mov.w	r3, r9, asr #1
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
    4a8c:	orr.w	r4, fp, r4, lsl #5
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
    4a90:	orr.w	r5, r3, r5, lsl #5
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
    4a94:	orr.w	r4, r4, r7, lsl #9
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
    4a98:	orr.w	r5, r5, sl, lsl #11
    goto fail;
  }

  date = FS_DATE(year, month, day);
  time = FS_TIME(hour, minute, second);
  ms10 = second & 1 ? 100 : 0;
    4a9c:	tst.w	r9, #1
    4aa0:	mov.w	r7, #0
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
    4aa4:	uxth	r4, r4
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
    4aa6:	uxth	r5, r5
    4aa8:	ite	eq
    4aaa:	moveq.w	r9, #0
    4aae:	movne.w	r9, #100	; 0x64
//------------------------------------------------------------------------------
bool ExFatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
  DirFile_t* df;
  uint8_t* cache;
  uint16_t checksum = 0;
    4ab2:	mov	fp, r7
    switch (cache[0]) {
      case EXFAT_TYPE_FILE:
        df = reinterpret_cast<DirFile_t*>(cache);
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        m_vol->dataCacheDirty();
        if (flags & T_ACCESS) {
    4ab4:	and.w	sl, r8, #1

  date = FS_DATE(year, month, day);
  time = FS_TIME(hour, minute, second);
  ms10 = second & 1 ? 100 : 0;

  for (uint8_t is = 0; is <= m_setCount ; is++) {
    4ab8:	ldrb.w	r3, [r6, #48]	; 0x30
    4abc:	uxtb	r1, r7
    4abe:	cmp	r3, r1
    4ac0:	bcc.n	4b2c <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0xf4>
    cache = dirCache(is, FsCache::CACHE_FOR_READ);
    4ac2:	movs	r2, #0
    4ac4:	mov	r0, r6
    4ac6:	bl	387a <ExFatFile::dirCache(unsigned char, unsigned char)>
    if (!cache) {
    4aca:	cbnz	r0, 4ad2 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x9a>
    goto fail;
  }
  return true;

 fail:
  return false;
    4acc:	movs	r0, #0
    4ace:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    cache = dirCache(is, FsCache::CACHE_FOR_READ);
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    switch (cache[0]) {
    4ad2:	ldrb	r3, [r0, #0]
    4ad4:	cmp	r3, #133	; 0x85
    4ad6:	beq.n	4ae2 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0xaa>
    4ad8:	bcc.n	4acc <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
    4ada:	subs	r3, #192	; 0xc0
    4adc:	cmp	r3, #1
    4ade:	bls.n	4b20 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0xe8>
    4ae0:	b.n	4acc <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
    4ae2:	ldrb.w	r3, [r6, #49]	; 0x31
      case EXFAT_TYPE_FILE:
        df = reinterpret_cast<DirFile_t*>(cache);
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        m_vol->dataCacheDirty();
    4ae6:	ldr	r2, [r6, #32]
    4ae8:	and.w	r3, r3, #55	; 0x37
    4aec:	strh	r3, [r0, #4]
  }
  /** Set current sector dirty. */
  void dirty() {
    m_status |= CACHE_STATUS_DIRTY;
    4aee:	ldrb.w	r3, [r2, #528]	; 0x210
    4af2:	orr.w	r3, r3, #1
    4af6:	strb.w	r3, [r2, #528]	; 0x210
        if (flags & T_ACCESS) {
    4afa:	cmp.w	sl, #0
    4afe:	beq.n	4b04 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0xcc>
    4b00:	strh	r5, [r0, #16]
    4b02:	strh	r4, [r0, #18]
          setLe16(df->accessTime, time);
          setLe16(df->accessDate, date);
        }
        if (flags & T_CREATE) {
    4b04:	tst.w	r8, #2
          df->createTimeMs = ms10;
    4b08:	ittt	ne
    4b0a:	strbne.w	r9, [r0, #20]
    4b0e:	strhne	r5, [r0, #8]
    4b10:	strhne	r4, [r0, #10]
          setLe16(df->createTime, time);
          setLe16(df->createDate, date);
        }
        if (flags & T_WRITE) {
    4b12:	tst.w	r8, #4
          df->modifyTimeMs = ms10;
    4b16:	ittt	ne
    4b18:	strbne.w	r9, [r0, #21]
    4b1c:	strhne	r5, [r0, #12]
    4b1e:	strhne	r4, [r0, #14]
      default:
        DBG_FAIL_MACRO;
        goto fail;
        break;
    }
    checksum = exFatDirChecksum(cache, checksum);
    4b20:	mov	r1, fp
    4b22:	bl	44d0 <exFatDirChecksum(unsigned char const*, unsigned short)>
    4b26:	adds	r7, #1
    4b28:	mov	fp, r0

  date = FS_DATE(year, month, day);
  time = FS_TIME(hour, minute, second);
  ms10 = second & 1 ? 100 : 0;

  for (uint8_t is = 0; is <= m_setCount ; is++) {
    4b2a:	b.n	4ab8 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x80>
        break;
    }
    checksum = exFatDirChecksum(cache, checksum);
  }
  df = reinterpret_cast<DirFile_t*>
       (m_vol->dirCache(&m_dirPos, FsCache::CACHE_FOR_WRITE));
    4b2c:	movs	r2, #1
    4b2e:	add.w	r1, r6, #36	; 0x24
    4b32:	ldr	r0, [r6, #32]
    4b34:	bl	41ba <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
  if (!df) {
    4b38:	cmp	r0, #0
    4b3a:	beq.n	4acc <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
    4b3c:	strh.w	fp, [r0, #2]
    DBG_FAIL_MACRO;
    goto fail;
  }
  setLe16(df->setChecksum, checksum);
  if (!m_vol->cacheSync()) {
    4b40:	ldr	r0, [r6, #32]
    4b42:	bl	44fe <ExFatPartition::cacheSync()>
    4b46:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

00004b4a <ExFatFile::truncate()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::truncate() {
    4b4a:	push	{r0, r1, r4, r5, r6, lr}
    4b4c:	ldrb.w	r3, [r0, #51]	; 0x33
  uint32_t toFree;
  // error if not a normal file or read-only
  if (!isWritable()) {
    4b50:	lsls	r2, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::truncate() {
    4b52:	mov	r4, r0
  uint32_t toFree;
  // error if not a normal file or read-only
  if (!isWritable()) {
    4b54:	bmi.n	4b5a <ExFatFile::truncate()+0x10>
  m_validLength = m_curPosition;
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return sync();

 fail:
  return false;
    4b56:	movs	r0, #0
    4b58:	b.n	4c04 <ExFatFile::truncate()+0xba>
  // error if not a normal file or read-only
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
    4b5a:	ldr	r5, [r0, #28]
    4b5c:	cmp	r5, #0
    4b5e:	beq.n	4be2 <ExFatFile::truncate()+0x98>
      return true;
  }
  if (isContiguous()) {
    4b60:	and.w	r3, r3, #64	; 0x40
    4b64:	and.w	r1, r3, #255	; 0xff
    4b68:	ldr	r6, [r0, #24]
    4b6a:	cbz	r3, 4baa <ExFatFile::truncate()+0x60>
    4b6c:	ldr	r3, [r4, #32]
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    4b6e:	ldrd	r0, r1, [r0, #8]
    4b72:	ldrb.w	r2, [r3, #1093]	; 0x445
    4b76:	adds.w	r0, r0, #4294967295
    4b7a:	add.w	r2, r2, #9
    4b7e:	uxtb	r2, r2
    4b80:	adc.w	r1, r1, #4294967295
    4b84:	bl	9cd4 <__aeabi_llsr>
    4b88:	adds	r2, r0, #1
    if (m_curCluster) {
    4b8a:	cbz	r6, 4b98 <ExFatFile::truncate()+0x4e>
      toFree = m_curCluster + 1;
      nc -= 1 + m_curCluster - m_firstCluster;
    4b8c:	subs	r5, #1
      return true;
  }
  if (isContiguous()) {
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    if (m_curCluster) {
      toFree = m_curCluster + 1;
    4b8e:	adds	r3, r6, #1
      nc -= 1 + m_curCluster - m_firstCluster;
    4b90:	subs	r5, r5, r6
      return true;
  }
  if (isContiguous()) {
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    if (m_curCluster) {
      toFree = m_curCluster + 1;
    4b92:	str	r3, [sp, #4]
      nc -= 1 + m_curCluster - m_firstCluster;
    4b94:	add	r2, r5
    4b96:	b.n	4b9c <ExFatFile::truncate()+0x52>
    } else {
      toFree = m_firstCluster;
    4b98:	str	r5, [sp, #4]
      m_firstCluster = 0;
    4b9a:	str	r6, [r4, #28]
    }
    if (nc && !m_vol->bitmapModify(toFree, nc, 0)) {
    4b9c:	cbz	r2, 4be6 <ExFatFile::truncate()+0x9c>
    4b9e:	movs	r3, #0
    4ba0:	ldr	r1, [sp, #4]
    4ba2:	ldr	r0, [r4, #32]
    4ba4:	bl	4114 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    4ba8:	b.n	4bde <ExFatFile::truncate()+0x94>
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else {
    // need to free chain
    if (m_curCluster) {
    4baa:	cbz	r6, 4bd0 <ExFatFile::truncate()+0x86>
      toFree = 0;
    4bac:	add	r2, sp, #8
      int8_t fg = m_vol->fatGet(m_curCluster, &toFree);
    4bae:	ldr	r0, [r0, #32]
      goto fail;
    }
  } else {
    // need to free chain
    if (m_curCluster) {
      toFree = 0;
    4bb0:	str.w	r1, [r2, #-4]!
      int8_t fg = m_vol->fatGet(m_curCluster, &toFree);
    4bb4:	mov	r1, r6
    4bb6:	bl	41f0 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
      if (fg < 0) {
    4bba:	cmp	r0, #0
    4bbc:	blt.n	4b56 <ExFatFile::truncate()+0xc>
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (fg) {
    4bbe:	beq.n	4bd4 <ExFatFile::truncate()+0x8a>
        // current cluster is end of chain
        if (!m_vol->fatPut(m_curCluster, EXFAT_EOC)) {
    4bc0:	mov.w	r2, #4294967295
    4bc4:	ldr	r1, [r4, #24]
    4bc6:	ldr	r0, [r4, #32]
    4bc8:	bl	429c <ExFatPartition::fatPut(unsigned long, unsigned long)>
    4bcc:	cbnz	r0, 4bd4 <ExFatFile::truncate()+0x8a>
    4bce:	b.n	4b56 <ExFatFile::truncate()+0xc>
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
    } else {
      toFree = m_firstCluster;
    4bd0:	str	r5, [sp, #4]
      m_firstCluster = 0;
    4bd2:	str	r6, [r0, #28]
    }
    if (toFree) {
    4bd4:	ldr	r1, [sp, #4]
    4bd6:	cbz	r1, 4be6 <ExFatFile::truncate()+0x9c>
      if (!m_vol->freeChain(toFree)) {
    4bd8:	ldr	r0, [r4, #32]
    4bda:	bl	42d6 <ExFatPartition::freeChain(unsigned long)>
    4bde:	cbnz	r0, 4be6 <ExFatFile::truncate()+0x9c>
    4be0:	b.n	4b56 <ExFatFile::truncate()+0xc>
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
      return true;
    4be2:	movs	r0, #1
    4be4:	b.n	4c04 <ExFatFile::truncate()+0xba>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
  }
  m_dataLength = m_curPosition;
    4be6:	ldrd	r2, r3, [r4]
    4bea:	strd	r2, r3, [r4, #8]
  m_validLength = m_curPosition;
    4bee:	strd	r2, r3, [r4, #16]
  m_flags |= FILE_FLAG_DIR_DIRTY;
    4bf2:	ldrb.w	r3, [r4, #51]	; 0x33
    4bf6:	orn	r3, r3, #127	; 0x7f
    4bfa:	strb.w	r3, [r4, #51]	; 0x33
  return sync();
    4bfe:	mov	r0, r4
    4c00:	bl	4770 <ExFatFile::sync()>

 fail:
  return false;
}
    4c04:	add	sp, #8
    4c06:	pop	{r4, r5, r6, pc}

00004c08 <ExFatFile::write(void const*, unsigned int)>:
//------------------------------------------------------------------------------
size_t ExFatFile::write(const void* buf, size_t nbyte) {
    4c08:	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4c0c:	ldrb.w	r3, [r0, #51]	; 0x33
    4c10:	mov	r9, r1

  // number of bytes left to write  -  must be before goto statements
  size_t toWrite = nbyte;
  size_t n;
  // error if not an open file or is read-only
  if (!isWritable()) {
    4c12:	lsls	r1, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t ExFatFile::write(const void* buf, size_t nbyte) {
    4c14:	mov	r4, r0
    4c16:	mov	sl, r2

  // number of bytes left to write  -  must be before goto statements
  size_t toWrite = nbyte;
  size_t n;
  // error if not an open file or is read-only
  if (!isWritable()) {
    4c18:	bpl.w	4d92 <ExFatFile::write(void const*, unsigned int)+0x18a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    4c1c:	lsls	r2, r3, #28
    4c1e:	bmi.n	4c2e <ExFatFile::write(void const*, unsigned int)+0x26>
            fg = 1;
          } else {
            fg = 0;
          }
        } else {
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    4c20:	add.w	r3, r4, #24

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t ExFatFile::write(const void* buf, size_t nbyte) {
    4c24:	mov	r8, sl
            fg = 1;
          } else {
            fg = 0;
          }
        } else {
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    4c26:	str	r3, [sp, #0]
      if (sectorOffset == 0 && m_curPosition >= m_validLength) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
    4c28:	mov.w	fp, #1
    4c2c:	b.n	4cf4 <ExFatFile::write(void const*, unsigned int)+0xec>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    if (!seekSet(m_validLength)) {
    4c2e:	ldrd	r2, r3, [r0, #16]
    4c32:	bl	3b58 <ExFatFile::seekSet(unsigned long long)>
    4c36:	cmp	r0, #0
    4c38:	bne.n	4c20 <ExFatFile::write(void const*, unsigned int)+0x18>
    4c3a:	b.n	4d92 <ExFatFile::write(void const*, unsigned int)+0x18a>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  while (toWrite) {
    clusterOffset = m_curPosition & m_vol->clusterMask();
    4c3c:	ldr	r0, [r4, #32]
    4c3e:	ldr	r6, [r4, #0]
    4c40:	ldr.w	r3, [r0, #1080]	; 0x438
    4c44:	ands	r6, r3
    sectorOffset = clusterOffset & m_vol->sectorMask();
    4c46:	ubfx	r5, r6, #0, #9
    if (clusterOffset == 0) {
    4c4a:	cmp	r6, #0
    4c4c:	beq.n	4cfc <ExFatFile::write(void const*, unsigned int)+0xf4>
          m_curCluster = m_firstCluster;
        }
      }
    }
    // sector for data write
    sector = m_vol->clusterStartSector(m_curCluster) +
    4c4e:	ldr.w	lr, [r4, #32]
             (clusterOffset >> m_vol->bytesPerSectorShift());
    4c52:	ldr	r1, [r4, #24]
  bool dataCacheSync() {return m_dataCache.sync();}
  //----------------------------------------------------------------------------
  uint32_t clusterMask() const {return m_clusterMask;}
  uint32_t clusterStartSector(uint32_t cluster) {
    return m_clusterHeapStartSector +
           ((cluster - 2) << m_sectorsPerClusterShift);
    4c54:	ldrb.w	r2, [lr, #1093]	; 0x445
    4c58:	ldr.w	r3, [lr, #1068]	; 0x42c
    4c5c:	subs	r1, #2
    4c5e:	lsls	r1, r2
    4c60:	lsrs	r6, r6, #9
    4c62:	add	r1, r3
    4c64:	add	r1, r6

    if (sectorOffset != 0 || toWrite < m_vol->bytesPerSector()) {
    4c66:	cmp	r5, #0
    4c68:	bne.n	4d64 <ExFatFile::write(void const*, unsigned int)+0x15c>
    4c6a:	cmp.w	r8, #512	; 0x200
    4c6e:	bcs.w	4da6 <ExFatFile::write(void const*, unsigned int)+0x19e>
      // lesser of space and amount to write
      if (n > toWrite) {
        n = toWrite;
      }

      if (sectorOffset == 0 && m_curPosition >= m_validLength) {
    4c72:	ldrd	r2, r3, [r4, #16]
    4c76:	ldrd	r6, r7, [r4]
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
    4c7a:	cmp	r7, r3
    4c7c:	it	eq
    4c7e:	cmpeq	r6, r2
    4c80:	ite	cc
    4c82:	movcc	r2, #1
    4c84:	movcs	r2, #5
#endif  // USE_EXFAT_BITMAP_CACHE
  }
  void dataCacheDirty() {m_dataCache.dirty();}
  void dataCacheInvalidate() {m_dataCache.invalidate();}
  uint8_t* dataCacheGet(uint32_t sector, uint8_t option) {
    return m_dataCache.get(sector, option);
    4c86:	add.w	r0, lr, #528	; 0x210
    4c8a:	bl	3072 <FsCache::get(unsigned long, unsigned char)>
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
      }
      cache = m_vol->dataCacheGet(sector, cacheOption);
      if (!cache) {
    4c8e:	cmp	r0, #0
    4c90:	beq.n	4d92 <ExFatFile::write(void const*, unsigned int)+0x18a>
             (clusterOffset >> m_vol->bytesPerSectorShift());

    if (sectorOffset != 0 || toWrite < m_vol->bytesPerSector()) {
      // partial sector - must use cache
      // max space in sector
      n = m_vol->bytesPerSector() - sectorOffset;
    4c92:	rsb	r6, r5, #512	; 0x200
    4c96:	cmp	r6, r8
    4c98:	it	cs
    4c9a:	movcs	r6, r8
      if (!cache) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = cache + sectorOffset;
      memcpy(dst, src, n);
    4c9c:	add	r0, r5
    4c9e:	mov	r2, r6
    4ca0:	mov	r1, r9
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    4ca2:	add	r5, r6
      if (!cache) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = cache + sectorOffset;
      memcpy(dst, src, n);
    4ca4:	bl	8720 <memcpy>
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    4ca8:	cmp.w	r5, #512	; 0x200
    4cac:	bne.n	4cbc <ExFatFile::write(void const*, unsigned int)+0xb4>
  }
  uint32_t dataCacheSector() {return m_dataCache.sector();}
  bool dataCacheSync() {return m_dataCache.sync();}
    4cae:	ldr	r0, [r4, #32]
    4cb0:	add.w	r0, r0, #528	; 0x210
    4cb4:	bl	3026 <FsCache::sync()>
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
      if (ns > maxNs) {
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
      if (!m_vol->cacheSafeWrite(sector, src, ns)) {
    4cb8:	cmp	r0, #0
    4cba:	beq.n	4d92 <ExFatFile::write(void const*, unsigned int)+0x18a>
      if (!m_vol->cacheSafeWrite(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    4cbc:	ldrd	r0, r1, [r4]
    4cc0:	adds	r2, r0, r6
    4cc2:	adc.w	r3, r1, #0
    4cc6:	mov	r0, r2
    4cc8:	mov	r1, r3
    4cca:	strd	r2, r3, [r4]
    src += n;
    toWrite -= n;
    if (m_curPosition > m_validLength) {
    4cce:	ldrd	r2, r3, [r4, #16]
    4cd2:	cmp	r3, r1
    4cd4:	it	eq
    4cd6:	cmpeq	r2, r0
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    src += n;
    4cd8:	add	r9, r6
    toWrite -= n;
    4cda:	rsb	r8, r6, r8
    if (m_curPosition > m_validLength) {
    4cde:	bcs.n	4cf4 <ExFatFile::write(void const*, unsigned int)+0xec>
      m_flags |= FILE_FLAG_DIR_DIRTY;
    4ce0:	ldrb.w	r3, [r4, #51]	; 0x33
    4ce4:	orn	r3, r3, #127	; 0x7f
    4ce8:	strb.w	r3, [r4, #51]	; 0x33
      m_validLength = m_curPosition;
    4cec:	mov	r2, r0
    4cee:	mov	r3, r1
    4cf0:	strd	r2, r3, [r4, #16]
    if (!seekSet(m_validLength)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  while (toWrite) {
    4cf4:	cmp.w	r8, #0
    4cf8:	bne.n	4c3c <ExFatFile::write(void const*, unsigned int)+0x34>
    4cfa:	b.n	4d68 <ExFatFile::write(void const*, unsigned int)+0x160>
    clusterOffset = m_curPosition & m_vol->clusterMask();
    sectorOffset = clusterOffset & m_vol->sectorMask();
    if (clusterOffset == 0) {
      // start of new cluster
      if (m_curCluster != 0) {
    4cfc:	ldr	r7, [r4, #24]
    4cfe:	cbz	r7, 4d4e <ExFatFile::write(void const*, unsigned int)+0x146>
        int fg;

        if (isContiguous()) {
    4d00:	ldrb.w	r3, [r4, #51]	; 0x33
    4d04:	lsls	r3, r3, #25
    4d06:	bpl.n	4d3e <ExFatFile::write(void const*, unsigned int)+0x136>
          uint32_t lc = m_firstCluster;
          lc += (m_dataLength - 1) >> m_vol->bytesPerClusterShift();
          if (m_curCluster < lc) {
    4d08:	ldrb.w	r2, [r0, #1093]	; 0x445
      // start of new cluster
      if (m_curCluster != 0) {
        int fg;

        if (isContiguous()) {
          uint32_t lc = m_firstCluster;
    4d0c:	ldr	r3, [r4, #28]
    4d0e:	str	r3, [sp, #4]
          lc += (m_dataLength - 1) >> m_vol->bytesPerClusterShift();
          if (m_curCluster < lc) {
    4d10:	ldrd	r0, r1, [r4, #8]
    4d14:	adds	r2, #9
    4d16:	adds.w	r0, r0, #4294967295
    4d1a:	adc.w	r1, r1, #4294967295
    4d1e:	uxtb	r2, r2
    4d20:	bl	9cd4 <__aeabi_llsr>
    4d24:	ldr	r3, [sp, #4]
    4d26:	add	r0, r3
    4d28:	cmp	r7, r0
    4d2a:	bcc.n	4d38 <ExFatFile::write(void const*, unsigned int)+0x130>
            goto fail;
          }
        }
        if (fg == 0) {
          // add cluster if at end of chain
          if (!addCluster()) {
    4d2c:	mov	r0, r4
    4d2e:	bl	4524 <ExFatFile::addCluster()>
    4d32:	cmp	r0, #0
    4d34:	bne.n	4c4e <ExFatFile::write(void const*, unsigned int)+0x46>
    4d36:	b.n	4d92 <ExFatFile::write(void const*, unsigned int)+0x18a>

        if (isContiguous()) {
          uint32_t lc = m_firstCluster;
          lc += (m_dataLength - 1) >> m_vol->bytesPerClusterShift();
          if (m_curCluster < lc) {
            m_curCluster++;
    4d38:	adds	r7, #1
    4d3a:	str	r7, [r4, #24]
    4d3c:	b.n	4c4e <ExFatFile::write(void const*, unsigned int)+0x46>
            fg = 1;
          } else {
            fg = 0;
          }
        } else {
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    4d3e:	ldr	r2, [sp, #0]
    4d40:	mov	r1, r7
    4d42:	bl	41f0 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
          if (fg < 0) {
    4d46:	cmp	r0, #0
    4d48:	blt.n	4d92 <ExFatFile::write(void const*, unsigned int)+0x18a>
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
        if (fg == 0) {
    4d4a:	bne.n	4c4e <ExFatFile::write(void const*, unsigned int)+0x46>
    4d4c:	b.n	4d2c <ExFatFile::write(void const*, unsigned int)+0x124>
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
      } else {
        if (m_firstCluster == 0) {
    4d4e:	ldr	r3, [r4, #28]
    4d50:	cbnz	r3, 4d60 <ExFatFile::write(void const*, unsigned int)+0x158>
          // allocate first cluster of file
          if (!addCluster()) {
    4d52:	mov	r0, r4
    4d54:	bl	4524 <ExFatFile::addCluster()>
    4d58:	cbz	r0, 4d92 <ExFatFile::write(void const*, unsigned int)+0x18a>
            DBG_FAIL_MACRO;
            goto fail;
          }
          m_firstCluster = m_curCluster;
    4d5a:	ldr	r3, [r4, #24]
    4d5c:	str	r3, [r4, #28]
    4d5e:	b.n	4c4e <ExFatFile::write(void const*, unsigned int)+0x46>
        } else {
          m_curCluster = m_firstCluster;
    4d60:	str	r3, [r4, #24]
    4d62:	b.n	4c4e <ExFatFile::write(void const*, unsigned int)+0x46>
      if (sectorOffset == 0 && m_curPosition >= m_validLength) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
    4d64:	movs	r2, #1
    4d66:	b.n	4c86 <ExFatFile::write(void const*, unsigned int)+0x7e>
    if (m_curPosition > m_validLength) {
      m_flags |= FILE_FLAG_DIR_DIRTY;
      m_validLength = m_curPosition;
    }
  }
  if (m_curPosition > m_dataLength) {
    4d68:	ldrd	r0, r1, [r4]
    4d6c:	ldrd	r2, r3, [r4, #8]
    4d70:	cmp	r3, r1
    4d72:	it	eq
    4d74:	cmpeq	r2, r0
    4d76:	bcs.n	4d7e <ExFatFile::write(void const*, unsigned int)+0x176>
    m_dataLength = m_curPosition;
    4d78:	strd	r0, r1, [r4, #8]
    4d7c:	b.n	4d84 <ExFatFile::write(void const*, unsigned int)+0x17c>
    // update fileSize and insure sync will update dir entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
  } else if (FsDateTime::callback) {
    4d7e:	ldr	r3, [pc, #148]	; (4e14 <ExFatFile::write(void const*, unsigned int)+0x20c>)
    4d80:	ldr	r3, [r3, #0]
    4d82:	cbz	r3, 4da2 <ExFatFile::write(void const*, unsigned int)+0x19a>
    // insure sync will update modified date and time
    m_flags |= FILE_FLAG_DIR_DIRTY;
    4d84:	ldrb.w	r3, [r4, #51]	; 0x33
    4d88:	orn	r3, r3, #127	; 0x7f
    4d8c:	strb.w	r3, [r4, #51]	; 0x33
    4d90:	b.n	4da2 <ExFatFile::write(void const*, unsigned int)+0x19a>
  }
  return nbyte;

 fail:
  // return for write error
  m_error |= WRITE_ERROR;
    4d92:	ldrb.w	r3, [r4, #50]	; 0x32
    4d96:	orr.w	r3, r3, #1
    4d9a:	strb.w	r3, [r4, #50]	; 0x32
  return 0;
    4d9e:	movs	r0, #0
    4da0:	b.n	4e0e <ExFatFile::write(void const*, unsigned int)+0x206>
    m_flags |= FILE_FLAG_DIR_DIRTY;
  } else if (FsDateTime::callback) {
    // insure sync will update modified date and time
    m_flags |= FILE_FLAG_DIR_DIRTY;
  }
  return nbyte;
    4da2:	mov	r0, sl
    4da4:	b.n	4e0e <ExFatFile::write(void const*, unsigned int)+0x206>
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
#if USE_MULTI_SECTOR_IO
    } else if (toWrite >= 2*m_vol->bytesPerSector()) {
    4da6:	cmp.w	r8, #1024	; 0x400
    4daa:	ldr.w	r7, [lr, #540]	; 0x21c
    4dae:	ldr.w	r0, [lr, #532]	; 0x214
    4db2:	bcc.n	4dde <ExFatFile::write(void const*, unsigned int)+0x1d6>
      // use multiple sector write command
      uint32_t ns = toWrite >> m_vol->bytesPerSectorShift();
      // Limit writes to current cluster.
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
    4db4:	lsl.w	r3, fp, r2
    4db8:	subs	r6, r3, r6
        }
      }
#if USE_MULTI_SECTOR_IO
    } else if (toWrite >= 2*m_vol->bytesPerSector()) {
      // use multiple sector write command
      uint32_t ns = toWrite >> m_vol->bytesPerSectorShift();
    4dba:	mov.w	ip, r8, lsr #9
    4dbe:	cmp	ip, r6
    4dc0:	mov	r3, ip
    4dc2:	it	cs
    4dc4:	movcs	r3, r6
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    4dc6:	cmp	r1, r7
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
      if (ns > maxNs) {
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
    4dc8:	mov.w	r6, r3, lsl #9
    4dcc:	bhi.n	4dd4 <ExFatFile::write(void const*, unsigned int)+0x1cc>
    4dce:	adds	r2, r1, r3
    4dd0:	cmp	r7, r2
    4dd2:	bcc.n	4e00 <ExFatFile::write(void const*, unsigned int)+0x1f8>
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src, size_t count) {
     if (isCached(sector, count)) {
      invalidate();
    }
    return m_blockDev->writeSectors(sector, src, count);
    4dd4:	ldr	r2, [r0, #0]
    4dd6:	ldr	r5, [r2, #36]	; 0x24
    4dd8:	mov	r2, r9
    4dda:	blx	r5
    4ddc:	b.n	4cb8 <ExFatFile::write(void const*, unsigned int)+0xb0>
   * \param[in] sector Logical sector to be written.
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src) {
    if (isCached(sector)) {
    4dde:	cmp	r1, r7
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    4de0:	ittt	eq
    4de2:	strbeq.w	r5, [lr, #528]	; 0x210
    m_sector = 0XFFFFFFFF;
    4de6:	moveq.w	r3, #4294967295
    4dea:	streq.w	r3, [lr, #540]	; 0x21c
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src) {
    if (isCached(sector)) {
      invalidate();
    }
    return m_blockDev->writeSector(sector, src);
    4dee:	ldr	r3, [r0, #0]
    4df0:	mov	r2, r9
    4df2:	ldr	r3, [r3, #32]
    4df4:	blx	r3
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeWrite(sector, src)) {
    4df6:	cmp	r0, #0
    4df8:	beq.n	4d92 <ExFatFile::write(void const*, unsigned int)+0x18a>
         DBG_FAIL_MACRO;
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      n = m_vol->bytesPerSector();
    4dfa:	mov.w	r6, #512	; 0x200
    4dfe:	b.n	4cbc <ExFatFile::write(void const*, unsigned int)+0xb4>
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    4e00:	mov.w	r2, #4294967295
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    4e04:	strb.w	r5, [lr, #528]	; 0x210
    m_sector = 0XFFFFFFFF;
    4e08:	str.w	r2, [lr, #540]	; 0x21c
    4e0c:	b.n	4dd4 <ExFatFile::write(void const*, unsigned int)+0x1cc>

 fail:
  // return for write error
  m_error |= WRITE_ERROR;
  return 0;
}
    4e0e:	add	sp, #12
    4e10:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    4e14:	.word	0x1fff8418

00004e18 <initFatDirCallback(unsigned long, void*)>:
  uint16_t count;
  uint16_t dotcount;
};
static const uint8_t * initFatDirCallback(uint32_t sector, void *context) {
  struct initFatDirState * state = (struct initFatDirState *)context;
  if (state->pr && ++state->count >= state->dotcount) {
    4e18:	ldr	r0, [r1, #4]
  uint8_t * buffer;
  print_t * pr;
  uint16_t count;
  uint16_t dotcount;
};
static const uint8_t * initFatDirCallback(uint32_t sector, void *context) {
    4e1a:	push	{r4, lr}
    4e1c:	mov	r4, r1
  struct initFatDirState * state = (struct initFatDirState *)context;
  if (state->pr && ++state->count >= state->dotcount) {
    4e1e:	cbz	r0, 4e38 <initFatDirCallback(unsigned long, void*)+0x20>
    4e20:	ldrh	r3, [r1, #8]
    4e22:	ldrh	r2, [r1, #10]
    4e24:	adds	r3, #1
    4e26:	uxth	r3, r3
    4e28:	cmp	r2, r3
    4e2a:	strh	r3, [r1, #8]
    4e2c:	bhi.n	4e38 <initFatDirCallback(unsigned long, void*)+0x20>
    state->pr->write(".");
    4e2e:	ldr	r1, [pc, #12]	; (4e3c <initFatDirCallback(unsigned long, void*)+0x24>)
    4e30:	bl	a40 <Print::write(char const*)>
    state->count = 0;
    4e34:	movs	r3, #0
    4e36:	strh	r3, [r4, #8]
  }
  return state->buffer;
    4e38:	ldr	r0, [r4, #0]
}
    4e3a:	pop	{r4, pc}
    4e3c:	.word	0x000124cd

00004e40 <FatFormatter::initFatDir(unsigned char, unsigned long)>:
bool FatFormatter::initFatDir(uint8_t fatType, uint32_t sectorCount) {
    4e40:	push	{r4, r5, r6, r7, lr}
    4e42:	mov	r4, r0
    4e44:	sub	sp, #28
    4e46:	mov	r6, r1
    4e48:	mov	r5, r2
  size_t n;
  memset(m_secBuf, 0, BYTES_PER_SECTOR);
    4e4a:	movs	r1, #0
    4e4c:	mov.w	r2, #512	; 0x200
    4e50:	ldr	r0, [r0, #36]	; 0x24
    4e52:	bl	88c8 <memset>
  writeMsg("Writing FAT ");
    4e56:	ldr	r0, [r4, #32]
    4e58:	cbz	r0, 4e60 <FatFormatter::initFatDir(unsigned char, unsigned long)+0x20>
    4e5a:	ldr	r1, [pc, #128]	; (4edc <FatFormatter::initFatDir(unsigned char, unsigned long)+0x9c>)
    4e5c:	bl	a40 <Print::write(char const*)>
  struct initFatDirState state;
  state.buffer = m_secBuf;
    4e60:	ldr	r3, [r4, #36]	; 0x24
    4e62:	str	r3, [sp, #12]
  state.pr = m_pr;
    4e64:	ldr	r3, [r4, #32]
    4e66:	str	r3, [sp, #16]
  state.count = 0;
  state.dotcount = sectorCount/32;
  if (!m_dev->writeSectorsCallback(m_fatStart + 1, sectorCount - 1, initFatDirCallback, &state)) {
    4e68:	ldr	r0, [r4, #28]
    4e6a:	ldr	r1, [r4, #12]
  memset(m_secBuf, 0, BYTES_PER_SECTOR);
  writeMsg("Writing FAT ");
  struct initFatDirState state;
  state.buffer = m_secBuf;
  state.pr = m_pr;
  state.count = 0;
    4e6c:	movs	r3, #0
    4e6e:	strh.w	r3, [sp, #20]
  state.dotcount = sectorCount/32;
    4e72:	lsrs	r3, r5, #5
  if (!m_dev->writeSectorsCallback(m_fatStart + 1, sectorCount - 1, initFatDirCallback, &state)) {
    4e74:	add	r2, sp, #12
  writeMsg("Writing FAT ");
  struct initFatDirState state;
  state.buffer = m_secBuf;
  state.pr = m_pr;
  state.count = 0;
  state.dotcount = sectorCount/32;
    4e76:	strh.w	r3, [sp, #22]
  if (!m_dev->writeSectorsCallback(m_fatStart + 1, sectorCount - 1, initFatDirCallback, &state)) {
    4e7a:	ldr	r3, [r0, #0]
    4e7c:	str	r2, [sp, #0]
    4e7e:	ldr	r7, [r3, #40]	; 0x28
    4e80:	ldr	r3, [pc, #92]	; (4ee0 <FatFormatter::initFatDir(unsigned char, unsigned long)+0xa0>)
    4e82:	subs	r2, r5, #1
    4e84:	adds	r1, #1
    4e86:	blx	r7
    4e88:	cbnz	r0, 4e8e <FatFormatter::initFatDir(unsigned char, unsigned long)+0x4e>
     return false;
    4e8a:	movs	r0, #0
    4e8c:	b.n	4ed6 <FatFormatter::initFatDir(unsigned char, unsigned long)+0x96>
  }
  writeMsg("\r\n");
    4e8e:	ldr	r0, [r4, #32]
    4e90:	cbz	r0, 4e98 <FatFormatter::initFatDir(unsigned char, unsigned long)+0x58>
    4e92:	ldr	r1, [pc, #80]	; (4ee4 <FatFormatter::initFatDir(unsigned char, unsigned long)+0xa4>)
    4e94:	bl	a40 <Print::write(char const*)>
  // Allocate reserved clusters and root for FAT32.
  m_secBuf[0] = 0XF8;
    4e98:	ldr	r3, [r4, #36]	; 0x24
    4e9a:	movs	r2, #248	; 0xf8
  n = fatType == 16 ? 4 : 12;
    4e9c:	cmp	r6, #16
  if (!m_dev->writeSectorsCallback(m_fatStart + 1, sectorCount - 1, initFatDirCallback, &state)) {
     return false;
  }
  writeMsg("\r\n");
  // Allocate reserved clusters and root for FAT32.
  m_secBuf[0] = 0XF8;
    4e9e:	strb	r2, [r3, #0]
  n = fatType == 16 ? 4 : 12;
  for (size_t i = 1; i < n; i++) {
    m_secBuf[i] = 0XFF;
    4ea0:	mov.w	r0, #255	; 0xff
     return false;
  }
  writeMsg("\r\n");
  // Allocate reserved clusters and root for FAT32.
  m_secBuf[0] = 0XF8;
  n = fatType == 16 ? 4 : 12;
    4ea4:	ite	eq
    4ea6:	moveq	r2, #4
    4ea8:	movne	r2, #12
  for (size_t i = 1; i < n; i++) {
    4eaa:	movs	r3, #1
    m_secBuf[i] = 0XFF;
    4eac:	ldr	r1, [r4, #36]	; 0x24
    4eae:	strb	r0, [r1, r3]
  }
  writeMsg("\r\n");
  // Allocate reserved clusters and root for FAT32.
  m_secBuf[0] = 0XF8;
  n = fatType == 16 ? 4 : 12;
  for (size_t i = 1; i < n; i++) {
    4eb0:	adds	r3, #1
    4eb2:	cmp	r2, r3
    4eb4:	bne.n	4eac <FatFormatter::initFatDir(unsigned char, unsigned long)+0x6c>
    m_secBuf[i] = 0XFF;
  }
  return m_dev->writeSector(m_fatStart, m_secBuf) &&
    4eb6:	ldr	r0, [r4, #28]
    4eb8:	ldr	r2, [r4, #36]	; 0x24
    4eba:	ldr	r3, [r0, #0]
    4ebc:	ldr	r1, [r4, #12]
    4ebe:	ldr	r3, [r3, #32]
    4ec0:	blx	r3
    4ec2:	cmp	r0, #0
    4ec4:	beq.n	4e8a <FatFormatter::initFatDir(unsigned char, unsigned long)+0x4a>
         m_dev->writeSector(m_fatStart + m_fatSize, m_secBuf);
    4ec6:	ldr	r0, [r4, #28]
    4ec8:	ldr	r5, [r4, #12]
    4eca:	ldr	r1, [r4, #8]
    4ecc:	ldr	r3, [r0, #0]
    4ece:	ldr	r2, [r4, #36]	; 0x24
    4ed0:	ldr	r3, [r3, #32]
    4ed2:	add	r1, r5
    4ed4:	blx	r3
}
    4ed6:	add	sp, #28
    4ed8:	pop	{r4, r5, r6, r7, pc}
    4eda:	nop
    4edc:	.word	0x000124c0
    4ee0:	.word	0x00004e19
    4ee4:	.word	0x0001253f

00004ee8 <FatFormatter::initPbs()>:
//------------------------------------------------------------------------------
void FatFormatter::initPbs() {
    4ee8:	push	{r3, r4, r5, lr}
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
    4eea:	ldr	r4, [r0, #36]	; 0x24
  memset(m_secBuf, 0, BYTES_PER_SECTOR);
    4eec:	mov.w	r2, #512	; 0x200
    4ef0:	movs	r1, #0
  }
  return m_dev->writeSector(m_fatStart, m_secBuf) &&
         m_dev->writeSector(m_fatStart + m_fatSize, m_secBuf);
}
//------------------------------------------------------------------------------
void FatFormatter::initPbs() {
    4ef2:	mov	r5, r0
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
  memset(m_secBuf, 0, BYTES_PER_SECTOR);
    4ef4:	mov	r0, r4
    4ef6:	bl	88c8 <memset>
  pbs->jmpInstruction[0] = 0XEB;
    4efa:	movs	r3, #235	; 0xeb
    4efc:	strb	r3, [r4, #0]
  pbs->jmpInstruction[1] = 0X76;
    4efe:	movs	r3, #118	; 0x76
    4f00:	strb	r3, [r4, #1]
  pbs->jmpInstruction[2] = 0X90;
    4f02:	mov	r3, r4
    4f04:	movs	r2, #144	; 0x90
    4f06:	strb.w	r2, [r3, #2]!
  for (uint8_t i = 0; i < sizeof(pbs->oemName); i++) {
    pbs->oemName[i] = ' ';
    4f0a:	movs	r1, #32
    4f0c:	add.w	r2, r4, #10
    4f10:	strb.w	r1, [r3, #1]!
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
  memset(m_secBuf, 0, BYTES_PER_SECTOR);
  pbs->jmpInstruction[0] = 0XEB;
  pbs->jmpInstruction[1] = 0X76;
  pbs->jmpInstruction[2] = 0X90;
  for (uint8_t i = 0; i < sizeof(pbs->oemName); i++) {
    4f14:	cmp	r3, r2
    4f16:	bne.n	4f10 <FatFormatter::initPbs()+0x28>
    4f18:	mov.w	r3, #512	; 0x200
    4f1c:	strh.w	r3, [r4, #11]
    pbs->oemName[i] = ' ';
  }
  setLe16(pbs->bpb.bpb16.bytesPerSector, BYTES_PER_SECTOR);
  pbs->bpb.bpb16.sectorsPerCluster = m_sectorsPerCluster;
    4f20:	ldrb.w	r3, [r5, #43]	; 0x2b
    4f24:	strb	r3, [r4, #13]
  setLe16(pbs->bpb.bpb16.reservedSectorCount, m_reservedSectorCount);
    4f26:	ldrh	r3, [r5, #40]	; 0x28
    4f28:	strh	r3, [r4, #14]
  pbs->bpb.bpb16.fatCount = 2;
    4f2a:	movs	r3, #2
    4f2c:	strb	r3, [r4, #16]
  // skip rootDirEntryCount
  // skip totalSectors16
  pbs->bpb.bpb16.mediaType = 0XF8;
    4f2e:	movs	r3, #248	; 0xf8
    4f30:	strb	r3, [r4, #21]
  // skip sectorsPerFat16
  // skip sectorsPerTrack
  // skip headCount
  setLe32(pbs->bpb.bpb16.hidddenSectors, m_relativeSectors);
    4f32:	ldr	r3, [r5, #16]
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    4f34:	str	r3, [r4, #28]
  setLe32(pbs->bpb.bpb16.totalSectors32, m_totalSectors);
    4f36:	ldr	r3, [r5, #24]
    4f38:	str	r3, [r4, #32]
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    4f3a:	movw	r3, #43605	; 0xaa55
    4f3e:	strh.w	r3, [r4, #510]	; 0x1fe
    4f42:	pop	{r3, r4, r5, pc}

00004f44 <FatFormatter::writeMbr()>:
    return false;
  }
  return initFatDir(32, 2*m_fatSize + m_sectorsPerCluster);
}
//------------------------------------------------------------------------------
bool FatFormatter::writeMbr() {
    4f44:	push	{r4, r5, r6, lr}
    4f46:	mov	r4, r0
  memset(m_secBuf, 0, BYTES_PER_SECTOR);
    4f48:	mov.w	r2, #512	; 0x200
    4f4c:	movs	r1, #0
    4f4e:	ldr	r0, [r0, #36]	; 0x24
    4f50:	bl	88c8 <memset>
  MbrSector_t* mbr = reinterpret_cast<MbrSector_t*>(m_secBuf);
    4f54:	ldr	r5, [r4, #36]	; 0x24

#if USE_LBA_TO_CHS
  lbaToMbrChs(mbr->part->beginCHS, m_capacityMB, m_relativeSectors);
    4f56:	ldr	r2, [r4, #16]
    4f58:	ldr	r1, [r4, #0]
    4f5a:	addw	r0, r5, #447	; 0x1bf
    4f5e:	bl	2f98 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)>
  lbaToMbrChs(mbr->part->endCHS, m_capacityMB,
              m_relativeSectors + m_totalSectors -1);
    4f62:	ldr	r3, [r4, #24]
    4f64:	ldr	r2, [r4, #16]
    4f66:	ldr	r1, [r4, #0]
    4f68:	add	r2, r3
    4f6a:	addw	r0, r5, #451	; 0x1c3
    4f6e:	subs	r2, #1
    4f70:	bl	2f98 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)>
  mbr->part->endCHS[0] = 0XFE;
  mbr->part->endCHS[1] = 0XFF;
  mbr->part->endCHS[2] = 0XFF;
#endif  // USE_LBA_TO_CHS

  mbr->part->type = m_partType;
    4f74:	ldrb.w	r3, [r4, #42]	; 0x2a
    4f78:	strb.w	r3, [r5, #450]	; 0x1c2
  setLe32(mbr->part->relativeSectors, m_relativeSectors);
    4f7c:	ldr	r3, [r4, #16]
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    4f7e:	str.w	r3, [r5, #454]	; 0x1c6
  setLe32(mbr->part->totalSectors, m_totalSectors);
    4f82:	ldr	r3, [r4, #24]
  setLe16(mbr->signature, MBR_SIGNATURE);
  return m_dev->writeSector(0, m_secBuf);
    4f84:	ldr	r0, [r4, #28]
    4f86:	str.w	r3, [r5, #458]	; 0x1ca
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    4f8a:	movw	r3, #43605	; 0xaa55
    4f8e:	strh.w	r3, [r5, #510]	; 0x1fe
    4f92:	ldr	r3, [r0, #0]
    4f94:	ldr	r2, [r4, #36]	; 0x24
    4f96:	ldr	r3, [r3, #32]
    4f98:	movs	r1, #0
}
    4f9a:	ldmia.w	sp!, {r4, r5, r6, lr}

  mbr->part->type = m_partType;
  setLe32(mbr->part->relativeSectors, m_relativeSectors);
  setLe32(mbr->part->totalSectors, m_totalSectors);
  setLe16(mbr->signature, MBR_SIGNATURE);
  return m_dev->writeSector(0, m_secBuf);
    4f9e:	bx	r3

00004fa0 <FatFormatter::makeFat16()>:
  setLe32(pbs->bpb.bpb16.totalSectors32, m_totalSectors);
  // skip rest of bpb
  setLe16(pbs->signature, PBR_SIGNATURE);
}
//------------------------------------------------------------------------------
bool FatFormatter::makeFat16() {
    4fa0:	push	{r3, r4, r5, r6, r7, lr}
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);

  for (m_dataStart = 2*BU16; ; m_dataStart += BU16) {
    4fa2:	mov.w	r3, #256	; 0x100
}
//------------------------------------------------------------------------------
bool FatFormatter::makeFat16() {
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
    4fa6:	ldr	r5, [r0, #36]	; 0x24

  for (m_dataStart = 2*BU16; ; m_dataStart += BU16) {
    nc = (m_sectorCount - m_dataStart)/m_sectorsPerCluster;
    4fa8:	ldr.w	lr, [r0, #20]
    4fac:	ldrb.w	r2, [r0, #43]	; 0x2b
bool FatFormatter::makeFat16() {
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);

  for (m_dataStart = 2*BU16; ; m_dataStart += BU16) {
    4fb0:	str	r3, [r0, #4]
  setLe32(pbs->bpb.bpb16.totalSectors32, m_totalSectors);
  // skip rest of bpb
  setLe16(pbs->signature, PBR_SIGNATURE);
}
//------------------------------------------------------------------------------
bool FatFormatter::makeFat16() {
    4fb2:	mov	r4, r0
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);

  for (m_dataStart = 2*BU16; ; m_dataStart += BU16) {
    nc = (m_sectorCount - m_dataStart)/m_sectorsPerCluster;
    4fb4:	ldr	r3, [r4, #4]
    4fb6:	rsb	r1, r3, lr
    4fba:	udiv	r1, r1, r2
    m_fatSize = (nc + 2 + (BYTES_PER_SECTOR/2) - 1)/(BYTES_PER_SECTOR/2);
    4fbe:	addw	r6, r1, #257	; 0x101
    4fc2:	lsrs	r6, r6, #8
    r = BU16 + 1 + 2*m_fatSize + FAT16_ROOT_SECTOR_COUNT;
    4fc4:	lsls	r0, r6, #1
    4fc6:	add.w	r7, r0, #161	; 0xa1
    if (m_dataStart >= r) {
    4fca:	cmp	r3, r7
    4fcc:	bcc.n	4fe4 <FatFormatter::makeFat16()+0x44>
      m_relativeSectors = m_dataStart - r + BU16;
    4fce:	subs	r3, r3, r7
    4fd0:	str	r6, [r4, #8]
    4fd2:	add.w	r6, r3, #128	; 0x80
    4fd6:	str	r6, [r4, #16]
      break;
    }
  }
  // check valid cluster count for FAT16 volume
  if (nc < 4085 || nc >= 65525) {
    4fd8:	subw	r6, r1, #4085	; 0xff5
    4fdc:	cmp.w	r6, #61440	; 0xf000
    4fe0:	bcs.n	4fea <FatFormatter::makeFat16()+0x4a>
    4fe2:	b.n	4ff8 <FatFormatter::makeFat16()+0x58>
bool FatFormatter::makeFat16() {
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);

  for (m_dataStart = 2*BU16; ; m_dataStart += BU16) {
    4fe4:	adds	r3, #128	; 0x80
    4fe6:	str	r3, [r4, #4]
    4fe8:	b.n	4fb4 <FatFormatter::makeFat16()+0x14>
      break;
    }
  }
  // check valid cluster count for FAT16 volume
  if (nc < 4085 || nc >= 65525) {
    writeMsg("Bad cluster count\r\n");
    4fea:	ldr	r0, [r4, #32]
    4fec:	cmp	r0, #0
    4fee:	beq.n	5098 <FatFormatter::makeFat16()+0xf8>
    4ff0:	ldr	r1, [pc, #168]	; (509c <FatFormatter::makeFat16()+0xfc>)
    4ff2:	bl	a40 <Print::write(char const*)>
    4ff6:	b.n	5098 <FatFormatter::makeFat16()+0xf8>
    return false;
  }
  m_reservedSectorCount = 1;
  m_fatStart = m_relativeSectors + m_reservedSectorCount;
    4ff8:	adds	r3, #129	; 0x81
    4ffa:	str	r3, [r4, #12]
  m_totalSectors = nc*m_sectorsPerCluster
                   + 2*m_fatSize + m_reservedSectorCount + 32;
    4ffc:	add.w	r3, r0, #33	; 0x21
    5000:	mla	r3, r1, r2, r3
  if (m_totalSectors < 65536) {
    5004:	cmp.w	r3, #65536	; 0x10000
    return false;
  }
  m_reservedSectorCount = 1;
  m_fatStart = m_relativeSectors + m_reservedSectorCount;
  m_totalSectors = nc*m_sectorsPerCluster
                   + 2*m_fatSize + m_reservedSectorCount + 32;
    5008:	str	r3, [r4, #24]
  // check valid cluster count for FAT16 volume
  if (nc < 4085 || nc >= 65525) {
    writeMsg("Bad cluster count\r\n");
    return false;
  }
  m_reservedSectorCount = 1;
    500a:	mov.w	r6, #1
  m_fatStart = m_relativeSectors + m_reservedSectorCount;
  m_totalSectors = nc*m_sectorsPerCluster
                   + 2*m_fatSize + m_reservedSectorCount + 32;
  if (m_totalSectors < 65536) {
    m_partType = 0X04;
    500e:	ite	cc
    5010:	movcc	r3, #4
  } else {
    m_partType = 0X06;
    5012:	movcs	r3, #6
  // check valid cluster count for FAT16 volume
  if (nc < 4085 || nc >= 65525) {
    writeMsg("Bad cluster count\r\n");
    return false;
  }
  m_reservedSectorCount = 1;
    5014:	strh	r6, [r4, #40]	; 0x28
  m_totalSectors = nc*m_sectorsPerCluster
                   + 2*m_fatSize + m_reservedSectorCount + 32;
  if (m_totalSectors < 65536) {
    m_partType = 0X04;
  } else {
    m_partType = 0X06;
    5016:	strb.w	r3, [r4, #42]	; 0x2a
  }
  // write MBR
  if (!writeMbr()) {
    501a:	mov	r0, r4
    501c:	bl	4f44 <FatFormatter::writeMbr()>
    5020:	cmp	r0, #0
    5022:	beq.n	5098 <FatFormatter::makeFat16()+0xf8>
    return false;
  }
  initPbs();
    5024:	mov	r0, r4
    5026:	bl	4ee8 <FatFormatter::initPbs()>
    502a:	mov.w	r3, #512	; 0x200
    502e:	strh.w	r3, [r5, #17]
    5032:	ldr	r3, [r4, #8]
    5034:	strh	r3, [r5, #22]
  setLe16(pbs->bpb.bpb16.rootDirEntryCount, FAT16_ROOT_ENTRY_COUNT);
  setLe16(pbs->bpb.bpb16.sectorsPerFat16, m_fatSize);
  pbs->bpb.bpb16.physicalDriveNumber = 0X80;
    5036:	movs	r3, #128	; 0x80
    5038:	strb.w	r3, [r5, #36]	; 0x24
  pbs->bpb.bpb16.extSignature = EXTENDED_BOOT_SIGNATURE;
    503c:	movs	r3, #41	; 0x29
    503e:	strb.w	r3, [r5, #38]	; 0x26
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    5042:	ldr	r3, [pc, #92]	; (50a0 <FatFormatter::makeFat16()+0x100>)
    5044:	str.w	r3, [r5, #39]	; 0x27
    5048:	add.w	r2, r5, #53	; 0x35
    504c:	add.w	r3, r5, #42	; 0x2a
  setLe32(pbs->bpb.bpb16.volumeSerialNumber, 1234567);
  for (size_t i = 0; i < sizeof(pbs->bpb.bpb16.volumeLabel); i++) {
    pbs->bpb.bpb16.volumeLabel[i] = ' ';
    5050:	movs	r1, #32
    5052:	strb.w	r1, [r3, #1]!
  setLe16(pbs->bpb.bpb16.rootDirEntryCount, FAT16_ROOT_ENTRY_COUNT);
  setLe16(pbs->bpb.bpb16.sectorsPerFat16, m_fatSize);
  pbs->bpb.bpb16.physicalDriveNumber = 0X80;
  pbs->bpb.bpb16.extSignature = EXTENDED_BOOT_SIGNATURE;
  setLe32(pbs->bpb.bpb16.volumeSerialNumber, 1234567);
  for (size_t i = 0; i < sizeof(pbs->bpb.bpb16.volumeLabel); i++) {
    5056:	cmp	r3, r2
    5058:	bne.n	5052 <FatFormatter::makeFat16()+0xb2>
    pbs->bpb.bpb16.volumeLabel[i] = ' ';
  }
  pbs->bpb.bpb16.volumeType[0] = 'F';
    505a:	movs	r3, #70	; 0x46
    505c:	strb.w	r3, [r5, #54]	; 0x36
  pbs->bpb.bpb16.volumeType[1] = 'A';
    5060:	movs	r3, #65	; 0x41
    5062:	strb.w	r3, [r5, #55]	; 0x37
  pbs->bpb.bpb16.volumeType[2] = 'T';
    5066:	movs	r3, #84	; 0x54
    5068:	strb.w	r3, [r5, #56]	; 0x38
  pbs->bpb.bpb16.volumeType[3] = '1';
    506c:	movs	r3, #49	; 0x31
    506e:	strb.w	r3, [r5, #57]	; 0x39
  pbs->bpb.bpb16.volumeType[4] = '6';
    5072:	movs	r3, #54	; 0x36
    5074:	strb.w	r3, [r5, #58]	; 0x3a
  if (!m_dev->writeSector(m_relativeSectors, m_secBuf)) {
    5078:	ldr	r0, [r4, #28]
    507a:	ldr	r2, [r4, #36]	; 0x24
    507c:	ldr	r3, [r0, #0]
    507e:	ldr	r1, [r4, #16]
    5080:	ldr	r3, [r3, #32]
    5082:	blx	r3
    5084:	cbz	r0, 5098 <FatFormatter::makeFat16()+0xf8>
    return false;
  }
  return initFatDir(16, m_dataStart - m_fatStart);
    5086:	ldr	r2, [r4, #4]
    5088:	ldr	r3, [r4, #12]
    508a:	mov	r0, r4
    508c:	subs	r2, r2, r3
    508e:	movs	r1, #16
}
    5090:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  pbs->bpb.bpb16.volumeType[3] = '1';
  pbs->bpb.bpb16.volumeType[4] = '6';
  if (!m_dev->writeSector(m_relativeSectors, m_secBuf)) {
    return false;
  }
  return initFatDir(16, m_dataStart - m_fatStart);
    5094:	b.w	4e40 <FatFormatter::initFatDir(unsigned char, unsigned long)>
}
    5098:	movs	r0, #0
    509a:	pop	{r3, r4, r5, r6, r7, pc}
    509c:	.word	0x00012519
    50a0:	.word	0x0012d687

000050a4 <FatFormatter::makeFat32()>:
//------------------------------------------------------------------------------
bool FatFormatter::makeFat32() {
    50a4:	push	{r3, r4, r5, r6, r7, lr}
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
  FsInfo_t* fsi = reinterpret_cast<FsInfo_t*>(m_secBuf);

  m_relativeSectors = BU32;
    50a6:	mov.w	r3, #8192	; 0x2000
    50aa:	str	r3, [r0, #16]
  for (m_dataStart = 2*BU32; ; m_dataStart += BU32) {
    50ac:	mov.w	r3, #16384	; 0x4000
    50b0:	str	r3, [r0, #4]
}
//------------------------------------------------------------------------------
bool FatFormatter::makeFat32() {
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
    50b2:	ldr	r5, [r0, #36]	; 0x24
  FsInfo_t* fsi = reinterpret_cast<FsInfo_t*>(m_secBuf);

  m_relativeSectors = BU32;
  for (m_dataStart = 2*BU32; ; m_dataStart += BU32) {
    nc = (m_sectorCount - m_dataStart)/m_sectorsPerCluster;
    50b4:	ldr	r3, [r0, #20]
    50b6:	ldrb.w	r1, [r0, #43]	; 0x2b
    return false;
  }
  return initFatDir(16, m_dataStart - m_fatStart);
}
//------------------------------------------------------------------------------
bool FatFormatter::makeFat32() {
    50ba:	mov	r4, r0
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
  FsInfo_t* fsi = reinterpret_cast<FsInfo_t*>(m_secBuf);

  m_relativeSectors = BU32;
  for (m_dataStart = 2*BU32; ; m_dataStart += BU32) {
    nc = (m_sectorCount - m_dataStart)/m_sectorsPerCluster;
    50bc:	ldr	r2, [r4, #4]
    50be:	subs	r0, r3, r2
    50c0:	udiv	r0, r0, r1
    m_fatSize = (nc + 2 + (BYTES_PER_SECTOR/4) - 1)/(BYTES_PER_SECTOR/4);
    50c4:	add.w	r6, r0, #129	; 0x81
    50c8:	lsrs	r6, r6, #7
    r = m_relativeSectors + 9 + 2*m_fatSize;
    if (m_dataStart >= r) {
    50ca:	mov.w	lr, r6, lsl #1
    50ce:	add.w	r7, lr, #8192	; 0x2000
    50d2:	adds	r7, #9
    50d4:	cmp	r2, r7
    50d6:	bcs.n	50e0 <FatFormatter::makeFat32()+0x3c>
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
  FsInfo_t* fsi = reinterpret_cast<FsInfo_t*>(m_secBuf);

  m_relativeSectors = BU32;
  for (m_dataStart = 2*BU32; ; m_dataStart += BU32) {
    50d8:	add.w	r2, r2, #8192	; 0x2000
    50dc:	str	r2, [r4, #4]
    50de:	b.n	50bc <FatFormatter::makeFat32()+0x18>
    if (m_dataStart >= r) {
      break;
    }
  }
  // error if too few clusters in FAT32 volume
  if (nc < 65525) {
    50e0:	movw	r3, #65524	; 0xfff4
    50e4:	cmp	r0, r3
    50e6:	str	r6, [r4, #8]
    50e8:	bhi.n	50fa <FatFormatter::makeFat32()+0x56>
    writeMsg("Bad cluster count\r\n");
    50ea:	ldr	r0, [r4, #32]
    50ec:	cmp	r0, #0
    50ee:	beq.w	5232 <FatFormatter::makeFat32()+0x18e>
    50f2:	ldr	r1, [pc, #324]	; (5238 <FatFormatter::makeFat32()+0x194>)
    50f4:	bl	a40 <Print::write(char const*)>
    50f8:	b.n	5232 <FatFormatter::makeFat32()+0x18e>
    return false;
  }
  m_reservedSectorCount = m_dataStart - m_relativeSectors - 2*m_fatSize;
    50fa:	sub.w	r3, r2, #8192	; 0x2000
    50fe:	rsb	r3, lr, r3
    5102:	uxth	r3, r3
  m_fatStart = m_relativeSectors + m_reservedSectorCount;
  m_totalSectors = nc*m_sectorsPerCluster + m_dataStart - m_relativeSectors;
    5104:	mla	r2, r0, r1, r2
  // error if too few clusters in FAT32 volume
  if (nc < 65525) {
    writeMsg("Bad cluster count\r\n");
    return false;
  }
  m_reservedSectorCount = m_dataStart - m_relativeSectors - 2*m_fatSize;
    5108:	strh	r3, [r4, #40]	; 0x28
  m_fatStart = m_relativeSectors + m_reservedSectorCount;
    510a:	add.w	r3, r3, #8192	; 0x2000
    510e:	str	r3, [r4, #12]
  m_totalSectors = nc*m_sectorsPerCluster + m_dataStart - m_relativeSectors;
    5110:	sub.w	r3, r2, #8192	; 0x2000
    5114:	str	r3, [r4, #24]
  // type depends on address of end sector
  // max CHS has lba = 16450560 = 1024*255*63
  if ((m_relativeSectors + m_totalSectors) <= 16450560) {
    5116:	ldr	r3, [pc, #292]	; (523c <FatFormatter::makeFat32()+0x198>)
    5118:	cmp	r2, r3
    // FAT32 with CHS and LBA
    m_partType = 0X0B;
    511a:	ite	ls
    511c:	movls	r3, #11
  } else {
    // FAT32 with only LBA
    m_partType = 0X0C;
    511e:	movhi	r3, #12
    5120:	strb.w	r3, [r4, #42]	; 0x2a
  }
  if (!writeMbr()) {
    5124:	mov	r0, r4
    5126:	bl	4f44 <FatFormatter::writeMbr()>
    512a:	cmp	r0, #0
    512c:	beq.w	5232 <FatFormatter::makeFat32()+0x18e>
    return false;
  }
  initPbs();
    5130:	mov	r0, r4
    5132:	bl	4ee8 <FatFormatter::initPbs()>
  setLe32(pbs->bpb.bpb32.sectorsPerFat32, m_fatSize);
    5136:	ldr	r3, [r4, #8]
    5138:	str	r3, [r5, #36]	; 0x24
    513a:	movs	r3, #2
    513c:	str	r3, [r5, #44]	; 0x2c
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    513e:	movs	r3, #1
    5140:	strh	r3, [r5, #48]	; 0x30
    5142:	movs	r3, #6
    5144:	strh	r3, [r5, #50]	; 0x32
  setLe32(pbs->bpb.bpb32.fat32RootCluster, 2);
  setLe16(pbs->bpb.bpb32.fat32FSInfoSector, 1);
  setLe16(pbs->bpb.bpb32.fat32BackBootSector, 6);
  pbs->bpb.bpb32.physicalDriveNumber = 0X80;
    5146:	movs	r3, #128	; 0x80
    5148:	strb.w	r3, [r5, #64]	; 0x40
  pbs->bpb.bpb32.extSignature = EXTENDED_BOOT_SIGNATURE;
    514c:	movs	r3, #41	; 0x29
    514e:	strb.w	r3, [r5, #66]	; 0x42
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    5152:	ldr	r3, [pc, #236]	; (5240 <FatFormatter::makeFat32()+0x19c>)
    5154:	str.w	r3, [r5, #67]	; 0x43
    5158:	add.w	r2, r5, #81	; 0x51
    515c:	add.w	r3, r5, #70	; 0x46
  setLe32(pbs->bpb.bpb32.volumeSerialNumber, 1234567);
  for (size_t i = 0; i < sizeof(pbs->bpb.bpb32.volumeLabel); i++) {
    pbs->bpb.bpb32.volumeLabel[i] = ' ';
    5160:	movs	r1, #32
    5162:	strb.w	r1, [r3, #1]!
  setLe16(pbs->bpb.bpb32.fat32FSInfoSector, 1);
  setLe16(pbs->bpb.bpb32.fat32BackBootSector, 6);
  pbs->bpb.bpb32.physicalDriveNumber = 0X80;
  pbs->bpb.bpb32.extSignature = EXTENDED_BOOT_SIGNATURE;
  setLe32(pbs->bpb.bpb32.volumeSerialNumber, 1234567);
  for (size_t i = 0; i < sizeof(pbs->bpb.bpb32.volumeLabel); i++) {
    5166:	cmp	r3, r2
    5168:	bne.n	5162 <FatFormatter::makeFat32()+0xbe>
    pbs->bpb.bpb32.volumeLabel[i] = ' ';
  }
  pbs->bpb.bpb32.volumeType[0] = 'F';
    516a:	movs	r3, #70	; 0x46
    516c:	strb.w	r3, [r5, #82]	; 0x52
  pbs->bpb.bpb32.volumeType[1] = 'A';
    5170:	movs	r3, #65	; 0x41
    5172:	strb.w	r3, [r5, #83]	; 0x53
  pbs->bpb.bpb32.volumeType[2] = 'T';
    5176:	movs	r3, #84	; 0x54
    5178:	strb.w	r3, [r5, #84]	; 0x54
  pbs->bpb.bpb32.volumeType[3] = '3';
    517c:	movs	r3, #51	; 0x33
    517e:	strb.w	r3, [r5, #85]	; 0x55
  pbs->bpb.bpb32.volumeType[4] = '2';
    5182:	movs	r3, #50	; 0x32
    5184:	strb.w	r3, [r5, #86]	; 0x56
  if (!m_dev->writeSector(m_relativeSectors, m_secBuf)  ||
    5188:	ldr	r0, [r4, #28]
    518a:	ldr	r2, [r4, #36]	; 0x24
    518c:	ldr	r3, [r0, #0]
    518e:	ldr	r1, [r4, #16]
    5190:	ldr	r3, [r3, #32]
    5192:	blx	r3
    5194:	cmp	r0, #0
    5196:	beq.n	5232 <FatFormatter::makeFat32()+0x18e>
      !m_dev->writeSector(m_relativeSectors + 6, m_secBuf)) {
    5198:	ldr	r0, [r4, #28]
    519a:	ldr	r1, [r4, #16]
    519c:	ldr	r3, [r0, #0]
    519e:	ldr	r2, [r4, #36]	; 0x24
    51a0:	ldr	r3, [r3, #32]
    51a2:	adds	r1, #6
    51a4:	blx	r3
  pbs->bpb.bpb32.volumeType[0] = 'F';
  pbs->bpb.bpb32.volumeType[1] = 'A';
  pbs->bpb.bpb32.volumeType[2] = 'T';
  pbs->bpb.bpb32.volumeType[3] = '3';
  pbs->bpb.bpb32.volumeType[4] = '2';
  if (!m_dev->writeSector(m_relativeSectors, m_secBuf)  ||
    51a6:	cmp	r0, #0
    51a8:	beq.n	5232 <FatFormatter::makeFat32()+0x18e>
      !m_dev->writeSector(m_relativeSectors + 6, m_secBuf)) {
    return false;
  }
  // write extra boot area and backup
  memset(m_secBuf, 0 , BYTES_PER_SECTOR);
    51aa:	mov.w	r2, #512	; 0x200
    51ae:	movs	r1, #0
    51b0:	ldr	r0, [r4, #36]	; 0x24
    51b2:	bl	88c8 <memset>
    51b6:	ldr	r3, [pc, #140]	; (5244 <FatFormatter::makeFat32()+0x1a0>)
  setLe32(fsi->trailSignature, FSINFO_TRAIL_SIGNATURE);
  if (!m_dev->writeSector(m_relativeSectors + 2, m_secBuf)  ||
    51b8:	ldr	r0, [r4, #28]
    51ba:	str.w	r3, [r5, #508]	; 0x1fc
    51be:	ldr	r1, [r4, #16]
    51c0:	ldr	r3, [r0, #0]
    51c2:	ldr	r2, [r4, #36]	; 0x24
    51c4:	ldr	r3, [r3, #32]
    51c6:	adds	r1, #2
    51c8:	blx	r3
    51ca:	cmp	r0, #0
    51cc:	beq.n	5232 <FatFormatter::makeFat32()+0x18e>
      !m_dev->writeSector(m_relativeSectors + 8, m_secBuf)) {
    51ce:	ldr	r0, [r4, #28]
    51d0:	ldr	r1, [r4, #16]
    51d2:	ldr	r3, [r0, #0]
    51d4:	ldr	r2, [r4, #36]	; 0x24
    51d6:	ldr	r3, [r3, #32]
    51d8:	adds	r1, #8
    51da:	blx	r3
    return false;
  }
  // write extra boot area and backup
  memset(m_secBuf, 0 , BYTES_PER_SECTOR);
  setLe32(fsi->trailSignature, FSINFO_TRAIL_SIGNATURE);
  if (!m_dev->writeSector(m_relativeSectors + 2, m_secBuf)  ||
    51dc:	cbz	r0, 5232 <FatFormatter::makeFat32()+0x18e>
    51de:	ldr	r3, [pc, #104]	; (5248 <FatFormatter::makeFat32()+0x1a4>)
    51e0:	str	r3, [r5, #0]
    51e2:	add.w	r3, r3, #534773760	; 0x1fe00000
    51e6:	add.w	r3, r3, #8192	; 0x2000
    51ea:	adds	r3, #32
    51ec:	str.w	r3, [r5, #484]	; 0x1e4
  // write FSINFO sector and backup
  setLe32(fsi->leadSignature, FSINFO_LEAD_SIGNATURE);
  setLe32(fsi->structSignature, FSINFO_STRUCT_SIGNATURE);
  setLe32(fsi->freeCount, 0XFFFFFFFF);
  setLe32(fsi->nextFree, 0XFFFFFFFF);
  if (!m_dev->writeSector(m_relativeSectors + 1, m_secBuf)  ||
    51f0:	ldr	r0, [r4, #28]
    51f2:	ldr	r2, [r4, #36]	; 0x24
    51f4:	mov.w	r3, #4294967295
    51f8:	str.w	r3, [r5, #488]	; 0x1e8
    51fc:	str.w	r3, [r5, #492]	; 0x1ec
    5200:	ldr	r1, [r4, #16]
    5202:	ldr	r3, [r0, #0]
    5204:	adds	r1, #1
    5206:	ldr	r3, [r3, #32]
    5208:	blx	r3
    520a:	cbz	r0, 5232 <FatFormatter::makeFat32()+0x18e>
      !m_dev->writeSector(m_relativeSectors + 7, m_secBuf)) {
    520c:	ldr	r0, [r4, #28]
    520e:	ldr	r1, [r4, #16]
    5210:	ldr	r3, [r0, #0]
    5212:	ldr	r2, [r4, #36]	; 0x24
    5214:	ldr	r3, [r3, #32]
    5216:	adds	r1, #7
    5218:	blx	r3
  // write FSINFO sector and backup
  setLe32(fsi->leadSignature, FSINFO_LEAD_SIGNATURE);
  setLe32(fsi->structSignature, FSINFO_STRUCT_SIGNATURE);
  setLe32(fsi->freeCount, 0XFFFFFFFF);
  setLe32(fsi->nextFree, 0XFFFFFFFF);
  if (!m_dev->writeSector(m_relativeSectors + 1, m_secBuf)  ||
    521a:	cbz	r0, 5232 <FatFormatter::makeFat32()+0x18e>
      !m_dev->writeSector(m_relativeSectors + 7, m_secBuf)) {
    return false;
  }
  return initFatDir(32, 2*m_fatSize + m_sectorsPerCluster);
    521c:	ldr	r2, [r4, #8]
    521e:	ldrb.w	r3, [r4, #43]	; 0x2b
    5222:	mov	r0, r4
    5224:	add.w	r2, r3, r2, lsl #1
    5228:	movs	r1, #32
}
    522a:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  setLe32(fsi->nextFree, 0XFFFFFFFF);
  if (!m_dev->writeSector(m_relativeSectors + 1, m_secBuf)  ||
      !m_dev->writeSector(m_relativeSectors + 7, m_secBuf)) {
    return false;
  }
  return initFatDir(32, 2*m_fatSize + m_sectorsPerCluster);
    522e:	b.w	4e40 <FatFormatter::initFatDir(unsigned char, unsigned long)>
}
    5232:	movs	r0, #0
    5234:	pop	{r3, r4, r5, r6, r7, pc}
    5236:	nop
    5238:	.word	0x00012519
    523c:	.word	0x00fb0400
    5240:	.word	0x0012d687
    5244:	.word	0xaa550000
    5248:	.word	0x41615252

0000524c <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)>:
#define writeMsg(str) if (m_pr) m_pr->print(F(str))
#else  // PRINT_FORMAT_PROGRESS
#define writeMsg(str) if (m_pr) m_pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool FatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
    524c:	push	{r3, r4, r5, lr}
  bool rtn;
  m_dev = dev;
  m_secBuf = secBuf;
  m_pr = pr;
    524e:	str	r3, [r0, #32]
  m_sectorCount = m_dev->sectorCount();
    5250:	ldr	r3, [r1, #0]
#define writeMsg(str) if (m_pr) m_pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool FatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
  bool rtn;
  m_dev = dev;
    5252:	str	r1, [r0, #28]
  m_secBuf = secBuf;
    5254:	str	r2, [r0, #36]	; 0x24
#define writeMsg(str) if (m_pr) m_pr->print(F(str))
#else  // PRINT_FORMAT_PROGRESS
#define writeMsg(str) if (m_pr) m_pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool FatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
    5256:	mov	r4, r0
  bool rtn;
  m_dev = dev;
  m_secBuf = secBuf;
  m_pr = pr;
  m_sectorCount = m_dev->sectorCount();
    5258:	ldr	r3, [r3, #24]
    525a:	mov	r0, r1
    525c:	blx	r3
  m_capacityMB = (m_sectorCount + SECTORS_PER_MB - 1)/SECTORS_PER_MB;
    525e:	addw	r3, r0, #2047	; 0x7ff
    5262:	lsrs	r3, r3, #11

  if (m_capacityMB <= 6) {
    5264:	cmp	r3, #6
bool FatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
  bool rtn;
  m_dev = dev;
  m_secBuf = secBuf;
  m_pr = pr;
  m_sectorCount = m_dev->sectorCount();
    5266:	str	r0, [r4, #20]
  m_capacityMB = (m_sectorCount + SECTORS_PER_MB - 1)/SECTORS_PER_MB;
    5268:	str	r3, [r4, #0]

  if (m_capacityMB <= 6) {
    526a:	bhi.n	527a <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x2e>
    writeMsg("Card is too small.\r\n");
    526c:	ldr	r0, [r4, #32]
    526e:	cbz	r0, 5276 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x2a>
    5270:	ldr	r1, [pc, #108]	; (52e0 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x94>)
    5272:	bl	a40 <Print::write(char const*)>
    return false;
    5276:	movs	r0, #0
    5278:	pop	{r3, r4, r5, pc}
  } else if (m_capacityMB <= 16) {
    527a:	cmp	r3, #16
    527c:	bhi.n	5282 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x36>
    m_sectorsPerCluster = 2;
    527e:	movs	r3, #2
    5280:	b.n	52ae <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x62>
  } else if (m_capacityMB <= 32) {
    5282:	cmp	r3, #32
    5284:	bhi.n	528a <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x3e>
    m_sectorsPerCluster = 4;
    5286:	movs	r3, #4
    5288:	b.n	52ae <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x62>
  } else if (m_capacityMB <= 64) {
    528a:	cmp	r3, #64	; 0x40
    528c:	bhi.n	5292 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x46>
    m_sectorsPerCluster = 8;
    528e:	movs	r3, #8
    5290:	b.n	52ae <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x62>
  } else if (m_capacityMB <= 128) {
    5292:	cmp	r3, #128	; 0x80
    5294:	bhi.n	529a <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x4e>
    m_sectorsPerCluster = 16;
    5296:	movs	r3, #16
    5298:	b.n	52ae <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x62>
  } else if (m_capacityMB <= 1024) {
    529a:	cmp.w	r3, #1024	; 0x400
    529e:	bhi.n	52a4 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x58>
    m_sectorsPerCluster = 32;
    52a0:	movs	r3, #32
    52a2:	b.n	52ae <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x62>
  } else if (m_capacityMB <= 32768) {
    52a4:	cmp.w	r3, #32768	; 0x8000
    m_sectorsPerCluster = 64;
    52a8:	ite	ls
    52aa:	movls	r3, #64	; 0x40
  } else {
    // SDXC cards
    m_sectorsPerCluster = 128;
    52ac:	movhi	r3, #128	; 0x80
  }
  rtn = m_sectorCount < 0X400000 ? makeFat16() : makeFat32();
    52ae:	cmp.w	r0, #4194304	; 0x400000
    m_sectorsPerCluster = 32;
  } else if (m_capacityMB <= 32768) {
    m_sectorsPerCluster = 64;
  } else {
    // SDXC cards
    m_sectorsPerCluster = 128;
    52b2:	strb.w	r3, [r4, #43]	; 0x2b
  }
  rtn = m_sectorCount < 0X400000 ? makeFat16() : makeFat32();
    52b6:	mov	r0, r4
    52b8:	bcs.n	52c0 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x74>
    52ba:	bl	4fa0 <FatFormatter::makeFat16()>
    52be:	b.n	52c4 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x78>
    52c0:	bl	50a4 <FatFormatter::makeFat32()>
    52c4:	mov	r5, r0
    52c6:	ldr	r0, [r4, #32]
  if (rtn) {
    52c8:	cbz	r5, 52d4 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x88>
    writeMsg("Format Done\r\n");
    52ca:	cbz	r0, 52dc <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x90>
    52cc:	ldr	r1, [pc, #20]	; (52e4 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x98>)
    52ce:	bl	a40 <Print::write(char const*)>
    52d2:	b.n	52dc <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x90>
  } else {
    writeMsg("Format Failed\r\n");
    52d4:	cmp	r0, #0
    52d6:	beq.n	5276 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x2a>
    52d8:	ldr	r1, [pc, #12]	; (52e8 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x9c>)
    52da:	b.n	5272 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x26>
    52dc:	movs	r0, #1
  }
  return rtn;
}
    52de:	pop	{r3, r4, r5, pc}
    52e0:	.word	0x0001252d
    52e4:	.word	0x00012542
    52e8:	.word	0x00012550

000052ec <FatFile::cacheDir(unsigned short)>:

  // private functions

  bool addCluster();
  bool addDirCluster();
  DirFat_t* cacheDir(uint16_t index) {
    52ec:	push	{r4, lr}
    return seekSet(32UL*index) ? readDirCache() : nullptr;
    52ee:	lsls	r1, r1, #5

  // private functions

  bool addCluster();
  bool addDirCluster();
  DirFat_t* cacheDir(uint16_t index) {
    52f0:	mov	r4, r0
    return seekSet(32UL*index) ? readDirCache() : nullptr;
    52f2:	bl	57ea <FatFile::seekSet(unsigned long)>
    52f6:	cbz	r0, 5304 <FatFile::cacheDir(unsigned short)+0x18>
    52f8:	mov	r0, r4
    52fa:	movs	r1, #0
  }
    52fc:	ldmia.w	sp!, {r4, lr}
  // private functions

  bool addCluster();
  bool addDirCluster();
  DirFat_t* cacheDir(uint16_t index) {
    return seekSet(32UL*index) ? readDirCache() : nullptr;
    5300:	b.w	57b0 <FatFile::readDirCache(bool)>
  }
    5304:	pop	{r4, pc}

00005306 <FatFile::getLfnChar(DirLfn_t*, unsigned char)>:
#include "FatFile.h"
#include "FatVolume.h"

//------------------------------------------------------------------------------
uint16_t FatFile::getLfnChar(DirLfn_t* ldir, uint8_t i) {
  if (i < 5) {
    5306:	cmp	r2, #4
    5308:	bhi.n	5314 <FatFile::getLfnChar(DirLfn_t*, unsigned char)+0xe>
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    530a:	add.w	r1, r1, r2, lsl #1
    530e:	ldrh.w	r0, [r1, #1]
    return getLe16(ldir->unicode1 + 2*i);
    5312:	bx	lr
  } else if (i < 11) {
    5314:	cmp	r2, #10
    5316:	bhi.n	5320 <FatFile::getLfnChar(DirLfn_t*, unsigned char)+0x1a>
    5318:	add.w	r1, r1, r2, lsl #1
    531c:	ldrh	r0, [r1, #4]
    return getLe16(ldir->unicode2 + 2*i - 10);
    531e:	bx	lr
  } else if (i < 13) {
    5320:	cmp	r2, #12
    5322:	itte	ls
    5324:	addls.w	r1, r1, r2, lsl #1
    5328:	ldrhls	r0, [r1, #6]
    return getLe16(ldir->unicode3 + 2*i - 22);
  }
  DBG_HALT_IF(i >= 13);
  return 0;
    532a:	movhi	r0, #0
}
    532c:	bx	lr

0000532e <FatFile::getSFN(char*, unsigned int)>:
 fail:
  *name = 0;
  return 0;
}
//------------------------------------------------------------------------------
size_t FatFile::getSFN(char* name, size_t size) {
    532e:	push	{r3, r4, r5, r6, r7, lr}
    5330:	mov	r6, r1
    5332:	ldrb	r1, [r0, #0]
    5334:	mov	r7, r2
  char c;
  uint8_t j = 0;
  uint8_t lcBit = FAT_CASE_LC_BASE;
  uint8_t* ptr;
  DirFat_t* dir;
  if (!isOpen()) {
    5336:	cbz	r1, 53b0 <FatFile::getSFN(char*, unsigned int)+0x82>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isRoot()) {
    5338:	ands.w	r4, r1, #96	; 0x60
    533c:	beq.n	534e <FatFile::getSFN(char*, unsigned int)+0x20>
    if (size < 2) {
    533e:	cmp	r2, #1
    5340:	bls.n	53b0 <FatFile::getSFN(char*, unsigned int)+0x82>
      DBG_FAIL_MACRO;
      goto fail;
    }
    name[0] = '/';
    5342:	movs	r3, #47	; 0x2f
    5344:	strb	r3, [r6, #0]
    name[1] = '\0';
    5346:	movs	r3, #0
    5348:	strb	r3, [r6, #1]
    return 1;
    534a:	movs	r0, #1
    534c:	pop	{r3, r4, r5, r6, r7, pc}
  }
  // cache entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_READ);
    534e:	mov	r1, r4
    5350:	bl	5594 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    5354:	cbz	r0, 53b0 <FatFile::getSFN(char*, unsigned int)+0x82>
    DBG_FAIL_MACRO;
    goto fail;
  }
  ptr = dir->name;
    5356:	mov	r5, r0
    5358:	mov	r1, r4
}
//------------------------------------------------------------------------------
size_t FatFile::getSFN(char* name, size_t size) {
  char c;
  uint8_t j = 0;
  uint8_t lcBit = FAT_CASE_LC_BASE;
    535a:	movs	r2, #8
  return 0;
}
//------------------------------------------------------------------------------
size_t FatFile::getSFN(char* name, size_t size) {
  char c;
  uint8_t j = 0;
    535c:	mov	r3, r4
    goto fail;
  }
  ptr = dir->name;
  // format name
  for (uint8_t i = 0; i < 12; i++) {
    if (i == 8) {
    535e:	cmp	r1, #8
    5360:	ldrb	r4, [r5, #0]
    5362:	bne.n	536e <FatFile::getSFN(char*, unsigned int)+0x40>
      if (*ptr == ' ') {
    5364:	cmp	r4, #32
    5366:	beq.n	53a8 <FatFile::getSFN(char*, unsigned int)+0x7a>
        break;
      }
      lcBit = FAT_CASE_LC_EXT;
    5368:	movs	r2, #16
      c = '.';
    536a:	movs	r4, #46	; 0x2e
    536c:	b.n	5390 <FatFile::getSFN(char*, unsigned int)+0x62>
    } else {
      c = *ptr++;
      if ('A' <= c && c <= 'Z' && (lcBit & dir->caseFlags)) {
    536e:	sub.w	lr, r4, #65	; 0x41
    5372:	cmp.w	lr, #25
        break;
      }
      lcBit = FAT_CASE_LC_EXT;
      c = '.';
    } else {
      c = *ptr++;
    5376:	add.w	r5, r5, #1
      if ('A' <= c && c <= 'Z' && (lcBit & dir->caseFlags)) {
    537a:	bhi.n	538c <FatFile::getSFN(char*, unsigned int)+0x5e>
    537c:	ldrb.w	lr, [r0, #12]
    5380:	tst.w	r2, lr
    5384:	beq.n	5390 <FatFile::getSFN(char*, unsigned int)+0x62>
        c += 'a' - 'A';
    5386:	adds	r4, #32
    5388:	uxtb	r4, r4
    538a:	b.n	5390 <FatFile::getSFN(char*, unsigned int)+0x62>
      }
      if (c == ' ') {
    538c:	cmp	r4, #32
    538e:	beq.n	53a2 <FatFile::getSFN(char*, unsigned int)+0x74>
        continue;
      }
    }
    if ((j + 1u) == size) {
    5390:	add.w	lr, r3, #1
    5394:	cmp	r7, lr
    5396:	mov	ip, r3
    5398:	beq.n	53a8 <FatFile::getSFN(char*, unsigned int)+0x7a>
      break;
    }
    name[j++] = c;
    539a:	strb.w	r4, [r6, ip]
    539e:	uxtb.w	r3, lr
    53a2:	adds	r1, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  ptr = dir->name;
  // format name
  for (uint8_t i = 0; i < 12; i++) {
    53a4:	cmp	r1, #12
    53a6:	bne.n	535e <FatFile::getSFN(char*, unsigned int)+0x30>
    if ((j + 1u) == size) {
      break;
    }
    name[j++] = c;
  }
  name[j] = '\0';
    53a8:	movs	r2, #0
    53aa:	strb	r2, [r6, r3]
  return j;
    53ac:	mov	r0, r3
    53ae:	pop	{r3, r4, r5, r6, r7, pc}

 fail:
  name[0] = '\0';
    53b0:	movs	r0, #0
    53b2:	strb	r0, [r6, #0]
  return 0;
}
    53b4:	pop	{r3, r4, r5, r6, r7, pc}
    53b6:	Address 0x000053b6 is out of bounds.


000053b8 <FatFile::getName8(char*, unsigned int)>:
 fail:
  name[0] = '\0';
  return 0;
}
//------------------------------------------------------------------------------
size_t FatFile::getName8(char* name, size_t size) {
    53b8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    53bc:	sub	sp, #44	; 0x2c
  char* ptr;
  FatFile dir;
  DirLfn_t* ldir;
  uint16_t hs = 0;
  uint32_t cp;
  if (!isOpen()) {
    53be:	ldrb	r3, [r0, #0]
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    53c0:	movs	r4, #0
 fail:
  name[0] = '\0';
  return 0;
}
//------------------------------------------------------------------------------
size_t FatFile::getName8(char* name, size_t size) {
    53c2:	mov	r7, r0
    53c4:	mov	r9, r1
    53c6:	mov	r8, r2
    53c8:	strb.w	r4, [sp, #4]
    53cc:	strb.w	r4, [sp, #5]
    53d0:	strb.w	r4, [sp, #6]
  char* ptr;
  FatFile dir;
  DirLfn_t* ldir;
  uint16_t hs = 0;
  uint32_t cp;
  if (!isOpen()) {
    53d4:	cmp	r3, #0
    53d6:	beq.n	5498 <FatFile::getName8(char*, unsigned int)+0xe0>
      DBG_FAIL_MACRO;
      goto fail;
  }
  if (!isLFN()) {
    53d8:	ldrb	r3, [r0, #3]
    53da:	cbnz	r3, 53e2 <FatFile::getName8(char*, unsigned int)+0x2a>
    return getSFN(name, size);
    53dc:	bl	532e <FatFile::getSFN(char*, unsigned int)>
    53e0:	b.n	549e <FatFile::getName8(char*, unsigned int)+0xe6>
  }
  if (!dir.openCluster(this)) {
    53e2:	mov	r1, r0
    53e4:	add	r0, sp, #4
    53e6:	bl	55e2 <FatFile::openCluster(FatFile*)>
    53ea:	cmp	r0, #0
    53ec:	beq.n	5498 <FatFile::getName8(char*, unsigned int)+0xe0>
      } else {
        DBG_FAIL_MACRO;
        goto fail;
      }
      // Save space for zero byte.
      ptr = FsUtf::cpToMb(cp, str, end - 1);
    53ee:	add.w	r8, r8, #4294967295
    53f2:	mov	r5, r9
    53f4:	movs	r6, #1
    53f6:	add	r8, r9
  }
  if (!dir.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    53f8:	ldrb	r3, [r7, #3]
    53fa:	cmp	r3, r6
    53fc:	bcc.n	548e <FatFile::getName8(char*, unsigned int)+0xd6>
    ldir = reinterpret_cast<DirLfn_t*>(dir.cacheDir(m_dirIndex - order));
    53fe:	ldrh	r1, [r7, #4]
    5400:	subs	r1, r1, r6
    5402:	uxth	r1, r1
    5404:	add	r0, sp, #4
    5406:	bl	52ec <FatFile::cacheDir(unsigned short)>
    if (!ldir) {
    540a:	mov	fp, r0
    540c:	cmp	r0, #0
    540e:	beq.n	5498 <FatFile::getName8(char*, unsigned int)+0xe0>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
    5410:	ldrb	r3, [r0, #11]
    5412:	cmp	r3, #15
    5414:	bne.n	5498 <FatFile::getName8(char*, unsigned int)+0xe0>
    5416:	ldrb	r3, [r0, #0]
    5418:	and.w	r3, r3, #31
    541c:	cmp	r6, r3
    541e:	bne.n	5498 <FatFile::getName8(char*, unsigned int)+0xe0>
    5420:	mov	r3, r4
    5422:	mov.w	sl, #0
        order != (ldir->order & 0X1F)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (uint8_t i = 0; i < 13; i++) {
      uint16_t c = getLfnChar(ldir, i);
    5426:	uxtb.w	r2, sl
    542a:	mov	r1, fp
    542c:	mov	r0, r7
    542e:	bl	5306 <FatFile::getLfnChar(DirLfn_t*, unsigned char)>
    5432:	mov	r4, r0
      if (hs) {
    5434:	cbz	r3, 5454 <FatFile::getName8(char*, unsigned int)+0x9c>
        if (!FsUtf::isLowSurrogate(c)) {
    5436:	add.w	r2, r0, #9216	; 0x2400
    543a:	uxth	r2, r2
    543c:	cmp.w	r2, #1024	; 0x400
    5440:	bcs.n	5498 <FatFile::getName8(char*, unsigned int)+0xe0>
   * \param[in] hs high surrogate.
   * \param[in] ls low surrogate.
   * \return code point.
   */
  inline uint32_t u16ToCp(uint16_t hs, uint16_t ls) {
    return 0X10000 + (((hs & 0X3FF) << 10) | (ls & 0X3FF));
    5442:	ldr	r0, [pc, #96]	; (54a4 <FatFile::getName8(char*, unsigned int)+0xec>)
    5444:	lsls	r3, r3, #10
    5446:	ands	r0, r3
    5448:	ubfx	r4, r4, #0, #10
    544c:	orrs	r4, r0
    544e:	add.w	r0, r4, #65536	; 0x10000
    5452:	b.n	546c <FatFile::getName8(char*, unsigned int)+0xb4>
  /** Check for UTF-16 surrogate.
   * \param[in] c UTF-16 unit.
   * \return true if c is a surrogate else false.
   */
  inline bool isSurrogate(uint16_t c) {
    return 0XD800 <= c && c <= 0XDFFF;
    5454:	add.w	r3, r0, #10240	; 0x2800
    5458:	uxth	r3, r3
          DBG_FAIL_MACRO;
          goto fail;
        }
        cp = FsUtf::u16ToCp(hs, c);
        hs = 0;
      } else if (!FsUtf::isSurrogate(c)) {
    545a:	cmp.w	r3, #2048	; 0x800
    545e:	bcc.n	5464 <FatFile::getName8(char*, unsigned int)+0xac>
        if (c == 0) {
    5460:	cbnz	r0, 546c <FatFile::getName8(char*, unsigned int)+0xb4>
    5462:	b.n	548e <FatFile::getName8(char*, unsigned int)+0xd6>
          goto done;
        }
        cp = c;
      } else if (FsUtf::isHighSurrogate(c)) {
    5464:	cmp.w	r3, #1024	; 0x400
    5468:	bcc.n	547a <FatFile::getName8(char*, unsigned int)+0xc2>
    546a:	b.n	5498 <FatFile::getName8(char*, unsigned int)+0xe0>
      } else {
        DBG_FAIL_MACRO;
        goto fail;
      }
      // Save space for zero byte.
      ptr = FsUtf::cpToMb(cp, str, end - 1);
    546c:	mov	r2, r8
    546e:	mov	r1, r5
    5470:	bl	2cd0 <FsUtf::cpToMb(unsigned long, char*, char*)>
      if (!ptr) {
    5474:	cbz	r0, 548e <FatFile::getName8(char*, unsigned int)+0xd6>
    5476:	mov	r5, r0
    5478:	movs	r4, #0
    547a:	add.w	sl, sl, #1
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
        order != (ldir->order & 0X1F)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (uint8_t i = 0; i < 13; i++) {
    547e:	cmp.w	sl, #13
    5482:	beq.n	5488 <FatFile::getName8(char*, unsigned int)+0xd0>
    5484:	mov	r3, r4
    5486:	b.n	5426 <FatFile::getName8(char*, unsigned int)+0x6e>
  }
  if (!dir.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    5488:	adds	r6, #1
    548a:	uxtb	r6, r6
    548c:	b.n	53f8 <FatFile::getName8(char*, unsigned int)+0x40>
      }
      str = ptr;
    }
  }
 done:
  *str = '\0';
    548e:	movs	r3, #0
    5490:	strb	r3, [r5, #0]
  return str - name;
    5492:	rsb	r0, r9, r5
    5496:	b.n	549e <FatFile::getName8(char*, unsigned int)+0xe6>

 fail:
  *name = 0;
    5498:	movs	r0, #0
    549a:	strb.w	r0, [r9]
  return 0;
}
    549e:	add	sp, #44	; 0x2c
    54a0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    54a4:	.word	0x000ffc00

000054a8 <FatFile::getName(char*, unsigned int)>:
//------------------------------------------------------------------------------
size_t FatFile::getName(char* name, size_t size) {
#if !USE_LONG_FILE_NAMES
  return getSFN(name, size);
#elif USE_UTF8_LONG_NAMES
  return getName8(name, size);
    54a8:	b.w	53b8 <FatFile::getName8(char*, unsigned int)>

000054ac <FatPartition::cacheSync()>:
  FsCache m_fatCache;
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    54ac:	push	{r4, lr}
    54ae:	mov	r4, r0
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
    54b0:	adds	r0, #40	; 0x28
    54b2:	bl	3026 <FsCache::sync()>
    54b6:	cbz	r0, 54ce <FatPartition::cacheSync()+0x22>
    54b8:	add.w	r0, r4, #568	; 0x238
    54bc:	bl	3026 <FsCache::sync()>
    54c0:	cbz	r0, 54ce <FatPartition::cacheSync()+0x22>
    54c2:	ldr	r0, [r4, #0]
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
    54c4:	ldr	r3, [r0, #0]
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
  }
    54c6:	ldmia.w	sp!, {r4, lr}
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
    54ca:	ldr	r3, [r3, #28]
    54cc:	bx	r3
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
  }
    54ce:	movs	r0, #0
    54d0:	pop	{r4, pc}

000054d2 <FatFile::addCluster()>:
#include "FatVolume.h"
//------------------------------------------------------------------------------
// Add a cluster to a file.
bool FatFile::addCluster() {
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  uint32_t cc = m_curCluster;
    54d2:	mov	r2, r0
#include "../common/DebugMacros.h"
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
// Add a cluster to a file.
bool FatFile::addCluster() {
    54d4:	push	{r3, r4, r5, lr}
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  uint32_t cc = m_curCluster;
    54d6:	ldr.w	r5, [r2, #16]!
#include "../common/DebugMacros.h"
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
// Add a cluster to a file.
bool FatFile::addCluster() {
    54da:	mov	r4, r0
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  uint32_t cc = m_curCluster;
  if (!m_vol->allocateCluster(m_curCluster, &m_curCluster)) {
    54dc:	mov	r1, r5
    54de:	ldr	r0, [r0, #8]
    54e0:	bl	634a <FatPartition::allocateCluster(unsigned long, unsigned long*)>
    54e4:	cbz	r0, 5506 <FatFile::addCluster()+0x34>
    54e6:	ldrb	r3, [r4, #2]
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (cc == 0) {
    54e8:	cbnz	r5, 54f0 <FatFile::addCluster()+0x1e>
    m_flags |= FILE_FLAG_CONTIGUOUS;
    54ea:	orr.w	r3, r3, #64	; 0x40
    54ee:	b.n	54fc <FatFile::addCluster()+0x2a>
  } else if (m_curCluster != (cc + 1)) {
    54f0:	ldr	r2, [r4, #16]
    54f2:	adds	r5, #1
    54f4:	cmp	r2, r5
    54f6:	beq.n	54fe <FatFile::addCluster()+0x2c>
    m_flags &= ~FILE_FLAG_CONTIGUOUS;
    54f8:	bic.w	r3, r3, #64	; 0x40
    54fc:	strb	r3, [r4, #2]
  }
  m_flags |= FILE_FLAG_DIR_DIRTY;
    54fe:	ldrb	r3, [r4, #2]
    5500:	orn	r3, r3, #127	; 0x7f
    5504:	strb	r3, [r4, #2]
  return false;
#else  // USE_FAT_FILE_FLAG_CONTIGUOUS
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return m_vol->allocateCluster(m_curCluster, &m_curCluster);
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
}
    5506:	pop	{r3, r4, r5, pc}

00005508 <FatFile::addDirCluster()>:
//------------------------------------------------------------------------------
// Add a cluster to a directory file and zero the cluster.
// Return with first sector of cluster in the cache.
bool FatFile::addDirCluster() {
    5508:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t sector;
  cache_t* pc;

  if (isRootFixed()) {
    550c:	ldrb	r3, [r0, #0]
    550e:	and.w	r3, r3, #32
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
}
//------------------------------------------------------------------------------
// Add a cluster to a directory file and zero the cluster.
// Return with first sector of cluster in the cache.
bool FatFile::addDirCluster() {
    5512:	mov	r4, r0
  uint32_t sector;
  cache_t* pc;

  if (isRootFixed()) {
    5514:	and.w	r5, r3, #255	; 0xff
    5518:	cbz	r3, 551e <FatFile::addDirCluster()+0x16>
  // Set position to EOF to avoid inconsistent curCluster/curPosition.
  m_curPosition += m_vol->bytesPerCluster();
  return true;

 fail:
  return false;
    551a:	movs	r6, #0
    551c:	b.n	5588 <FatFile::addDirCluster()+0x80>
  if (isRootFixed()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // max folder size
  if (m_curPosition >= 512UL*4095) {
    551e:	ldr	r2, [r0, #20]
    5520:	ldr	r3, [pc, #108]	; (5590 <FatFile::addDirCluster()+0x88>)
    5522:	cmp	r2, r3
    5524:	bhi.n	551a <FatFile::addDirCluster()+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!addCluster()) {
    5526:	bl	54d2 <FatFile::addCluster()>
    552a:	mov	r6, r0
    552c:	cmp	r0, #0
    552e:	beq.n	551a <FatFile::addDirCluster()+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  sector = m_vol->clusterStartSector(m_curCluster);
    5530:	ldr	r0, [r4, #8]
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
  }
  uint32_t clusterStartSector(uint32_t cluster) const {
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
    5532:	ldr	r1, [r4, #16]
    5534:	ldrb	r3, [r0, #6]
    5536:	ldr	r7, [r0, #20]
    5538:	subs	r1, #2
    553a:	lsls	r1, r3
    553c:	add	r7, r1
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    553e:	movs	r2, #5
    5540:	mov	r1, r7
    5542:	adds	r0, #40	; 0x28
    5544:	bl	3072 <FsCache::get(unsigned long, unsigned char)>
  pc = m_vol->cacheFetchData(sector, FsCache::CACHE_RESERVE_FOR_WRITE);
  if (!pc) {
    5548:	mov	r8, r0
    554a:	cmp	r0, #0
    554c:	beq.n	551a <FatFile::addDirCluster()+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(pc, 0, m_vol->bytesPerSector());
    554e:	mov	r1, r5
    5550:	mov.w	r2, #512	; 0x200
    5554:	bl	88c8 <memset>
  // zero rest of clusters
  for (uint8_t i = 1; i < m_vol->sectorsPerCluster(); i++) {
    5558:	movs	r5, #1
    555a:	ldr	r3, [r4, #8]
    555c:	ldrb	r2, [r3, #4]
    555e:	cmp	r2, r5
    5560:	bls.n	5578 <FatFile::addDirCluster()+0x70>
    5562:	ldr	r0, [r3, #0]
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
  }
  bool writeSector(uint32_t sector, const uint8_t* src) {
    return m_blockDev->writeSector(sector, src);
    5564:	ldr	r3, [r0, #0]
    5566:	mov	r2, r8
    5568:	ldr	r3, [r3, #32]
    556a:	adds	r1, r5, r7
    556c:	blx	r3
    if (!m_vol->writeSector(sector + i, pc->data)) {
    556e:	cmp	r0, #0
    5570:	beq.n	551a <FatFile::addDirCluster()+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(pc, 0, m_vol->bytesPerSector());
  // zero rest of clusters
  for (uint8_t i = 1; i < m_vol->sectorsPerCluster(); i++) {
    5572:	adds	r5, #1
    5574:	uxtb	r5, r5
    5576:	b.n	555a <FatFile::addDirCluster()+0x52>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // Set position to EOF to avoid inconsistent curCluster/curPosition.
  m_curPosition += m_vol->bytesPerCluster();
    5578:	ldrb	r2, [r3, #6]
    557a:	mov.w	r3, #512	; 0x200
    557e:	lsls	r3, r2
    5580:	ldr	r2, [r4, #20]
    5582:	uxtah	r3, r2, r3
    5586:	str	r3, [r4, #20]
  return true;

 fail:
  return false;
}
    5588:	mov	r0, r6
    558a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    558e:	nop
    5590:	.word	0x001ffdff

00005594 <FatFile::cacheDirEntry(unsigned char)>:
//------------------------------------------------------------------------------
// cache a file's directory entry
// return pointer to cached entry or null for failure
DirFat_t* FatFile::cacheDirEntry(uint8_t action) {
    5594:	push	{r4, lr}
    5596:	mov	r4, r0
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    5598:	ldr	r0, [r0, #8]
    559a:	mov	r2, r1
    559c:	adds	r0, #40	; 0x28
    559e:	ldr	r1, [r4, #24]
    55a0:	bl	3072 <FsCache::get(unsigned long, unsigned char)>
  cache_t* pc;
  pc = m_vol->cacheFetchData(m_dirSector, action);
  if (!pc) {
    55a4:	cbz	r0, 55b0 <FatFile::cacheDirEntry(unsigned char)+0x1c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  return pc->dir + (m_dirIndex & 0XF);
    55a6:	ldrh	r3, [r4, #4]
    55a8:	and.w	r3, r3, #15
    55ac:	add.w	r0, r0, r3, lsl #5

 fail:
  return nullptr;
}
    55b0:	pop	{r4, pc}

000055b2 <FatFile::openRoot(FatVolume*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openRoot(FatVolume* vol) {
    55b2:	push	{r4, r5, r6, lr}
  // error if file is already open
  if (isOpen()) {
    55b4:	ldrb	r4, [r0, #0]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openRoot(FatVolume* vol) {
    55b6:	mov	r5, r0
    55b8:	mov	r6, r1
  // error if file is already open
  if (isOpen()) {
    55ba:	cbnz	r4, 55de <FatFile::openRoot(FatVolume*)+0x2c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(FatFile));
    55bc:	movs	r2, #36	; 0x24
    55be:	mov	r1, r4
    55c0:	bl	88c8 <memset>

  m_vol = vol;
    55c4:	str	r6, [r5, #8]
  switch (vol->fatType()) {
    55c6:	ldrb	r3, [r6, #7]
    55c8:	cmp	r3, #16
    55ca:	beq.n	55d4 <FatFile::openRoot(FatVolume*)+0x22>
    55cc:	cmp	r3, #32
    55ce:	bne.n	55de <FatFile::openRoot(FatVolume*)+0x2c>
  case 16:
    m_attributes = FILE_ATTR_ROOT_FIXED;
    break;

  case 32:
    m_attributes = FILE_ATTR_ROOT32;
    55d0:	movs	r3, #64	; 0x40
    55d2:	b.n	55d6 <FatFile::openRoot(FatVolume*)+0x24>
  switch (vol->fatType()) {
#if FAT12_SUPPORT
  case 12:
#endif  // FAT12_SUPPORT
  case 16:
    m_attributes = FILE_ATTR_ROOT_FIXED;
    55d4:	movs	r3, #32
  default:
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read only
  m_flags = FILE_FLAG_READ;
    55d6:	movs	r0, #1
  case 16:
    m_attributes = FILE_ATTR_ROOT_FIXED;
    break;

  case 32:
    m_attributes = FILE_ATTR_ROOT32;
    55d8:	strb	r3, [r5, #0]
  default:
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read only
  m_flags = FILE_FLAG_READ;
    55da:	strb	r0, [r5, #2]
    55dc:	pop	{r4, r5, r6, pc}
  return true;

 fail:
  return false;
    55de:	movs	r0, #0
    55e0:	pop	{r4, r5, r6, pc}

000055e2 <FatFile::openCluster(FatFile*)>:
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openCluster(FatFile* file) {
    55e2:	push	{r3, r4, r5, lr}
  if (file->m_dirCluster == 0) {
    55e4:	ldr	r3, [r1, #12]
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openCluster(FatFile* file) {
    55e6:	mov	r4, r0
    55e8:	mov	r5, r1
  if (file->m_dirCluster == 0) {
    55ea:	cbnz	r3, 55f6 <FatFile::openCluster(FatFile*)+0x14>
    return openRoot(file->m_vol);
    55ec:	ldr	r1, [r1, #8]
  m_attributes = FILE_ATTR_SUBDIR;
  m_flags = FILE_FLAG_READ;
  m_vol = file->m_vol;
  m_firstCluster = file->m_dirCluster;
  return true;
}
    55ee:	ldmia.w	sp!, {r3, r4, r5, lr}
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openCluster(FatFile* file) {
  if (file->m_dirCluster == 0) {
    return openRoot(file->m_vol);
    55f2:	b.w	55b2 <FatFile::openRoot(FatVolume*)>
  }
  memset(this, 0, sizeof(FatFile));
    55f6:	movs	r2, #36	; 0x24
    55f8:	movs	r1, #0
    55fa:	bl	88c8 <memset>
  m_attributes = FILE_ATTR_SUBDIR;
    55fe:	movs	r3, #16
  m_flags = FILE_FLAG_READ;
    5600:	movs	r0, #1
bool FatFile::openCluster(FatFile* file) {
  if (file->m_dirCluster == 0) {
    return openRoot(file->m_vol);
  }
  memset(this, 0, sizeof(FatFile));
  m_attributes = FILE_ATTR_SUBDIR;
    5602:	strb	r3, [r4, #0]
  m_flags = FILE_FLAG_READ;
    5604:	strb	r0, [r4, #2]
  m_vol = file->m_vol;
    5606:	ldr	r3, [r5, #8]
    5608:	str	r3, [r4, #8]
  m_firstCluster = file->m_dirCluster;
    560a:	ldr	r3, [r5, #12]
    560c:	str	r3, [r4, #32]
  return true;
}
    560e:	pop	{r3, r4, r5, pc}

00005610 <FatFile::read(void*, unsigned int)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
int FatFile::read(void* buf, size_t nbyte) {
    5610:	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  size_t toRead;
  uint32_t sector;  // raw device sector number
  cache_t* pc;

  // error if not open for read
  if (!isReadable()) {
    5614:	ldrb	r3, [r0, #2]
    5616:	lsls	r5, r3, #31

 fail:
  return false;
}
//------------------------------------------------------------------------------
int FatFile::read(void* buf, size_t nbyte) {
    5618:	mov	r4, r0
    561a:	mov	r9, r1
    561c:	mov	r6, r2
  size_t toRead;
  uint32_t sector;  // raw device sector number
  cache_t* pc;

  // error if not open for read
  if (!isReadable()) {
    561e:	bpl.n	5710 <FatFile::read(void*, unsigned int)+0x100>
    5620:	ldrb	r3, [r0, #0]
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (isFile()) {
    5622:	lsls	r0, r3, #28
    5624:	bpl.n	562e <FatFile::read(void*, unsigned int)+0x1e>
    uint32_t tmp32 = m_fileSize - m_curPosition;
    5626:	ldr	r3, [r4, #28]
    5628:	ldr	r2, [r4, #20]
    562a:	subs	r3, r3, r2
    562c:	b.n	563e <FatFile::read(void*, unsigned int)+0x2e>
    if (nbyte >= tmp32) {
      nbyte = tmp32;
    }
  } else if (isRootFixed()) {
    562e:	lsls	r1, r3, #26
    5630:	bpl.n	5644 <FatFile::read(void*, unsigned int)+0x34>
    uint16_t tmp16 = 32*m_vol->m_rootDirEntryCount - (uint16_t)m_curPosition;
    5632:	ldr	r3, [r4, #8]
    if (nbyte > tmp16) {
    5634:	ldrh	r2, [r3, #8]
    5636:	ldr	r3, [r4, #20]
    5638:	rsb	r3, r3, r2, lsl #5
    563c:	uxth	r3, r3
    563e:	cmp	r6, r3
    5640:	it	cs
    5642:	movcs	r6, r3
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
    5644:	mov	r7, r6
  return false;
}
//------------------------------------------------------------------------------
int FatFile::read(void* buf, size_t nbyte) {
  int8_t fg;
  uint8_t sectorOfCluster = 0;
    5646:	mov.w	r8, #0
        } else if (isFile() && isContiguous()) {
          m_curCluster++;
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
        } else {
          // get next cluster from FAT
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    564a:	add.w	sl, r4, #16
    if (nbyte > tmp16) {
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
  while (toRead) {
    564e:	cmp	r7, #0
    5650:	beq.n	56d6 <FatFile::read(void*, unsigned int)+0xc6>
    5652:	ldrb	r3, [r4, #0]
    size_t n;
    offset = m_curPosition & m_vol->sectorMask();  // offset in sector
    5654:	ldr	r2, [r4, #20]
    5656:	ldr	r0, [r4, #8]
    if (isRootFixed()) {
    5658:	tst.w	r3, #32
    }
  }
  toRead = nbyte;
  while (toRead) {
    size_t n;
    offset = m_curPosition & m_vol->sectorMask();  // offset in sector
    565c:	ubfx	r5, r2, #0, #9
    5660:	mov.w	r1, r2, lsr #9
    if (isRootFixed()) {
    5664:	beq.n	566c <FatFile::read(void*, unsigned int)+0x5c>
      sector = m_vol->rootDirStart()
               + (m_curPosition >> m_vol->bytesPerSectorShift());
    5666:	ldr	r3, [r0, #32]
    5668:	add	r1, r3
    566a:	b.n	56b6 <FatFile::read(void*, unsigned int)+0xa6>
  }
  //----------------------------------------------------------------------------
  bool allocateCluster(uint32_t current, uint32_t* next);
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
    566c:	ldrb.w	r8, [r0, #5]
    5670:	and.w	r8, r1, r8
    } else {
      sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
      if (offset == 0 && sectorOfCluster == 0) {
    5674:	cbnz	r5, 56a6 <FatFile::read(void*, unsigned int)+0x96>
    5676:	cmp.w	r8, #0
    567a:	bne.n	56a6 <FatFile::read(void*, unsigned int)+0x96>
        // start of new cluster
        if (m_curPosition == 0) {
    567c:	cbnz	r2, 5688 <FatFile::read(void*, unsigned int)+0x78>
          // use first cluster in file
          m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
    567e:	lsls	r2, r3, #25
    5680:	ite	mi
    5682:	ldrmi	r3, [r0, #32]
    5684:	ldrpl	r3, [r4, #32]
    5686:	b.n	571e <FatFile::read(void*, unsigned int)+0x10e>
#if USE_FAT_FILE_FLAG_CONTIGUOUS
        } else if (isFile() && isContiguous()) {
    5688:	lsls	r3, r3, #28
    568a:	bpl.n	5698 <FatFile::read(void*, unsigned int)+0x88>
    568c:	ldrb	r3, [r4, #2]
    568e:	lsls	r1, r3, #25
    5690:	bpl.n	5698 <FatFile::read(void*, unsigned int)+0x88>
          m_curCluster++;
    5692:	ldr	r3, [r4, #16]
    5694:	adds	r3, #1
    5696:	b.n	571e <FatFile::read(void*, unsigned int)+0x10e>
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
        } else {
          // get next cluster from FAT
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    5698:	mov	r2, sl
    569a:	ldr	r1, [r4, #16]
    569c:	bl	6284 <FatPartition::fatGet(unsigned long, unsigned long*)>
          if (fg < 0) {
    56a0:	cmp	r0, #0
    56a2:	blt.n	5710 <FatFile::read(void*, unsigned int)+0x100>
            DBG_FAIL_MACRO;
            goto fail;
          }
          if (fg == 0) {
    56a4:	beq.n	56ce <FatFile::read(void*, unsigned int)+0xbe>
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
      }
      sector = m_vol->clusterStartSector(m_curCluster) + sectorOfCluster;
    56a6:	ldr	r3, [r4, #8]
    56a8:	ldr	r1, [r4, #16]
    56aa:	ldrb	r2, [r3, #6]
    56ac:	ldr	r3, [r3, #20]
    56ae:	subs	r1, #2
    56b0:	lsls	r1, r2
    56b2:	add	r1, r3
    56b4:	add	r1, r8
    56b6:	ldr.w	fp, [r4, #8]
    }
    if (offset != 0 || toRead < m_vol->bytesPerSector()
        || sector == m_vol->cacheSectorNumber()) {
    56ba:	cmp	r5, #0
    56bc:	bne.n	575e <FatFile::read(void*, unsigned int)+0x14e>
          }
        }
      }
      sector = m_vol->clusterStartSector(m_curCluster) + sectorOfCluster;
    }
    if (offset != 0 || toRead < m_vol->bytesPerSector()
    56be:	cmp.w	r7, #512	; 0x200
    56c2:	bcc.n	575e <FatFile::read(void*, unsigned int)+0x14e>
    56c4:	ldr.w	r3, [fp, #52]	; 0x34
        || sector == m_vol->cacheSectorNumber()) {
    56c8:	cmp	r1, r3
    56ca:	bne.n	56da <FatFile::read(void*, unsigned int)+0xca>
    56cc:	b.n	575e <FatFile::read(void*, unsigned int)+0x14e>
          if (fg < 0) {
            DBG_FAIL_MACRO;
            goto fail;
          }
          if (fg == 0) {
            if (isDir()) {
    56ce:	ldrb	r3, [r4, #0]
    56d0:	tst.w	r3, #112	; 0x70
    56d4:	beq.n	5710 <FatFile::read(void*, unsigned int)+0x100>
    }
    dst += n;
    m_curPosition += n;
    toRead -= n;
  }
  return nbyte - toRead;
    56d6:	subs	r0, r6, r7
    56d8:	b.n	5782 <FatFile::read(void*, unsigned int)+0x172>
        goto fail;
      }
      uint8_t* src = pc->data + offset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
    56da:	cmp.w	r7, #1024	; 0x400
    56de:	bcc.n	573c <FatFile::read(void*, unsigned int)+0x12c>
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
      if (!isRootFixed()) {
    56e0:	ldrb	r2, [r4, #0]
    56e2:	lsls	r2, r2, #26
      }
      uint8_t* src = pc->data + offset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
    56e4:	mov.w	r5, r7, lsr #9
      if (!isRootFixed()) {
    56e8:	bmi.n	56f8 <FatFile::read(void*, unsigned int)+0xe8>
        uint32_t mb = m_vol->sectorsPerCluster() - sectorOfCluster;
    56ea:	ldrb.w	r2, [fp, #4]
    56ee:	rsb	r2, r8, r2
    56f2:	cmp	r5, r2
    56f4:	it	cs
    56f6:	movcs	r5, r2
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    56f8:	cmp	r1, r3
    56fa:	bhi.n	5722 <FatFile::read(void*, unsigned int)+0x112>
    56fc:	adds	r2, r1, r5
    56fe:	cmp	r3, r2
    5700:	bcs.n	5722 <FatFile::read(void*, unsigned int)+0x112>
   * \param[in] count Number of sectors to be read.
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool cacheSafeRead(uint32_t sector, uint8_t* dst, size_t count) {
    if (isCached(sector, count) && !sync()) {
    5702:	add.w	r0, fp, #40	; 0x28
    5706:	str	r1, [sp, #4]
    5708:	bl	3026 <FsCache::sync()>
    570c:	ldr	r1, [sp, #4]
    570e:	cbnz	r0, 5722 <FatFile::read(void*, unsigned int)+0x112>
    toRead -= n;
  }
  return nbyte - toRead;

 fail:
  m_error |= READ_ERROR;
    5710:	ldrb	r3, [r4, #1]
    5712:	orr.w	r3, r3, #2
    5716:	strb	r3, [r4, #1]
  return -1;
    5718:	mov.w	r0, #4294967295
    571c:	b.n	5782 <FatFile::read(void*, unsigned int)+0x172>
        if (m_curPosition == 0) {
          // use first cluster in file
          m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
#if USE_FAT_FILE_FLAG_CONTIGUOUS
        } else if (isFile() && isContiguous()) {
          m_curCluster++;
    571e:	str	r3, [r4, #16]
    5720:	b.n	56a6 <FatFile::read(void*, unsigned int)+0x96>
      return false;
    }
    return m_blockDev->readSectors(sector, dst, count);
    5722:	ldr.w	r0, [fp, #44]	; 0x2c
    5726:	ldr	r3, [r0, #0]
    5728:	mov	r2, r9
    572a:	ldr.w	fp, [r3, #16]
    572e:	mov	r3, r5
    5730:	blx	fp
        if (mb < ns) {
          ns = mb;
        }
      }
      n = ns << m_vol->bytesPerSectorShift();
      if (!m_vol->cacheSafeRead(sector, dst, ns)) {
    5732:	cmp	r0, #0
    5734:	beq.n	5710 <FatFile::read(void*, unsigned int)+0x100>
        uint32_t mb = m_vol->sectorsPerCluster() - sectorOfCluster;
        if (mb < ns) {
          ns = mb;
        }
      }
      n = ns << m_vol->bytesPerSectorShift();
    5736:	mov.w	fp, r5, lsl #9
    573a:	b.n	5750 <FatFile::read(void*, unsigned int)+0x140>
  bool cacheSafeRead(uint32_t sector, uint8_t* dst) {
    if (isCached(sector)) {
      memcpy(dst, m_buffer, 512);
      return true;
    }
    return m_blockDev->readSector(sector, dst);
    573c:	ldr.w	r0, [fp, #44]	; 0x2c
    5740:	ldr	r3, [r0, #0]
    5742:	mov	r2, r9
    5744:	ldr	r3, [r3, #12]
    5746:	blx	r3
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeRead(sector, dst)) {
    5748:	cmp	r0, #0
    574a:	beq.n	5710 <FatFile::read(void*, unsigned int)+0x100>
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
    574c:	mov.w	fp, #512	; 0x200
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    m_curPosition += n;
    5750:	ldr	r3, [r4, #20]
    5752:	add	r3, fp
      if (!m_vol->cacheSafeRead(sector, dst)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    5754:	add	r9, fp
    m_curPosition += n;
    5756:	str	r3, [r4, #20]
    toRead -= n;
    5758:	rsb	r7, fp, r7
    if (nbyte > tmp16) {
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
  while (toRead) {
    575c:	b.n	564e <FatFile::read(void*, unsigned int)+0x3e>
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    575e:	movs	r2, #0
    5760:	add.w	r0, fp, #40	; 0x28
    5764:	bl	3072 <FsCache::get(unsigned long, unsigned char)>
      if (n > toRead) {
        n = toRead;
      }
      // read sector to cache and copy data to caller
      pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_READ);
      if (!pc) {
    5768:	cmp	r0, #0
    576a:	beq.n	5710 <FatFile::read(void*, unsigned int)+0x100>
      sector = m_vol->clusterStartSector(m_curCluster) + sectorOfCluster;
    }
    if (offset != 0 || toRead < m_vol->bytesPerSector()
        || sector == m_vol->cacheSectorNumber()) {
      // amount to be read from current sector
      n = m_vol->bytesPerSector() - offset;
    576c:	rsb	fp, r5, #512	; 0x200
    5770:	cmp	fp, r7
    5772:	it	cs
    5774:	movcs	fp, r7
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* src = pc->data + offset;
      memcpy(dst, src, n);
    5776:	adds	r1, r0, r5
    5778:	mov	r2, fp
    577a:	mov	r0, r9
    577c:	bl	8720 <memcpy>
    5780:	b.n	5750 <FatFile::read(void*, unsigned int)+0x140>
  return nbyte - toRead;

 fail:
  m_error |= READ_ERROR;
  return -1;
}
    5782:	add	sp, #12
    5784:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00005788 <FatFile::peek()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
int FatFile::peek() {
    5788:	push	{r0, r1, r4, r5, r6, lr}
   * \return For success read returns the next byte in the file as an int.
   * If an error occurs or end of file is reached -1 is returned.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
    578a:	movs	r2, #1
    578c:	add.w	r1, sp, #7
    5790:	mov	r4, r0
  uint32_t curPosition = m_curPosition;
    5792:	ldr	r6, [r0, #20]
  uint32_t curCluster = m_curCluster;
    5794:	ldr	r5, [r0, #16]
    5796:	bl	5610 <FatFile::read(void*, unsigned int)>
    579a:	cmp	r0, #1
    579c:	it	eq
    579e:	ldrbeq.w	r0, [sp, #7]
  int c = read();
  m_curPosition = curPosition;
    57a2:	str	r6, [r4, #20]
    57a4:	it	ne
    57a6:	movne.w	r0, #4294967295
  m_curCluster = curCluster;
    57aa:	str	r5, [r4, #16]
  return c;
}
    57ac:	add	sp, #8
    57ae:	pop	{r4, r5, r6, pc}

000057b0 <FatFile::readDirCache(bool)>:
//------------------------------------------------------------------------------
// Read next directory entry into the cache.
// Assumes file is correctly positioned.
DirFat_t* FatFile::readDirCache(bool skipReadOk) {
  DBG_HALT_IF(m_curPosition & 0X1F);
  uint8_t i = (m_curPosition >> 5) & 0XF;
    57b0:	ldr	r3, [r0, #20]
  }
}
//------------------------------------------------------------------------------
// Read next directory entry into the cache.
// Assumes file is correctly positioned.
DirFat_t* FatFile::readDirCache(bool skipReadOk) {
    57b2:	push	{r0, r1, r2, r4, r5, lr}
  DBG_HALT_IF(m_curPosition & 0X1F);
  uint8_t i = (m_curPosition >> 5) & 0XF;
    57b4:	ubfx	r5, r3, #5, #4
  }
}
//------------------------------------------------------------------------------
// Read next directory entry into the cache.
// Assumes file is correctly positioned.
DirFat_t* FatFile::readDirCache(bool skipReadOk) {
    57b8:	mov	r4, r0
  DBG_HALT_IF(m_curPosition & 0X1F);
  uint8_t i = (m_curPosition >> 5) & 0XF;

  if (i == 0 || !skipReadOk) {
    57ba:	cbz	r5, 57be <FatFile::readDirCache(bool)+0xe>
    57bc:	cbnz	r1, 57da <FatFile::readDirCache(bool)+0x2a>
    int8_t n = read(&n, 1);
    57be:	movs	r2, #1
    57c0:	add.w	r1, sp, #7
    57c4:	mov	r0, r4
    57c6:	bl	5610 <FatFile::read(void*, unsigned int)>
    57ca:	sxtb	r0, r0
    if  (n != 1) {
    57cc:	cmp	r0, #1
    57ce:	beq.n	57d4 <FatFile::readDirCache(bool)+0x24>
  }
  // return pointer to entry
  return reinterpret_cast<DirFat_t*>(m_vol->cacheAddress()) + i;

 fail:
  return nullptr;
    57d0:	movs	r0, #0
    57d2:	b.n	57e6 <FatFile::readDirCache(bool)+0x36>
      if (n != 0) {
        DBG_FAIL_MACRO;
      }
      goto fail;
    }
    m_curPosition += 31;
    57d4:	ldr	r3, [r4, #20]
    57d6:	adds	r3, #31
    57d8:	b.n	57dc <FatFile::readDirCache(bool)+0x2c>
  } else {
    m_curPosition += 32;
    57da:	adds	r3, #32
  static const uint8_t CACHE_RESERVE_FOR_WRITE =
    CACHE_STATUS_DIRTY | CACHE_OPTION_NO_READ;
  //----------------------------------------------------------------------------
  /** \return Cache buffer address. */
  uint8_t* cacheBuffer() {
    return m_buffer;
    57dc:	ldr	r0, [r4, #8]
    57de:	str	r3, [r4, #20]
    57e0:	adds	r0, #56	; 0x38
  }
  // return pointer to entry
  return reinterpret_cast<DirFat_t*>(m_vol->cacheAddress()) + i;
    57e2:	add.w	r0, r0, r5, lsl #5

 fail:
  return nullptr;
}
    57e6:	add	sp, #12
    57e8:	pop	{r4, r5, pc}

000057ea <FatFile::seekSet(unsigned long)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::seekSet(uint32_t pos) {
    57ea:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    57ee:	mov	r4, r0
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
    57f0:	ldr	r7, [r0, #16]
    57f2:	ldrb	r0, [r0, #0]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::seekSet(uint32_t pos) {
    57f4:	mov	r6, r1
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
  // error if file not open
  if (!isOpen()) {
    57f6:	cmp	r0, #0
    57f8:	beq.n	5888 <FatFile::seekSet(unsigned long)+0x9e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    57fa:	ldr	r5, [r4, #20]
    57fc:	cmp	r5, r1
    57fe:	beq.n	5890 <FatFile::seekSet(unsigned long)+0xa6>
    return true;
  }
  if (pos == 0) {
    5800:	cbnz	r1, 5806 <FatFile::seekSet(unsigned long)+0x1c>
    // set position to start of file
    m_curCluster = 0;
    5802:	str	r1, [r4, #16]
    goto done;
    5804:	b.n	587c <FatFile::seekSet(unsigned long)+0x92>
  }
  if (isFile()) {
    5806:	lsls	r2, r0, #28
    5808:	bpl.n	5812 <FatFile::seekSet(unsigned long)+0x28>
    if (pos > m_fileSize) {
    580a:	ldr	r3, [r4, #28]
    580c:	cmp	r1, r3
    580e:	bhi.n	5888 <FatFile::seekSet(unsigned long)+0x9e>
    5810:	b.n	5822 <FatFile::seekSet(unsigned long)+0x38>
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if (isRootFixed()) {
    5812:	lsls	r3, r0, #26
    5814:	bpl.n	5822 <FatFile::seekSet(unsigned long)+0x38>
    5816:	ldr	r3, [r4, #8]
    if (pos <= 32*m_vol->rootDirEntryCount()) {
    5818:	ldrh	r3, [r3, #8]
    581a:	cmp.w	r1, r3, lsl #5
    581e:	bhi.n	5888 <FatFile::seekSet(unsigned long)+0x9e>
    5820:	b.n	587c <FatFile::seekSet(unsigned long)+0x92>
    }
    DBG_FAIL_MACRO;
    goto fail;
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> (m_vol->bytesPerClusterShift());
    5822:	ldr.w	lr, [r4, #8]
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  if (isContiguous()) {
    5826:	ldrb	r1, [r4, #2]
    }
    DBG_FAIL_MACRO;
    goto fail;
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> (m_vol->bytesPerClusterShift());
    5828:	ldrb.w	r2, [lr, #6]
    582c:	adds	r2, #9
    582e:	uxtb	r2, r2
    5830:	subs	r3, r6, #1
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  if (isContiguous()) {
    5832:	lsls	r1, r1, #25
    }
    DBG_FAIL_MACRO;
    goto fail;
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> (m_vol->bytesPerClusterShift());
    5834:	lsr.w	r3, r3, r2
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  if (isContiguous()) {
    5838:	bpl.n	5842 <FatFile::seekSet(unsigned long)+0x58>
    m_curCluster = m_firstCluster + nNew;
    583a:	ldr	r2, [r4, #32]
    583c:	add	r3, r2
    583e:	str	r3, [r4, #16]
    goto done;
    5840:	b.n	587c <FatFile::seekSet(unsigned long)+0x92>
  }
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  // calculate cluster index for current position
  nCur = (m_curPosition - 1) >> (m_vol->bytesPerClusterShift());
    5842:	subs	r1, r5, #1
    5844:	lsr.w	r2, r1, r2

  if (nNew < nCur || m_curPosition == 0) {
    5848:	cmp	r3, r2
    584a:	bcc.n	584e <FatFile::seekSet(unsigned long)+0x64>
    584c:	cbnz	r5, 5862 <FatFile::seekSet(unsigned long)+0x78>
    // must follow chain from first cluster
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
    584e:	lsls	r2, r0, #25
    5850:	ite	mi
    5852:	ldrmi.w	r2, [lr, #32]
    5856:	ldrpl	r2, [r4, #32]
    5858:	str	r2, [r4, #16]
    585a:	mov	r5, r3
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
    585c:	add.w	r8, r4, #16
    5860:	b.n	5878 <FatFile::seekSet(unsigned long)+0x8e>
  if (nNew < nCur || m_curPosition == 0) {
    // must follow chain from first cluster
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
    5862:	subs	r3, r3, r2
    5864:	b.n	585a <FatFile::seekSet(unsigned long)+0x70>
  }
  while (nNew--) {
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
    5866:	mov	r2, r8
    5868:	ldr	r1, [r4, #16]
    586a:	ldr	r0, [r4, #8]
    586c:	bl	6284 <FatPartition::fatGet(unsigned long, unsigned long*)>
    5870:	cmp	r0, #0
    5872:	add.w	r5, r5, #4294967295
    5876:	ble.n	5888 <FatFile::seekSet(unsigned long)+0x9e>
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    5878:	cmp	r5, #0
    587a:	bne.n	5866 <FatFile::seekSet(unsigned long)+0x7c>
    }
  }

 done:
  m_curPosition = pos;
  m_flags &= ~FILE_FLAG_PREALLOCATE;
    587c:	ldrb	r3, [r4, #2]
      goto fail;
    }
  }

 done:
  m_curPosition = pos;
    587e:	str	r6, [r4, #20]
  m_flags &= ~FILE_FLAG_PREALLOCATE;
    5880:	bic.w	r3, r3, #32
    5884:	strb	r3, [r4, #2]
    5886:	b.n	5890 <FatFile::seekSet(unsigned long)+0xa6>
  return true;

 fail:
  m_curCluster = tmp;
    5888:	str	r7, [r4, #16]
  return false;
    588a:	movs	r0, #0
    588c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    return true;
    5890:	movs	r0, #1
  return true;

 fail:
  m_curCluster = tmp;
  return false;
}
    5892:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00005896 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)>:
  return false;
}
//------------------------------------------------------------------------------
// open a cached directory entry.
bool FatFile::openCachedEntry(FatFile* dirFile, uint16_t dirIndex,
                              oflag_t oflag, uint8_t lfnOrd) {
    5896:	push	{r3, r4, r5, r6, r7, lr}
    5898:	mov	r7, r1
    589a:	mov	r6, r2
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
    589c:	movs	r1, #0
    589e:	movs	r2, #36	; 0x24
  return false;
}
//------------------------------------------------------------------------------
// open a cached directory entry.
bool FatFile::openCachedEntry(FatFile* dirFile, uint16_t dirIndex,
                              oflag_t oflag, uint8_t lfnOrd) {
    58a0:	mov	r4, r0
    58a2:	mov	r5, r3
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
    58a4:	bl	88c8 <memset>
  // location of entry in cache
  m_vol = dirFile->m_vol;
    58a8:	ldr	r0, [r7, #8]
  m_dirIndex = dirIndex;
    58aa:	strh	r6, [r4, #4]
    58ac:	add.w	r2, r0, #56	; 0x38
  m_dirCluster = dirFile->m_firstCluster;
  DirFat_t* dir = reinterpret_cast<DirFat_t*>(m_vol->cacheAddress());
  dir += 0XF & dirIndex;
    58b0:	and.w	r6, r6, #15
    58b4:	add.w	r2, r2, r6, lsl #5
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
  // location of entry in cache
  m_vol = dirFile->m_vol;
  m_dirIndex = dirIndex;
  m_dirCluster = dirFile->m_firstCluster;
    58b8:	ldr	r3, [r7, #32]
bool FatFile::openCachedEntry(FatFile* dirFile, uint16_t dirIndex,
                              oflag_t oflag, uint8_t lfnOrd) {
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
  // location of entry in cache
  m_vol = dirFile->m_vol;
    58ba:	str	r0, [r4, #8]
  m_dirIndex = dirIndex;
  m_dirCluster = dirFile->m_firstCluster;
    58bc:	str	r3, [r4, #12]
    58be:	ldrb	r1, [r2, #11]
  DirFat_t* dir = reinterpret_cast<DirFat_t*>(m_vol->cacheAddress());
  dir += 0XF & dirIndex;

  // Must be file or subdirectory.
  if (!isFileOrSubdir(dir)) {
    58c0:	lsls	r6, r1, #28
    58c2:	bmi.n	5942 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xac>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_attributes = dir->attributes & FILE_ATTR_COPY;
    58c4:	and.w	r1, r1, #23
    58c8:	strb	r1, [r4, #0]
  if (isFileDir(dir)) {
    58ca:	ldrb	r3, [r2, #11]
    58cc:	tst.w	r3, #24
    m_attributes |= FILE_ATTR_FILE;
  }
  m_lfnOrd = lfnOrd;
    58d0:	ldrb.w	r3, [sp, #24]
    58d4:	strb	r3, [r4, #3]
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_attributes = dir->attributes & FILE_ATTR_COPY;
  if (isFileDir(dir)) {
    m_attributes |= FILE_ATTR_FILE;
    58d6:	it	eq
    58d8:	orreq.w	r1, r1, #8
  }
  m_lfnOrd = lfnOrd;

  switch (oflag & O_ACCMODE) {
    58dc:	and.w	r3, r5, #3
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_attributes = dir->attributes & FILE_ATTR_COPY;
  if (isFileDir(dir)) {
    m_attributes |= FILE_ATTR_FILE;
    58e0:	it	eq
    58e2:	strbeq	r1, [r4, #0]
  }
  m_lfnOrd = lfnOrd;

  switch (oflag & O_ACCMODE) {
    58e4:	cmp	r3, #1
    58e6:	beq.n	58fa <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x64>
    58e8:	cmp	r3, #2
    58ea:	beq.n	58f6 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x60>
    58ec:	cbnz	r3, 5942 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xac>
    case O_RDONLY:
      if (oflag & O_TRUNC) {
    58ee:	lsls	r3, r5, #21
    58f0:	bmi.n	5942 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xac>
        DBG_FAIL_MACRO;
        goto fail;
      }
      m_flags = FILE_FLAG_READ;
    58f2:	movs	r3, #1
    58f4:	b.n	58fc <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x66>
      break;

    case O_RDWR:
      m_flags = FILE_FLAG_READ | FILE_FLAG_WRITE;
    58f6:	movs	r3, #3
    58f8:	b.n	58fc <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x66>
      break;

    case O_WRONLY:
      m_flags = FILE_FLAG_WRITE;
    58fa:	movs	r3, #2
    58fc:	strb	r3, [r4, #2]
    default:
      DBG_FAIL_MACRO;
      goto fail;
  }

  if (m_flags & FILE_FLAG_WRITE) {
    58fe:	ldrb	r3, [r4, #2]
    5900:	lsls	r7, r3, #30
    5902:	bpl.n	590c <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x76>
    if (isSubDir() || isReadOnly()) {
    5904:	ldrb	r1, [r4, #0]
    5906:	tst.w	r1, #17
    590a:	bne.n	5942 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xac>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  m_flags |= (oflag & O_APPEND ? FILE_FLAG_APPEND : 0);
    590c:	and.w	r1, r5, #8
    5910:	orrs	r3, r1
    5912:	strb	r3, [r4, #2]
    5914:	ldr	r3, [r0, #52]	; 0x34

  m_dirSector = m_vol->cacheSectorNumber();
    5916:	str	r3, [r4, #24]

  // copy first cluster number for directory fields
  firstCluster = ((uint32_t)getLe16(dir->firstClusterHigh) << 16)
                 | getLe16(dir->firstClusterLow);
    5918:	ldrh	r1, [r2, #20]
    591a:	ldrh	r3, [r2, #26]

  if (oflag & O_TRUNC) {
    591c:	lsls	r6, r5, #21

  m_dirSector = m_vol->cacheSectorNumber();

  // copy first cluster number for directory fields
  firstCluster = ((uint32_t)getLe16(dir->firstClusterHigh) << 16)
                 | getLe16(dir->firstClusterLow);
    591e:	orr.w	r1, r3, r1, lsl #16

  if (oflag & O_TRUNC) {
    5922:	bpl.n	592e <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x98>
    if (firstCluster && !m_vol->freeChain(firstCluster)) {
    5924:	cbz	r1, 594a <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xb4>
    5926:	bl	63ca <FatPartition::freeChain(unsigned long)>
    592a:	cbnz	r0, 594a <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xb4>
    592c:	b.n	5942 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xac>
    }

    // need to update directory entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
  } else {
    m_firstCluster = firstCluster;
    592e:	str	r1, [r4, #32]
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    5930:	ldr	r3, [r2, #28]
    m_fileSize = getLe32(dir->fileSize);
    5932:	str	r3, [r4, #28]
  }
  if ((oflag & O_AT_END) && !seekSet(m_fileSize)) {
    5934:	lsls	r3, r5, #17
    5936:	bpl.n	5954 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xbe>
    5938:	ldr	r1, [r4, #28]
    593a:	mov	r0, r4
    593c:	bl	57ea <FatFile::seekSet(unsigned long)>
    5940:	cbnz	r0, 5954 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xbe>
    goto fail;
  }
  return true;

 fail:
  m_attributes = FILE_ATTR_CLOSED;
    5942:	movs	r0, #0
    5944:	strb	r0, [r4, #0]
  m_flags = 0;
    5946:	strb	r0, [r4, #2]
  return false;
    5948:	pop	{r3, r4, r5, r6, r7, pc}
      DBG_FAIL_MACRO;
      goto fail;
    }

    // need to update directory entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
    594a:	ldrb	r3, [r4, #2]
    594c:	orn	r3, r3, #127	; 0x7f
    5950:	strb	r3, [r4, #2]
    5952:	b.n	5934 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x9e>
  }
  if ((oflag & O_AT_END) && !seekSet(m_fileSize)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  return true;
    5954:	movs	r0, #1

 fail:
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
    5956:	pop	{r3, r4, r5, r6, r7, pc}

00005958 <FatFile::openNext(FatFile*, int)>:
  m_vol = file->m_vol;
  m_firstCluster = file->m_dirCluster;
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::openNext(FatFile* dirFile, oflag_t oflag) {
    5958:	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  DirLfn_t* ldir;
  uint8_t lfnOrd = 0;
  uint16_t index;

  // Check for not open and valid directory..
  if (isOpen() || !dirFile->isDir() || (dirFile->curPosition() & 0X1F)) {
    595c:	ldrb	r3, [r0, #0]
  m_vol = file->m_vol;
  m_firstCluster = file->m_dirCluster;
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::openNext(FatFile* dirFile, oflag_t oflag) {
    595e:	mov	r6, r0
    5960:	mov	r5, r1
    5962:	mov	r9, r2
  DirLfn_t* ldir;
  uint8_t lfnOrd = 0;
  uint16_t index;

  // Check for not open and valid directory..
  if (isOpen() || !dirFile->isDir() || (dirFile->curPosition() & 0X1F)) {
    5964:	cbnz	r3, 59d6 <FatFile::openNext(FatFile*, int)+0x7e>
    5966:	ldrb	r3, [r1, #0]
    5968:	tst.w	r3, #112	; 0x70
    596c:	beq.n	59d6 <FatFile::openNext(FatFile*, int)+0x7e>
    596e:	ldr	r4, [r1, #20]
    5970:	ands.w	r4, r4, #31
    5974:	bne.n	59d6 <FatFile::openNext(FatFile*, int)+0x7e>
    5976:	mov	r7, r4
    goto fail;
  }
  while (1) {
    // read entry into cache
    index = dirFile->curPosition()/32;
    DirFat_t* dir = dirFile->readDirCache();
    5978:	movs	r1, #0
    597a:	mov	r0, r5
    597c:	ldr.w	r8, [r5, #20]
    5980:	bl	57b0 <FatFile::readDirCache(bool)>
    if (!dir) {
    5984:	cbz	r0, 59d6 <FatFile::openNext(FatFile*, int)+0x7e>
        DBG_FAIL_MACRO;
      }
      goto fail;
    }
    // done if last entry
    if (dir->name[0] == FAT_NAME_FREE) {
    5986:	ldrb	r3, [r0, #0]
    5988:	cbz	r3, 59d6 <FatFile::openNext(FatFile*, int)+0x7e>
      goto fail;
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == '.' || dir->name[0] == FAT_NAME_DELETED) {
    598a:	cmp	r3, #46	; 0x2e
    598c:	bne.n	5992 <FatFile::openNext(FatFile*, int)+0x3a>
      if (ldir->order & FAT_ORDER_LAST_LONG_ENTRY) {
        lfnOrd = ldir->order & 0X1F;
        checksum = ldir->checksum;
      }
    } else {
      lfnOrd = 0;
    598e:	movs	r4, #0
    5990:	b.n	5978 <FatFile::openNext(FatFile*, int)+0x20>
    // done if last entry
    if (dir->name[0] == FAT_NAME_FREE) {
      goto fail;
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == '.' || dir->name[0] == FAT_NAME_DELETED) {
    5992:	cmp	r3, #229	; 0xe5
    5994:	beq.n	598e <FatFile::openNext(FatFile*, int)+0x36>
    5996:	ldrb	r2, [r0, #11]
      lfnOrd = 0;
    } else if (isFileOrSubdir(dir)) {
    5998:	and.w	lr, r2, #8
    599c:	and.w	r1, lr, #255	; 0xff
    59a0:	cmp.w	lr, #0
    59a4:	bne.n	59c6 <FatFile::openNext(FatFile*, int)+0x6e>
      if (lfnOrd && checksum != lfnChecksum(dir->name)) {
    59a6:	cbz	r4, 59da <FatFile::openNext(FatFile*, int)+0x82>
    59a8:	subs	r2, r0, #1
    59aa:	adds	r0, #10
    59ac:	lsls	r3, r1, #7
    59ae:	orr.w	r1, r3, r1, lsr #1
  bool createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  uint16_t getLfnChar(DirLfn_t* ldir, uint8_t i);
  uint8_t lfnChecksum(uint8_t* name) {
    uint8_t sum = 0;
    for (uint8_t i = 0; i < 11; i++) {
        sum = (((sum & 1) << 7) | (sum >> 1)) + name[i];
    59b2:	ldrb.w	r3, [r2, #1]!
    59b6:	uxtab	r1, r3, r1
  bool cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  bool createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  uint16_t getLfnChar(DirLfn_t* ldir, uint8_t i);
  uint8_t lfnChecksum(uint8_t* name) {
    uint8_t sum = 0;
    for (uint8_t i = 0; i < 11; i++) {
    59ba:	cmp	r0, r2
        sum = (((sum & 1) << 7) | (sum >> 1)) + name[i];
    59bc:	uxtb	r1, r1
  bool cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  bool createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  uint16_t getLfnChar(DirLfn_t* ldir, uint8_t i);
  uint8_t lfnChecksum(uint8_t* name) {
    uint8_t sum = 0;
    for (uint8_t i = 0; i < 11; i++) {
    59be:	bne.n	59ac <FatFile::openNext(FatFile*, int)+0x54>
    59c0:	cmp	r7, r1
    59c2:	bne.n	59d6 <FatFile::openNext(FatFile*, int)+0x7e>
    59c4:	b.n	59da <FatFile::openNext(FatFile*, int)+0x82>
      if (!openCachedEntry(dirFile, index, oflag, lfnOrd)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      return true;
    } else if (isLongName(dir)) {
    59c6:	cmp	r2, #15
    59c8:	bne.n	598e <FatFile::openNext(FatFile*, int)+0x36>
      ldir = reinterpret_cast<DirLfn_t*>(dir);
      if (ldir->order & FAT_ORDER_LAST_LONG_ENTRY) {
    59ca:	lsls	r2, r3, #25
    59cc:	bpl.n	5978 <FatFile::openNext(FatFile*, int)+0x20>
        lfnOrd = ldir->order & 0X1F;
    59ce:	and.w	r4, r3, #31
        checksum = ldir->checksum;
    59d2:	ldrb	r7, [r0, #13]
    59d4:	b.n	5978 <FatFile::openNext(FatFile*, int)+0x20>
      lfnOrd = 0;
    }
  }

 fail:
  return false;
    59d6:	movs	r0, #0
    59d8:	b.n	59ea <FatFile::openNext(FatFile*, int)+0x92>
    } else if (isFileOrSubdir(dir)) {
      if (lfnOrd && checksum != lfnChecksum(dir->name)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!openCachedEntry(dirFile, index, oflag, lfnOrd)) {
    59da:	str	r4, [sp, #0]
    59dc:	mov	r3, r9
    59de:	ubfx	r2, r8, #5, #16
    59e2:	mov	r1, r5
    59e4:	mov	r0, r6
    59e6:	bl	5896 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)>
    }
  }

 fail:
  return false;
}
    59ea:	add	sp, #12
    59ec:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

000059f0 <FatFile::rmdir()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::rmdir() {
    59f0:	push	{r4, lr}
  // must be open subdirectory
  if (!isSubDir() || (!USE_LONG_FILE_NAMES && isLFN())) {
    59f2:	ldrb	r3, [r0, #0]
    59f4:	lsls	r2, r3, #27

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::rmdir() {
    59f6:	mov	r4, r0
  // must be open subdirectory
  if (!isSubDir() || (!USE_LONG_FILE_NAMES && isLFN())) {
    59f8:	bpl.n	5a3a <FatFile::rmdir()+0x4a>
   * \return true for success or false for failure.
   */
  bool rename(FatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    59fa:	movs	r1, #0
    59fc:	bl	57ea <FatFile::seekSet(unsigned long)>
  }
  rewind();

  // make sure directory is empty
  while (1) {
    DirFat_t* dir = readDirCache(true);
    5a00:	movs	r1, #1
    5a02:	mov	r0, r4
    5a04:	bl	57b0 <FatFile::readDirCache(bool)>
    if (!dir) {
    5a08:	cbnz	r0, 5a10 <FatFile::rmdir()+0x20>
      // EOF if no error.
      if (!getError()) {
    5a0a:	ldrb	r3, [r4, #1]
    5a0c:	cbz	r3, 5a24 <FatFile::rmdir()+0x34>
    5a0e:	b.n	5a3a <FatFile::rmdir()+0x4a>
      }
      DBG_FAIL_MACRO;
      goto fail;
    }
    // done if past last used entry
    if (dir->name[0] == FAT_NAME_FREE) {
    5a10:	ldrb	r3, [r0, #0]
    5a12:	cbz	r3, 5a24 <FatFile::rmdir()+0x34>
      break;
    }
    // skip empty slot, '.' or '..'
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
    5a14:	cmp	r3, #229	; 0xe5
    5a16:	beq.n	5a00 <FatFile::rmdir()+0x10>
    5a18:	cmp	r3, #46	; 0x2e
    5a1a:	beq.n	5a00 <FatFile::rmdir()+0x10>
      continue;
    }
    // error not empty
    if (isFileOrSubdir(dir)) {
    5a1c:	ldrb	r3, [r0, #11]
    5a1e:	lsls	r3, r3, #28
    5a20:	bmi.n	5a00 <FatFile::rmdir()+0x10>
    5a22:	b.n	5a3a <FatFile::rmdir()+0x4a>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
    5a24:	movs	r3, #8
    5a26:	strb	r3, [r4, #0]
  m_flags |= FILE_FLAG_WRITE;
    5a28:	ldrb	r3, [r4, #2]
    5a2a:	orr.w	r3, r3, #2
    5a2e:	strb	r3, [r4, #2]
  return remove();
    5a30:	mov	r0, r4

 fail:
  return false;
}
    5a32:	ldmia.w	sp!, {r4, lr}
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
  m_flags |= FILE_FLAG_WRITE;
  return remove();
    5a36:	b.w	6bec <FatFile::remove()>

 fail:
  return false;
}
    5a3a:	movs	r0, #0
    5a3c:	pop	{r4, pc}
    5a3e:	Address 0x00005a3e is out of bounds.


00005a40 <FatFile::sync()>:
 fail:
  m_curCluster = tmp;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
    5a40:	push	{r0, r1, r2, r4, r5, lr}
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    5a42:	ldrb	r3, [r0, #0]
 fail:
  m_curCluster = tmp;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
    5a44:	mov	r4, r0
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    5a46:	cmp	r3, #0
    5a48:	beq.n	5ab4 <FatFile::sync()+0x74>
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    5a4a:	ldrsb.w	r3, [r0, #2]
    5a4e:	cmp	r3, #0
    5a50:	bge.n	5aa8 <FatFile::sync()+0x68>
    DirFat_t* dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    5a52:	movs	r1, #1
    5a54:	bl	5594 <FatFile::cacheDirEntry(unsigned char)>
    // check for deleted by another open file object
    if (!dir || dir->name[0] == FAT_NAME_DELETED) {
    5a58:	mov	r5, r0
    5a5a:	cbnz	r0, 5a68 <FatFile::sync()+0x28>
    return true;
  }
  DBG_FAIL_MACRO;

 fail:
  m_error |= WRITE_ERROR;
    5a5c:	ldrb	r3, [r4, #1]
    5a5e:	orr.w	r3, r3, #1
    5a62:	strb	r3, [r4, #1]
  return false;
    5a64:	movs	r0, #0
    5a66:	b.n	5ab6 <FatFile::sync()+0x76>
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    DirFat_t* dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    // check for deleted by another open file object
    if (!dir || dir->name[0] == FAT_NAME_DELETED) {
    5a68:	ldrb	r3, [r0, #0]
    5a6a:	cmp	r3, #229	; 0xe5
    5a6c:	beq.n	5a5c <FatFile::sync()+0x1c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // do not set filesize for dir files
    if (isFile()) {
    5a6e:	ldrb	r3, [r4, #0]
    5a70:	lsls	r3, r3, #28
      setLe32(dir->fileSize, m_fileSize);
    5a72:	itt	mi
    5a74:	ldrmi	r3, [r4, #28]
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    5a76:	strmi	r3, [r0, #28]
    }
    // update first cluster fields
    setLe16(dir->firstClusterLow, m_firstCluster & 0XFFFF);
    5a78:	ldr	r3, [r4, #32]
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    5a7a:	strh	r3, [r0, #26]
    5a7c:	lsrs	r3, r3, #16
    5a7e:	strh	r3, [r0, #20]
    setLe16(dir->firstClusterHigh, m_firstCluster >> 16);

    // set modify time if user supplied a callback date/time function
    if (FsDateTime::callback) {
    5a80:	ldr	r3, [pc, #56]	; (5abc <FatFile::sync()+0x7c>)
    5a82:	ldr	r3, [r3, #0]
    5a84:	cbz	r3, 5aa0 <FatFile::sync()+0x60>
      FsDateTime::callback(&date, &time, &ms10);
    5a86:	add.w	r2, sp, #3
    5a8a:	add.w	r1, sp, #6
    5a8e:	add	r0, sp, #4
    5a90:	blx	r3
      setLe16(dir->modifyDate, date);
    5a92:	ldrh.w	r3, [sp, #4]
    5a96:	strh	r3, [r5, #24]
    5a98:	strh	r3, [r5, #18]
    5a9a:	ldrh.w	r3, [sp, #6]
    5a9e:	strh	r3, [r5, #22]
      setLe16(dir->accessDate, date);
      setLe16(dir->modifyTime, time);
    }
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
    5aa0:	ldrb	r3, [r4, #2]
    5aa2:	and.w	r3, r3, #127	; 0x7f
    5aa6:	strb	r3, [r4, #2]
  }
  if (m_vol->cacheSync()) {
    5aa8:	ldr	r0, [r4, #8]
    5aaa:	bl	54ac <FatPartition::cacheSync()>
    5aae:	cmp	r0, #0
    5ab0:	beq.n	5a5c <FatFile::sync()+0x1c>
    5ab2:	b.n	5ab6 <FatFile::sync()+0x76>
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    return true;
    5ab4:	movs	r0, #1
  DBG_FAIL_MACRO;

 fail:
  m_error |= WRITE_ERROR;
  return false;
}
    5ab6:	add	sp, #12
    5ab8:	pop	{r4, r5, pc}
    5aba:	nop
    5abc:	.word	0x1fff8418

00005ac0 <FatFile::close()>:

 fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FatFile::close() {
    5ac0:	push	{r4, lr}
    5ac2:	mov	r4, r0
  bool rtn = sync();
    5ac4:	bl	5a40 <FatFile::sync()>
  m_attributes = FILE_ATTR_CLOSED;
    5ac8:	movs	r3, #0
    5aca:	strb	r3, [r4, #0]
  m_flags = 0;
    5acc:	strb	r3, [r4, #2]
  return rtn;
}
    5ace:	pop	{r4, pc}

00005ad0 <FatFile::open(FatFile*, char const*, int)>:
//------------------------------------------------------------------------------
bool FatFile::open(FatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, const char* path, oflag_t oflag) {
    5ad0:	push	{r4, r5, r6, r7, lr}
    5ad2:	sub	sp, #84	; 0x54
    5ad4:	mov	r7, r3
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    5ad6:	movs	r3, #0
    5ad8:	strb.w	r3, [sp, #8]
    5adc:	strb.w	r3, [sp, #9]
    5ae0:	strb.w	r3, [sp, #10]
    5ae4:	strh.w	r3, [sp, #56]	; 0x38
  FatFile tmpDir;
  FatName_t fname;

  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    5ae8:	ldrb	r3, [r0, #0]
//------------------------------------------------------------------------------
bool FatFile::open(FatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, const char* path, oflag_t oflag) {
    5aea:	str	r2, [sp, #4]
    5aec:	mov	r6, r0
    5aee:	mov	r4, r1
  FatFile tmpDir;
  FatName_t fname;

  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    5af0:	cbz	r3, 5af6 <FatFile::open(FatFile*, char const*, int)+0x26>
    close();
  }
  return open(dirFile, &fname, oflag);

 fail:
  return false;
    5af2:	movs	r0, #0
    5af4:	b.n	5b74 <FatFile::open(FatFile*, char const*, int)+0xa4>
bool FatFile::open(FatFile* dirFile, const char* path, oflag_t oflag) {
  FatFile tmpDir;
  FatName_t fname;

  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    5af6:	ldrb	r3, [r1, #0]
    5af8:	tst.w	r3, #112	; 0x70
    5afc:	beq.n	5af2 <FatFile::open(FatFile*, char const*, int)+0x22>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    5afe:	ldrb	r3, [r2, #0]
    5b00:	cmp	r3, #47	; 0x2f
    5b02:	bne.n	5b2a <FatFile::open(FatFile*, char const*, int)+0x5a>
    while (isDirSeparator(*path)) {
    5b04:	ldr	r3, [sp, #4]
    5b06:	ldrb	r2, [r3, #0]
    5b08:	cmp	r2, #47	; 0x2f
    5b0a:	bne.n	5b12 <FatFile::open(FatFile*, char const*, int)+0x42>
      path++;
    5b0c:	adds	r3, #1
    5b0e:	str	r3, [sp, #4]
  if (isOpen() || !dirFile->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    5b10:	b.n	5b04 <FatFile::open(FatFile*, char const*, int)+0x34>
      path++;
    }
    if (*path == 0) {
      return openRoot(dirFile->m_vol);
    5b12:	ldr	r1, [r4, #8]
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    }
    if (*path == 0) {
    5b14:	cbnz	r2, 5b1e <FatFile::open(FatFile*, char const*, int)+0x4e>
      return openRoot(dirFile->m_vol);
    5b16:	mov	r0, r6
    5b18:	bl	55b2 <FatFile::openRoot(FatVolume*)>
    5b1c:	b.n	5b74 <FatFile::open(FatFile*, char const*, int)+0xa4>
    }
    if (!tmpDir.openRoot(dirFile->m_vol)) {
    5b1e:	add	r0, sp, #8
    5b20:	bl	55b2 <FatFile::openRoot(FatVolume*)>
    5b24:	cmp	r0, #0
    5b26:	beq.n	5af2 <FatFile::open(FatFile*, char const*, int)+0x22>
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile = &tmpDir;
    5b28:	add	r4, sp, #8
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    5b2a:	add	r3, sp, #4
    5b2c:	add	r2, sp, #44	; 0x2c
    5b2e:	ldr	r1, [sp, #4]
    5b30:	mov	r0, r6
    5b32:	bl	6b54 <FatFile::parsePathName(char const*, FatName_t*, char const**)>
    5b36:	cmp	r0, #0
    5b38:	beq.n	5af2 <FatFile::open(FatFile*, char const*, int)+0x22>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (*path == 0) {
    5b3a:	ldr	r3, [sp, #4]
    5b3c:	ldrb	r3, [r3, #0]
    5b3e:	cbz	r3, 5b68 <FatFile::open(FatFile*, char const*, int)+0x98>
      break;
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
    5b40:	movs	r3, #0
    5b42:	add	r2, sp, #44	; 0x2c
    5b44:	mov	r1, r4
    5b46:	mov	r0, r6
    5b48:	bl	6904 <FatFile::open(FatFile*, FatName_t*, int)>
    5b4c:	cmp	r0, #0
    5b4e:	beq.n	5af2 <FatFile::open(FatFile*, char const*, int)+0x22>
      DBG_WARN_MACRO;
      goto fail;
    }
    tmpDir = *this;
    5b50:	mov	r5, r6
    5b52:	ldmia	r5!, {r0, r1, r2, r3}
    5b54:	add	r4, sp, #8
    5b56:	stmia	r4!, {r0, r1, r2, r3}
    5b58:	ldmia	r5!, {r0, r1, r2, r3}
    5b5a:	stmia	r4!, {r0, r1, r2, r3}
    5b5c:	ldr	r3, [r5, #0]
    5b5e:	str	r3, [r4, #0]
    dirFile = &tmpDir;
    close();
    5b60:	mov	r0, r6
    5b62:	bl	5ac0 <FatFile::close()>
    5b66:	b.n	5b28 <FatFile::open(FatFile*, char const*, int)+0x58>
  }
  return open(dirFile, &fname, oflag);
    5b68:	mov	r3, r7
    5b6a:	add	r2, sp, #44	; 0x2c
    5b6c:	mov	r1, r4
    5b6e:	mov	r0, r6
    5b70:	bl	6904 <FatFile::open(FatFile*, FatName_t*, int)>

 fail:
  return false;
}
    5b74:	add	sp, #84	; 0x54
    5b76:	pop	{r4, r5, r6, r7, pc}

00005b78 <FatFile::open(FatVolume*, char const*, int)>:
bool FatFile::open(const char* path, oflag_t oflag) {
  return open(FatVolume::cwv(), path, oflag);
}
//------------------------------------------------------------------------------
bool FatFile::open(FatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
    5b78:	cbz	r1, 5b82 <FatFile::open(FatVolume*, char const*, int)+0xa>
    5b7a:	add.w	r1, r1, #1096	; 0x448
    5b7e:	b.w	5ad0 <FatFile::open(FatFile*, char const*, int)>
}
    5b82:	mov	r0, r1
    5b84:	bx	lr

00005b86 <FatFile::dirEntry(DirFat_t*)>:
  close();
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::dirEntry(DirFat_t* dst) {
    5b86:	push	{r4, r5, r6, lr}
    5b88:	mov	r6, r0
    5b8a:	mov	r4, r1
  DirFat_t* dir;
  // Make sure fields on device are correct.
  if (!sync()) {
    5b8c:	bl	5a40 <FatFile::sync()>
    5b90:	mov	r5, r0
    5b92:	cbnz	r0, 5b98 <FatFile::dirEntry(DirFat_t*)+0x12>
  // copy to caller's struct
  memcpy(dst, dir, sizeof(DirFat_t));
  return true;

 fail:
  return false;
    5b94:	movs	r5, #0
    5b96:	b.n	5bb6 <FatFile::dirEntry(DirFat_t*)+0x30>
  if (!sync()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_READ);
    5b98:	movs	r1, #0
    5b9a:	mov	r0, r6
    5b9c:	bl	5594 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    5ba0:	cmp	r0, #0
    5ba2:	beq.n	5b94 <FatFile::dirEntry(DirFat_t*)+0xe>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // copy to caller's struct
  memcpy(dst, dir, sizeof(DirFat_t));
    5ba4:	mov	r1, r4
    5ba6:	add.w	r3, r0, #32
    5baa:	ldr.w	r2, [r0], #4
    5bae:	str.w	r2, [r1], #4
    5bb2:	cmp	r0, r3
    5bb4:	bne.n	5baa <FatFile::dirEntry(DirFat_t*)+0x24>
  return true;

 fail:
  return false;
}
    5bb6:	mov	r0, r5
    5bb8:	pop	{r4, r5, r6, pc}

00005bba <FatFile::getCreateDateTime(unsigned short*, unsigned short*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::getCreateDateTime(uint16_t* pdate, uint16_t* ptime) {
    5bba:	push	{r4, r5, lr}
    5bbc:	sub	sp, #36	; 0x24
    5bbe:	mov	r5, r1
  DirFat_t dir;
  if (!dirEntry(&dir)) {
    5bc0:	mov	r1, sp

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::getCreateDateTime(uint16_t* pdate, uint16_t* ptime) {
    5bc2:	mov	r4, r2
  DirFat_t dir;
  if (!dirEntry(&dir)) {
    5bc4:	bl	5b86 <FatFile::dirEntry(DirFat_t*)>
    5bc8:	cbz	r0, 5bd6 <FatFile::getCreateDateTime(unsigned short*, unsigned short*)+0x1c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  *pdate = getLe16(dir.createDate);
    5bca:	ldrh.w	r3, [sp, #16]
    5bce:	strh	r3, [r5, #0]
  *ptime = getLe16(dir.createTime);
    5bd0:	ldrh.w	r3, [sp, #14]
    5bd4:	strh	r3, [r4, #0]
  return true;

 fail:
  return false;
}
    5bd6:	add	sp, #36	; 0x24
    5bd8:	pop	{r4, r5, pc}

00005bda <FatFile::getModifyDateTime(unsigned short*, unsigned short*)>:
//------------------------------------------------------------------------------
bool FatFile::getModifyDateTime(uint16_t* pdate, uint16_t* ptime) {
    5bda:	push	{r4, r5, lr}
    5bdc:	sub	sp, #36	; 0x24
    5bde:	mov	r5, r1
  DirFat_t dir;
  if (!dirEntry(&dir)) {
    5be0:	mov	r1, sp

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::getModifyDateTime(uint16_t* pdate, uint16_t* ptime) {
    5be2:	mov	r4, r2
  DirFat_t dir;
  if (!dirEntry(&dir)) {
    5be4:	bl	5b86 <FatFile::dirEntry(DirFat_t*)>
    5be8:	cbz	r0, 5bf6 <FatFile::getModifyDateTime(unsigned short*, unsigned short*)+0x1c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  *pdate = getLe16(dir.modifyDate);
    5bea:	ldrh.w	r3, [sp, #24]
    5bee:	strh	r3, [r5, #0]
  *ptime = getLe16(dir.modifyTime);
    5bf0:	ldrh.w	r3, [sp, #22]
    5bf4:	strh	r3, [r4, #0]
  return true;

 fail:
  return false;
}
    5bf6:	add	sp, #36	; 0x24
    5bf8:	pop	{r4, r5, pc}

00005bfa <FatFile::mkdir(FatFile*, FatName_t*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, FatName_t* fname) {
    5bfa:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t sector;
  DirFat_t dot;
  DirFat_t* dir;
  cache_t* pc;

  if (!parent->isDir()) {
    5bfe:	ldrb	r3, [r1, #0]
    5c00:	tst.w	r3, #112	; 0x70

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, FatName_t* fname) {
    5c04:	sub	sp, #32
    5c06:	mov	r4, r0
    5c08:	mov	r6, r1
  uint32_t sector;
  DirFat_t dot;
  DirFat_t* dir;
  cache_t* pc;

  if (!parent->isDir()) {
    5c0a:	beq.n	5c46 <FatFile::mkdir(FatFile*, FatName_t*)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // create a normal file
  if (!open(parent, fname, O_CREAT | O_EXCL | O_RDWR)) {
    5c0c:	movw	r3, #2562	; 0xa02
    5c10:	bl	6904 <FatFile::open(FatFile*, FatName_t*, int)>
    5c14:	cbz	r0, 5c46 <FatFile::mkdir(FatFile*, FatName_t*)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // convert file to directory
  m_flags = FILE_FLAG_READ;
    5c16:	movs	r7, #1
  m_attributes = FILE_ATTR_SUBDIR;
    5c18:	movs	r5, #16
  if (!open(parent, fname, O_CREAT | O_EXCL | O_RDWR)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // convert file to directory
  m_flags = FILE_FLAG_READ;
    5c1a:	strb	r7, [r4, #2]
  m_attributes = FILE_ATTR_SUBDIR;
    5c1c:	strb	r5, [r4, #0]

  // allocate and zero first cluster
  if (!addDirCluster()) {
    5c1e:	mov	r0, r4
    5c20:	bl	5508 <FatFile::addDirCluster()>
    5c24:	cbz	r0, 5c46 <FatFile::mkdir(FatFile*, FatName_t*)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_firstCluster = m_curCluster;
    5c26:	ldr	r3, [r4, #16]
    5c28:	str	r3, [r4, #32]
   * \return true for success or false for failure.
   */
  bool rename(FatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    5c2a:	movs	r1, #0
    5c2c:	mov	r0, r4
    5c2e:	bl	57ea <FatFile::seekSet(unsigned long)>
  // Set to start of dir
  rewind();
  // force entry to device
  if (!sync()) {
    5c32:	mov	r0, r4
    5c34:	bl	5a40 <FatFile::sync()>
    5c38:	cbz	r0, 5c46 <FatFile::mkdir(FatFile*, FatName_t*)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // cache entry - should already be in cache due to sync() call
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    5c3a:	mov	r1, r7
    5c3c:	mov	r0, r4
    5c3e:	bl	5594 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    5c42:	mov	r3, r0
    5c44:	cbnz	r0, 5c4a <FatFile::mkdir(FatFile*, FatName_t*)+0x50>
  memcpy(&pc->dir[1], &dot, sizeof(dot));
  // write first sector
  return m_vol->cacheSync();

 fail:
  return false;
    5c46:	movs	r0, #0
    5c48:	b.n	5cee <FatFile::mkdir(FatFile*, FatName_t*)+0xf4>
  if (!dir) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // change directory entry attribute
  dir->attributes = FAT_ATTRIB_DIRECTORY;
    5c4a:	strb	r5, [r0, #11]

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
    5c4c:	mov	r2, r0
    5c4e:	mov	r7, sp
    5c50:	add.w	ip, r0, #32
    5c54:	mov	r5, sp
    5c56:	ldr	r0, [r2, #0]
    5c58:	ldr	r1, [r2, #4]
    5c5a:	mov	lr, r7
    5c5c:	stmia.w	lr!, {r0, r1}
    5c60:	adds	r2, #8
    5c62:	cmp	r2, ip
    5c64:	mov	r7, lr
    5c66:	bne.n	5c56 <FatFile::mkdir(FatFile*, FatName_t*)+0x5c>
    5c68:	ldrh	r7, [r3, #20]
    5c6a:	ldrh.w	r8, [r3, #26]
  dot.name[0] = '.';
    5c6e:	movs	r3, #46	; 0x2e
    5c70:	strb.w	r3, [sp]
  for (uint8_t i = 1; i < 11; i++) {
    dot.name[i] = ' ';
    5c74:	movs	r1, #32
  // change directory entry attribute
  dir->attributes = FAT_ATTRIB_DIRECTORY;

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
  dot.name[0] = '.';
    5c76:	movs	r3, #0
  for (uint8_t i = 1; i < 11; i++) {
    dot.name[i] = ' ';
    5c78:	adds	r2, r5, r3
    5c7a:	adds	r3, #1
  dir->attributes = FAT_ATTRIB_DIRECTORY;

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
  dot.name[0] = '.';
  for (uint8_t i = 1; i < 11; i++) {
    5c7c:	cmp	r3, #10
    dot.name[i] = ' ';
    5c7e:	strb	r1, [r2, #1]
  dir->attributes = FAT_ATTRIB_DIRECTORY;

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
  dot.name[0] = '.';
  for (uint8_t i = 1; i < 11; i++) {
    5c80:	bne.n	5c78 <FatFile::mkdir(FatFile*, FatName_t*)+0x7e>
    dot.name[i] = ' ';
  }

  // cache sector for '.'  and '..'
  sector = m_vol->clusterStartSector(m_firstCluster);
    5c82:	ldr	r0, [r4, #8]
    5c84:	ldr	r1, [r4, #32]
    5c86:	ldrb	r3, [r0, #6]
    5c88:	subs	r1, #2
    5c8a:	lsls	r1, r3
    5c8c:	ldr	r3, [r0, #20]
    5c8e:	movs	r2, #1
    5c90:	add	r1, r3
    5c92:	adds	r0, #40	; 0x28
    5c94:	bl	3072 <FsCache::get(unsigned long, unsigned char)>
  pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_WRITE);
  if (!pc) {
    5c98:	mov	r3, r0
    5c9a:	cmp	r0, #0
    5c9c:	beq.n	5c46 <FatFile::mkdir(FatFile*, FatName_t*)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // copy '.' to sector
  memcpy(&pc->dir[0], &dot, sizeof(dot));
    5c9e:	strh.w	r7, [sp, #20]
    5ca2:	strh.w	r8, [sp, #26]
    5ca6:	mov	lr, r5
    5ca8:	mov	r7, r0
    5caa:	add.w	ip, sp, #32
    5cae:	mov	r2, lr
    5cb0:	ldmia	r2!, {r0, r1}
    5cb2:	cmp	r2, ip
    5cb4:	str	r0, [r7, #0]
    5cb6:	str	r1, [r7, #4]
    5cb8:	mov	lr, r2
    5cba:	add.w	r7, r7, #8
    5cbe:	bne.n	5cae <FatFile::mkdir(FatFile*, FatName_t*)+0xb4>
  // make entry for '..'
  dot.name[1] = '.';
    5cc0:	movs	r2, #46	; 0x2e
    5cc2:	strb.w	r2, [sp, #1]
  setLe16(dot.firstClusterLow, parent->m_firstCluster & 0XFFFF);
    5cc6:	ldr	r2, [r6, #32]
  setLe16(dot.firstClusterHigh, parent->m_firstCluster >> 16);
  // copy '..' to sector
  memcpy(&pc->dir[1], &dot, sizeof(dot));
    5cc8:	strh.w	r2, [sp, #26]
    5ccc:	lsrs	r1, r2, #16
    5cce:	strh.w	r1, [sp, #20]
    5cd2:	adds	r3, #32
    5cd4:	add	r6, sp, #32
    5cd6:	mov	r2, r5
    5cd8:	ldmia	r2!, {r0, r1}
    5cda:	cmp	r2, r6
    5cdc:	str	r0, [r3, #0]
    5cde:	str	r1, [r3, #4]
    5ce0:	mov	r5, r2
    5ce2:	add.w	r3, r3, #8
    5ce6:	bne.n	5cd6 <FatFile::mkdir(FatFile*, FatName_t*)+0xdc>
  // write first sector
  return m_vol->cacheSync();
    5ce8:	ldr	r0, [r4, #8]
    5cea:	bl	54ac <FatPartition::cacheSync()>

 fail:
  return false;
}
    5cee:	add	sp, #32
    5cf0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00005cf4 <FatFile::mkdir(FatFile*, char const*, bool)>:
//------------------------------------------------------------------------------
bool FatFile::isBusy() {
  return m_vol->isBusy();
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, const char* path, bool pFlag) {
    5cf4:	push	{r4, r5, r6, r7, lr}
    5cf6:	sub	sp, #84	; 0x54
    5cf8:	mov	r7, r3
    5cfa:	movs	r3, #0
    5cfc:	strh.w	r3, [sp, #20]
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    5d00:	strb.w	r3, [sp, #44]	; 0x2c
    5d04:	strb.w	r3, [sp, #45]	; 0x2d
    5d08:	strb.w	r3, [sp, #46]	; 0x2e
  FatName_t fname;
  FatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    5d0c:	ldrb	r3, [r0, #0]
//------------------------------------------------------------------------------
bool FatFile::isBusy() {
  return m_vol->isBusy();
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, const char* path, bool pFlag) {
    5d0e:	str	r2, [sp, #4]
    5d10:	mov	r6, r0
    5d12:	mov	r4, r1
  FatName_t fname;
  FatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    5d14:	cmp	r3, #0
    5d16:	bne.n	5d98 <FatFile::mkdir(FatFile*, char const*, bool)+0xa4>
    5d18:	ldrb	r3, [r1, #0]
    5d1a:	tst.w	r3, #112	; 0x70
    5d1e:	beq.n	5d98 <FatFile::mkdir(FatFile*, char const*, bool)+0xa4>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    5d20:	ldrb	r3, [r2, #0]
    5d22:	cmp	r3, #47	; 0x2f
    5d24:	bne.n	5d40 <FatFile::mkdir(FatFile*, char const*, bool)+0x4c>
    while (isDirSeparator(*path)) {
    5d26:	ldr	r3, [sp, #4]
    5d28:	ldrb	r2, [r3, #0]
    5d2a:	cmp	r2, #47	; 0x2f
    5d2c:	bne.n	5d34 <FatFile::mkdir(FatFile*, char const*, bool)+0x40>
      path++;
    5d2e:	adds	r3, #1
    5d30:	str	r3, [sp, #4]
  if (isOpen() || !parent->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    5d32:	b.n	5d26 <FatFile::mkdir(FatFile*, char const*, bool)+0x32>
      path++;
    }
    if (!tmpDir.openRoot(parent->m_vol)) {
    5d34:	ldr	r1, [r4, #8]
    5d36:	add	r0, sp, #44	; 0x2c
    5d38:	bl	55b2 <FatFile::openRoot(FatVolume*)>
    5d3c:	cbz	r0, 5d98 <FatFile::mkdir(FatFile*, char const*, bool)+0xa4>
      DBG_FAIL_MACRO;
      goto fail;
    }
    parent = &tmpDir;
    5d3e:	add	r4, sp, #44	; 0x2c
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    5d40:	add	r3, sp, #4
    5d42:	add	r2, sp, #8
    5d44:	ldr	r1, [sp, #4]
    5d46:	mov	r0, r6
    5d48:	bl	6b54 <FatFile::parsePathName(char const*, FatName_t*, char const**)>
    5d4c:	cbz	r0, 5d98 <FatFile::mkdir(FatFile*, char const*, bool)+0xa4>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!*path) {
    5d4e:	ldr	r3, [sp, #4]
    5d50:	ldrb	r3, [r3, #0]
    5d52:	cbz	r3, 5d8c <FatFile::mkdir(FatFile*, char const*, bool)+0x98>
      break;
    }
    if (!open(parent, &fname, O_RDONLY)) {
    5d54:	movs	r3, #0
    5d56:	add	r2, sp, #8
    5d58:	mov	r1, r4
    5d5a:	mov	r0, r6
    5d5c:	bl	6904 <FatFile::open(FatFile*, FatName_t*, int)>
    5d60:	cbz	r0, 5d7a <FatFile::mkdir(FatFile*, char const*, bool)+0x86>
      if (!pFlag || !mkdir(parent, &fname)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    tmpDir = *this;
    5d62:	mov	r5, r6
    5d64:	ldmia	r5!, {r0, r1, r2, r3}
    5d66:	add	r4, sp, #44	; 0x2c
    5d68:	stmia	r4!, {r0, r1, r2, r3}
    5d6a:	ldmia	r5!, {r0, r1, r2, r3}
    5d6c:	stmia	r4!, {r0, r1, r2, r3}
    5d6e:	ldr	r3, [r5, #0]
    5d70:	str	r3, [r4, #0]
    parent = &tmpDir;
    close();
    5d72:	mov	r0, r6
    5d74:	bl	5ac0 <FatFile::close()>
    5d78:	b.n	5d3e <FatFile::mkdir(FatFile*, char const*, bool)+0x4a>
    }
    if (!*path) {
      break;
    }
    if (!open(parent, &fname, O_RDONLY)) {
      if (!pFlag || !mkdir(parent, &fname)) {
    5d7a:	cbz	r7, 5d98 <FatFile::mkdir(FatFile*, char const*, bool)+0xa4>
    5d7c:	add	r2, sp, #8
    5d7e:	mov	r1, r4
    5d80:	mov	r0, r6
    5d82:	bl	5bfa <FatFile::mkdir(FatFile*, FatName_t*)>
    5d86:	cmp	r0, #0
    5d88:	bne.n	5d62 <FatFile::mkdir(FatFile*, char const*, bool)+0x6e>
    5d8a:	b.n	5d98 <FatFile::mkdir(FatFile*, char const*, bool)+0xa4>
    }
    tmpDir = *this;
    parent = &tmpDir;
    close();
  }
  return mkdir(parent, &fname);
    5d8c:	add	r2, sp, #8
    5d8e:	mov	r1, r4
    5d90:	mov	r0, r6
    5d92:	bl	5bfa <FatFile::mkdir(FatFile*, FatName_t*)>
    5d96:	b.n	5d9a <FatFile::mkdir(FatFile*, char const*, bool)+0xa6>

 fail:
  return false;
    5d98:	movs	r0, #0
}
    5d9a:	add	sp, #84	; 0x54
    5d9c:	pop	{r4, r5, r6, r7, pc}

00005d9e <FatFile::rename(FatFile*, char const*)>:
//------------------------------------------------------------------------------
bool FatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool FatFile::rename(FatFile* dirFile, const char* newPath) {
    5d9e:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  FatFile oldFile;
  cache_t* pc;
  DirFat_t* dir;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    5da2:	ldrb	r3, [r0, #0]
//------------------------------------------------------------------------------
bool FatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool FatFile::rename(FatFile* dirFile, const char* newPath) {
    5da4:	sub	sp, #108	; 0x6c
    5da6:	movs	r7, #0
  FatFile oldFile;
  cache_t* pc;
  DirFat_t* dir;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    5da8:	tst.w	r3, #24
//------------------------------------------------------------------------------
bool FatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool FatFile::rename(FatFile* dirFile, const char* newPath) {
    5dac:	mov	r4, r0
    5dae:	mov	r8, r1
    5db0:	mov	r9, r2
    5db2:	strb.w	r7, [sp, #32]
    5db6:	strb.w	r7, [sp, #33]	; 0x21
    5dba:	strb.w	r7, [sp, #34]	; 0x22
    5dbe:	strb.w	r7, [sp, #68]	; 0x44
    5dc2:	strb.w	r7, [sp, #69]	; 0x45
    5dc6:	strb.w	r7, [sp, #70]	; 0x46
  FatFile oldFile;
  cache_t* pc;
  DirFat_t* dir;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    5dca:	bne.n	5dd0 <FatFile::rename(FatFile*, char const*)+0x32>
    goto fail;
  }
  return m_vol->cacheSync();

 fail:
  return false;
    5dcc:	movs	r0, #0
    5dce:	b.n	5f2e <FatFile::rename(FatFile*, char const*)+0x190>
  if (!USE_LONG_FILE_NAMES && isLFN()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Can't move file to new volume.
  if (m_vol != dirFile->m_vol) {
    5dd0:	ldr	r2, [r0, #8]
    5dd2:	ldr	r3, [r1, #8]
    5dd4:	cmp	r2, r3
    5dd6:	bne.n	5dcc <FatFile::rename(FatFile*, char const*)+0x2e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // sync() and cache directory entry
  sync();
  oldFile = *this;
    5dd8:	mov	r6, r4
  if (m_vol != dirFile->m_vol) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // sync() and cache directory entry
  sync();
    5dda:	bl	5a40 <FatFile::sync()>
  oldFile = *this;
    5dde:	ldmia	r6!, {r0, r1, r2, r3}
    5de0:	add	r5, sp, #68	; 0x44
    5de2:	stmia	r5!, {r0, r1, r2, r3}
    5de4:	ldmia	r6!, {r0, r1, r2, r3}
    5de6:	stmia	r5!, {r0, r1, r2, r3}
    5de8:	ldr	r3, [r6, #0]
    5dea:	str	r3, [r5, #0]
  dir = cacheDirEntry(FsCache::CACHE_FOR_READ);
    5dec:	mov	r1, r7
    5dee:	mov	r0, r4
    5df0:	bl	5594 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    5df4:	cmp	r0, #0
    5df6:	beq.n	5dcc <FatFile::rename(FatFile*, char const*)+0x2e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // save directory entry
  memcpy(&entry, dir, sizeof(entry));
    5df8:	mov	r3, r0
    5dfa:	mov	r2, sp
    5dfc:	add.w	r7, r0, #32
    5e00:	mov	r5, sp
    5e02:	ldr	r0, [r3, #0]
    5e04:	ldr	r1, [r3, #4]
    5e06:	mov	r6, r2
    5e08:	stmia	r6!, {r0, r1}
    5e0a:	adds	r3, #8
    5e0c:	cmp	r3, r7
    5e0e:	mov	r2, r6
    5e10:	bne.n	5e02 <FatFile::rename(FatFile*, char const*)+0x64>
  // make directory entry for new path
  if (isFile()) {
    5e12:	ldrb	r2, [r4, #0]
    5e14:	and.w	r2, r2, #8
    5e18:	and.w	r3, r2, #255	; 0xff
    5e1c:	add	r6, sp, #32
    5e1e:	cbz	r2, 5e36 <FatFile::rename(FatFile*, char const*)+0x98>
    if (!file.open(dirFile, newPath, O_CREAT | O_EXCL | O_WRONLY)) {
    5e20:	movw	r3, #2561	; 0xa01
    5e24:	mov	r2, r9
    5e26:	mov	r1, r8
    5e28:	mov	r0, r6
    5e2a:	bl	5ad0 <FatFile::open(FatFile*, char const*, int)>
    5e2e:	cmp	r0, #0
    5e30:	beq.n	5dcc <FatFile::rename(FatFile*, char const*)+0x2e>
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool FatFile::rename(FatFile* dirFile, const char* newPath) {
  DirFat_t entry;
  uint32_t dirCluster = 0;
    5e32:	movs	r7, #0
    5e34:	b.n	5e46 <FatFile::rename(FatFile*, char const*)+0xa8>
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else {
    // don't create missing path prefix components
    if (!file.mkdir(dirFile, newPath, false)) {
    5e36:	mov	r2, r9
    5e38:	mov	r1, r8
    5e3a:	mov	r0, r6
    5e3c:	bl	5cf4 <FatFile::mkdir(FatFile*, char const*, bool)>
    5e40:	cmp	r0, #0
    5e42:	beq.n	5dcc <FatFile::rename(FatFile*, char const*)+0x2e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // save cluster containing new dot dot
    dirCluster = file.m_firstCluster;
    5e44:	ldr	r7, [sp, #64]	; 0x40
  }
  // change to new directory entry

  m_dirSector = file.m_dirSector;
    5e46:	ldr	r3, [sp, #56]	; 0x38
    5e48:	str	r3, [r4, #24]
  m_dirIndex = file.m_dirIndex;
    5e4a:	ldrh.w	r3, [sp, #36]	; 0x24
    5e4e:	strh	r3, [r4, #4]
  m_lfnOrd = file.m_lfnOrd;
    5e50:	ldrb.w	r3, [sp, #35]	; 0x23
    5e54:	strb	r3, [r4, #3]
  m_dirCluster = file.m_dirCluster;
    5e56:	ldr	r3, [sp, #44]	; 0x2c
    5e58:	str	r3, [r4, #12]
  // mark closed to avoid possible destructor close call
  file.m_attributes = FILE_ATTR_CLOSED;
  file.m_flags = 0;

  // cache new directory entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    5e5a:	movs	r1, #1
  m_dirSector = file.m_dirSector;
  m_dirIndex = file.m_dirIndex;
  m_lfnOrd = file.m_lfnOrd;
  m_dirCluster = file.m_dirCluster;
  // mark closed to avoid possible destructor close call
  file.m_attributes = FILE_ATTR_CLOSED;
    5e5c:	movs	r3, #0
  file.m_flags = 0;

  // cache new directory entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    5e5e:	mov	r0, r4
  m_dirSector = file.m_dirSector;
  m_dirIndex = file.m_dirIndex;
  m_lfnOrd = file.m_lfnOrd;
  m_dirCluster = file.m_dirCluster;
  // mark closed to avoid possible destructor close call
  file.m_attributes = FILE_ATTR_CLOSED;
    5e60:	strb.w	r3, [sp, #32]
  file.m_flags = 0;
    5e64:	strb.w	r3, [sp, #34]	; 0x22

  // cache new directory entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    5e68:	bl	5594 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    5e6c:	cmp	r0, #0
    5e6e:	beq.n	5dcc <FatFile::rename(FatFile*, char const*)+0x2e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // copy all but name and name flags to new directory entry
  memcpy(&dir->createTimeMs, &entry.createTimeMs,
         sizeof(entry) - sizeof(dir->name) - 2);
    5e70:	add.w	r3, sp, #13
    5e74:	add.w	r2, r0, #13
    5e78:	add.w	r1, sp, #29
    5e7c:	ldr.w	lr, [r3], #4
    5e80:	str.w	lr, [r2], #4
    5e84:	cmp	r3, r1
    5e86:	bne.n	5e7c <FatFile::rename(FatFile*, char const*)+0xde>
    5e88:	ldrh	r1, [r3, #0]
    5e8a:	strh	r1, [r2, #0]
    5e8c:	ldrb	r3, [r3, #2]
    5e8e:	strb	r3, [r2, #2]
  dir->attributes = entry.attributes;
    5e90:	ldrb.w	r3, [sp, #11]
    5e94:	strb	r3, [r0, #11]

  // update dot dot if directory
  if (dirCluster) {
    5e96:	cmp	r7, #0
    5e98:	beq.n	5f0c <FatFile::rename(FatFile*, char const*)+0x16e>
    // get new dot dot
    uint32_t sector = m_vol->clusterStartSector(dirCluster);
    5e9a:	ldr	r0, [r4, #8]
    5e9c:	ldrb	r1, [r0, #6]
    5e9e:	subs	r3, r7, #2
    5ea0:	lsls	r3, r1
    5ea2:	ldr	r1, [r0, #20]
    5ea4:	movs	r2, #0
    5ea6:	add	r1, r3
    5ea8:	adds	r0, #40	; 0x28
    5eaa:	bl	3072 <FsCache::get(unsigned long, unsigned char)>
    pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_READ);
    if (!pc) {
    5eae:	cmp	r0, #0
    5eb0:	beq.n	5dcc <FatFile::rename(FatFile*, char const*)+0x2e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    memcpy(&entry, &pc->dir[1], sizeof(entry));
    5eb2:	add.w	r3, r0, #32
    5eb6:	mov	lr, r5
    5eb8:	add.w	ip, r0, #64	; 0x40
    5ebc:	ldr	r0, [r3, #0]
    5ebe:	ldr	r1, [r3, #4]
    5ec0:	mov	r2, lr
    5ec2:	stmia	r2!, {r0, r1}
    5ec4:	adds	r3, #8
    5ec6:	cmp	r3, ip
    5ec8:	mov	lr, r2
    5eca:	bne.n	5ebc <FatFile::rename(FatFile*, char const*)+0x11e>

    // free unused cluster
    if (!m_vol->freeChain(dirCluster)) {
    5ecc:	mov	r1, r7
    5ece:	ldr	r0, [r4, #8]
    5ed0:	bl	63ca <FatPartition::freeChain(unsigned long)>
    5ed4:	cmp	r0, #0
    5ed6:	beq.w	5dcc <FatFile::rename(FatFile*, char const*)+0x2e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // store new dot dot
    sector = m_vol->clusterStartSector(m_firstCluster);
    5eda:	ldr	r0, [r4, #8]
    5edc:	ldr	r1, [r4, #32]
    5ede:	ldrb	r3, [r0, #6]
    5ee0:	subs	r1, #2
    5ee2:	lsls	r1, r3
    5ee4:	ldr	r3, [r0, #20]
    5ee6:	movs	r2, #1
    5ee8:	add	r1, r3
    5eea:	adds	r0, #40	; 0x28
    5eec:	bl	3072 <FsCache::get(unsigned long, unsigned char)>
    pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_WRITE);
    if (!pc) {
    5ef0:	cmp	r0, #0
    5ef2:	beq.w	5dcc <FatFile::rename(FatFile*, char const*)+0x2e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    memcpy(&pc->dir[1], &entry, sizeof(entry));
    5ef6:	add.w	r3, r0, #32
    5efa:	mov	r2, r5
    5efc:	ldmia	r2!, {r0, r1}
    5efe:	cmp	r2, r6
    5f00:	str	r0, [r3, #0]
    5f02:	str	r1, [r3, #4]
    5f04:	mov	r5, r2
    5f06:	add.w	r3, r3, #8
    5f0a:	bne.n	5efa <FatFile::rename(FatFile*, char const*)+0x15c>
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
    5f0c:	movs	r3, #0
    5f0e:	str	r3, [sp, #100]	; 0x64
  oldFile.m_flags = FILE_FLAG_WRITE;
    5f10:	movs	r3, #2
    5f12:	strb.w	r3, [sp, #70]	; 0x46
  oldFile.m_attributes = FILE_ATTR_FILE;
  if (!oldFile.remove()) {
    5f16:	add	r0, sp, #68	; 0x44
    memcpy(&pc->dir[1], &entry, sizeof(entry));
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
  oldFile.m_flags = FILE_FLAG_WRITE;
  oldFile.m_attributes = FILE_ATTR_FILE;
    5f18:	movs	r3, #8
    5f1a:	strb.w	r3, [sp, #68]	; 0x44
  if (!oldFile.remove()) {
    5f1e:	bl	6bec <FatFile::remove()>
    5f22:	cmp	r0, #0
    5f24:	beq.w	5dcc <FatFile::rename(FatFile*, char const*)+0x2e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  return m_vol->cacheSync();
    5f28:	ldr	r0, [r4, #8]
    5f2a:	bl	54ac <FatPartition::cacheSync()>

 fail:
  return false;
}
    5f2e:	add	sp, #108	; 0x6c
    5f30:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

00005f34 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>:
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
    5f34:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5f38:	mov	r4, r3
      || month > 12
      || day < 1
      || day > 31
      || hour > 23
      || minute > 59
      || second > 59) {
    5f3a:	ldrb	r3, [r0, #0]
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
    5f3c:	ldrb.w	fp, [sp, #40]	; 0x28
    5f40:	ldrb.w	r9, [sp, #44]	; 0x2c
    5f44:	ldrb.w	sl, [sp, #48]	; 0x30
    5f48:	ldrb.w	r5, [sp, #52]	; 0x34
      || month > 12
      || day < 1
      || day > 31
      || hour > 23
      || minute > 59
      || second > 59) {
    5f4c:	lsls	r3, r3, #28
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
    5f4e:	mov	r6, r0
    5f50:	mov	r7, r1
      || month > 12
      || day < 1
      || day > 31
      || hour > 23
      || minute > 59
      || second > 59) {
    5f52:	bmi.n	5f5a <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x26>
    setLe16(dir->modifyTime, dirTime);
  }
  return m_vol->cacheSync();

 fail:
  return false;
    5f54:	movs	r0, #0
    5f56:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  uint16_t dirDate;
  uint16_t dirTime;
  DirFat_t* dir;

  if (!isFile()
      || year < 1980
    5f5a:	subw	r2, r2, #1980	; 0x7bc
    5f5e:	uxth.w	r8, r2
    5f62:	cmp.w	r8, #127	; 0x7f
    5f66:	bhi.n	5f54 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
      || year > 2107
      || month < 1
    5f68:	subs	r3, r4, #1
    5f6a:	cmp	r3, #11
    5f6c:	bhi.n	5f54 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
      || month > 12
      || day < 1
    5f6e:	add.w	r3, fp, #4294967295
    5f72:	cmp	r3, #30
    5f74:	bhi.n	5f54 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
      || day > 31
      || hour > 23
    5f76:	cmp.w	r9, #23
    5f7a:	bhi.n	5f54 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
      || minute > 59
    5f7c:	cmp.w	sl, #59	; 0x3b
    5f80:	bhi.n	5f54 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
      || second > 59) {
    5f82:	cmp	r5, #59	; 0x3b
    5f84:	bhi.n	5f54 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // update directory entry
  if (!sync()) {
    5f86:	bl	5a40 <FatFile::sync()>
    5f8a:	cmp	r0, #0
    5f8c:	beq.n	5f54 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
    DBG_FAIL_MACRO;
    goto fail;
  }
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    5f8e:	movs	r1, #1
    5f90:	mov	r0, r6
    5f92:	bl	5594 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    5f96:	cmp	r0, #0
    5f98:	beq.n	5f54 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
    5f9a:	orr.w	r4, fp, r4, lsl #5
    5f9e:	orr.w	r8, r4, r8, lsl #9
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
    5fa2:	asrs	r3, r5, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  dirDate = FS_DATE(year, month, day);
  dirTime = FS_TIME(hour, minute, second);
  if (flags & T_ACCESS) {
    5fa4:	lsls	r4, r7, #31
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
    5fa6:	uxth.w	r8, r8
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
    5faa:	orr.w	r3, r3, sl, lsl #5
    5fae:	orr.w	r3, r3, r9, lsl #11
    5fb2:	it	mi
    5fb4:	strhmi.w	r8, [r0, #18]
    setLe16(dir->accessDate, dirDate);
  }
  if (flags & T_CREATE) {
    5fb8:	lsls	r1, r7, #30
    5fba:	uxth	r3, r3
    5fbc:	bpl.n	5fce <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x9a>
    setLe16(dir->createDate, dirDate);
    setLe16(dir->createTime, dirTime);
    // units of 10 ms
    dir->createTimeMs = second & 1 ? 100 : 0;
    5fbe:	ands.w	r5, r5, #1
    5fc2:	it	ne
    5fc4:	movne	r5, #100	; 0x64
    5fc6:	strh.w	r8, [r0, #16]
    5fca:	strh	r3, [r0, #14]
    5fcc:	strb	r5, [r0, #13]
  }
  if (flags & T_WRITE) {
    5fce:	lsls	r2, r7, #29
    5fd0:	itt	mi
    5fd2:	strhmi.w	r8, [r0, #24]
    5fd6:	strhmi	r3, [r0, #22]
    setLe16(dir->modifyDate, dirDate);
    setLe16(dir->modifyTime, dirTime);
  }
  return m_vol->cacheSync();
    5fd8:	ldr	r0, [r6, #8]
    5fda:	bl	54ac <FatPartition::cacheSync()>
    5fde:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

00005fe2 <FatFile::truncate()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::truncate() {
    5fe2:	push	{r0, r1, r4, lr}
  uint32_t toFree;
  // error if not a normal file or read-only
  if (!isWritable()) {
    5fe4:	ldrb	r3, [r0, #2]
    5fe6:	lsls	r3, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::truncate() {
    5fe8:	mov	r4, r0
  uint32_t toFree;
  // error if not a normal file or read-only
  if (!isWritable()) {
    5fea:	bmi.n	5ff0 <FatFile::truncate()+0xe>
  // need to update directory entry
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return sync();

 fail:
  return false;
    5fec:	movs	r0, #0
    5fee:	b.n	6046 <FatFile::truncate()+0x64>
  // error if not a normal file or read-only
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
    5ff0:	ldr	r3, [r0, #32]
    5ff2:	cbz	r3, 6044 <FatFile::truncate()+0x62>
      return true;
  }
  if (m_curCluster) {
    5ff4:	ldr	r1, [r0, #16]
    5ff6:	cbz	r1, 601c <FatFile::truncate()+0x3a>
    toFree = 0;
    5ff8:	add	r2, sp, #8
    5ffa:	movs	r3, #0
    5ffc:	str.w	r3, [r2, #-4]!
    int8_t fg = m_vol->fatGet(m_curCluster, &toFree);
    6000:	ldr	r0, [r0, #8]
    6002:	bl	6284 <FatPartition::fatGet(unsigned long, unsigned long*)>
    if (fg < 0) {
    6006:	cmp	r0, #0
    6008:	blt.n	5fec <FatFile::truncate()+0xa>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (fg) {
    600a:	beq.n	6020 <FatFile::truncate()+0x3e>
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
  }
  int8_t fatGet(uint32_t cluster, uint32_t* value);
  bool fatPut(uint32_t cluster, uint32_t value);
  bool fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
    600c:	mvn.w	r2, #4026531840	; 0xf0000000
    6010:	ldr	r1, [r4, #16]
    6012:	ldr	r0, [r4, #8]
    6014:	bl	62ee <FatPartition::fatPut(unsigned long, unsigned long)>
      // current cluster is end of chain
      if (!m_vol->fatPutEOC(m_curCluster)) {
    6018:	cbnz	r0, 6020 <FatFile::truncate()+0x3e>
    601a:	b.n	5fec <FatFile::truncate()+0xa>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
  } else {
    toFree = m_firstCluster;
    601c:	str	r3, [sp, #4]
    m_firstCluster = 0;
    601e:	str	r1, [r0, #32]
  }
  if (toFree) {
    6020:	ldr	r1, [sp, #4]
    6022:	cbnz	r1, 6038 <FatFile::truncate()+0x56>
    if (!m_vol->freeChain(toFree)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  m_fileSize = m_curPosition;
    6024:	ldr	r3, [r4, #20]
    6026:	str	r3, [r4, #28]

  // need to update directory entry
  m_flags |= FILE_FLAG_DIR_DIRTY;
    6028:	ldrb	r3, [r4, #2]
    602a:	orn	r3, r3, #127	; 0x7f
    602e:	strb	r3, [r4, #2]
  return sync();
    6030:	mov	r0, r4
    6032:	bl	5a40 <FatFile::sync()>
    6036:	b.n	6046 <FatFile::truncate()+0x64>
  } else {
    toFree = m_firstCluster;
    m_firstCluster = 0;
  }
  if (toFree) {
    if (!m_vol->freeChain(toFree)) {
    6038:	ldr	r0, [r4, #8]
    603a:	bl	63ca <FatPartition::freeChain(unsigned long)>
    603e:	cmp	r0, #0
    6040:	bne.n	6024 <FatFile::truncate()+0x42>
    6042:	b.n	5fec <FatFile::truncate()+0xa>
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
      return true;
    6044:	movs	r0, #1
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return sync();

 fail:
  return false;
}
    6046:	add	sp, #8
    6048:	pop	{r4, pc}
    604a:	Address 0x0000604a is out of bounds.


0000604c <FatFile::write(void const*, unsigned int)>:
//------------------------------------------------------------------------------
size_t FatFile::write(const void* buf, size_t nbyte) {
    604c:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6050:	ldrb	r3, [r0, #2]
    6052:	mov	r9, r1
  uint8_t cacheOption;
  // number of bytes left to write  -  must be before goto statements
  size_t nToWrite = nbyte;
  size_t n;
  // error if not a normal file or is read-only
  if (!isWritable()) {
    6054:	lsls	r1, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t FatFile::write(const void* buf, size_t nbyte) {
    6056:	mov	r4, r0
    6058:	mov	r5, r2
  uint8_t cacheOption;
  // number of bytes left to write  -  must be before goto statements
  size_t nToWrite = nbyte;
  size_t n;
  // error if not a normal file or is read-only
  if (!isWritable()) {
    605a:	bpl.w	617a <FatFile::write(void const*, unsigned int)+0x12e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    605e:	lsls	r2, r3, #28
    6060:	bmi.n	6078 <FatFile::write(void const*, unsigned int)+0x2c>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // Don't exceed max fileSize.
  if (nbyte > (0XFFFFFFFF - m_curPosition)) {
    6062:	ldr	r3, [r4, #20]
    6064:	mvns	r3, r3
    6066:	cmp	r5, r3
    6068:	bhi.w	617a <FatFile::write(void const*, unsigned int)+0x12e>
    606c:	mov	r7, r5
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    606e:	mov.w	sl, #0
    m_sector = 0XFFFFFFFF;
    6072:	mov.w	fp, #4294967295
    6076:	b.n	6106 <FatFile::write(void const*, unsigned int)+0xba>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    if (!seekSet(m_fileSize)) {
    6078:	ldr	r1, [r0, #28]
    607a:	bl	57ea <FatFile::seekSet(unsigned long)>
    607e:	cmp	r0, #0
    6080:	bne.n	6062 <FatFile::write(void const*, unsigned int)+0x16>
    6082:	b.n	617a <FatFile::write(void const*, unsigned int)+0x12e>
  if (nbyte > (0XFFFFFFFF - m_curPosition)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
    uint8_t sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
    6084:	ldr	r0, [r4, #8]
  }
  //----------------------------------------------------------------------------
  bool allocateCluster(uint32_t current, uint32_t* next);
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
    6086:	ldrb	r6, [r0, #5]
    uint16_t sectorOffset = m_curPosition & m_vol->sectorMask();
    if (sectorOfCluster == 0 && sectorOffset == 0) {
    6088:	ands.w	r6, r6, r2, lsr #9
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
    uint8_t sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
    uint16_t sectorOffset = m_curPosition & m_vol->sectorMask();
    608c:	ubfx	r8, r2, #0, #9
    if (sectorOfCluster == 0 && sectorOffset == 0) {
    6090:	beq.n	610e <FatFile::write(void const*, unsigned int)+0xc2>
          m_curCluster = m_firstCluster;
        }
      }
    }
    // sector for data write
    uint32_t sector = m_vol->clusterStartSector(m_curCluster)
    6092:	ldr.w	lr, [r4, #8]
                      + sectorOfCluster;
    6096:	ldr	r1, [r4, #16]
    6098:	ldrb.w	r3, [lr, #6]
    609c:	subs	r1, #2
    609e:	lsls	r1, r3
    60a0:	ldr.w	r3, [lr, #20]
    60a4:	add	r1, r3
    60a6:	add	r1, r6

    if (sectorOffset != 0 || nToWrite < m_vol->bytesPerSector()) {
    60a8:	cmp.w	r8, #0
    60ac:	bne.n	6140 <FatFile::write(void const*, unsigned int)+0xf4>
    60ae:	cmp.w	r7, #512	; 0x200
    60b2:	bcs.n	618e <FatFile::write(void const*, unsigned int)+0x142>
      // lesser of space and amount to write
      if (n > nToWrite) {
        n = nToWrite;
      }

      if (sectorOffset == 0 &&
    60b4:	ldr	r2, [r4, #20]
    60b6:	ldr	r3, [r4, #28]
    60b8:	cmp	r2, r3
    60ba:	bcs.n	6144 <FatFile::write(void const*, unsigned int)+0xf8>
         (m_curPosition >= m_fileSize || m_flags & FILE_FLAG_PREALLOCATE)) {
    60bc:	ldrb	r3, [r4, #2]
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
    60be:	tst.w	r3, #32
    60c2:	ite	eq
    60c4:	moveq	r2, #1
    60c6:	movne	r2, #5
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    60c8:	add.w	r0, lr, #40	; 0x28
    60cc:	bl	3072 <FsCache::get(unsigned long, unsigned char)>
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
      }
      pc = m_vol->cacheFetchData(sector, cacheOption);
      if (!pc) {
    60d0:	cmp	r0, #0
    60d2:	beq.n	617a <FatFile::write(void const*, unsigned int)+0x12e>
                      + sectorOfCluster;

    if (sectorOffset != 0 || nToWrite < m_vol->bytesPerSector()) {
      // partial sector - must use cache
      // max space in sector
      n = m_vol->bytesPerSector() - sectorOffset;
    60d4:	rsb	r6, r8, #512	; 0x200
    60d8:	cmp	r6, r7
    60da:	it	cs
    60dc:	movcs	r6, r7
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = pc->data + sectorOffset;
      memcpy(dst, src, n);
    60de:	add	r0, r8
    60e0:	mov	r2, r6
    60e2:	mov	r1, r9
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    60e4:	add	r8, r6
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = pc->data + sectorOffset;
      memcpy(dst, src, n);
    60e6:	bl	8720 <memcpy>
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    60ea:	cmp.w	r8, #512	; 0x200
    60ee:	bne.n	60fc <FatFile::write(void const*, unsigned int)+0xb0>
  }
  void cacheInvalidate() {
    m_cache.invalidate();
  }
  bool cacheSyncData() {
    return m_cache.sync();
    60f0:	ldr	r0, [r4, #8]
    60f2:	adds	r0, #40	; 0x28
    60f4:	bl	3026 <FsCache::sync()>
      uint32_t nSector = nToWrite >> m_vol->bytesPerSectorShift();
      if (nSector > maxSectors) {
        nSector = maxSectors;
      }
      n = nSector << m_vol->bytesPerSectorShift();
      if (!m_vol->cacheSafeWrite(sector, src, nSector)) {
    60f8:	cmp	r0, #0
    60fa:	beq.n	617a <FatFile::write(void const*, unsigned int)+0x12e>
      if (!m_vol->cacheSafeWrite(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    60fc:	ldr	r3, [r4, #20]
    60fe:	add	r3, r6
    6100:	str	r3, [r4, #20]
    src += n;
    6102:	add	r9, r6
    nToWrite -= n;
    6104:	subs	r7, r7, r6
    6106:	ldr	r2, [r4, #20]
  // Don't exceed max fileSize.
  if (nbyte > (0XFFFFFFFF - m_curPosition)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
    6108:	cmp	r7, #0
    610a:	bne.n	6084 <FatFile::write(void const*, unsigned int)+0x38>
    610c:	b.n	6148 <FatFile::write(void const*, unsigned int)+0xfc>
    uint8_t sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
    uint16_t sectorOffset = m_curPosition & m_vol->sectorMask();
    if (sectorOfCluster == 0 && sectorOffset == 0) {
    610e:	cmp.w	r8, #0
    6112:	bne.n	6092 <FatFile::write(void const*, unsigned int)+0x46>
      // start of new cluster
      if (m_curCluster != 0) {
    6114:	ldr	r1, [r4, #16]
    6116:	cbz	r1, 612a <FatFile::write(void const*, unsigned int)+0xde>
#if USE_FAT_FILE_FLAG_CONTIGUOUS
        int8_t fg;
        if (isContiguous() && m_fileSize > m_curPosition) {
    6118:	ldrb	r3, [r4, #2]
    611a:	lsls	r3, r3, #25
    611c:	bpl.n	6162 <FatFile::write(void const*, unsigned int)+0x116>
    611e:	ldr	r3, [r4, #28]
    6120:	cmp	r2, r3
    6122:	bcs.n	6162 <FatFile::write(void const*, unsigned int)+0x116>
          m_curCluster++;
    6124:	adds	r1, #1
    6126:	str	r1, [r4, #16]
    6128:	b.n	6092 <FatFile::write(void const*, unsigned int)+0x46>
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
      } else {
        if (m_firstCluster == 0) {
    612a:	ldr	r3, [r4, #32]
    612c:	cbnz	r3, 613c <FatFile::write(void const*, unsigned int)+0xf0>
          // allocate first cluster of file
          if (!addCluster()) {
    612e:	mov	r0, r4
    6130:	bl	54d2 <FatFile::addCluster()>
    6134:	cbz	r0, 617a <FatFile::write(void const*, unsigned int)+0x12e>
            DBG_FAIL_MACRO;
            goto fail;
          }
          m_firstCluster = m_curCluster;
    6136:	ldr	r3, [r4, #16]
    6138:	str	r3, [r4, #32]
    613a:	b.n	6092 <FatFile::write(void const*, unsigned int)+0x46>
        } else {
          m_curCluster = m_firstCluster;
    613c:	str	r3, [r4, #16]
    613e:	b.n	6092 <FatFile::write(void const*, unsigned int)+0x46>
         (m_curPosition >= m_fileSize || m_flags & FILE_FLAG_PREALLOCATE)) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
    6140:	movs	r2, #1
    6142:	b.n	60c8 <FatFile::write(void const*, unsigned int)+0x7c>
      }

      if (sectorOffset == 0 &&
         (m_curPosition >= m_fileSize || m_flags & FILE_FLAG_PREALLOCATE)) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
    6144:	movs	r2, #5
    6146:	b.n	60c8 <FatFile::write(void const*, unsigned int)+0x7c>
    }
    m_curPosition += n;
    src += n;
    nToWrite -= n;
  }
  if (m_curPosition > m_fileSize) {
    6148:	ldr	r3, [r4, #28]
    614a:	cmp	r2, r3
    614c:	bls.n	6152 <FatFile::write(void const*, unsigned int)+0x106>
    // update fileSize and insure sync will update dir entry
    m_fileSize = m_curPosition;
    614e:	str	r2, [r4, #28]
    6150:	b.n	6158 <FatFile::write(void const*, unsigned int)+0x10c>
    m_flags |= FILE_FLAG_DIR_DIRTY;
  } else if (FsDateTime::callback) {
    6152:	ldr	r3, [pc, #180]	; (6208 <FatFile::write(void const*, unsigned int)+0x1bc>)
    6154:	ldr	r3, [r3, #0]
    6156:	cbz	r3, 6188 <FatFile::write(void const*, unsigned int)+0x13c>
    // insure sync will update modified date and time
    m_flags |= FILE_FLAG_DIR_DIRTY;
    6158:	ldrb	r3, [r4, #2]
    615a:	orn	r3, r3, #127	; 0x7f
    615e:	strb	r3, [r4, #2]
    6160:	b.n	6188 <FatFile::write(void const*, unsigned int)+0x13c>
        int8_t fg;
        if (isContiguous() && m_fileSize > m_curPosition) {
          m_curCluster++;
          fg = 1;
        } else {
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    6162:	add.w	r2, r4, #16
    6166:	bl	6284 <FatPartition::fatGet(unsigned long, unsigned long*)>
          if (fg < 0) {
    616a:	cmp	r0, #0
    616c:	blt.n	617a <FatFile::write(void const*, unsigned int)+0x12e>
        if (fg < 0) {
          DBG_FAIL_MACRO;
          goto fail;
        }
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
        if (fg == 0) {
    616e:	bne.n	61f0 <FatFile::write(void const*, unsigned int)+0x1a4>
          // add cluster if at end of chain
          if (!addCluster()) {
    6170:	mov	r0, r4
    6172:	bl	54d2 <FatFile::addCluster()>
    6176:	cmp	r0, #0
    6178:	bne.n	61f0 <FatFile::write(void const*, unsigned int)+0x1a4>
  }
  return nbyte;

 fail:
  // return for write error
  m_error |= WRITE_ERROR;
    617a:	ldrb	r3, [r4, #1]
    617c:	orr.w	r3, r3, #1
    6180:	strb	r3, [r4, #1]
  return 0;
    6182:	movs	r0, #0
    6184:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    6188:	mov	r0, r5
    618a:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
#if USE_MULTI_SECTOR_IO
    } else if (nToWrite >= 2*m_vol->bytesPerSector()) {
    618e:	cmp.w	r7, #1024	; 0x400
    6192:	ldr.w	r2, [lr, #52]	; 0x34
    6196:	ldr.w	r0, [lr, #44]	; 0x2c
    619a:	bcc.n	61c6 <FatFile::write(void const*, unsigned int)+0x17a>
      // use multiple sector write command
      uint32_t maxSectors = m_vol->sectorsPerCluster() - sectorOfCluster;
    619c:	ldrb.w	r3, [lr, #4]
    61a0:	subs	r6, r3, r6
      uint32_t nSector = nToWrite >> m_vol->bytesPerSectorShift();
    61a2:	lsrs	r3, r7, #9
    61a4:	cmp	r3, r6
    61a6:	it	cs
    61a8:	movcs	r3, r6
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    61aa:	cmp	r2, r1
      if (nSector > maxSectors) {
        nSector = maxSectors;
      }
      n = nSector << m_vol->bytesPerSectorShift();
    61ac:	mov.w	r6, r3, lsl #9
    61b0:	bcc.n	61ba <FatFile::write(void const*, unsigned int)+0x16e>
    61b2:	add.w	ip, r3, r1
    61b6:	cmp	r2, ip
    61b8:	bcc.n	61e6 <FatFile::write(void const*, unsigned int)+0x19a>
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src, size_t count) {
     if (isCached(sector, count)) {
      invalidate();
    }
    return m_blockDev->writeSectors(sector, src, count);
    61ba:	ldr	r2, [r0, #0]
    61bc:	ldr.w	r8, [r2, #36]	; 0x24
    61c0:	mov	r2, r9
    61c2:	blx	r8
    61c4:	b.n	60f8 <FatFile::write(void const*, unsigned int)+0xac>
   * \param[in] sector Logical sector to be written.
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src) {
    if (isCached(sector)) {
    61c6:	cmp	r2, r1
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    61c8:	it	eq
    61ca:	strbeq.w	sl, [lr, #40]	; 0x28
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src) {
    if (isCached(sector)) {
      invalidate();
    }
    return m_blockDev->writeSector(sector, src);
    61ce:	ldr	r3, [r0, #0]
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    61d0:	it	eq
    61d2:	streq.w	fp, [lr, #52]	; 0x34
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src) {
    if (isCached(sector)) {
      invalidate();
    }
    return m_blockDev->writeSector(sector, src);
    61d6:	ldr	r3, [r3, #32]
    61d8:	mov	r2, r9
    61da:	blx	r3
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // use single sector write command
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeWrite(sector, src)) {
    61dc:	cmp	r0, #0
    61de:	beq.n	617a <FatFile::write(void const*, unsigned int)+0x12e>
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // use single sector write command
      n = m_vol->bytesPerSector();
    61e0:	mov.w	r6, #512	; 0x200
    61e4:	b.n	60fc <FatFile::write(void const*, unsigned int)+0xb0>
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    61e6:	strb.w	sl, [lr, #40]	; 0x28
    m_sector = 0XFFFFFFFF;
    61ea:	str.w	fp, [lr, #52]	; 0x34
    61ee:	b.n	61ba <FatFile::write(void const*, unsigned int)+0x16e>
          m_curCluster = m_firstCluster;
        }
      }
    }
    // sector for data write
    uint32_t sector = m_vol->clusterStartSector(m_curCluster)
    61f0:	ldr.w	lr, [r4, #8]
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
  }
  uint32_t clusterStartSector(uint32_t cluster) const {
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
    61f4:	ldr	r1, [r4, #16]
    61f6:	ldrb.w	r3, [lr, #6]
    61fa:	subs	r1, #2
    61fc:	lsls	r1, r3
    61fe:	ldr.w	r3, [lr, #20]
    6202:	add	r1, r3
    6204:	b.n	60ae <FatFile::write(void const*, unsigned int)+0x62>
    6206:	nop
    6208:	.word	0x1fff8418

0000620c <FatPartition::freeClusterCount_cb_fat16(unsigned long, unsigned char*, void*)>:

//------------------------------------------------------------------------------
void FatPartition::freeClusterCount_cb_fat16(uint32_t sector, uint8_t *buf, void *context) {
   struct FreeClusterCountStruct *state = (struct FreeClusterCountStruct *)context;
  uint16_t *p = (uint16_t *)buf;
  unsigned int n = state->clusters_to_do;
    620c:	ldr	r3, [r2, #0]
    620e:	cmp.w	r3, #256	; 0x100
  uint32_t clusters_to_do;
  uint32_t free_count;
};

//------------------------------------------------------------------------------
void FatPartition::freeClusterCount_cb_fat16(uint32_t sector, uint8_t *buf, void *context) {
    6212:	push	{r4, r5, lr}
    6214:	mov	r4, r3
    6216:	it	cs
    6218:	movcs.w	r4, #256	; 0x100
   struct FreeClusterCountStruct *state = (struct FreeClusterCountStruct *)context;
  uint16_t *p = (uint16_t *)buf;
  unsigned int n = state->clusters_to_do;
  if (n > 256) n = 256;
  uint16_t *e = p + n;
    621c:	add.w	r5, r1, r4, lsl #1
  while (p < e) {
    6220:	cmp	r1, r5
    6222:	bcs.n	6234 <FatPartition::freeClusterCount_cb_fat16(unsigned long, unsigned char*, void*)+0x28>
    if (*p++ == 0) state->free_count++;
    6224:	ldrh.w	r0, [r1], #2
    6228:	cmp	r0, #0
    622a:	bne.n	6220 <FatPartition::freeClusterCount_cb_fat16(unsigned long, unsigned char*, void*)+0x14>
    622c:	ldr	r0, [r2, #4]
    622e:	adds	r0, #1
    6230:	str	r0, [r2, #4]
    6232:	b.n	6220 <FatPartition::freeClusterCount_cb_fat16(unsigned long, unsigned char*, void*)+0x14>
  }
  state->clusters_to_do -= n;
    6234:	subs	r3, r3, r4
    6236:	str	r3, [r2, #0]
    6238:	pop	{r4, r5, pc}

0000623a <FatPartition::freeClusterCount_cb_fat32(unsigned long, unsigned char*, void*)>:

//------------------------------------------------------------------------------
void FatPartition::freeClusterCount_cb_fat32(uint32_t sector, uint8_t *buf, void *context) {
  struct FreeClusterCountStruct *state = (struct FreeClusterCountStruct *)context;
  uint32_t *p = (uint32_t *)buf;
  unsigned int n = state->clusters_to_do;
    623a:	ldr	r3, [r2, #0]
    623c:	cmp	r3, #128	; 0x80
  }
  state->clusters_to_do -= n;
}

//------------------------------------------------------------------------------
void FatPartition::freeClusterCount_cb_fat32(uint32_t sector, uint8_t *buf, void *context) {
    623e:	push	{r4, r5, lr}
    6240:	mov	r4, r3
    6242:	it	cs
    6244:	movcs	r4, #128	; 0x80
  struct FreeClusterCountStruct *state = (struct FreeClusterCountStruct *)context;
  uint32_t *p = (uint32_t *)buf;
  unsigned int n = state->clusters_to_do;
  if (n > 128) n = 128;
  uint32_t *e = p + n;
    6246:	add.w	r5, r1, r4, lsl #2
  while (p < e) {
    624a:	cmp	r1, r5
    624c:	bcs.n	625e <FatPartition::freeClusterCount_cb_fat32(unsigned long, unsigned char*, void*)+0x24>
    if (*p++ == 0) state->free_count++;
    624e:	ldr.w	r0, [r1], #4
    6252:	cmp	r0, #0
    6254:	bne.n	624a <FatPartition::freeClusterCount_cb_fat32(unsigned long, unsigned char*, void*)+0x10>
    6256:	ldr	r0, [r2, #4]
    6258:	adds	r0, #1
    625a:	str	r0, [r2, #4]
    625c:	b.n	624a <FatPartition::freeClusterCount_cb_fat32(unsigned long, unsigned char*, void*)+0x10>
  }
  state->clusters_to_do -= n;
    625e:	subs	r3, r3, r4
    6260:	str	r3, [r2, #0]
    6262:	pop	{r4, r5, pc}

00006264 <FsCache::clear()>:
      invalidate();
    }
    return m_blockDev->writeSectors(sector, src, count);
  }
  /** \return Clear the cache and returns a pointer to the cache. */
  uint8_t* clear() {
    6264:	push	{r4, lr}
    if (isDirty() && !sync()) {
    6266:	ldrb	r3, [r0, #0]
    6268:	lsls	r3, r3, #31
      invalidate();
    }
    return m_blockDev->writeSectors(sector, src, count);
  }
  /** \return Clear the cache and returns a pointer to the cache. */
  uint8_t* clear() {
    626a:	mov	r4, r0
    if (isDirty() && !sync()) {
    626c:	bpl.n	6274 <FsCache::clear()+0x10>
    626e:	bl	3026 <FsCache::sync()>
    6272:	cbz	r0, 6282 <FsCache::clear()+0x1e>
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    6274:	movs	r3, #0
    6276:	strb	r3, [r4, #0]
    m_sector = 0XFFFFFFFF;
    6278:	mov.w	r3, #4294967295
    627c:	str	r3, [r4, #12]
  uint8_t* clear() {
    if (isDirty() && !sync()) {
      return nullptr;
    }
    invalidate();
    return m_buffer;
    627e:	add.w	r0, r4, #16
  }
    6282:	pop	{r4, pc}

00006284 <FatPartition::fatGet(unsigned long, unsigned long*)>:
  uint32_t sector;
  uint32_t next;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    6284:	cmp	r1, #1
 fail:
  return false;
}
//------------------------------------------------------------------------------
// Fetch a FAT entry - return -1 error, 0 EOC, else 1.
int8_t FatPartition::fatGet(uint32_t cluster, uint32_t* value) {
    6286:	push	{r4, r5, r6, lr}
    6288:	mov	r5, r0
    628a:	mov	r4, r1
    628c:	mov	r6, r2
  uint32_t sector;
  uint32_t next;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    628e:	bhi.n	6296 <FatPartition::fatGet(unsigned long, unsigned long*)+0x12>
  }
  *value = next;
  return 1;

 fail:
  return -1;
    6290:	mov.w	r0, #4294967295
    6294:	pop	{r4, r5, r6, pc}
  uint32_t sector;
  uint32_t next;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    6296:	ldr	r3, [r0, #28]
    6298:	cmp	r1, r3
    629a:	bhi.n	6290 <FatPartition::fatGet(unsigned long, unsigned long*)+0xc>
    629c:	ldrb	r3, [r0, #7]
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (fatType() == 32) {
    629e:	cmp	r3, #32
    62a0:	bne.n	62c0 <FatPartition::fatGet(unsigned long, unsigned long*)+0x3c>
  FsCache m_cache;
#if USE_SEPARATE_FAT_CACHE
  FsCache m_fatCache;
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
    62a2:	ldr	r1, [r0, #24]
    62a4:	movs	r2, #2
    62a6:	add.w	r1, r1, r4, lsr #7
    62aa:	add.w	r0, r0, #568	; 0x238
    62ae:	bl	3072 <FsCache::get(unsigned long, unsigned char)>
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_READ);
    if (!pc) {
    62b2:	cmp	r0, #0
    62b4:	beq.n	6290 <FatPartition::fatGet(unsigned long, unsigned long*)+0xc>
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    62b6:	and.w	r4, r4, #127	; 0x7f
    62ba:	ldr.w	r3, [r0, r4, lsl #2]
    62be:	b.n	62e0 <FatPartition::fatGet(unsigned long, unsigned long*)+0x5c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    next = getLe32(reinterpret_cast<uint8_t*>
                  (&pc->fat32[cluster & (m_sectorMask >> 2)]));
  } else if (fatType() == 16) {
    62c0:	cmp	r3, #16
    62c2:	bne.n	6290 <FatPartition::fatGet(unsigned long, unsigned long*)+0xc>
    62c4:	ldr	r3, [r0, #24]
    62c6:	ubfx	r1, r1, #8, #8
    62ca:	movs	r2, #2
    62cc:	add	r1, r3
    62ce:	add.w	r0, r0, #568	; 0x238
    62d2:	bl	3072 <FsCache::get(unsigned long, unsigned char)>
    cluster &= 0XFFFF;
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 1) );
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_READ);
    if (!pc) {
    62d6:	cmp	r0, #0
    62d8:	beq.n	6290 <FatPartition::fatGet(unsigned long, unsigned long*)+0xc>
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    62da:	uxtb	r4, r4
      DBG_FAIL_MACRO;
      goto fail;
    }
    next = getLe16(reinterpret_cast<uint8_t*>
                  (&pc->fat16[cluster & (m_sectorMask >> 1)]));
    62dc:	ldrh.w	r3, [r0, r4, lsl #1]
    next = cluster & 1 ? tmp >> 4 : tmp & 0XFFF;
  } else {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isEOC(next)) {
    62e0:	ldr	r2, [r5, #28]
    62e2:	cmp	r3, r2
    return 0;
  }
  *value = next;
  return 1;
    62e4:	itte	ls
    62e6:	movls	r0, #1
    goto fail;
  }
  if (isEOC(next)) {
    return 0;
  }
  *value = next;
    62e8:	strls	r3, [r6, #0]
  } else {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isEOC(next)) {
    return 0;
    62ea:	movhi	r0, #0
  *value = next;
  return 1;

 fail:
  return -1;
}
    62ec:	pop	{r4, r5, r6, pc}

000062ee <FatPartition::fatPut(unsigned long, unsigned long)>:
bool FatPartition::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t sector;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    62ee:	cmp	r1, #1
 fail:
  return -1;
}
//------------------------------------------------------------------------------
// Store a FAT entry
bool FatPartition::fatPut(uint32_t cluster, uint32_t value) {
    62f0:	push	{r3, r4, r5, lr}
    62f2:	mov	r4, r1
    62f4:	mov	r5, r2
  uint32_t sector;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    62f6:	bhi.n	62fc <FatPartition::fatPut(unsigned long, unsigned long)+0xe>
    DBG_FAIL_MACRO;
    goto fail;
  }

 fail:
  return false;
    62f8:	movs	r0, #0
    62fa:	pop	{r3, r4, r5, pc}
bool FatPartition::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t sector;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    62fc:	ldr	r3, [r0, #28]
    62fe:	cmp	r1, r3
    6300:	bhi.n	62f8 <FatPartition::fatPut(unsigned long, unsigned long)+0xa>
    6302:	ldrb	r3, [r0, #7]
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (fatType() == 32) {
    6304:	cmp	r3, #32
    6306:	bne.n	6326 <FatPartition::fatPut(unsigned long, unsigned long)+0x38>
    6308:	ldr	r1, [r0, #24]
    630a:	movs	r2, #3
    630c:	add.w	r1, r1, r4, lsr #7
    6310:	add.w	r0, r0, #568	; 0x238
    6314:	bl	3072 <FsCache::get(unsigned long, unsigned char)>
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_WRITE);
    if (!pc) {
    6318:	cmp	r0, #0
    631a:	beq.n	62f8 <FatPartition::fatPut(unsigned long, unsigned long)+0xa>
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    631c:	and.w	r4, r4, #127	; 0x7f
    6320:	str.w	r5, [r0, r4, lsl #2]
    6324:	b.n	6346 <FatPartition::fatPut(unsigned long, unsigned long)+0x58>
    setLe32(reinterpret_cast<uint8_t*>
           (&pc->fat32[cluster & (m_sectorMask >> 2)]), value);
    return true;
  }

  if (fatType() == 16) {
    6326:	cmp	r3, #16
    6328:	bne.n	62f8 <FatPartition::fatPut(unsigned long, unsigned long)+0xa>
    632a:	ldr	r3, [r0, #24]
    632c:	ubfx	r1, r1, #8, #8
    6330:	movs	r2, #3
    6332:	add	r1, r3
    6334:	add.w	r0, r0, #568	; 0x238
    6338:	bl	3072 <FsCache::get(unsigned long, unsigned char)>
    cluster &= 0XFFFF;
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 1) );
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_WRITE);
    if (!pc) {
    633c:	cmp	r0, #0
    633e:	beq.n	62f8 <FatPartition::fatPut(unsigned long, unsigned long)+0xa>
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    6340:	uxtb	r4, r4
    6342:	strh.w	r5, [r0, r4, lsl #1]
      DBG_FAIL_MACRO;
      goto fail;
    }
    setLe16(reinterpret_cast<uint8_t*>
           (&pc->fat16[cluster & (m_sectorMask >> 1)]), value);
    return true;
    6346:	movs	r0, #1
    goto fail;
  }

 fail:
  return false;
}
    6348:	pop	{r3, r4, r5, pc}

0000634a <FatPartition::allocateCluster(unsigned long, unsigned long*)>:
#include "../common/FsStructs.h"
#include "../common/FsGetPartitionInfo.h"
#include "FatPartition.h"

//------------------------------------------------------------------------------
bool FatPartition::allocateCluster(uint32_t current, uint32_t* next) {
    634a:	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  uint32_t find;
  bool setStart;
  if (m_allocSearchStart < current) {
    634e:	ldr	r4, [r0, #12]
    6350:	cmp	r4, r1
#include "../common/FsStructs.h"
#include "../common/FsGetPartitionInfo.h"
#include "FatPartition.h"

//------------------------------------------------------------------------------
bool FatPartition::allocateCluster(uint32_t current, uint32_t* next) {
    6352:	mov	r5, r0
    6354:	mov	r6, r1
    6356:	mov	r8, r2
  uint32_t find;
  bool setStart;
  if (m_allocSearchStart < current) {
    6358:	bcs.n	636a <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x20>
    635a:	mov	r4, r1
    // Try to keep file contiguous. Start just after current cluster.
    find = current;
    setStart = false;
    635c:	movs	r7, #0
    find = m_allocSearchStart;
    setStart = true;
  }
  while (1) {
    find++;
    if (find > m_lastCluster) {
    635e:	ldr	r3, [r5, #28]
  } else {
    find = m_allocSearchStart;
    setStart = true;
  }
  while (1) {
    find++;
    6360:	adds	r4, #1
    if (find > m_lastCluster) {
    6362:	cmp	r4, r3
    6364:	bls.n	636e <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x24>
      if (setStart) {
    6366:	cbnz	r7, 639c <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x52>
        // Can't find space, checked all clusters.
        DBG_FAIL_MACRO;
        goto fail;
      }
      find = m_allocSearchStart;
    6368:	ldr	r4, [r5, #12]
      setStart = true;
    636a:	movs	r7, #1
    636c:	b.n	635e <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x14>
      continue;
    }
    if (find == current) {
    636e:	cmp	r6, r4
    6370:	beq.n	639c <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x52>
      // Can't find space, already searched clusters after current.
      DBG_FAIL_MACRO;
      goto fail;
    }
    uint32_t f;
    int8_t fg = fatGet(find, &f);
    6372:	add	r2, sp, #4
    6374:	mov	r1, r4
    6376:	mov	r0, r5
    6378:	bl	6284 <FatPartition::fatGet(unsigned long, unsigned long*)>
    if (fg < 0) {
    637c:	cmp	r0, #0
    637e:	blt.n	639c <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x52>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (fg && f == 0) {
    6380:	beq.n	635e <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x14>
    6382:	ldr	r3, [sp, #4]
    6384:	cmp	r3, #0
    6386:	bne.n	635e <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x14>
      break;
    }
  }
  if (setStart) {
    6388:	cbz	r7, 638c <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x42>
    m_allocSearchStart = find;
    638a:	str	r4, [r5, #12]
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
  }
  int8_t fatGet(uint32_t cluster, uint32_t* value);
  bool fatPut(uint32_t cluster, uint32_t value);
  bool fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
    638c:	mvn.w	r2, #4026531840	; 0xf0000000
    6390:	mov	r1, r4
    6392:	mov	r0, r5
    6394:	bl	62ee <FatPartition::fatPut(unsigned long, unsigned long)>
  }
  // Mark end of chain.
  if (!fatPutEOC(find)) {
    6398:	mov	r7, r0
    639a:	cbnz	r0, 63a0 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x56>
  updateFreeClusterCount(-1);
  *next = find;
  return true;

 fail:
  return false;
    639c:	movs	r7, #0
    639e:	b.n	63c2 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x78>
  // Mark end of chain.
  if (!fatPutEOC(find)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (current) {
    63a0:	cbnz	r6, 63ae <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x64>
  int32_t  m_freeClusterCount;     // Count of free clusters in volume.
  void setFreeClusterCount(int32_t value) {
    m_freeClusterCount = value;
  }
  void updateFreeClusterCount(int32_t change) {
    if (m_freeClusterCount >= 0) {
    63a2:	ldr	r3, [r5, #36]	; 0x24
    63a4:	cmp	r3, #0
    63a6:	blt.n	63be <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x74>
      m_freeClusterCount += change;
    63a8:	subs	r3, #1
    63aa:	str	r3, [r5, #36]	; 0x24
    63ac:	b.n	63be <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x74>
    // Link clusters.
    if (!fatPut(current, find)) {
    63ae:	mov	r2, r4
    63b0:	mov	r1, r6
    63b2:	mov	r0, r5
    63b4:	bl	62ee <FatPartition::fatPut(unsigned long, unsigned long)>
    63b8:	cmp	r0, #0
    63ba:	bne.n	63a2 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x58>
    63bc:	b.n	639c <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x52>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  updateFreeClusterCount(-1);
  *next = find;
    63be:	str.w	r4, [r8]
  return true;

 fail:
  return false;
}
    63c2:	mov	r0, r7
    63c4:	add	sp, #8
    63c6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000063ca <FatPartition::freeChain(unsigned long)>:
 fail:
  return false;
}
//------------------------------------------------------------------------------
// free a cluster chain
bool FatPartition::freeChain(uint32_t cluster) {
    63ca:	push	{r0, r1, r4, r5, r6, lr}
    63cc:	mov	r5, r0
    63ce:	mov	r4, r1
  uint32_t next;
  int8_t fg;
  do {
    fg = fatGet(cluster, &next);
    63d0:	add	r2, sp, #4
    63d2:	mov	r1, r4
    63d4:	mov	r0, r5
    63d6:	bl	6284 <FatPartition::fatGet(unsigned long, unsigned long*)>
    if (fg < 0) {
    63da:	subs	r6, r0, #0
    63dc:	bge.n	63e2 <FatPartition::freeChain(unsigned long)+0x18>
  } while (fg);

  return true;

 fail:
  return false;
    63de:	movs	r0, #0
    63e0:	b.n	640c <FatPartition::freeChain(unsigned long)+0x42>
    if (fg < 0) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    // free cluster
    if (!fatPut(cluster, 0)) {
    63e2:	movs	r2, #0
    63e4:	mov	r1, r4
    63e6:	mov	r0, r5
    63e8:	bl	62ee <FatPartition::fatPut(unsigned long, unsigned long)>
    63ec:	cmp	r0, #0
    63ee:	beq.n	63de <FatPartition::freeChain(unsigned long)+0x14>
  int32_t  m_freeClusterCount;     // Count of free clusters in volume.
  void setFreeClusterCount(int32_t value) {
    m_freeClusterCount = value;
  }
  void updateFreeClusterCount(int32_t change) {
    if (m_freeClusterCount >= 0) {
    63f0:	ldr	r3, [r5, #36]	; 0x24
    63f2:	cmp	r3, #0
      m_freeClusterCount += change;
    63f4:	itt	ge
    63f6:	addge	r3, #1
    63f8:	strge	r3, [r5, #36]	; 0x24
      DBG_FAIL_MACRO;
      goto fail;
    }
    // Add one to count of free clusters.
    updateFreeClusterCount(1);
    if (cluster < m_allocSearchStart) {
    63fa:	ldr	r3, [r5, #12]
    63fc:	cmp	r4, r3
      m_allocSearchStart = cluster - 1;
    63fe:	itt	cc
    6400:	addcc.w	r4, r4, #4294967295
    6404:	strcc	r4, [r5, #12]
    }
    cluster = next;
    6406:	ldr	r4, [sp, #4]
//------------------------------------------------------------------------------
// free a cluster chain
bool FatPartition::freeChain(uint32_t cluster) {
  uint32_t next;
  int8_t fg;
  do {
    6408:	cmp	r6, #0
    640a:	bne.n	63d0 <FatPartition::freeChain(unsigned long)+0x6>

  return true;

 fail:
  return false;
}
    640c:	add	sp, #8
    640e:	pop	{r4, r5, r6, pc}

00006410 <FatPartition::freeClusterCount()>:
  }
  state->clusters_to_do -= n;
}

//------------------------------------------------------------------------------
int32_t FatPartition::freeClusterCount() {
    6410:	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    6412:	mov	r4, r0
#if MAINTAIN_FREE_CLUSTER_COUNT
  if (m_freeClusterCount >= 0) {
    6414:	ldr	r0, [r0, #36]	; 0x24
    6416:	cmp	r0, #0
    6418:	bge.n	645e <FatPartition::freeClusterCount()+0x4e>
    return free;
  }

  struct FreeClusterCountStruct state;

  state.free_count = 0;
    641a:	movs	r3, #0
    641c:	str	r3, [sp, #12]
  state.clusters_to_do = m_lastCluster + 1;
    641e:	ldr	r3, [r4, #28]
  uint32_t num_sectors;

  //num_sectors = SD.sdfs.m_fVol->sectorsPerFat(); // edit FsVolume.h for public
  //Serial.printf("  num_sectors = %u\n", num_sectors);

  num_sectors = m_sectorsPerFat;
    6420:	ldr	r5, [r4, #16]
  }

  struct FreeClusterCountStruct state;

  state.free_count = 0;
  state.clusters_to_do = m_lastCluster + 1;
    6422:	adds	r3, #1
  //Serial.printf("  num_sectors = %u\n", num_sectors);

  num_sectors = m_sectorsPerFat;
  //Serial.printf("  num_sectors = %u\n", num_sectors);
#if USE_SEPARATE_FAT_CACHE
  uint8_t *buf = m_fatCache.clear();  // will clear out anything and return buffer 
    6424:	add.w	r0, r4, #568	; 0x238
  }

  struct FreeClusterCountStruct state;

  state.free_count = 0;
  state.clusters_to_do = m_lastCluster + 1;
    6428:	str	r3, [sp, #8]
  //Serial.printf("  num_sectors = %u\n", num_sectors);

  num_sectors = m_sectorsPerFat;
  //Serial.printf("  num_sectors = %u\n", num_sectors);
#if USE_SEPARATE_FAT_CACHE
  uint8_t *buf = m_fatCache.clear();  // will clear out anything and return buffer 
    642a:	bl	6264 <FsCache::clear()>
#else  
  uint8_t *buf = m_cache.clear();  // will clear out anything and return buffer 
#endif  // USE_SEPARATE_FAT_CACHE
  if (buf == nullptr) return -1;
    642e:	mov	r2, r0
    6430:	cbnz	r0, 6438 <FatPartition::freeClusterCount()+0x28>
    6432:	mov.w	r0, #4294967295
    6436:	b.n	645e <FatPartition::freeClusterCount()+0x4e>
  if (fatType() == FAT_TYPE_FAT32) {
    6438:	ldrb	r3, [r4, #7]
    643a:	ldr	r0, [r4, #0]
    643c:	cmp	r3, #32
    643e:	add	r3, sp, #8
    if (!m_blockDev->readSectorsCallback(m_fatStartSector, buf, num_sectors, freeClusterCount_cb_fat32, &state)) return -1;
    6440:	ldr	r1, [r0, #0]
    6442:	str	r3, [sp, #4]
  uint8_t *buf = m_fatCache.clear();  // will clear out anything and return buffer 
#else  
  uint8_t *buf = m_cache.clear();  // will clear out anything and return buffer 
#endif  // USE_SEPARATE_FAT_CACHE
  if (buf == nullptr) return -1;
  if (fatType() == FAT_TYPE_FAT32) {
    6444:	bne.n	644a <FatPartition::freeClusterCount()+0x3a>
    if (!m_blockDev->readSectorsCallback(m_fatStartSector, buf, num_sectors, freeClusterCount_cb_fat32, &state)) return -1;
    6446:	ldr	r3, [pc, #28]	; (6464 <FatPartition::freeClusterCount()+0x54>)
    6448:	b.n	644c <FatPartition::freeClusterCount()+0x3c>
  } else {
    if (!m_blockDev->readSectorsCallback(m_fatStartSector, buf, num_sectors, freeClusterCount_cb_fat16, &state)) return -1;
    644a:	ldr	r3, [pc, #28]	; (6468 <FatPartition::freeClusterCount()+0x58>)
    644c:	str	r3, [sp, #0]
    644e:	ldr	r6, [r1, #20]
    6450:	ldr	r1, [r4, #24]
    6452:	mov	r3, r5
    6454:	blx	r6
    6456:	cmp	r0, #0
    6458:	beq.n	6432 <FatPartition::freeClusterCount()+0x22>
  }

  setFreeClusterCount(state.free_count);
    645a:	ldr	r0, [sp, #12]
    return m_blockDev->writeSector(sector, src);
  }
#if MAINTAIN_FREE_CLUSTER_COUNT
  int32_t  m_freeClusterCount;     // Count of free clusters in volume.
  void setFreeClusterCount(int32_t value) {
    m_freeClusterCount = value;
    645c:	str	r0, [r4, #36]	; 0x24
  return state.free_count;
}
    645e:	add	sp, #16
    6460:	pop	{r4, r5, r6, pc}
    6462:	nop
    6464:	.word	0x0000623b
    6468:	.word	0x0000620d

0000646c <FatPartition::init(BlockDeviceInterface*, unsigned char)>:


//------------------------------------------------------------------------------
bool FatPartition::init(BlockDevice* dev, uint8_t part) {
    646c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    6470:	mov	r4, r0
  MbrSector_t* mbr;
  MbrPart_t* mp;
  #endif

  uint8_t tmp;
  m_fatType = 0;
    6472:	movs	r7, #0
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    6474:	mov.w	r3, #4294967295
  m_allocSearchStart = 1;
    6478:	movs	r6, #1
  }
  /** Clear the cache and returns a pointer to the cache.  Not for normal apps.
   * \return A pointer to the cache buffer or zero if an error occurs.
   */
  uint8_t* cacheClear() {
    return m_cache.clear();
    647a:	add.w	r8, r0, #40	; 0x28
bool FatPartition::init(BlockDevice* dev, uint8_t part) {
//  Serial.printf(" FatPartition::init(%x %u)\n", (uint32_t)dev, part);
  uint32_t clusterCount;
  uint32_t totalSectors;
  uint32_t volumeStartSector = 0;
  m_blockDev = dev;
    647e:	str	r1, [r4, #0]
  return state.free_count;
}


//------------------------------------------------------------------------------
bool FatPartition::init(BlockDevice* dev, uint8_t part) {
    6480:	sub	sp, #28
  MbrSector_t* mbr;
  MbrPart_t* mp;
  #endif

  uint8_t tmp;
  m_fatType = 0;
    6482:	strb	r7, [r0, #7]
  m_allocSearchStart = 1;
    6484:	str	r6, [r0, #12]
  }
  /** Initialize the cache.
   * \param[in] blockDev Block device for this cache.
   */
  void init(BlockDevice* blockDev) {
    m_blockDev = blockDev;
    6486:	str	r1, [r4, #44]	; 0x2c
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    6488:	str	r3, [r0, #52]	; 0x34
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    648a:	strb.w	r7, [r0, #40]	; 0x28
  }
  /** Initialize the cache.
   * \param[in] blockDev Block device for this cache.
   */
  void init(BlockDevice* blockDev) {
    m_blockDev = blockDev;
    648e:	str.w	r1, [r4, #572]	; 0x23c
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    6492:	str.w	r3, [r0, #580]	; 0x244
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    6496:	strb.w	r7, [r0, #568]	; 0x238
    649a:	mov	r0, r8
  return state.free_count;
}


//------------------------------------------------------------------------------
bool FatPartition::init(BlockDevice* dev, uint8_t part) {
    649c:	mov	r5, r1
    649e:	mov	r9, r2
    64a0:	bl	6264 <FsCache::clear()>
#if USE_SEPARATE_FAT_CACHE
  m_fatCache.init(dev);
#endif  // USE_SEPARATE_FAT_CACHE

  #if SUPPORT_GPT_AND_EXTENDED_PATITIONS 
  FsGetPartitionInfo::voltype_t vt = FsGetPartitionInfo::getPartitionInfo(m_blockDev, part, cacheClear(), &firstLBA);
    64a4:	str	r7, [sp, #8]
    64a6:	mov	r2, r0
    64a8:	str	r7, [sp, #4]
    64aa:	str	r7, [sp, #0]
    64ac:	add	r3, sp, #20
    64ae:	mov	r1, r9
    64b0:	mov	r0, r5
    64b2:	bl	2de8 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)>
  if ((vt == FsGetPartitionInfo::INVALID_VOL) || (vt == FsGetPartitionInfo::OTHER_VOL)) {
    64b6:	tst.w	r0, #251	; 0xfb
    64ba:	beq.n	6540 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd4>
    DBG_FAIL_MACRO;
    goto fail;    
  }
  volumeStartSector = firstLBA;
    64bc:	ldr	r5, [sp, #20]
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    64be:	mov	r2, r7
    64c0:	mov	r1, r5
    64c2:	mov	r0, r8
    64c4:	bl	3072 <FsCache::get(unsigned long, unsigned char)>
  #endif

  pbs = reinterpret_cast<pbs_t*>
        (cacheFetchData(volumeStartSector, FsCache::CACHE_FOR_READ));
  bpb = reinterpret_cast<BpbFat32_t*>(pbs->bpb);
  if (!pbs || bpb->fatCount != 2 || getLe16(bpb->bytesPerSector) != 512) {
    64c8:	cmp	r0, #0
    64ca:	beq.n	6540 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd4>
    64cc:	ldrb	r3, [r0, #16]
    64ce:	cmp	r3, #2
    64d0:	bne.n	6540 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd4>
    64d2:	ldrh.w	r3, [r0, #11]
    64d6:	cmp.w	r3, #512	; 0x200
    64da:	bne.n	6540 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd4>
    64dc:	b.n	6544 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd8>
  m_sectorsPerCluster = bpb->sectorsPerCluster;
  m_clusterSectorMask = m_sectorsPerCluster - 1;
  // determine shift that is same as multiply by m_sectorsPerCluster
  m_sectorsPerClusterShift = 0;
  for (tmp = 1; m_sectorsPerCluster != tmp; tmp <<= 1) {
    if (tmp == 0) {
    64de:	subs	r2, #1
    64e0:	beq.n	6540 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd4>
      DBG_FAIL_MACRO;
      goto fail;
    }
    m_sectorsPerClusterShift++;
    64e2:	ldrb	r6, [r4, #6]
  }
  m_sectorsPerCluster = bpb->sectorsPerCluster;
  m_clusterSectorMask = m_sectorsPerCluster - 1;
  // determine shift that is same as multiply by m_sectorsPerCluster
  m_sectorsPerClusterShift = 0;
  for (tmp = 1; m_sectorsPerCluster != tmp; tmp <<= 1) {
    64e4:	lsls	r3, r3, #1
    if (tmp == 0) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    m_sectorsPerClusterShift++;
    64e6:	adds	r6, #1
    64e8:	strb	r6, [r4, #6]
  }
  m_sectorsPerCluster = bpb->sectorsPerCluster;
  m_clusterSectorMask = m_sectorsPerCluster - 1;
  // determine shift that is same as multiply by m_sectorsPerCluster
  m_sectorsPerClusterShift = 0;
  for (tmp = 1; m_sectorsPerCluster != tmp; tmp <<= 1) {
    64ea:	uxtb	r3, r3
    64ec:	cmp	r3, r1
    64ee:	bne.n	64de <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x72>
      DBG_FAIL_MACRO;
      goto fail;
    }
    m_sectorsPerClusterShift++;
  }
  m_sectorsPerFat = getLe16(bpb->sectorsPerFat16);
    64f0:	ldrh	r3, [r0, #22]
    64f2:	str	r3, [r4, #16]
  if (m_sectorsPerFat == 0) {
    64f4:	cbnz	r3, 64fa <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x8e>
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    64f6:	ldr	r3, [r0, #36]	; 0x24
    m_sectorsPerFat = getLe32(bpb->sectorsPerFat32);
    64f8:	str	r3, [r4, #16]
  }
  m_fatStartSector = volumeStartSector + getLe16(bpb->reservedSectorCount);
    64fa:	ldrh	r1, [r0, #14]
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    64fc:	ldrh.w	r2, [r0, #17]

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
    6500:	ldr	r6, [r4, #16]
    m_sectorsPerFat = getLe32(bpb->sectorsPerFat32);
  }
  m_fatStartSector = volumeStartSector + getLe16(bpb->reservedSectorCount);

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);
    6502:	strh	r2, [r4, #8]
  }
  m_sectorsPerFat = getLe16(bpb->sectorsPerFat16);
  if (m_sectorsPerFat == 0) {
    m_sectorsPerFat = getLe32(bpb->sectorsPerFat32);
  }
  m_fatStartSector = volumeStartSector + getLe16(bpb->reservedSectorCount);
    6504:	add	r1, r5

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
    6506:	add.w	r3, r1, r6, lsl #1
  }
  m_sectorsPerFat = getLe16(bpb->sectorsPerFat16);
  if (m_sectorsPerFat == 0) {
    m_sectorsPerFat = getLe32(bpb->sectorsPerFat32);
  }
  m_fatStartSector = volumeStartSector + getLe16(bpb->reservedSectorCount);
    650a:	str	r1, [r4, #24]
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
  // data start for FAT16 and FAT32
  m_dataStartSector = m_rootDirStart +
    650c:	lsls	r1, r2, #5
    650e:	addw	r1, r1, #511	; 0x1ff
    6512:	add.w	r1, r3, r1, asr #9

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
    6516:	str	r3, [r4, #32]
  // data start for FAT16 and FAT32
  m_dataStartSector = m_rootDirStart +
    ((32 * m_rootDirEntryCount + m_bytesPerSector - 1)/m_bytesPerSector);

  // total sectors for FAT16 or FAT32
  totalSectors = getLe16(bpb->totalSectors16);
    6518:	ldrh.w	r3, [r0, #19]

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
  // data start for FAT16 and FAT32
  m_dataStartSector = m_rootDirStart +
    ((32 * m_rootDirEntryCount + m_bytesPerSector - 1)/m_bytesPerSector);
    651c:	str	r1, [r4, #20]

  // total sectors for FAT16 or FAT32
  totalSectors = getLe16(bpb->totalSectors16);
  if (totalSectors == 0) {
    651e:	cbnz	r3, 6522 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xb6>
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    6520:	ldr	r3, [r0, #32]
    totalSectors = getLe32(bpb->totalSectors32);
  }
  // total data sectors
  clusterCount = totalSectors - (m_dataStartSector - volumeStartSector);
    6522:	subs	r1, r5, r1
    6524:	add	r1, r3

  // divide by cluster size to get cluster count
  clusterCount >>= m_sectorsPerClusterShift;
    6526:	ldrb	r3, [r4, #6]
    6528:	lsrs	r1, r3
  m_lastCluster = clusterCount + 1;
    652a:	adds	r3, r1, #1
    652c:	str	r3, [r4, #28]
    return m_blockDev->writeSector(sector, src);
  }
#if MAINTAIN_FREE_CLUSTER_COUNT
  int32_t  m_freeClusterCount;     // Count of free clusters in volume.
  void setFreeClusterCount(int32_t value) {
    m_freeClusterCount = value;
    652e:	mov.w	r3, #4294967295
    6532:	str	r3, [r4, #36]	; 0x24

  // Indicate unknown number of free clusters.
  setFreeClusterCount(-1);
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    6534:	movw	r3, #4084	; 0xff4
    6538:	cmp	r1, r3
    653a:	bhi.n	6554 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xe8>
    m_fatType = 12;
    653c:	movs	r3, #12
    653e:	strb	r3, [r4, #7]
  m_fatCache.setMirrorOffset(m_sectorsPerFat);
#endif  // USE_SEPARATE_FAT_CACHE
  return true;

 fail:
  return false;
    6540:	movs	r0, #0
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    m_fatType = 12;
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
      goto fail;
    6542:	b.n	656e <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x102>
  bpb = reinterpret_cast<BpbFat32_t*>(pbs->bpb);
  if (!pbs || bpb->fatCount != 2 || getLe16(bpb->bytesPerSector) != 512) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_sectorsPerCluster = bpb->sectorsPerCluster;
    6544:	ldrb	r1, [r0, #13]
    6546:	strb	r1, [r4, #4]
  m_clusterSectorMask = m_sectorsPerCluster - 1;
    6548:	subs	r3, r1, #1
    654a:	strb	r3, [r4, #5]
  // determine shift that is same as multiply by m_sectorsPerCluster
  m_sectorsPerClusterShift = 0;
    654c:	strb	r7, [r4, #6]
    654e:	movs	r2, #9
  for (tmp = 1; m_sectorsPerCluster != tmp; tmp <<= 1) {
    6550:	mov	r3, r6
    6552:	b.n	64ec <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x80>
    m_fatType = 12;
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if (clusterCount < 65525) {
    6554:	movw	r3, #65524	; 0xfff4
    6558:	cmp	r1, r3
    655a:	ittet	hi
    655c:	ldrhi	r3, [r0, #44]	; 0x2c
    m_fatType = 16;
  } else {
    m_rootDirStart = getLe32(bpb->fat32RootCluster);
    655e:	strhi	r3, [r4, #32]
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if (clusterCount < 65525) {
    m_fatType = 16;
    6560:	movls	r3, #16
  } else {
    m_rootDirStart = getLe32(bpb->fat32RootCluster);
    m_fatType = 32;
    6562:	movhi	r3, #32
    6564:	strb	r3, [r4, #7]
  }
  /** Set the offset to the second FAT for mirroring.
   * \param[in] offset Sector offset to second FAT.
   */
  void setMirrorOffset(uint32_t offset) {
    m_mirrorOffset = offset;
    6566:	str	r6, [r4, #48]	; 0x30
    6568:	str.w	r6, [r4, #576]	; 0x240
  }
  m_cache.setMirrorOffset(m_sectorsPerFat);
#if USE_SEPARATE_FAT_CACHE
  m_fatCache.setMirrorOffset(m_sectorsPerFat);
#endif  // USE_SEPARATE_FAT_CACHE
  return true;
    656c:	movs	r0, #1

 fail:
  return false;
}
    656e:	add	sp, #28
    6570:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

00006574 <FatVolume::chdir(char const*)>:
#define DBG_FILE "FatVolume.cpp"
#include "../common/DebugMacros.h"
#include "FatVolume.h"
FatVolume* FatVolume::m_cwv = nullptr;
//------------------------------------------------------------------------------
bool FatVolume::chdir(const char *path) {
    6574:	push	{r4, r5, r6, lr}
#endif  // ENABLE_ARDUINO_STRING

 private:
  friend FatFile;
  static FatVolume* cwv() {return m_cwv;}
  FatFile* vwd() {return &m_vwd;}
    6576:	add.w	r4, r0, #1096	; 0x448
    657a:	sub	sp, #40	; 0x28
    657c:	movs	r3, #0
  FatFile dir;
  if (!dir.open(vwd(), path, O_RDONLY)) {
    657e:	mov	r2, r1
    6580:	add	r0, sp, #4
    6582:	mov	r1, r4
    6584:	strb.w	r3, [sp, #4]
    6588:	strb.w	r3, [sp, #5]
    658c:	strb.w	r3, [sp, #6]
    6590:	bl	5ad0 <FatFile::open(FatFile*, char const*, int)>
    6594:	mov	r6, r0
    6596:	cbz	r0, 65b4 <FatVolume::chdir(char const*)+0x40>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!dir.isDir()) {
    6598:	ldrb.w	r3, [sp, #4]
    659c:	ands.w	r3, r3, #112	; 0x70
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_vwd = dir;
    65a0:	itttt	ne
    65a2:	addne	r5, sp, #4
    65a4:	ldmiane	r5!, {r0, r1, r2, r3}
    65a6:	stmiane	r4!, {r0, r1, r2, r3}
    65a8:	ldmiane	r5!, {r0, r1, r2, r3}
    65aa:	ittte	ne
    65ac:	stmiane	r4!, {r0, r1, r2, r3}
    65ae:	ldrne	r3, [r5, #0]
    65b0:	strne	r3, [r4, #0]
  return true;

 fail:
  return false;
    65b2:	moveq	r6, r3
}
    65b4:	mov	r0, r6
    65b6:	add	sp, #40	; 0x28
    65b8:	pop	{r4, r5, r6, pc}

000065ba <FatFile::lfnChecksum(unsigned char*) [clone .isra.14]>:
  }
  DirFat_t* cacheDirEntry(uint8_t action);
  bool cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  bool createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  uint16_t getLfnChar(DirLfn_t* ldir, uint8_t i);
  uint8_t lfnChecksum(uint8_t* name) {
    65ba:	subs	r1, r0, #1
    65bc:	add.w	r2, r0, #10
    uint8_t sum = 0;
    65c0:	movs	r0, #0
    65c2:	lsls	r3, r0, #7
    65c4:	orr.w	r0, r3, r0, lsr #1
    for (uint8_t i = 0; i < 11; i++) {
        sum = (((sum & 1) << 7) | (sum >> 1)) + name[i];
    65c8:	ldrb.w	r3, [r1, #1]!
    65cc:	uxtab	r0, r3, r0
  bool cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  bool createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  uint16_t getLfnChar(DirLfn_t* ldir, uint8_t i);
  uint8_t lfnChecksum(uint8_t* name) {
    uint8_t sum = 0;
    for (uint8_t i = 0; i < 11; i++) {
    65d0:	cmp	r1, r2
        sum = (((sum & 1) << 7) | (sum >> 1)) + name[i];
    65d2:	uxtb	r0, r0
  bool cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  bool createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  uint16_t getLfnChar(DirLfn_t* ldir, uint8_t i);
  uint8_t lfnChecksum(uint8_t* name) {
    uint8_t sum = 0;
    for (uint8_t i = 0; i < 11; i++) {
    65d4:	bne.n	65c2 <FatFile::lfnChecksum(unsigned char*) [clone .isra.14]+0x8>
        sum = (((sum & 1) << 7) | (sum >> 1)) + name[i];
    }
    return sum;
  }
    65d6:	bx	lr

000065d8 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)>:
    hash = ((hash << 5) + hash) ^ (*bgn++);
  }
  return hash;
}
//==============================================================================
bool FatFile::cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
    65d8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  FatFile dir = *this;
    65dc:	mov	r5, r0
    hash = ((hash << 5) + hash) ^ (*bgn++);
  }
  return hash;
}
//==============================================================================
bool FatFile::cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
    65de:	mov	r6, r2
    65e0:	mov	r7, r0
    65e2:	mov	r8, r1
    65e4:	mov	r9, r3
  FatFile dir = *this;
    65e6:	ldmia	r5!, {r0, r1, r2, r3}
    hash = ((hash << 5) + hash) ^ (*bgn++);
  }
  return hash;
}
//==============================================================================
bool FatFile::cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
    65e8:	sub	sp, #52	; 0x34
  FatFile dir = *this;
    65ea:	add	r4, sp, #12
    65ec:	stmia	r4!, {r0, r1, r2, r3}
    65ee:	ldmia	r5!, {r0, r1, r2, r3}
    65f0:	stmia	r4!, {r0, r1, r2, r3}
    65f2:	ldr	r3, [r5, #0]
    65f4:	str	r3, [r4, #0]
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
  }
  void reset() {
    next = begin;
    65f6:	ldr	r3, [r6, #0]
    65f8:	str	r3, [r6, #4]
    ls = 0;
    65fa:	movs	r3, #0
    65fc:	strh	r3, [r6, #12]
  DirLfn_t* ldir;
  fname->reset();
  for (uint8_t order = 1; order <= lfnOrd; order++) {
    65fe:	movs	r5, #1
    6600:	cmp	r5, r9
    6602:	bhi.n	663e <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x66>
    ldir = reinterpret_cast<DirLfn_t*>(dir.cacheDir(index - order));
    6604:	rsb	r1, r5, r8
    6608:	uxth	r1, r1
    660a:	add	r0, sp, #12
    660c:	bl	52ec <FatFile::cacheDir(unsigned short)>
    if (!ldir) {
    6610:	mov	fp, r0
    6612:	cbnz	r0, 6618 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x40>
    }
  }
  return true;

 fail:
  return false;
    6614:	movs	r0, #0
    6616:	b.n	666e <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x96>
    6618:	mov.w	sl, #0
    }
    // These should be checked in caller.
    DBG_HALT_IF(ldir->attributes != FAT_ATTRIB_LONG_NAME);
    DBG_HALT_IF(order != (ldir->order & 0X1F));
    for (uint8_t i = 0; i < 13; i++) {
      uint16_t u = getLfnChar(ldir, i);
    661c:	uxtb.w	r2, sl
    6620:	mov	r1, fp
    6622:	mov	r0, r7
    6624:	bl	5306 <FatFile::getLfnChar(DirLfn_t*, unsigned char)>
  /** \return next UTF-16 unit of LFN. */
  uint16_t get16() {return atEnd() ? 0 : *next++;}
#else  // !USE_UTF8_LONG_NAMES
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
    6628:	ldrh	r3, [r6, #12]
    662a:	mov	r4, r0
    662c:	cbnz	r3, 6642 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x6a>
    662e:	ldr	r2, [r6, #4]
    6630:	ldr	r3, [r6, #8]
    6632:	cmp	r2, r3
    6634:	bne.n	6642 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x6a>
      if (fname->atEnd()) {
        return u == 0;
    6636:	clz	r0, r0
    663a:	lsrs	r0, r0, #5
    663c:	b.n	666e <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x96>
        return false;
      }
#endif  // USE_UTF8_LONG_NAMES
    }
  }
  return true;
    663e:	movs	r0, #1
    6640:	b.n	666e <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x96>
      uint16_t u = getLfnChar(ldir, i);
      if (fname->atEnd()) {
        return u == 0;
      }
#if USE_UTF8_LONG_NAMES
      uint16_t cp = fname->get16();
    6642:	mov	r0, r6
    6644:	bl	3164 <FsName::get16()>
    6648:	str	r0, [sp, #4]
      // Make sure caller checked for valid UTF-8.
      DBG_HALT_IF(cp == 0XFFFF);
      if (toUpcase(u) != toUpcase(cp)) {
    664a:	mov	r0, r4
    664c:	bl	30c0 <toUpcase(unsigned short)>
    6650:	ldr	r3, [sp, #4]
    6652:	mov	r4, r0
    6654:	mov	r0, r3
    6656:	bl	30c0 <toUpcase(unsigned short)>
    665a:	cmp	r4, r0
    665c:	bne.n	6614 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x3c>
    665e:	add.w	sl, sl, #1
      goto fail;
    }
    // These should be checked in caller.
    DBG_HALT_IF(ldir->attributes != FAT_ATTRIB_LONG_NAME);
    DBG_HALT_IF(order != (ldir->order & 0X1F));
    for (uint8_t i = 0; i < 13; i++) {
    6662:	cmp.w	sl, #13
    6666:	bne.n	661c <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x44>
//==============================================================================
bool FatFile::cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
  FatFile dir = *this;
  DirLfn_t* ldir;
  fname->reset();
  for (uint8_t order = 1; order <= lfnOrd; order++) {
    6668:	adds	r5, #1
    666a:	uxtb	r5, r5
    666c:	b.n	6600 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x28>
  }
  return true;

 fail:
  return false;
}
    666e:	add	sp, #52	; 0x34
    6670:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00006674 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)>:
//------------------------------------------------------------------------------
bool FatFile::createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
    6674:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  FatFile dir = *this;
    6678:	mov	r5, r0

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
    667a:	mov	r6, r2
    667c:	mov	sl, r1
    667e:	mov	r7, r3
  FatFile dir = *this;
    6680:	ldmia	r5!, {r0, r1, r2, r3}

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
    6682:	sub	sp, #52	; 0x34
  FatFile dir = *this;
    6684:	add	r4, sp, #12
    6686:	stmia	r4!, {r0, r1, r2, r3}
    6688:	ldmia	r5!, {r0, r1, r2, r3}
    668a:	stmia	r4!, {r0, r1, r2, r3}
    668c:	ldr	r3, [r5, #0]
    668e:	str	r3, [r4, #0]
  DirLfn_t* ldir;
  uint8_t checksum = lfnChecksum(fname->sfn);
    6690:	add.w	r0, r6, #22
    6694:	bl	65ba <FatFile::lfnChecksum(unsigned char*) [clone .isra.14]>
  }
  void reset() {
    next = begin;
    ls = 0;
    6698:	movs	r5, #0
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
  }
  void reset() {
    next = begin;
    669a:	ldr	r3, [r6, #0]
    669c:	str	r3, [r6, #4]
    669e:	mov	r9, r0
    ls = 0;
    66a0:	strh	r5, [r6, #12]
  uint8_t fc = 0;
  fname->reset();

  for (uint8_t order = 1; order <= lfnOrd; order++) {
    66a2:	mov.w	fp, #1
      goto fail;
    }
    dir.m_vol->cacheDirty();
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    ldir->attributes = FAT_ATTRIB_LONG_NAME;
    ldir->mustBeZero1 = 0;
    66a6:	mov	r8, r5
  DirLfn_t* ldir;
  uint8_t checksum = lfnChecksum(fname->sfn);
  uint8_t fc = 0;
  fname->reset();

  for (uint8_t order = 1; order <= lfnOrd; order++) {
    66a8:	cmp	fp, r7
    66aa:	bhi.n	66fa <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x86>
    ldir = reinterpret_cast<DirLfn_t*>(dir.cacheDir(index - order));
    66ac:	rsb	r1, fp, sl
    66b0:	uxth	r1, r1
    66b2:	add	r0, sp, #12
    66b4:	bl	52ec <FatFile::cacheDir(unsigned short)>
    if (!ldir) {
    66b8:	cmp	r0, #0
    66ba:	beq.n	6742 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0xce>
      DBG_FAIL_MACRO;
      goto fail;
    }
    dir.m_vol->cacheDirty();
    66bc:	ldr	r2, [sp, #20]
    invalidate();
    return m_buffer;
  }
  /** Set current sector dirty. */
  void dirty() {
    m_status |= CACHE_STATUS_DIRTY;
    66be:	ldrb.w	r3, [r2, #40]	; 0x28
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    66c2:	cmp	fp, r7
    66c4:	orr.w	r3, r3, #1
    66c8:	strb.w	r3, [r2, #40]	; 0x28
    66cc:	ite	eq
    66ce:	orreq.w	r3, fp, #64	; 0x40
    66d2:	movne	r3, fp
    66d4:	strb	r3, [r0, #0]
    ldir->attributes = FAT_ATTRIB_LONG_NAME;
    66d6:	mov.w	r3, #15
    66da:	strb	r3, [r0, #11]
    ldir->mustBeZero1 = 0;
    66dc:	strb.w	r8, [r0, #12]
    ldir->checksum = checksum;
    66e0:	strb.w	r9, [r0, #13]
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    66e4:	strh.w	r8, [r0, #26]
    66e8:	adds	r4, r0, #4
    setLe16(ldir->mustBeZero2, 0);
    for (uint8_t i = 0; i < 13; i++) {
    66ea:	movs	r1, #0
  /** \return next UTF-16 unit of LFN. */
  uint16_t get16() {return atEnd() ? 0 : *next++;}
#else  // !USE_UTF8_LONG_NAMES
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
    66ec:	ldrh	r3, [r6, #12]
    66ee:	cbnz	r3, 66fe <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x8a>
    66f0:	ldr	r2, [r6, #4]
    66f2:	ldr	r3, [r6, #8]
    66f4:	cmp	r2, r3
    66f6:	bne.n	66fe <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x8a>
    66f8:	b.n	6730 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0xbc>
        DBG_HALT_IF(cp == 0XFFFF);
      }
      putLfnChar(ldir, i, cp);
    }
  }
  return true;
    66fa:	movs	r0, #1
    66fc:	b.n	6742 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0xce>
    for (uint8_t i = 0; i < 13; i++) {
      uint16_t cp;
      if (fname->atEnd()) {
        cp = fc++ ? 0XFFFF : 0;
      } else {
        cp = fname->get16();
    66fe:	mov	r0, r6
    6700:	str	r1, [sp, #4]
    6702:	bl	3164 <FsName::get16()>
    6706:	ldr	r1, [sp, #4]
 * \param[in] ldir Pointer to long file name directory entry.
 * \param[in] i Index of character.
 * \param[in] c The 16-bit character.
 */
static void putLfnChar(DirLfn_t* ldir, uint8_t i, uint16_t c) {
  if (i < 5) {
    6708:	cmp	r1, #4
    670a:	bhi.n	6712 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x9e>
    670c:	strh.w	r0, [r4, #-3]
    6710:	b.n	671a <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0xa6>
    setLe16(ldir->unicode1 + 2*i, c);
  } else if (i < 11) {
    6712:	cmp	r1, #10
    6714:	ite	ls
    6716:	strhls	r0, [r4, #0]
    6718:	strhhi	r0, [r4, #2]
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    ldir->attributes = FAT_ATTRIB_LONG_NAME;
    ldir->mustBeZero1 = 0;
    ldir->checksum = checksum;
    setLe16(ldir->mustBeZero2, 0);
    for (uint8_t i = 0; i < 13; i++) {
    671a:	adds	r1, #1
    671c:	uxtb	r1, r1
    671e:	cmp	r1, #13
    6720:	add.w	r4, r4, #2
    6724:	bne.n	66ec <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x78>
  DirLfn_t* ldir;
  uint8_t checksum = lfnChecksum(fname->sfn);
  uint8_t fc = 0;
  fname->reset();

  for (uint8_t order = 1; order <= lfnOrd; order++) {
    6726:	add.w	fp, fp, #1
    672a:	uxtb.w	fp, fp
    672e:	b.n	66a8 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x34>
    ldir->checksum = checksum;
    setLe16(ldir->mustBeZero2, 0);
    for (uint8_t i = 0; i < 13; i++) {
      uint16_t cp;
      if (fname->atEnd()) {
        cp = fc++ ? 0XFFFF : 0;
    6730:	cbz	r5, 673c <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0xc8>
    6732:	adds	r5, #1
    6734:	uxtb	r5, r5
    6736:	movw	r0, #65535	; 0xffff
    673a:	b.n	6708 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x94>
    673c:	mov	r0, r5
    673e:	movs	r5, #1
    6740:	b.n	6708 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x94>
  }
  return true;

 fail:
  return false;
}
    6742:	add	sp, #52	; 0x34
    6744:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00006748 <FatFile::makeSFN(FatName_t*)>:
  uint8_t uc = 0;
  uint8_t i = 0;
  uint8_t in = 7;
  const char* dot;
  const char* end = fname->end;
  const char* ptr = fname->begin;
    6748:	mov	r2, r0

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::makeSFN(FatName_t* fname) {
    674a:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  uint8_t uc = 0;
  uint8_t i = 0;
  uint8_t in = 7;
  const char* dot;
  const char* end = fname->end;
  const char* ptr = fname->begin;
    674e:	ldr.w	r3, [r2], #21
  uint8_t lc = 0;
  uint8_t uc = 0;
  uint8_t i = 0;
  uint8_t in = 7;
  const char* dot;
  const char* end = fname->end;
    6752:	ldr	r7, [r0, #8]
    6754:	add.w	r1, r0, #32
  // Assume blanks removed from start and end.
  DBG_HALT_IF(*ptr == ' ' || *(end - 1) == ' ' || *(end - 1) == '.');

  // Blank file short name.
  for (uint8_t k = 0; k < 11; k++) {
    fname->sfn[k] = ' ';
    6758:	movs	r4, #32
    675a:	strb.w	r4, [r2, #1]!
  DBG_HALT_IF(end == ptr);
  // Assume blanks removed from start and end.
  DBG_HALT_IF(*ptr == ' ' || *(end - 1) == ' ' || *(end - 1) == '.');

  // Blank file short name.
  for (uint8_t k = 0; k < 11; k++) {
    675e:	cmp	r1, r2
    6760:	bne.n	675a <FatFile::makeSFN(FatName_t*)+0x12>
    fname->sfn[k] = ' ';
  }
  // Not 8.3 if starts with dot.
  is83 = *ptr == '.' ? false : true;
    6762:	ldrb	r6, [r3, #0]
    6764:	subs	r6, #46	; 0x2e
    6766:	it	ne
    6768:	movne	r6, #1
    676a:	mov	r5, r3
    676c:	adds	r3, #1
  // Skip leading dots.
  for (; *ptr == '.'; ptr++) {}
    676e:	ldrb	r2, [r5, #0]
    6770:	cmp	r2, #46	; 0x2e
    6772:	beq.n	676a <FatFile::makeSFN(FatName_t*)+0x22>
    6774:	subs	r3, r7, #1
  // Find last dot.
  for (dot = end - 1; dot > ptr && *dot != '.'; dot--) {}
    6776:	cmp	r3, r5
    6778:	mov	lr, r3
    677a:	bhi.n	678c <FatFile::makeSFN(FatName_t*)+0x44>
    677c:	movs	r2, #0
    677e:	mov.w	ip, #7
    6782:	mov	r1, r2
    6784:	mov	r8, r2
    6786:	mov.w	r9, #8
    678a:	b.n	67b0 <FatFile::makeSFN(FatName_t*)+0x68>
    678c:	ldrb.w	r2, [lr]
    6790:	cmp	r2, #46	; 0x2e
    6792:	add.w	r3, r3, #4294967295
    6796:	bne.n	6776 <FatFile::makeSFN(FatName_t*)+0x2e>
    6798:	b.n	677c <FatFile::makeSFN(FatName_t*)+0x34>

  for (; ptr < end; ptr++) {
    c = *ptr;
    679a:	ldrb	r3, [r5, #0]
//  Could skip UTF-8 units where (0XC0 & c) == 0X80

    if (c == '.' && ptr == dot) {
    679c:	cmp	r3, #46	; 0x2e
    679e:	bne.n	67b6 <FatFile::makeSFN(FatName_t*)+0x6e>
    67a0:	cmp	lr, r5
    67a2:	bne.n	67be <FatFile::makeSFN(FatName_t*)+0x76>
      in = 10;  // Max index for full 8.3 name.
    67a4:	mov.w	ip, #10
      i = 8;    // Place for extension.
    67a8:	movs	r1, #8
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    67aa:	mov.w	r9, #16
  // Skip leading dots.
  for (; *ptr == '.'; ptr++) {}
  // Find last dot.
  for (dot = end - 1; dot > ptr && *dot != '.'; dot--) {}

  for (; ptr < end; ptr++) {
    67ae:	adds	r5, #1
    67b0:	cmp	r5, r7
    67b2:	bcc.n	679a <FatFile::makeSFN(FatName_t*)+0x52>
    67b4:	b.n	6840 <FatFile::makeSFN(FatName_t*)+0xf8>
  /** Check for a legal 8.3 character.
   * \param[in] c Character to be checked.
   * \return true for a legal 8.3 character.
   */
  static bool legal83Char(uint8_t c) {
    if (c == '"' || c == '|') {
    67b6:	cmp	r3, #34	; 0x22
    67b8:	beq.n	67e2 <FatFile::makeSFN(FatName_t*)+0x9a>
    67ba:	cmp	r3, #124	; 0x7c
    67bc:	beq.n	67e2 <FatFile::makeSFN(FatName_t*)+0x9a>
      return false;
    }
    // *+,./
    if (0X2A <= c && c <= 0X2F && c != 0X2D) {
    67be:	sub.w	r4, r3, #42	; 0x2a
    67c2:	cmp	r4, #5
    67c4:	bhi.n	67ca <FatFile::makeSFN(FatName_t*)+0x82>
    67c6:	cmp	r3, #45	; 0x2d
    67c8:	bne.n	67e2 <FatFile::makeSFN(FatName_t*)+0x9a>
      return false;
    }
    // :;<=>?
    if (0X3A <= c && c <= 0X3F) {
    67ca:	sub.w	r4, r3, #58	; 0x3a
    67ce:	cmp	r4, #5
    67d0:	bls.n	67e2 <FatFile::makeSFN(FatName_t*)+0x9a>
      return false;
    }
    // [\]
    if (0X5B <= c && c <= 0X5D) {
    67d2:	sub.w	r4, r3, #91	; 0x5b
    67d6:	cmp	r4, #2
    67d8:	bls.n	67e2 <FatFile::makeSFN(FatName_t*)+0x9a>
    if (c == '.' && ptr == dot) {
      in = 10;  // Max index for full 8.3 name.
      i = 8;    // Place for extension.
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    } else {
      if (!legal83Char(c)) {
    67da:	sub.w	r4, r3, #33	; 0x21
    67de:	cmp	r4, #93	; 0x5d
    67e0:	bls.n	67ec <FatFile::makeSFN(FatName_t*)+0xa4>
        is83 = false;
        // Skip UTF-8 trailing characters.
        if ((c & 0XC0) == 0X80) {
    67e2:	and.w	r3, r3, #192	; 0xc0
    67e6:	cmp	r3, #128	; 0x80
    67e8:	bne.n	6812 <FatFile::makeSFN(FatName_t*)+0xca>
    67ea:	b.n	6836 <FatFile::makeSFN(FatName_t*)+0xee>
          continue;
        }
        c = '_';
      }
      if (i > in) {
    67ec:	cmp	r1, ip
    67ee:	bls.n	6800 <FatFile::makeSFN(FatName_t*)+0xb8>
        is83 = false;
        if (in == 10 || ptr > dot) {
    67f0:	cmp.w	ip, #10
    67f4:	beq.n	683e <FatFile::makeSFN(FatName_t*)+0xf6>
    67f6:	cmp	lr, r5
    67f8:	bcc.n	683e <FatFile::makeSFN(FatName_t*)+0xf6>
         // Done - extension longer than three characters or no extension.
          break;
        }
        // Skip to dot.
        ptr = dot - 1;
    67fa:	add.w	r5, lr, #4294967295
    67fe:	b.n	6836 <FatFile::makeSFN(FatName_t*)+0xee>
        continue;
      }
      if (isLower(c)) {
    6800:	sub.w	r4, r3, #97	; 0x61
    6804:	cmp	r4, #25
    6806:	bhi.n	681a <FatFile::makeSFN(FatName_t*)+0xd2>
        c += 'A' - 'a';
    6808:	subs	r3, #32
    680a:	uxtb	r3, r3
        lc |= bit;
    680c:	orr.w	r2, r9, r2
    6810:	b.n	6826 <FatFile::makeSFN(FatName_t*)+0xde>
        if ((c & 0XC0) == 0X80) {
          continue;
        }
        c = '_';
      }
      if (i > in) {
    6812:	cmp	r1, ip
    6814:	bhi.n	67f0 <FatFile::makeSFN(FatName_t*)+0xa8>
        is83 = false;
        // Skip UTF-8 trailing characters.
        if ((c & 0XC0) == 0X80) {
          continue;
        }
        c = '_';
    6816:	movs	r3, #95	; 0x5f
      in = 10;  // Max index for full 8.3 name.
      i = 8;    // Place for extension.
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    } else {
      if (!legal83Char(c)) {
        is83 = false;
    6818:	movs	r6, #0
        continue;
      }
      if (isLower(c)) {
        c += 'A' - 'a';
        lc |= bit;
      } else if (isUpper(c)) {
    681a:	sub.w	r4, r3, #65	; 0x41
    681e:	cmp	r4, #25
        uc |= bit;
    6820:	it	ls
    6822:	orrls.w	r8, r9, r8
      }
      fname->sfn[i++] = c;
    6826:	adds	r4, r1, #1
    6828:	uxtb	r4, r4
    682a:	add	r1, r0
      if (i < 7) {
    682c:	cmp	r4, #6
        c += 'A' - 'a';
        lc |= bit;
      } else if (isUpper(c)) {
        uc |= bit;
      }
      fname->sfn[i++] = c;
    682e:	strb	r3, [r1, #22]
      if (i < 7) {
    6830:	bhi.n	683a <FatFile::makeSFN(FatName_t*)+0xf2>
        fname->seqPos = i;
    6832:	strb	r4, [r0, #20]
    6834:	b.n	683a <FatFile::makeSFN(FatName_t*)+0xf2>
      in = 10;  // Max index for full 8.3 name.
      i = 8;    // Place for extension.
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    } else {
      if (!legal83Char(c)) {
        is83 = false;
    6836:	movs	r6, #0
    6838:	b.n	67ae <FatFile::makeSFN(FatName_t*)+0x66>
    683a:	mov	r1, r4
    683c:	b.n	67ae <FatFile::makeSFN(FatName_t*)+0x66>
          continue;
        }
        c = '_';
      }
      if (i > in) {
        is83 = false;
    683e:	movs	r6, #0
      if (i < 7) {
        fname->seqPos = i;
      }
    }
  }
  if (fname->sfn[0] == ' ') {
    6840:	ldrb	r3, [r0, #22]
    6842:	cmp	r3, #32
    6844:	beq.n	686a <FatFile::makeSFN(FatName_t*)+0x122>
    DBG_HALT_MACRO;
    goto fail;
  }
  if (is83) {
    6846:	cbz	r6, 6858 <FatFile::makeSFN(FatName_t*)+0x110>
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
    6848:	tst.w	r8, r2
    684c:	it	ne
    684e:	movne	r2, #2
    6850:	strb	r2, [r0, #21]
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    fname->sfn[fname->seqPos] = '~';
    fname->sfn[fname->seqPos + 1] = '1';
  }
  return true;
    6852:	movs	r0, #1
    6854:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  }
  if (is83) {
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    fname->sfn[fname->seqPos] = '~';
    6858:	ldrb	r2, [r0, #20]
    goto fail;
  }
  if (is83) {
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    685a:	movs	r3, #1
    685c:	strb	r3, [r0, #21]
    fname->sfn[fname->seqPos] = '~';
    685e:	add	r0, r2
    6860:	movs	r2, #126	; 0x7e
    6862:	strb	r2, [r0, #22]
    fname->sfn[fname->seqPos + 1] = '1';
    6864:	movs	r2, #49	; 0x31
    6866:	strb	r2, [r0, #23]
    6868:	b.n	6852 <FatFile::makeSFN(FatName_t*)+0x10a>
  }
  return true;

 fail:
  return false;
    686a:	movs	r0, #0
    686c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

00006870 <FatFile::makeUniqueSfn(FatName_t*)>:
}
//------------------------------------------------------------------------------
bool FatFile::makeUniqueSfn(FatName_t* fname) {
    6870:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  const uint8_t FIRST_HASH_SEQ = 2;  // min value is 2
  uint8_t pos = fname->seqPos;
    6874:	ldrb	r5, [r1, #20]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::makeUniqueSfn(FatName_t* fname) {
    6876:	mov	r7, r0
    6878:	mov	r6, r1
  const uint8_t FIRST_HASH_SEQ = 2;  // min value is 2
  uint8_t pos = fname->seqPos;
    687a:	movs	r4, #98	; 0x62
    for (uint8_t i = pos + 4 ; i > pos; i--) {
      uint8_t h = hex & 0XF;
      fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
      hex >>= 4;
    }
    fname->sfn[pos] = '~';
    687c:	mov.w	r8, #126	; 0x7e
        goto fail;
      }
      if (dir->name[0] == FAT_NAME_FREE) {
        goto done;
      }
      if (isFileOrSubdir(dir) && !memcmp(fname->sfn, dir->name, 11)) {
    6880:	add.w	r9, r1, #22
  for (uint8_t seq = FIRST_HASH_SEQ; seq < 100; seq++) {
     DBG_WARN_IF(seq > FIRST_HASH_SEQ);
#ifdef USE_LFN_HASH
    hex = Bernstein(fname->begin, fname->end, seq);
#else
    hex = micros();
    6884:	bl	8d98 <micros>
    6888:	cmp	r5, #3
    688a:	it	cs
    688c:	movcs	r5, #3
#endif
    if (pos > 3) {
      // Make space in name for ~HHHH.
      pos = 3;
    }
    for (uint8_t i = pos + 4 ; i > pos; i--) {
    688e:	adds	r3, r5, #4
  for (uint8_t seq = FIRST_HASH_SEQ; seq < 100; seq++) {
     DBG_WARN_IF(seq > FIRST_HASH_SEQ);
#ifdef USE_LFN_HASH
    hex = Bernstein(fname->begin, fname->end, seq);
#else
    hex = micros();
    6890:	uxth	r0, r0
#endif
    if (pos > 3) {
      // Make space in name for ~HHHH.
      pos = 3;
    }
    for (uint8_t i = pos + 4 ; i > pos; i--) {
    6892:	uxtb	r3, r3
      uint8_t h = hex & 0XF;
    6894:	and.w	r2, r0, #15
      fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    6898:	adds	r1, r6, r3
#endif
    if (pos > 3) {
      // Make space in name for ~HHHH.
      pos = 3;
    }
    for (uint8_t i = pos + 4 ; i > pos; i--) {
    689a:	subs	r3, #1
      uint8_t h = hex & 0XF;
      fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    689c:	cmp	r2, #9
#endif
    if (pos > 3) {
      // Make space in name for ~HHHH.
      pos = 3;
    }
    for (uint8_t i = pos + 4 ; i > pos; i--) {
    689e:	uxtb	r3, r3
      uint8_t h = hex & 0XF;
      fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    68a0:	ite	ls
    68a2:	addls	r2, #48	; 0x30
    68a4:	addhi	r2, #55	; 0x37
#endif
    if (pos > 3) {
      // Make space in name for ~HHHH.
      pos = 3;
    }
    for (uint8_t i = pos + 4 ; i > pos; i--) {
    68a6:	cmp	r5, r3
      uint8_t h = hex & 0XF;
      fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    68a8:	strb	r2, [r1, #22]
      hex >>= 4;
    68aa:	mov.w	r0, r0, lsr #4
#endif
    if (pos > 3) {
      // Make space in name for ~HHHH.
      pos = 3;
    }
    for (uint8_t i = pos + 4 ; i > pos; i--) {
    68ae:	bcc.n	6894 <FatFile::makeUniqueSfn(FatName_t*)+0x24>
      uint8_t h = hex & 0XF;
      fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
      hex >>= 4;
    }
    fname->sfn[pos] = '~';
    68b0:	adds	r3, r6, r5
   * \return true for success or false for failure.
   */
  bool rename(FatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    68b2:	movs	r1, #0
    68b4:	strb.w	r8, [r3, #22]
    68b8:	mov	r0, r7
    68ba:	bl	57ea <FatFile::seekSet(unsigned long)>
    rewind();
    while (1) {
      dir = readDirCache(true);
    68be:	movs	r1, #1
    68c0:	mov	r0, r7
    68c2:	bl	57b0 <FatFile::readDirCache(bool)>
      if (!dir) {
    68c6:	mov	r1, r0
    68c8:	cbnz	r0, 68d6 <FatFile::makeUniqueSfn(FatName_t*)+0x66>
        if (!getError()) {
    68ca:	ldrb	r0, [r7, #1]
    68cc:	clz	r0, r0
    68d0:	lsrs	r0, r0, #5
    68d2:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
          goto done;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (dir->name[0] == FAT_NAME_FREE) {
    68d6:	ldrb	r3, [r0, #0]
    68d8:	cbz	r3, 68ee <FatFile::makeUniqueSfn(FatName_t*)+0x7e>
        goto done;
      }
      if (isFileOrSubdir(dir) && !memcmp(fname->sfn, dir->name, 11)) {
    68da:	ldrb	r3, [r0, #11]
    68dc:	lsls	r3, r3, #28
    68de:	bmi.n	68be <FatFile::makeUniqueSfn(FatName_t*)+0x4e>
    68e0:	movs	r2, #11
    68e2:	mov	r0, r9
    68e4:	bl	b120 <memcmp>
    68e8:	cmp	r0, #0
    68ea:	bne.n	68be <FatFile::makeUniqueSfn(FatName_t*)+0x4e>
    68ec:	b.n	68f4 <FatFile::makeUniqueSfn(FatName_t*)+0x84>

 fail:
  return false;

 done:
  return true;
    68ee:	movs	r0, #1
    68f0:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    68f4:	subs	r0, r4, #1
  uint16_t hex;

  DBG_HALT_IF(!(fname->flags & FNAME_FLAG_LOST_CHARS));
  DBG_HALT_IF(fname->sfn[pos] != '~' && fname->sfn[pos + 1] != '1');

  for (uint8_t seq = FIRST_HASH_SEQ; seq < 100; seq++) {
    68f6:	ands.w	r4, r0, #255	; 0xff
    68fa:	bne.n	6884 <FatFile::makeUniqueSfn(FatName_t*)+0x14>
  }
  // fall inti fail - too many tries.
  DBG_FAIL_MACRO;

 fail:
  return false;
    68fc:	mov	r0, r4
    68fe:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    6902:	Address 0x00006902 is out of bounds.


00006904 <FatFile::open(FatFile*, FatName_t*, int)>:

 done:
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
    6904:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6908:	sub	sp, #44	; 0x2c
    690a:	mov	r6, r1
    690c:	str	r3, [sp, #12]
  uint16_t date;
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;

  if (!dirFile->isDir() || isOpen()) {
    690e:	ldrb	r3, [r1, #0]

 done:
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
    6910:	str	r0, [sp, #24]
  uint16_t date;
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;

  if (!dirFile->isDir() || isOpen()) {
    6912:	tst.w	r3, #112	; 0x70

 done:
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
    6916:	mov	sl, r2
  uint16_t date;
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;

  if (!dirFile->isDir() || isOpen()) {
    6918:	bne.n	691e <FatFile::open(FatFile*, FatName_t*, int)+0x1a>
    goto fail;
  }
  return true;

 fail:
  return false;
    691a:	movs	r0, #0
    691c:	b.n	6b48 <FatFile::open(FatFile*, FatName_t*, int)+0x244>
  uint16_t date;
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;

  if (!dirFile->isDir() || isOpen()) {
    691e:	ldr	r3, [sp, #24]
    6920:	ldrb	r3, [r3, #0]
    6922:	cmp	r3, #0
    6924:	bne.n	691a <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Number of directory entries needed.
  nameOrd = (fname->len + 12)/13;
    6926:	ldr	r3, [r2, #16]
    6928:	movs	r2, #13
    692a:	adds	r3, #12
    692c:	udiv	r3, r3, r2
    6930:	uxtb	r3, r3
    6932:	str	r3, [sp, #8]
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + nameOrd : 1;
    6934:	ldrb.w	r3, [sl, #21]
    6938:	lsls	r3, r3, #30
    693a:	beq.w	6b42 <FatFile::open(FatFile*, FatName_t*, int)+0x23e>
    693e:	ldr	r3, [sp, #8]
    6940:	add.w	fp, r3, #1
    6944:	uxtb.w	fp, fp
    6948:	movs	r1, #0
    694a:	mov	r0, r6
  uint8_t freeFound = 0;
  uint8_t order = 0;
  uint8_t checksum = 0;
  uint8_t ms10;
  uint8_t nameOrd;
  uint16_t freeIndex = 0;
    694c:	mov.w	r9, #0
    6950:	bl	57ea <FatFile::seekSet(unsigned long)>
          goto found;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
    6954:	add.w	r3, sl, #22
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
  uint8_t freeNeed;
  uint8_t freeFound = 0;
  uint8_t order = 0;
  uint8_t checksum = 0;
    6958:	str.w	r9, [sp, #16]
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
  uint8_t freeNeed;
  uint8_t freeFound = 0;
  uint8_t order = 0;
    695c:	mov	r8, r9
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
  uint8_t freeNeed;
  uint8_t freeFound = 0;
    695e:	mov	r4, r9
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
    6960:	mov	r5, r9
 done:
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
  bool fnameFound = false;
    6962:	str.w	r9, [sp, #20]
          goto found;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
    6966:	str	r3, [sp, #28]
  // Number of directory entries needed.
  nameOrd = (fname->len + 12)/13;
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + nameOrd : 1;
  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    6968:	ldr	r7, [r6, #20]
    dir = dirFile->readDirCache();
    696a:	movs	r1, #0
    696c:	mov	r0, r6
  // Number of directory entries needed.
  nameOrd = (fname->len + 12)/13;
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + nameOrd : 1;
  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    696e:	ubfx	r7, r7, #5, #16
    dir = dirFile->readDirCache();
    6972:	bl	57b0 <FatFile::readDirCache(bool)>
    if (!dir) {
    6976:	cbnz	r0, 6980 <FatFile::open(FatFile*, FatName_t*, int)+0x7c>
      if (dirFile->getError()) {
    6978:	ldrb	r3, [r6, #1]
    697a:	cmp	r3, #0
    697c:	beq.n	6a40 <FatFile::open(FatFile*, FatName_t*, int)+0x13c>
    697e:	b.n	691a <FatFile::open(FatFile*, FatName_t*, int)+0x16>
        goto fail;
      }
      // At EOF
      goto create;
    }
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == FAT_NAME_FREE) {
    6980:	ldrb	r3, [r0, #0]
    6982:	cmp	r3, #229	; 0xe5
    6984:	beq.n	6988 <FatFile::open(FatFile*, FatName_t*, int)+0x84>
    6986:	cbnz	r3, 699a <FatFile::open(FatFile*, FatName_t*, int)+0x96>
  // Number of directory entries needed.
  nameOrd = (fname->len + 12)/13;
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + nameOrd : 1;
  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    6988:	cmp	r4, #0
    698a:	it	eq
    698c:	moveq	r9, r7
    }
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == FAT_NAME_FREE) {
      if (freeFound == 0) {
        freeIndex = curIndex;
      }
      if (freeFound < freeNeed) {
    698e:	cmp	r4, fp
        freeFound++;
    6990:	itt	cc
    6992:	addcc	r4, #1
    6994:	uxtbcc	r4, r4
      }
      if (dir->name[0] == FAT_NAME_FREE) {
    6996:	cbnz	r3, 69a2 <FatFile::open(FatFile*, FatName_t*, int)+0x9e>
    6998:	b.n	6a40 <FatFile::open(FatFile*, FatName_t*, int)+0x13c>
        goto create;
      }
    } else {
      if (freeFound < freeNeed) {
        freeFound = 0;
    699a:	cmp	r4, fp
    699c:	it	cc
    699e:	movcc	r4, #0
    69a0:	b.n	69aa <FatFile::open(FatFile*, FatName_t*, int)+0xa6>
      }
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
    69a2:	cmp	r3, #229	; 0xe5
    69a4:	bne.n	69aa <FatFile::open(FatFile*, FatName_t*, int)+0xa6>
          goto found;
        }
        fnameFound = true;
      }
    } else {
      lfnOrd = 0;
    69a6:	movs	r5, #0
    69a8:	b.n	6968 <FatFile::open(FatFile*, FatName_t*, int)+0x64>
      if (freeFound < freeNeed) {
        freeFound = 0;
      }
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
    69aa:	cmp	r3, #46	; 0x2e
    69ac:	beq.n	69a6 <FatFile::open(FatFile*, FatName_t*, int)+0xa2>
    69ae:	ldrb	r2, [r0, #11]
      lfnOrd = 0;
    } else if (isLongName(dir)) {
    69b0:	cmp	r2, #15
    69b2:	bne.n	6a04 <FatFile::open(FatFile*, FatName_t*, int)+0x100>
      ldir = reinterpret_cast<DirLfn_t*>(dir);
      if (!lfnOrd) {
    69b4:	cbnz	r5, 69d4 <FatFile::open(FatFile*, FatName_t*, int)+0xd0>
        order = ldir->order & 0X1F;
        if (order != nameOrd ||
    69b6:	ldr	r2, [sp, #8]
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
      lfnOrd = 0;
    } else if (isLongName(dir)) {
      ldir = reinterpret_cast<DirLfn_t*>(dir);
      if (!lfnOrd) {
        order = ldir->order & 0X1F;
    69b8:	and.w	r8, r3, #31
        if (order != nameOrd ||
    69bc:	cmp	r2, r8
    69be:	bne.n	6968 <FatFile::open(FatFile*, FatName_t*, int)+0x64>
    69c0:	lsls	r1, r3, #25
    69c2:	bmi.n	69ca <FatFile::open(FatFile*, FatName_t*, int)+0xc6>
    69c4:	ldr.w	r8, [sp, #8]
    69c8:	b.n	6968 <FatFile::open(FatFile*, FatName_t*, int)+0x64>
          (ldir->order & FAT_ORDER_LAST_LONG_ENTRY) == 0) {
          continue;
        }
        lfnOrd = nameOrd;
        checksum = ldir->checksum;
    69ca:	ldrb	r3, [r0, #13]
    69cc:	str	r3, [sp, #16]
    69ce:	mov	r8, r2
    69d0:	mov	r5, r2
    69d2:	b.n	69e8 <FatFile::open(FatFile*, FatName_t*, int)+0xe4>
      } else if (ldir->order != --order || checksum != ldir->checksum) {
    69d4:	add.w	r8, r8, #4294967295
    69d8:	uxtb.w	r8, r8
    69dc:	cmp	r3, r8
    69de:	bne.n	69a6 <FatFile::open(FatFile*, FatName_t*, int)+0xa2>
    69e0:	ldrb	r3, [r0, #13]
    69e2:	ldr	r2, [sp, #16]
    69e4:	cmp	r2, r3
    69e6:	bne.n	69a6 <FatFile::open(FatFile*, FatName_t*, int)+0xa2>
        lfnOrd = 0;
        continue;
      }
      if (order == 1) {
    69e8:	cmp.w	r8, #1
    69ec:	bne.n	6968 <FatFile::open(FatFile*, FatName_t*, int)+0x64>
        if (!dirFile->cmpName(curIndex + 1, fname, lfnOrd)) {
    69ee:	adds	r1, r7, #1
    69f0:	mov	r3, r5
    69f2:	mov	r2, sl
    69f4:	uxth	r1, r1
    69f6:	mov	r0, r6
    69f8:	bl	65d8 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)>
          lfnOrd = 0;
    69fc:	cmp	r0, #0
    69fe:	it	eq
    6a00:	moveq	r5, #0
    6a02:	b.n	6968 <FatFile::open(FatFile*, FatName_t*, int)+0x64>
        }
      }
    } else if (isFileOrSubdir(dir)) {
    6a04:	lsls	r3, r2, #28
    6a06:	bmi.n	69a6 <FatFile::open(FatFile*, FatName_t*, int)+0xa2>
      if (lfnOrd) {
    6a08:	cbz	r5, 6a1e <FatFile::open(FatFile*, FatName_t*, int)+0x11a>
        if (1 == order && lfnChecksum(dir->name) == checksum) {
    6a0a:	cmp.w	r8, #1
    6a0e:	bne.n	691a <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    6a10:	bl	65ba <FatFile::lfnChecksum(unsigned char*) [clone .isra.14]>
    6a14:	ldr	r3, [sp, #16]
    6a16:	cmp	r3, r0
    6a18:	bne.w	691a <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    6a1c:	b.n	6a38 <FatFile::open(FatFile*, FatName_t*, int)+0x134>
          goto found;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
    6a1e:	movs	r2, #11
    6a20:	ldr	r1, [sp, #28]
    6a22:	bl	b120 <memcmp>
    6a26:	cmp	r0, #0
    6a28:	bne.n	6968 <FatFile::open(FatFile*, FatName_t*, int)+0x64>
        if (!(fname->flags & FNAME_FLAG_LOST_CHARS)) {
    6a2a:	ldrb.w	r3, [sl, #21]
    6a2e:	lsls	r0, r3, #31
    6a30:	bpl.n	6a38 <FatFile::open(FatFile*, FatName_t*, int)+0x134>
          goto found;
        }
        fnameFound = true;
    6a32:	movs	r3, #1
    6a34:	str	r3, [sp, #20]
    6a36:	b.n	6968 <FatFile::open(FatFile*, FatName_t*, int)+0x64>
    }
  }

 found:
  // Don't open if create only.
  if (oflag & O_EXCL) {
    6a38:	ldr	r3, [sp, #12]
    6a3a:	lsls	r1, r3, #20
    6a3c:	bpl.n	6b32 <FatFile::open(FatFile*, FatName_t*, int)+0x22e>
    6a3e:	b.n	691a <FatFile::open(FatFile*, FatName_t*, int)+0x16>
  }
  goto open;

 create:
  // don't create unless O_CREAT and write mode
  if (!(oflag & O_CREAT) || !isWriteMode(oflag)) {
    6a40:	ldr	r3, [sp, #12]
    6a42:	lsls	r2, r3, #22
    6a44:	bpl.w	691a <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    6a48:	and.w	r3, r3, #3
    6a4c:	subs	r3, #1
    6a4e:	cmp	r3, #1
    6a50:	bhi.w	691a <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    DBG_WARN_MACRO;
    goto fail;
  }
  // Keep found entries or start at current index if no free entries found.
  if (freeFound == 0) {
    6a54:	cmp	r4, #0
    6a56:	it	eq
    6a58:	moveq	r9, r7
    freeIndex = curIndex;
  }

  while (freeFound < freeNeed) {
    6a5a:	cmp	r4, fp
    6a5c:	bcc.n	6a64 <FatFile::open(FatFile*, FatName_t*, int)+0x160>
      DBG_FAIL_MACRO;
      goto fail;
    }
    freeFound += dirFile->m_vol->sectorsPerCluster();
  }
  if (fnameFound) {
    6a5e:	ldr	r3, [sp, #20]
    6a60:	cbnz	r3, 6a92 <FatFile::open(FatFile*, FatName_t*, int)+0x18e>
    6a62:	b.n	6aa0 <FatFile::open(FatFile*, FatName_t*, int)+0x19c>
  if (freeFound == 0) {
    freeIndex = curIndex;
  }

  while (freeFound < freeNeed) {
    dir = dirFile->readDirCache();
    6a64:	movs	r1, #0
    6a66:	mov	r0, r6
    6a68:	bl	57b0 <FatFile::readDirCache(bool)>
    if (!dir) {
    6a6c:	cbnz	r0, 6a74 <FatFile::open(FatFile*, FatName_t*, int)+0x170>
      if (dirFile->getError()) {
    6a6e:	ldrb	r3, [r6, #1]
    6a70:	cbz	r3, 6a86 <FatFile::open(FatFile*, FatName_t*, int)+0x182>
    6a72:	b.n	691a <FatFile::open(FatFile*, FatName_t*, int)+0x16>
        goto fail;
      }
      // EOF if no error.
      break;
    }
    freeFound++;
    6a74:	adds	r4, #1
    6a76:	uxtb	r4, r4
  // Keep found entries or start at current index if no free entries found.
  if (freeFound == 0) {
    freeIndex = curIndex;
  }

  while (freeFound < freeNeed) {
    6a78:	b.n	6a5a <FatFile::open(FatFile*, FatName_t*, int)+0x156>
    6a7a:	ldr	r3, [r6, #8]
    // Will fail if FAT16 root.
    if (!dirFile->addDirCluster()) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    freeFound += dirFile->m_vol->sectorsPerCluster();
    6a7c:	ldrb	r3, [r3, #4]
    6a7e:	add	r4, r3
    6a80:	uxtb	r4, r4
      // EOF if no error.
      break;
    }
    freeFound++;
  }
  while (freeFound < freeNeed) {
    6a82:	cmp	fp, r4
    6a84:	bls.n	6a5e <FatFile::open(FatFile*, FatName_t*, int)+0x15a>
    // Will fail if FAT16 root.
    if (!dirFile->addDirCluster()) {
    6a86:	mov	r0, r6
    6a88:	bl	5508 <FatFile::addDirCluster()>
    6a8c:	cmp	r0, #0
    6a8e:	bne.n	6a7a <FatFile::open(FatFile*, FatName_t*, int)+0x176>
    6a90:	b.n	691a <FatFile::open(FatFile*, FatName_t*, int)+0x16>
      goto fail;
    }
    freeFound += dirFile->m_vol->sectorsPerCluster();
  }
  if (fnameFound) {
    if (!dirFile->makeUniqueSfn(fname)) {
    6a92:	mov	r1, sl
    6a94:	mov	r0, r6
    6a96:	bl	6870 <FatFile::makeUniqueSfn(FatName_t*)>
    6a9a:	cmp	r0, #0
    6a9c:	beq.w	691a <FatFile::open(FatFile*, FatName_t*, int)+0x16>
      goto fail;
    }
  }
  lfnOrd = freeNeed - 1;
    6aa0:	add.w	r5, fp, #4294967295
    6aa4:	uxtb	r5, r5
  curIndex = freeIndex + lfnOrd;
    6aa6:	add.w	r7, r9, r5
    6aaa:	uxth	r7, r7
  if (!dirFile->createLFN(curIndex, fname, lfnOrd)) {
    6aac:	mov	r3, r5
    6aae:	mov	r2, sl
    6ab0:	mov	r1, r7
    6ab2:	mov	r0, r6
    6ab4:	bl	6674 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)>
    6ab8:	cmp	r0, #0
    6aba:	beq.w	691a <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    goto fail;
  }
  dir = dirFile->cacheDir(curIndex);
    6abe:	mov	r1, r7
    6ac0:	mov	r0, r6
    6ac2:	bl	52ec <FatFile::cacheDir(unsigned short)>
  if (!dir) {
    6ac6:	mov	r4, r0
    6ac8:	cmp	r0, #0
    6aca:	beq.w	691a <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // initialize as empty file
  memset(dir, 0, sizeof(DirFat_t));
    6ace:	movs	r2, #32
    6ad0:	movs	r1, #0
    6ad2:	bl	88c8 <memset>
  memcpy(dir->name, fname->sfn, 11);
    6ad6:	mov	r3, sl
    6ad8:	ldr.w	r2, [r3, #22]!
    6adc:	str	r2, [r4, #0]
    6ade:	ldr	r2, [r3, #4]
    6ae0:	str	r2, [r4, #4]
    6ae2:	ldrh	r2, [r3, #8]
    6ae4:	strh	r2, [r4, #8]
    6ae6:	ldrb	r3, [r3, #10]
    6ae8:	strb	r3, [r4, #10]

  // Set base-name and extension lower case bits.
  dir->caseFlags = (FAT_CASE_LC_BASE | FAT_CASE_LC_EXT) & fname->flags;
    6aea:	ldrb.w	r3, [sl, #21]
    6aee:	and.w	r3, r3, #24
    6af2:	strb	r3, [r4, #12]

  // Set timestamps.
  if (FsDateTime::callback) {
    6af4:	ldr	r3, [pc, #88]	; (6b50 <FatFile::open(FatFile*, FatName_t*, int)+0x24c>)
    6af6:	ldr	r3, [r3, #0]
    6af8:	cbz	r3, 6b1a <FatFile::open(FatFile*, FatName_t*, int)+0x216>
    // call user date/time function
    FsDateTime::callback(&date, &time, &ms10);
    6afa:	add.w	r2, sp, #35	; 0x23
    6afe:	add.w	r1, sp, #38	; 0x26
    6b02:	add	r0, sp, #36	; 0x24
    6b04:	blx	r3
    6b06:	ldrh.w	r3, [sp, #36]	; 0x24
    6b0a:	strh	r3, [r4, #16]
    6b0c:	ldrh.w	r3, [sp, #38]	; 0x26
    6b10:	strh	r3, [r4, #14]
    setLe16(dir->createDate, date);
    setLe16(dir->createTime, time);
    dir->createTimeMs = ms10;
    6b12:	ldrb.w	r3, [sp, #35]	; 0x23
    6b16:	strb	r3, [r4, #13]
    6b18:	b.n	6b24 <FatFile::open(FatFile*, FatName_t*, int)+0x220>
    6b1a:	movw	r3, #21537	; 0x5421
    6b1e:	strh	r3, [r4, #16]
    6b20:	strh	r3, [r4, #24]
    6b22:	strh	r3, [r4, #18]
      setLe16(dir->createTime, FS_DEFAULT_TIME);
      setLe16(dir->modifyTime, FS_DEFAULT_TIME);
    }
  }
  // Force write of entry to device.
  dirFile->m_vol->cacheDirty();
    6b24:	ldr	r2, [r6, #8]
    6b26:	ldrb.w	r3, [r2, #40]	; 0x28
    6b2a:	orr.w	r3, r3, #1
    6b2e:	strb.w	r3, [r2, #40]	; 0x28

 open:
  // open entry in cache.
  if (!openCachedEntry(dirFile, curIndex, oflag, lfnOrd)) {
    6b32:	str	r5, [sp, #0]
    6b34:	ldr	r3, [sp, #12]
    6b36:	ldr	r0, [sp, #24]
    6b38:	mov	r2, r7
    6b3a:	mov	r1, r6
    6b3c:	bl	5896 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)>
    6b40:	b.n	6b48 <FatFile::open(FatFile*, FatName_t*, int)+0x244>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Number of directory entries needed.
  nameOrd = (fname->len + 12)/13;
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + nameOrd : 1;
    6b42:	mov.w	fp, #1
    6b46:	b.n	6948 <FatFile::open(FatFile*, FatName_t*, int)+0x44>
  }
  return true;

 fail:
  return false;
}
    6b48:	add	sp, #44	; 0x2c
    6b4a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    6b4e:	nop
    6b50:	.word	0x1fff8418

00006b54 <FatFile::parsePathName(char const*, FatName_t*, char const**)>:
//------------------------------------------------------------------------------
bool FatFile::parsePathName(const char* path,
                            FatName_t* fname, const char** ptr) {
    6b54:	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    6b56:	mov	r4, r2
    6b58:	mov	r6, r3
    6b5a:	mov	r0, r1
    6b5c:	adds	r1, #1
  size_t len = 0;
  // Skip leading spaces.
  while (*path == ' ') {
    6b5e:	ldrb	r3, [r0, #0]
    6b60:	cmp	r3, #32
    6b62:	beq.n	6b5a <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x6>
}
#endif  // USE_SIMPLE_LITTLE_ENDIAN
//------------------------------------------------------------------------------
// Reserved characters for exFAT names and FAT LFN.
inline bool lfnReservedChar(uint8_t c) {
  return c < 0X20 || c == '"' || c == '*' || c == '/' || c == ':'
    6b64:	ldr	r7, [pc, #128]	; (6be8 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x94>)
    path++;
  }
  fname->begin = path;
    6b66:	str	r0, [r4, #0]
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::parsePathName(const char* path,
                            FatName_t* fname, const char** ptr) {
  size_t len = 0;
    6b68:	movs	r5, #0
  // Skip leading spaces.
  while (*path == ' ') {
    path++;
  }
  fname->begin = path;
  while (*path && !isDirSeparator(*path)) {
    6b6a:	ldrb	r3, [r0, #0]
    6b6c:	cbz	r3, 6bc0 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x6c>
    6b6e:	cmp	r3, #47	; 0x2f
    6b70:	beq.n	6bc0 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x6c>
#if USE_UTF8_LONG_NAMES
    uint32_t cp;
    // Allow end = path + 4 since path is zero terminated.
    path = FsUtf::mbToCp(path, path + 4, &cp);
    6b72:	add	r2, sp, #4
    6b74:	adds	r1, r0, #4
    6b76:	bl	2d64 <FsUtf::mbToCp(char const*, char const*, unsigned long*)>
    if (!path) {
    6b7a:	cbz	r0, 6be0 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    len += cp <= 0XFFFF ? 1 : 2;
    6b7c:	ldr	r2, [sp, #4]
    6b7e:	cmp.w	r2, #65536	; 0x10000
    6b82:	ite	cs
    6b84:	movcs	r3, #2
    6b86:	movcc	r3, #1
    if (cp < 0X80 && lfnReservedChar(cp)) {
    6b88:	cmp	r2, #127	; 0x7f
    path = FsUtf::mbToCp(path, path + 4, &cp);
    if (!path) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    len += cp <= 0XFFFF ? 1 : 2;
    6b8a:	add	r5, r3
    if (cp < 0X80 && lfnReservedChar(cp)) {
    6b8c:	bhi.n	6bb6 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x62>
      || c == '<' || c == '>' || c == '?' || c == '\\'|| c == '|';
    6b8e:	cmp	r2, #31
    6b90:	bls.n	6be0 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8c>
    6b92:	uxtb	r3, r2
}
#endif  // USE_SIMPLE_LITTLE_ENDIAN
//------------------------------------------------------------------------------
// Reserved characters for exFAT names and FAT LFN.
inline bool lfnReservedChar(uint8_t c) {
  return c < 0X20 || c == '"' || c == '*' || c == '/' || c == ':'
    6b94:	sub.w	r1, r3, #34	; 0x22
    6b98:	uxtb	r1, r1
    6b9a:	cmp	r1, #29
    6b9c:	bhi.n	6ba6 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x52>
    6b9e:	lsr.w	r1, r7, r1
    6ba2:	lsls	r1, r1, #31
    6ba4:	bmi.n	6be0 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8c>
      || c == '<' || c == '>' || c == '?' || c == '\\'|| c == '|';
    6ba6:	and.w	r3, r3, #191	; 0xbf
    6baa:	cmp	r3, #60	; 0x3c
    6bac:	beq.n	6be0 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8c>
    6bae:	cmp	r2, #92	; 0x5c
    6bb0:	beq.n	6be0 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    len++;
#endif  // USE_UTF8_LONG_NAMES
    if (cp != '.' && cp != ' ') {
    6bb2:	cmp	r2, #46	; 0x2e
    6bb4:	beq.n	6b6a <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x16>
    6bb6:	cmp	r2, #32
    6bb8:	beq.n	6b6a <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x16>
      // Need to trim trailing dots spaces.
      fname->len = len;
    6bba:	str	r5, [r4, #16]
      fname->end = path;
    6bbc:	str	r0, [r4, #8]
  // Skip leading spaces.
  while (*path == ' ') {
    path++;
  }
  fname->begin = path;
  while (*path && !isDirSeparator(*path)) {
    6bbe:	b.n	6b6a <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x16>
      // Need to trim trailing dots spaces.
      fname->len = len;
      fname->end = path;
    }
  }
  if (!fname->len || fname->len > FAT_MAX_LFN_LENGTH) {
    6bc0:	ldr	r3, [r4, #16]
    6bc2:	subs	r3, #1
    6bc4:	cmp	r3, #254	; 0xfe
    6bc6:	bhi.n	6be0 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8c>
    6bc8:	mov	r2, r0
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Advance to next path component.
  for (; *path == ' ' || isDirSeparator(*path); path++) {}
    6bca:	ldrb.w	r3, [r0], #1
    6bce:	cmp	r3, #32
    6bd0:	beq.n	6bc8 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x74>
    6bd2:	cmp	r3, #47	; 0x2f
    6bd4:	beq.n	6bc8 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x74>
  *ptr = path;
    6bd6:	str	r2, [r6, #0]
  return makeSFN(fname);
    6bd8:	mov	r0, r4
    6bda:	bl	6748 <FatFile::makeSFN(FatName_t*)>
    6bde:	b.n	6be2 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8e>

 fail:
  return false;
    6be0:	movs	r0, #0
}
    6be2:	add	sp, #12
    6be4:	pop	{r4, r5, r6, r7, pc}
    6be6:	nop
    6be8:	.word	0x31002101

00006bec <FatFile::remove()>:
//------------------------------------------------------------------------------
bool FatFile::remove() {
    6bec:	push	{r4, r5, r6, r7, lr}
    6bee:	sub	sp, #44	; 0x2c
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    6bf0:	movs	r3, #0
    6bf2:	strb.w	r3, [sp, #4]
    6bf6:	strb.w	r3, [sp, #5]
    6bfa:	strb.w	r3, [sp, #6]
  FatFile dirFile;
  DirFat_t* dir;
  DirLfn_t* ldir;

  // Cant' remove not open for write.
  if (!isWritable()) {
    6bfe:	ldrb	r3, [r0, #2]
    6c00:	lsls	r2, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::remove() {
    6c02:	mov	r4, r0
  FatFile dirFile;
  DirFat_t* dir;
  DirLfn_t* ldir;

  // Cant' remove not open for write.
  if (!isWritable()) {
    6c04:	bpl.n	6c36 <FatFile::remove()+0x4a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster && !m_vol->freeChain(m_firstCluster)) {
    6c06:	ldr	r1, [r0, #32]
    6c08:	cbz	r1, 6c12 <FatFile::remove()+0x26>
    6c0a:	ldr	r0, [r0, #8]
    6c0c:	bl	63ca <FatPartition::freeChain(unsigned long)>
    6c10:	cbz	r0, 6c36 <FatFile::remove()+0x4a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Cache directory entry.
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    6c12:	movs	r1, #1
    6c14:	mov	r0, r4
    6c16:	bl	5594 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    6c1a:	mov	r5, r0
    6c1c:	cbz	r0, 6c36 <FatFile::remove()+0x4a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  checksum = lfnChecksum(dir->name);
    6c1e:	bl	65ba <FatFile::lfnChecksum(unsigned char*) [clone .isra.14]>

  // Mark entry deleted.
  dir->name[0] = FAT_NAME_DELETED;
    6c22:	movs	r6, #229	; 0xe5
    6c24:	strb	r6, [r5, #0]

  // Set this file closed.
  m_attributes = FILE_ATTR_CLOSED;
    6c26:	movs	r3, #0
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
  if (!dir) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  checksum = lfnChecksum(dir->name);
    6c28:	mov	r7, r0

  // Mark entry deleted.
  dir->name[0] = FAT_NAME_DELETED;

  // Set this file closed.
  m_attributes = FILE_ATTR_CLOSED;
    6c2a:	strb	r3, [r4, #0]
  m_flags = 0;
    6c2c:	strb	r3, [r4, #2]

  // Write entry to device.
  if (!m_vol->cacheSync()) {
    6c2e:	ldr	r0, [r4, #8]
    6c30:	bl	54ac <FatPartition::cacheSync()>
    6c34:	cbnz	r0, 6c3a <FatFile::remove()+0x4e>
  }
  // Fall into fail.
  DBG_FAIL_MACRO;

 fail:
  return false;
    6c36:	movs	r0, #0
    6c38:	b.n	6c9a <FatFile::remove()+0xae>
  // Write entry to device.
  if (!m_vol->cacheSync()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!isLFN()) {
    6c3a:	ldrb	r3, [r4, #3]
    6c3c:	cbz	r3, 6c9a <FatFile::remove()+0xae>
    // Done, no LFN entries.
    return true;
  }
  if (!dirFile.openCluster(this)) {
    6c3e:	mov	r1, r4
    6c40:	add	r0, sp, #4
    6c42:	bl	55e2 <FatFile::openCluster(FatFile*)>
    6c46:	cmp	r0, #0
    6c48:	beq.n	6c36 <FatFile::remove()+0x4a>
    6c4a:	movs	r5, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    6c4c:	ldrb	r3, [r4, #3]
    6c4e:	cmp	r3, r5
    6c50:	bcc.n	6c36 <FatFile::remove()+0x4a>
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.cacheDir(m_dirIndex - order));
    6c52:	ldrh	r1, [r4, #4]
    6c54:	subs	r1, r1, r5
    6c56:	uxth	r1, r1
    6c58:	add	r0, sp, #4
    6c5a:	bl	52ec <FatFile::cacheDir(unsigned short)>
    if (!ldir) {
    6c5e:	cmp	r0, #0
    6c60:	beq.n	6c36 <FatFile::remove()+0x4a>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
    6c62:	ldrb	r3, [r0, #11]
    6c64:	cmp	r3, #15
    6c66:	bne.n	6c36 <FatFile::remove()+0x4a>
        order != (ldir->order & 0X1F) ||
    6c68:	ldrb	r2, [r0, #0]
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.cacheDir(m_dirIndex - order));
    if (!ldir) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
    6c6a:	and.w	r3, r2, #31
    6c6e:	cmp	r5, r3
    6c70:	bne.n	6c36 <FatFile::remove()+0x4a>
        order != (ldir->order & 0X1F) ||
    6c72:	ldrb	r3, [r0, #13]
    6c74:	cmp	r3, r7
    6c76:	bne.n	6c36 <FatFile::remove()+0x4a>
        checksum != ldir->checksum) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    last = ldir->order & FAT_ORDER_LAST_LONG_ENTRY;
    ldir->order = FAT_NAME_DELETED;
    6c78:	strb	r6, [r0, #0]
    m_vol->cacheDirty();
    6c7a:	ldr	r1, [r4, #8]
    6c7c:	ldrb.w	r3, [r1, #40]	; 0x28
    6c80:	orr.w	r3, r3, #1
    6c84:	strb.w	r3, [r1, #40]	; 0x28
    if (last) {
    6c88:	lsls	r3, r2, #25
    6c8a:	bpl.n	6c94 <FatFile::remove()+0xa8>
      if (!m_vol->cacheSync()) {
    6c8c:	ldr	r0, [r4, #8]
    6c8e:	bl	54ac <FatPartition::cacheSync()>
    6c92:	b.n	6c9a <FatFile::remove()+0xae>
  }
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    6c94:	adds	r5, #1
    6c96:	uxtb	r5, r5
    6c98:	b.n	6c4c <FatFile::remove()+0x60>
  // Fall into fail.
  DBG_FAIL_MACRO;

 fail:
  return false;
}
    6c9a:	add	sp, #44	; 0x2c
    6c9c:	pop	{r4, r5, r6, r7, pc}

00006c9e <FsBaseFile::FsBaseFile(FsBaseFile const&)>:
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
//------------------------------------------------------------------------------
FsBaseFile::FsBaseFile(const FsBaseFile& from) {
    6c9e:	push	{r3, r4, r5, r6, r7, lr}
    6ca0:	movs	r4, #0
    6ca2:	str	r4, [r0, #56]	; 0x38
  m_fFile = nullptr;
  m_xFile = nullptr;
  if (from.m_fFile) {
    6ca4:	ldr	r7, [r1, #56]	; 0x38
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
//------------------------------------------------------------------------------
FsBaseFile::FsBaseFile(const FsBaseFile& from) {
    6ca6:	str	r4, [r0, #60]	; 0x3c
    6ca8:	mov	r6, r0
    6caa:	mov	r5, r1
  m_fFile = nullptr;
  m_xFile = nullptr;
  if (from.m_fFile) {
    6cac:	cbz	r7, 6cd0 <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x32>
    m_fFile = new (m_fileMem) FatFile;
    6cae:	mov	r1, r0
    6cb0:	movs	r0, #36	; 0x24
    6cb2:	bl	6ee8 <operator new(unsigned int, unsigned long*)>
    6cb6:	strb	r4, [r0, #0]
    6cb8:	strb	r4, [r0, #1]
    6cba:	strb	r4, [r0, #2]
    6cbc:	str	r0, [r6, #56]	; 0x38
    *m_fFile = *from.m_fFile;
    6cbe:	ldr	r5, [r5, #56]	; 0x38
    6cc0:	mov	r4, r0
    6cc2:	ldmia	r5!, {r0, r1, r2, r3}
    6cc4:	stmia	r4!, {r0, r1, r2, r3}
    6cc6:	ldmia	r5!, {r0, r1, r2, r3}
    6cc8:	stmia	r4!, {r0, r1, r2, r3}
    6cca:	ldr	r3, [r5, #0]
    6ccc:	str	r3, [r4, #0]
    6cce:	b.n	6cfc <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x5e>
  } else if (from.m_xFile) {
    6cd0:	ldr	r3, [r1, #60]	; 0x3c
    6cd2:	cbz	r3, 6cfc <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x5e>
    m_xFile = new (m_fileMem) ExFatFile;
    6cd4:	mov	r1, r0
    6cd6:	movs	r0, #56	; 0x38
    6cd8:	bl	6ee8 <operator new(unsigned int, unsigned long*)>
    6cdc:	strb.w	r7, [r0, #49]	; 0x31
    6ce0:	strb.w	r7, [r0, #50]	; 0x32
    6ce4:	strb.w	r7, [r0, #51]	; 0x33
    6ce8:	str	r0, [r6, #60]	; 0x3c
    *m_xFile = *from.m_xFile;
    6cea:	ldr	r3, [r5, #60]	; 0x3c
    6cec:	add.w	r2, r3, #52	; 0x34
    6cf0:	ldr.w	r1, [r3], #4
    6cf4:	str.w	r1, [r0], #4
    6cf8:	cmp	r3, r2
    6cfa:	bne.n	6cf0 <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x52>
  }
}
    6cfc:	mov	r0, r6
    6cfe:	pop	{r3, r4, r5, r6, r7, pc}

00006d00 <FsBaseFile::close()>:
    *m_xFile = *from.m_xFile;
  }
  return *this;
}
//------------------------------------------------------------------------------
bool FsBaseFile::close() {
    6d00:	push	{r4, lr}
    6d02:	mov	r4, r0
  if (m_fFile && m_fFile->close()) {
    6d04:	ldr	r0, [r0, #56]	; 0x38
    6d06:	cbz	r0, 6d0e <FsBaseFile::close()+0xe>
    6d08:	bl	5ac0 <FatFile::close()>
    6d0c:	cbnz	r0, 6d1e <FsBaseFile::close()+0x1e>
    m_fFile = nullptr;
    return true;
  }
  if (m_xFile && m_xFile->close()) {
    6d0e:	ldr	r0, [r4, #60]	; 0x3c
    6d10:	cbz	r0, 6d24 <FsBaseFile::close()+0x24>
    6d12:	bl	38b2 <ExFatFile::close()>
    6d16:	cbz	r0, 6d24 <FsBaseFile::close()+0x24>
    m_xFile = nullptr;
    6d18:	movs	r3, #0
    6d1a:	str	r3, [r4, #60]	; 0x3c
    6d1c:	pop	{r4, pc}
  return *this;
}
//------------------------------------------------------------------------------
bool FsBaseFile::close() {
  if (m_fFile && m_fFile->close()) {
    m_fFile = nullptr;
    6d1e:	movs	r3, #0
    6d20:	str	r3, [r4, #56]	; 0x38
    return true;
    6d22:	pop	{r4, pc}
  }
  if (m_xFile && m_xFile->close()) {
    m_xFile = nullptr;
    return true;
  }
  return false;
    6d24:	movs	r0, #0
}
    6d26:	pop	{r4, pc}

00006d28 <FsBaseFile::open(FsVolume*, char const*, int)>:
    m_xFile = nullptr;
  }
  return false;
}
//------------------------------------------------------------------------------
bool FsBaseFile::open(FsVolume* vol, const char* path, oflag_t oflag) {
    6d28:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    6d2c:	mov	r4, r0
    6d2e:	mov	r7, r2
    6d30:	mov	r8, r3
  if (!vol) {
    6d32:	mov	r5, r1
    6d34:	cbnz	r1, 6d3c <FsBaseFile::open(FsVolume*, char const*, int)+0x14>
    return false;
    6d36:	movs	r0, #0
    6d38:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  }
  close();
    6d3c:	bl	6d00 <FsBaseFile::close()>
  if (vol->m_fVol) {
    6d40:	ldr.w	r6, [r5, #1152]	; 0x480
    6d44:	cbz	r6, 6d6c <FsBaseFile::open(FsVolume*, char const*, int)+0x44>
    m_fFile = new (m_fileMem) FatFile;
    6d46:	mov	r1, r4
    6d48:	movs	r0, #36	; 0x24
    6d4a:	bl	6ee8 <operator new(unsigned int, unsigned long*)>
    6d4e:	movs	r2, #0
    6d50:	strb	r2, [r0, #0]
    6d52:	strb	r2, [r0, #1]
    6d54:	strb	r2, [r0, #2]
    if (m_fFile && m_fFile->open(vol->m_fVol, path, oflag)) {
    6d56:	mov	r3, r8
  if (!vol) {
    return false;
  }
  close();
  if (vol->m_fVol) {
    m_fFile = new (m_fileMem) FatFile;
    6d58:	str	r0, [r4, #56]	; 0x38
    if (m_fFile && m_fFile->open(vol->m_fVol, path, oflag)) {
    6d5a:	mov	r2, r7
    6d5c:	ldr.w	r1, [r5, #1152]	; 0x480
    6d60:	bl	5b78 <FatFile::open(FatVolume*, char const*, int)>
    6d64:	cbz	r0, 6da0 <FsBaseFile::open(FsVolume*, char const*, int)+0x78>
      return true;
    6d66:	movs	r0, #1
    6d68:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
    m_fFile = nullptr;
  } else if (vol->m_xVol) {
    6d6c:	ldr.w	r3, [r5, #1156]	; 0x484
    6d70:	cmp	r3, #0
    6d72:	beq.n	6d36 <FsBaseFile::open(FsVolume*, char const*, int)+0xe>
    m_xFile = new (m_fileMem) ExFatFile;
    6d74:	mov	r1, r4
    6d76:	movs	r0, #56	; 0x38
    6d78:	bl	6ee8 <operator new(unsigned int, unsigned long*)>
    6d7c:	strb.w	r6, [r0, #49]	; 0x31
    6d80:	strb.w	r6, [r0, #50]	; 0x32
    6d84:	strb.w	r6, [r0, #51]	; 0x33
    if (m_xFile && m_xFile->open(vol->m_xVol, path, oflag)) {
    6d88:	mov	r3, r8
    if (m_fFile && m_fFile->open(vol->m_fVol, path, oflag)) {
      return true;
    }
    m_fFile = nullptr;
  } else if (vol->m_xVol) {
    m_xFile = new (m_fileMem) ExFatFile;
    6d8a:	str	r0, [r4, #60]	; 0x3c
    if (m_xFile && m_xFile->open(vol->m_xVol, path, oflag)) {
    6d8c:	mov	r2, r7
    6d8e:	ldr.w	r1, [r5, #1156]	; 0x484
    6d92:	bl	4032 <ExFatFile::open(ExFatVolume*, char const*, int)>
    6d96:	cmp	r0, #0
    6d98:	bne.n	6d66 <FsBaseFile::open(FsVolume*, char const*, int)+0x3e>
      return true;
    }
    m_xFile = nullptr;
    6d9a:	str	r0, [r4, #60]	; 0x3c
  }
  return false;
}
    6d9c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (vol->m_fVol) {
    m_fFile = new (m_fileMem) FatFile;
    if (m_fFile && m_fFile->open(vol->m_fVol, path, oflag)) {
      return true;
    }
    m_fFile = nullptr;
    6da0:	str	r0, [r4, #56]	; 0x38
    6da2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00006da6 <FsBaseFile::openNext(FsBaseFile*, int)>:
    m_xFile = nullptr;
  }
  return false;
}
//------------------------------------------------------------------------------
bool FsBaseFile::openNext(FsBaseFile* dir, oflag_t oflag) {
    6da6:	push	{r3, r4, r5, r6, r7, lr}
    6da8:	mov	r5, r1
    6daa:	mov	r4, r0
    6dac:	mov	r7, r2
  close();
    6dae:	bl	6d00 <FsBaseFile::close()>
  if (dir->m_fFile) {
    6db2:	ldr	r6, [r5, #56]	; 0x38
    6db4:	cbz	r6, 6dda <FsBaseFile::openNext(FsBaseFile*, int)+0x34>
    m_fFile = new (m_fileMem) FatFile;
    6db6:	mov	r1, r4
    6db8:	movs	r0, #36	; 0x24
    6dba:	bl	6ee8 <operator new(unsigned int, unsigned long*)>
    6dbe:	movs	r2, #0
    6dc0:	strb	r2, [r0, #0]
    6dc2:	strb	r2, [r0, #1]
    6dc4:	strb	r2, [r0, #2]
    6dc6:	str	r0, [r4, #56]	; 0x38
    if (m_fFile->openNext(dir->m_fFile, oflag)) {
    6dc8:	mov	r2, r7
    6dca:	ldr	r1, [r5, #56]	; 0x38
    6dcc:	bl	5958 <FatFile::openNext(FatFile*, int)>
    6dd0:	cbz	r0, 6dd6 <FsBaseFile::openNext(FsBaseFile*, int)+0x30>
      return true;
    6dd2:	movs	r0, #1
    6dd4:	pop	{r3, r4, r5, r6, r7, pc}
    }
    m_fFile = nullptr;
    6dd6:	str	r0, [r4, #56]	; 0x38
    6dd8:	pop	{r3, r4, r5, r6, r7, pc}
  } else if (dir->m_xFile) {
    6dda:	ldr	r0, [r5, #60]	; 0x3c
    6ddc:	cbz	r0, 6e02 <FsBaseFile::openNext(FsBaseFile*, int)+0x5c>
    m_xFile = new (m_fileMem) ExFatFile;
    6dde:	mov	r1, r4
    6de0:	movs	r0, #56	; 0x38
    6de2:	bl	6ee8 <operator new(unsigned int, unsigned long*)>
    6de6:	strb.w	r6, [r0, #49]	; 0x31
    6dea:	strb.w	r6, [r0, #50]	; 0x32
    6dee:	strb.w	r6, [r0, #51]	; 0x33
    6df2:	str	r0, [r4, #60]	; 0x3c
    if (m_xFile->openNext(dir->m_xFile, oflag)) {
    6df4:	mov	r2, r7
    6df6:	ldr	r1, [r5, #60]	; 0x3c
    6df8:	bl	4040 <ExFatFile::openNext(ExFatFile*, int)>
    6dfc:	cmp	r0, #0
    6dfe:	bne.n	6dd2 <FsBaseFile::openNext(FsBaseFile*, int)+0x2c>
      return true;
    }
    m_xFile = nullptr;
    6e00:	str	r0, [r4, #60]	; 0x3c
  }
  return false;
}
    6e02:	pop	{r3, r4, r5, r6, r7, pc}

00006e04 <FsVolume::begin(BlockDeviceInterface*)>:
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
FsVolume* FsVolume::m_cwv = nullptr;
//------------------------------------------------------------------------------
bool FsVolume::begin(BlockDevice* blockDev) {
    6e04:	push	{r3, r4, r5, r6, r7, lr}
  m_blockDev = blockDev;
  m_fVol = nullptr;
    6e06:	movs	r6, #0
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
FsVolume* FsVolume::m_cwv = nullptr;
//------------------------------------------------------------------------------
bool FsVolume::begin(BlockDevice* blockDev) {
    6e08:	mov	r4, r0
  m_blockDev = blockDev;
    6e0a:	str.w	r1, [r0, #1160]	; 0x488
  m_fVol = nullptr;
    6e0e:	str.w	r6, [r0, #1152]	; 0x480
  m_xVol = new (m_volMem) ExFatVolume;
    6e12:	mov	r1, r0
    6e14:	mov.w	r0, #1152	; 0x480
    6e18:	bl	6ee8 <operator new(unsigned int, unsigned long*)>
 * \class ExFatPartition
 * \brief Access exFat partitions on raw file devices.
 */
class ExFatPartition {
 public:
  ExFatPartition() {}
    6e1c:	strb.w	r6, [r0, #1092]	; 0x444
    6e20:	strb.w	r6, [r0, #1145]	; 0x479
    6e24:	strb.w	r6, [r0, #1146]	; 0x47a
    6e28:	strb.w	r6, [r0, #1147]	; 0x47b
   * \param[in] setCwv Set current working volume if true.
   * \param[in] part partition to initialize.
   * \return true for success or false for failure.
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
    6e2c:	movs	r2, #1
    6e2e:	str.w	r0, [r4, #1156]	; 0x484
    6e32:	ldr.w	r1, [r4, #1160]	; 0x488
    6e36:	ldr	r7, [pc, #124]	; (6eb4 <FsVolume::begin(BlockDeviceInterface*)+0xb0>)
    6e38:	mov	r5, r0
    6e3a:	bl	4398 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)>
    6e3e:	cbz	r0, 6e58 <FsVolume::begin(BlockDeviceInterface*)+0x54>
  /**
   * Set volume working directory to root.
   * \return true for success or false for failure.
   */
  bool chdir() {
    m_vwd.close();
    6e40:	add.w	r6, r5, #1096	; 0x448
    6e44:	mov	r0, r6
    6e46:	bl	38b2 <ExFatFile::close()>
    return m_vwd.openRoot(this);
    6e4a:	mov	r1, r5
    6e4c:	mov	r0, r6
    6e4e:	bl	3906 <ExFatFile::openRoot(ExFatVolume*)>
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
      return false;
    }
    if (!chdir()) {
    6e52:	cbz	r0, 6e58 <FsVolume::begin(BlockDeviceInterface*)+0x54>
      return false;
    }
    if (setCwv || !m_cwv) {
    6e54:	ldr	r3, [pc, #96]	; (6eb8 <FsVolume::begin(BlockDeviceInterface*)+0xb4>)
    6e56:	b.n	6e9e <FsVolume::begin(BlockDeviceInterface*)+0x9a>
  if (m_xVol && m_xVol->begin(m_blockDev, false)) {
    goto done;
  }
  m_xVol = nullptr;
    6e58:	movs	r6, #0
  m_fVol = new (m_volMem) FatVolume;
    6e5a:	mov	r1, r4
  m_fVol = nullptr;
  m_xVol = new (m_volMem) ExFatVolume;
  if (m_xVol && m_xVol->begin(m_blockDev, false)) {
    goto done;
  }
  m_xVol = nullptr;
    6e5c:	str.w	r6, [r4, #1156]	; 0x484
  m_fVol = new (m_volMem) FatVolume;
    6e60:	movw	r0, #1132	; 0x46c
    6e64:	bl	6ee8 <operator new(unsigned int, unsigned long*)>
 */
class FatPartition {
 public:
  /** Create an instance of FatPartition
   */
  FatPartition() {}
    6e68:	strb	r6, [r0, #7]
    6e6a:	strb.w	r6, [r0, #1096]	; 0x448
    6e6e:	strb.w	r6, [r0, #1097]	; 0x449
    6e72:	strb.w	r6, [r0, #1098]	; 0x44a
   * \param[in] setCwv Set current working volume if true.
   * \param[in] part partition to initialize.
   * \return true for success or false for failure.
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
    6e76:	movs	r2, #1
    6e78:	str.w	r0, [r4, #1152]	; 0x480
    6e7c:	ldr.w	r1, [r4, #1160]	; 0x488
    6e80:	mov	r5, r0
    6e82:	bl	646c <FatPartition::init(BlockDeviceInterface*, unsigned char)>
    6e86:	cbz	r0, 6eaa <FsVolume::begin(BlockDeviceInterface*)+0xa6>
  /**
   * Set volume working directory to root.
   * \return true for success or false for failure.
   */
  bool chdir() {
    m_vwd.close();
    6e88:	add.w	r6, r5, #1096	; 0x448
    6e8c:	mov	r0, r6
    6e8e:	bl	5ac0 <FatFile::close()>
    return m_vwd.openRoot(this);
    6e92:	mov	r1, r5
    6e94:	mov	r0, r6
    6e96:	bl	55b2 <FatFile::openRoot(FatVolume*)>
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
      return false;
    }
    if (!chdir()) {
    6e9a:	cbz	r0, 6eaa <FsVolume::begin(BlockDeviceInterface*)+0xa6>
      return false;
    }
    if (setCwv || !m_cwv) {
    6e9c:	ldr	r3, [pc, #28]	; (6ebc <FsVolume::begin(BlockDeviceInterface*)+0xb8>)
    6e9e:	ldr	r2, [r3, #0]
    6ea0:	cbnz	r2, 6ea4 <FsVolume::begin(BlockDeviceInterface*)+0xa0>
      m_cwv = this;
    6ea2:	str	r5, [r3, #0]
  m_cwv = nullptr;
  m_fVol = nullptr;
  return false;

 done:
  m_cwv = this;
    6ea4:	str	r4, [r7, #0]
  return true;
    6ea6:	movs	r0, #1
    6ea8:	pop	{r3, r4, r5, r6, r7, pc}
  m_xVol = nullptr;
  m_fVol = new (m_volMem) FatVolume;
  if (m_fVol && m_fVol->begin(m_blockDev, false)) {
    goto done;
  }
  m_cwv = nullptr;
    6eaa:	movs	r0, #0
    6eac:	str	r0, [r7, #0]
  m_fVol = nullptr;
    6eae:	str.w	r0, [r4, #1152]	; 0x480
  return false;

 done:
  m_cwv = this;
  return true;
}
    6eb2:	pop	{r3, r4, r5, r6, r7, pc}
    6eb4:	.word	0x1fff8424
    6eb8:	.word	0x1fff841c
    6ebc:	.word	0x1fff8420

00006ec0 <FsVolume::open(char const*, int)>:
bool FsVolume::ls(print_t* pr, const char* path, uint8_t flags) {
  FsBaseFile dir;
  return dir.open(this, path, O_RDONLY) && dir.ls(pr, flags);
}
//------------------------------------------------------------------------------
FsFile FsVolume::open(const char *path, oflag_t oflag) {
    6ec0:	push	{r3, r4, r5, lr}
    6ec2:	mov	r4, r0
class __FlashStringHelper;

class Print
{
  public:
	constexpr Print() : write_error(0) {}
    6ec4:	movs	r0, #0
    6ec6:	strb	r0, [r4, #4]
    6ec8:	strb	r0, [r4, #12]
 * \brief FsBaseFile class.
 */
class FsBaseFile {
 public:
  /** Create an instance. */
  FsBaseFile() {}
    6eca:	str	r0, [r4, #72]	; 0x48
    6ecc:	str	r0, [r4, #76]	; 0x4c
    6ece:	mov.w	r5, #1000	; 0x3e8
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
    6ed2:	mov	r0, r4
    6ed4:	str	r5, [r4, #8]
    6ed6:	ldr	r5, [pc, #12]	; (6ee4 <FsVolume::open(char const*, int)+0x24>)
    6ed8:	str.w	r5, [r0], #16
  FsFile tmpFile;
  tmpFile.open(this, path, oflag);
    6edc:	bl	6d28 <FsBaseFile::open(FsVolume*, char const*, int)>
  return tmpFile;
}
    6ee0:	mov	r0, r4
    6ee2:	pop	{r3, r4, r5, pc}
    6ee4:	.word	0x00011cbc

00006ee8 <operator new(unsigned int, unsigned long*)>:
 */
#include "FsNew.h"
void* operator new(size_t size, newalign_t* ptr) {
  (void)size;
  return ptr;
}
    6ee8:	mov	r0, r1
    6eea:	bx	lr

00006eec <SdSpiCard::errorCode() const>:
  /**
   * \return code for the last error. See SdCardInfo.h for a list of error codes.
   */
  uint8_t errorCode() const {
    return m_errorCode;
  }
    6eec:	ldrb	r0, [r0, #15]
    6eee:	bx	lr

00006ef0 <SdSpiCard::errorData() const>:
  /** \return error data for last error. */
  uint32_t errorData() const {
    return m_status;
  }
    6ef0:	ldrb	r0, [r0, #17]
    6ef2:	bx	lr

00006ef4 <SdSpiCard::readSector(unsigned long, unsigned char*)>:
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool readSector(uint32_t sector, uint8_t* dst) {
#if ENABLE_DEDICATED_SPI
    return readSectors(sector, dst, 1);
    6ef4:	ldr	r3, [r0, #0]
   *
   * \param[in] sector Logical sector to be read.
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool readSector(uint32_t sector, uint8_t* dst) {
    6ef6:	push	{r4}
#if ENABLE_DEDICATED_SPI
    return readSectors(sector, dst, 1);
    6ef8:	ldr	r4, [r3, #16]
    6efa:	movs	r3, #1
    6efc:	mov	ip, r4
#else  // ENABLE_DEDICATED_SPI
    return readSingle(sector, dst);
#endif  // ENABLE_DEDICATED_SPI
  }
    6efe:	ldr.w	r4, [sp], #4
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool readSector(uint32_t sector, uint8_t* dst) {
#if ENABLE_DEDICATED_SPI
    return readSectors(sector, dst, 1);
    6f02:	bx	ip

00006f04 <SdSpiCard::type() const>:
  /** Return the card type: SD V1, SD V2 or SDHC/SDXC
   * \return 0 - SD V1, 1 - SD V2, or 3 - SDHC/SDXC.
   */
  uint8_t type() const {
    return m_type;
  }
    6f04:	ldrb	r0, [r0, #18]
    6f06:	bx	lr

00006f08 <SdSpiCard::~SdSpiCard()>:
/**
 * \class SdSpiCard
 * \brief Raw access to SD and SDHC flash memory cards via SPI protocol.
 */
#if HAS_SDIO_CLASS
class SdSpiCard : public SdCardInterface {
    6f08:	bx	lr

00006f0a <SdSpiCard::~SdSpiCard()>:
    6f0a:	push	{r4, lr}
    6f0c:	movs	r1, #20
    6f0e:	mov	r4, r0
    6f10:	bl	9c08 <operator delete(void*, unsigned int)>
    6f14:	mov	r0, r4
    6f16:	pop	{r4, pc}

00006f18 <SdSpiCard::sectorCount()>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
uint32_t SdSpiCard::sectorCount() {
    6f18:	push	{r0, r1, r2, r3, r4, lr}
  csd_t csd;
  return readCSD(&csd) ? sdCardCapacity(&csd) : 0;
    6f1a:	ldr	r3, [r0, #0]
    6f1c:	mov	r1, sp
    6f1e:	ldr	r3, [r3, #60]	; 0x3c
    6f20:	blx	r3
    6f22:	cbz	r0, 6f92 <SdSpiCard::sectorCount()+0x7a>
  csd1_t v1;
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    6f24:	ldrb.w	r3, [sp]
    6f28:	ands.w	r3, r3, #192	; 0xc0
    6f2c:	bne.n	6f6e <SdSpiCard::sectorCount()+0x56>
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
    6f2e:	ldrb.w	r0, [sp, #6]
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    6f32:	ldrb.w	r3, [sp, #7]
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    6f36:	ldrb.w	r2, [sp, #10]
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    6f3a:	and.w	r0, r0, #3
    6f3e:	lsls	r3, r3, #2
    6f40:	orr.w	r3, r3, r0, lsl #10
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    6f44:	ldrb.w	r0, [sp, #8]
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    6f48:	orr.w	r0, r3, r0, lsr #6
    6f4c:	adds	r3, r0, #1
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
    6f4e:	ldrb.w	r0, [sp, #9]
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    6f52:	and.w	r0, r0, #3
    6f56:	lsls	r0, r0, #1
    6f58:	orr.w	r0, r0, r2, lsr #7
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    6f5c:	ldrb.w	r2, [sp, #5]
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    6f60:	and.w	r2, r2, #15
    6f64:	add	r0, r2
    6f66:	subs	r0, #7
    6f68:	lsl.w	r0, r3, r0
    6f6c:	b.n	6f92 <SdSpiCard::sectorCount()+0x7a>
  } else if (csd->v2.csd_ver == 1) {
    6f6e:	cmp	r3, #64	; 0x40
    6f70:	bne.n	6f90 <SdSpiCard::sectorCount()+0x78>
    return (((uint32_t)csd->v2.c_size_high << 16) +
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    6f72:	ldrb.w	r0, [sp, #9]
    6f76:	adds	r3, r0, #1
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
  } else if (csd->v2.csd_ver == 1) {
    return (((uint32_t)csd->v2.c_size_high << 16) +
    6f78:	ldrb.w	r0, [sp, #7]
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    6f7c:	and.w	r0, r0, #63	; 0x3f
    6f80:	add.w	r0, r3, r0, lsl #16
    6f84:	ldrb.w	r3, [sp, #8]
    6f88:	add.w	r0, r0, r3, lsl #8
    6f8c:	lsls	r0, r0, #10
    6f8e:	b.n	6f92 <SdSpiCard::sectorCount()+0x7a>
    6f90:	movs	r0, #0
}
    6f92:	add	sp, #20
    6f94:	ldr.w	pc, [sp], #4

00006f98 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>:
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return m_spiDriverPtr->receive(buf, n);
  }
  void spiSend(uint8_t data) {
    m_spiDriverPtr->send(data);
    6f98:	ldr	r3, [r0, #0]
    6f9a:	ldr	r3, [r3, #20]
    6f9c:	bx	r3

00006f9e <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>:
  }
  void spiDeactivate() {
    m_spiDriverPtr->deactivate();
  }
  uint8_t spiReceive() {
    return m_spiDriverPtr->receive();
    6f9e:	ldr	r3, [r0, #0]
    6fa0:	ldr	r3, [r3, #12]
    6fa2:	bx	r3

00006fa4 <SysCall::curTimeMS()>:
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    6fa4:	ldr	r3, [pc, #12]	; (6fb4 <SysCall::curTimeMS()+0x10>)
/** Define macro for strings stored in flash. */
#define F(str) (str)
#endif  // F
//------------------------------------------------------------------------------
/** \return the time in milliseconds. */
inline SdMillis_t SysCall::curTimeMS() {
    6fa6:	sub	sp, #8
    6fa8:	ldr	r3, [r3, #0]
    6faa:	str	r3, [sp, #4]
	return ret;
    6fac:	ldr	r0, [sp, #4]
  return millis();
}
    6fae:	uxth	r0, r0
    6fb0:	add	sp, #8
    6fb2:	bx	lr
    6fb4:	.word	0x1fff8484

00006fb8 <SdSpiCard::spiStart()>:
//------------------------------------------------------------------------------
void SdSpiCard::spiStart() {
    6fb8:	push	{r3, r4, r5, lr}
  if (!m_spiActive) {
    6fba:	ldrb	r5, [r0, #16]
uint32_t SdSpiCard::sectorCount() {
  csd_t csd;
  return readCSD(&csd) ? sdCardCapacity(&csd) : 0;
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStart() {
    6fbc:	mov	r4, r0
  if (!m_spiActive) {
    6fbe:	cbnz	r5, 6fdc <SdSpiCard::spiStart()+0x24>
    6fc0:	ldr	r0, [r0, #4]
    m_spiDriver.setSckSpeed(maxSck);
  }
  SdSpiDriver m_spiDriver;
#else  // SPI_DRIVER_SELECT < 2
  void spiActivate() {
    m_spiDriverPtr->activate();
    6fc2:	ldr	r3, [r0, #0]
    6fc4:	ldr	r3, [r3, #0]
    6fc6:	blx	r3
  uint8_t cardCommand(uint8_t cmd, uint32_t arg);
  bool isTimedOut(SdMillis_t startMS, SdMillis_t timeoutMS);
  bool readData(uint8_t* dst, size_t count);
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
    6fc8:	mov	r1, r5
    6fca:	ldrb	r0, [r4, #14]
    6fcc:	bl	1968 <sdCsWrite(unsigned char, bool)>
    spiActivate();
    spiSelect();
    // Dummy byte to drive MISO busy status.
    spiSend(0XFF);    
    6fd0:	movs	r1, #255	; 0xff
    6fd2:	ldr	r0, [r4, #4]
    6fd4:	bl	6f98 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
    m_spiActive = true;
    6fd8:	movs	r3, #1
    6fda:	strb	r3, [r4, #16]
    6fdc:	pop	{r3, r4, r5, pc}

00006fde <SdSpiCard::spiStop()>:
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    6fde:	ldrb	r3, [r0, #16]
    spiSend(0XFF);    
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
    6fe0:	push	{r4, lr}
    6fe2:	mov	r4, r0
  if (m_spiActive) {
    6fe4:	cbz	r3, 7002 <SdSpiCard::spiStop()+0x24>
  }
  void type(uint8_t value) {
    m_type = value;
  }
  void spiUnselect() {
    sdCsWrite(m_csPin, true);
    6fe6:	movs	r1, #1
    6fe8:	ldrb	r0, [r0, #14]
    6fea:	bl	1968 <sdCsWrite(unsigned char, bool)>
    spiUnselect();
    // Insure MISO goes to low Z.
    spiSend(0XFF);        
    6fee:	movs	r1, #255	; 0xff
    6ff0:	ldr	r0, [r4, #4]
    6ff2:	bl	6f98 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
    6ff6:	ldr	r0, [r4, #4]
  }
  void spiBegin(SdSpiConfig spiConfig) {
    m_spiDriverPtr->begin(spiConfig);
  }
  void spiDeactivate() {
    m_spiDriverPtr->deactivate();
    6ff8:	ldr	r3, [r0, #0]
    6ffa:	ldr	r3, [r3, #8]
    6ffc:	blx	r3
    spiDeactivate();
    m_spiActive = false;
    6ffe:	movs	r3, #0
    7000:	strb	r3, [r4, #16]
    7002:	pop	{r4, pc}

00007004 <SdSpiCard::isBusy()>:
bool SdSpiCard::eraseSingleSectorEnable() {
  csd_t csd;
  return readCSD(&csd) ? csd.v1.erase_blk_en : false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::isBusy() {
    7004:	push	{r4, r5, r6, lr}
#if ENABLE_DEDICATED_SPI
  if (m_curState == READ_STATE) {
    7006:	ldrb	r3, [r0, #12]
    7008:	cmp	r3, #1
bool SdSpiCard::eraseSingleSectorEnable() {
  csd_t csd;
  return readCSD(&csd) ? csd.v1.erase_blk_en : false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::isBusy() {
    700a:	mov	r5, r0
#if ENABLE_DEDICATED_SPI
  if (m_curState == READ_STATE) {
    700c:	beq.n	702e <SdSpiCard::isBusy()+0x2a>
    return false;
  }
#endif  // ENABLE_DEDICATED_SPI
  bool spiActive = m_spiActive;
    700e:	ldrb	r6, [r0, #16]
  if (!spiActive) {
    7010:	cbnz	r6, 7016 <SdSpiCard::isBusy()+0x12>
    spiStart();
    7012:	bl	6fb8 <SdSpiCard::spiStart()>
  }
  bool rtn = 0XFF != spiReceive();
    7016:	ldr	r0, [r5, #4]
    7018:	bl	6f9e <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    701c:	subs.w	r4, r0, #255	; 0xff
    7020:	it	ne
    7022:	movne	r4, #1
  if (!spiActive) {
    7024:	cbnz	r6, 7032 <SdSpiCard::isBusy()+0x2e>
    spiStop();
    7026:	mov	r0, r5
    7028:	bl	6fde <SdSpiCard::spiStop()>
    702c:	b.n	7032 <SdSpiCard::isBusy()+0x2e>
}
//------------------------------------------------------------------------------
bool SdSpiCard::isBusy() {
#if ENABLE_DEDICATED_SPI
  if (m_curState == READ_STATE) {
    return false;
    702e:	movs	r0, #0
    7030:	pop	{r4, r5, r6, pc}
  }
  bool rtn = 0XFF != spiReceive();
  if (!spiActive) {
    spiStop();
  }
  return rtn;
    7032:	mov	r0, r4
}
    7034:	pop	{r4, r5, r6, pc}

00007036 <SdSpiCard::readData(unsigned char*, unsigned int)>:
//------------------------------------------------------------------------------
bool SdSpiCard::readData(uint8_t* dst) {
  return readData(dst, 512);
}
//------------------------------------------------------------------------------
bool SdSpiCard::readData(uint8_t* dst, size_t count) {
    7036:	push	{r3, r4, r5, r6, r7, lr}
    7038:	mov	r4, r0
    703a:	mov	r5, r1
    703c:	mov	r6, r2
  uint16_t crc;
#endif  // USE_SD_CRC

  DBG_BEGIN_TIME(DBG_WAIT_READ);
  // wait for start sector token
  SdMillis_t t0 = SysCall::curTimeMS();
    703e:	bl	6fa4 <SysCall::curTimeMS()>
    7042:	mov	r7, r0
  while ((m_status = spiReceive()) == 0XFF) {
    7044:	ldr	r0, [r4, #4]
    7046:	bl	6f9e <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    704a:	cmp	r0, #255	; 0xff
    704c:	strb	r0, [r4, #17]
    704e:	bne.n	7060 <SdSpiCard::readData(unsigned char*, unsigned int)+0x2a>
  if ((SysCall::curTimeMS() - last) > WDT_YIELD_TIME_MILLIS) {
    SysCall::yield();
    last = SysCall::curTimeMS();
  }
#endif  // WDT_YIELD_TIME_MILLIS
  return (SysCall::curTimeMS() - startMS) > timeoutMS;
    7050:	bl	6fa4 <SysCall::curTimeMS()>

  DBG_BEGIN_TIME(DBG_WAIT_READ);
  // wait for start sector token
  SdMillis_t t0 = SysCall::curTimeMS();
  while ((m_status = spiReceive()) == 0XFF) {
    if (isTimedOut(t0, SD_READ_TIMEOUT)) {
    7054:	subs	r0, r0, r7
    7056:	cmp.w	r0, #300	; 0x12c
    705a:	ble.n	7044 <SdSpiCard::readData(unsigned char*, unsigned int)+0xe>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    705c:	movs	r3, #29
    705e:	b.n	707a <SdSpiCard::readData(unsigned char*, unsigned int)+0x44>
      error(SD_CARD_ERROR_READ_TIMEOUT);
      goto fail;
    }
  }
  DBG_END_TIME(DBG_WAIT_READ);
  if (m_status != DATA_START_SECTOR) {
    7060:	cmp	r0, #254	; 0xfe
    7062:	beq.n	7068 <SdSpiCard::readData(unsigned char*, unsigned int)+0x32>
    7064:	movs	r3, #24
    7066:	b.n	707a <SdSpiCard::readData(unsigned char*, unsigned int)+0x44>
    7068:	ldr	r0, [r4, #4]
  }
  uint8_t spiReceive() {
    return m_spiDriverPtr->receive();
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return m_spiDriverPtr->receive(buf, n);
    706a:	ldr	r3, [r0, #0]
    706c:	mov	r2, r6
    706e:	ldr	r3, [r3, #16]
    7070:	mov	r1, r5
    7072:	blx	r3
    error(SD_CARD_ERROR_READ_TOKEN);
    goto fail;
  }
  // transfer data
  if ((m_status = spiReceive(dst, count))) {
    7074:	strb	r0, [r4, #17]
    7076:	cbz	r0, 7086 <SdSpiCard::readData(unsigned char*, unsigned int)+0x50>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7078:	movs	r3, #37	; 0x25
  spiReceive();
#endif  // USE_SD_CRC
  return true;

 fail:
  spiStop();
    707a:	mov	r0, r4
    707c:	strb	r3, [r4, #15]
    707e:	bl	6fde <SdSpiCard::spiStop()>
  return false;
    7082:	movs	r0, #0
}
    7084:	pop	{r3, r4, r5, r6, r7, pc}
    error(SD_CARD_ERROR_READ_CRC);
    goto fail;
  }
#else  // USE_SD_CRC
  // discard crc
  spiReceive();
    7086:	ldr	r0, [r4, #4]
    7088:	bl	6f9e <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
  spiReceive();
    708c:	ldr	r0, [r4, #4]
    708e:	bl	6f9e <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7092:	movs	r0, #1
    7094:	pop	{r3, r4, r5, r6, r7, pc}

00007096 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectors(uint32_t sector, const uint8_t* src, size_t ns) {
    7096:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    709a:	mov	r7, r3
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    709c:	ldrb	r3, [r0, #12]
    709e:	cmp	r3, #2
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectors(uint32_t sector, const uint8_t* src, size_t ns) {
    70a0:	mov	r4, r0
    70a2:	mov	r5, r1
    70a4:	mov	r6, r2
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    70a6:	bne.n	70ae <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x18>
    70a8:	ldr	r3, [r0, #8]
    70aa:	cmp	r3, r1
    70ac:	beq.n	70c0 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x2a>
    if (!writeStart(sector)) {
    70ae:	ldr	r3, [r4, #0]
    70b0:	mov	r1, r5
    70b2:	ldr	r3, [r3, #80]	; 0x50
    70b4:	mov	r0, r4
    70b6:	blx	r3
    70b8:	cbz	r0, 70ee <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x58>
      goto fail;
    }
    m_curSector = sector;
    m_curState = WRITE_STATE;
    70ba:	movs	r3, #2
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    if (!writeStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    70bc:	str	r5, [r4, #8]
    m_curState = WRITE_STATE;
    70be:	strb	r3, [r4, #12]
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectors(uint32_t sector, const uint8_t* src, size_t ns) {
    70c0:	movs	r5, #0
      goto fail;
    }
    m_curSector = sector;
    m_curState = WRITE_STATE;
  }
  for (size_t i = 0; i < ns; i++, src += 512) {
    70c2:	cmp	r5, r7
    70c4:	add.w	r1, r6, r5, lsl #9
    70c8:	beq.n	70d8 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x42>
    if (!writeData(src)) {
    70ca:	ldr	r3, [r4, #0]
    70cc:	mov	r0, r4
    70ce:	ldr	r3, [r3, #76]	; 0x4c
    70d0:	blx	r3
    70d2:	cbz	r0, 70ee <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x58>
      goto fail;
    }
    m_curSector = sector;
    m_curState = WRITE_STATE;
  }
  for (size_t i = 0; i < ns; i++, src += 512) {
    70d4:	adds	r5, #1
    70d6:	b.n	70c2 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x2c>
      callback(sector + i, dst, context);
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
    70d8:	ldr	r3, [r4, #8]
    70da:	add	r5, r3
  return m_sharedSpi ? syncDevice() : true;
    70dc:	ldrb	r3, [r4, #13]
      callback(sector + i, dst, context);
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
    70de:	str	r5, [r4, #8]
  return m_sharedSpi ? syncDevice() : true;
    70e0:	cbz	r3, 70fa <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x64>
    70e2:	ldr	r3, [r4, #0]
    70e4:	mov	r0, r4
    70e6:	ldr	r3, [r3, #28]
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
  return false;
}
    70e8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    70ec:	bx	r3
  }
  return writeStop();
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
    70ee:	mov	r0, r4
    70f0:	bl	6fde <SdSpiCard::spiStop()>
  return false;
    70f4:	movs	r0, #0
    70f6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    70fa:	movs	r0, #1
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
  return false;
}
    70fc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00007100 <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)>:
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectorsCallback(uint32_t sector, size_t ns,
 const uint8_t * (*callback)(uint32_t sector, void *context), void *context) {
    7100:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    7104:	mov	r7, r3
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    7106:	ldrb	r3, [r0, #12]
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectorsCallback(uint32_t sector, size_t ns,
 const uint8_t * (*callback)(uint32_t sector, void *context), void *context) {
    7108:	ldr.w	r8, [sp, #32]
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    710c:	cmp	r3, #2
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectorsCallback(uint32_t sector, size_t ns,
 const uint8_t * (*callback)(uint32_t sector, void *context), void *context) {
    710e:	mov	r4, r0
    7110:	mov	r5, r1
    7112:	mov	r6, r2
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    7114:	bne.n	711c <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x1c>
    7116:	ldr	r3, [r0, #8]
    7118:	cmp	r3, r1
    711a:	beq.n	712e <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x2e>
    if (!writeStart(sector)) {
    711c:	ldr	r3, [r4, #0]
    711e:	mov	r1, r5
    7120:	ldr	r3, [r3, #80]	; 0x50
    7122:	mov	r0, r4
    7124:	blx	r3
    7126:	cbz	r0, 7164 <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x64>
      goto fail;
    }
    m_curSector = sector;
    m_curState = WRITE_STATE;
    7128:	movs	r3, #2
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    if (!writeStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    712a:	str	r5, [r4, #8]
    m_curState = WRITE_STATE;
    712c:	strb	r3, [r4, #12]
    712e:	add.w	r9, r5, r6
  }
  for (size_t i = 0; i < ns; i++) {
    7132:	cmp	r5, r9
    7134:	beq.n	714e <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x4e>
    const uint8_t *src = callback(sector + i, context);
    7136:	mov	r1, r8
    7138:	mov	r0, r5
    713a:	blx	r7
    if (!writeData(src)) {
    713c:	ldr	r3, [r4, #0]
    713e:	mov	r1, r0
    7140:	ldr	r3, [r3, #76]	; 0x4c
    7142:	mov	r0, r4
    7144:	blx	r3
    7146:	adds	r5, #1
    7148:	cmp	r0, #0
    714a:	bne.n	7132 <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x32>
    714c:	b.n	7164 <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x64>
      goto fail;
    }
  }
  m_curSector += ns;
    714e:	ldr	r3, [r4, #8]
    7150:	add	r6, r3
  return m_sharedSpi ? syncDevice() : true;
    7152:	ldrb	r3, [r4, #13]
    const uint8_t *src = callback(sector + i, context);
    if (!writeData(src)) {
      goto fail;
    }
  }
  m_curSector += ns;
    7154:	str	r6, [r4, #8]
  return m_sharedSpi ? syncDevice() : true;
    7156:	cbz	r3, 7170 <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x70>
    7158:	ldr	r3, [r4, #0]
    715a:	mov	r0, r4
    715c:	ldr	r3, [r3, #28]
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
  return false;
}
    715e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    if (!writeData(src)) {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    7162:	bx	r3
  }
  return writeStop();
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
    7164:	mov	r0, r4
    7166:	bl	6fde <SdSpiCard::spiStop()>
  return false;
    716a:	movs	r0, #0
    716c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (!writeData(src)) {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    7170:	movs	r0, #1
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
  return false;
}
    7172:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

00007176 <SdSpiCard::waitNotBusy(unsigned short)>:
#endif  // ENABLE_DEDICATED_SPI
  return true;
}
//------------------------------------------------------------------------------
// wait for card to go not busy
bool SdSpiCard::waitNotBusy(SdMillis_t timeoutMS) {
    7176:	push	{r4, r5, r6, lr}
    7178:	mov	r6, r0
    717a:	mov	r4, r1
  SdMillis_t t0 = SysCall::curTimeMS();
    717c:	bl	6fa4 <SysCall::curTimeMS()>
    7180:	mov	r5, r0
    }
  }
  return false;
#else  // WDT_YIELD_TIME_MILLIS
  // Check not busy first since yield is not called in isTimedOut.
  while (spiReceive() != 0XFF) {
    7182:	ldr	r0, [r6, #4]
    7184:	bl	6f9e <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7188:	cmp	r0, #255	; 0xff
    718a:	beq.n	719a <SdSpiCard::waitNotBusy(unsigned short)+0x24>
  if ((SysCall::curTimeMS() - last) > WDT_YIELD_TIME_MILLIS) {
    SysCall::yield();
    last = SysCall::curTimeMS();
  }
#endif  // WDT_YIELD_TIME_MILLIS
  return (SysCall::curTimeMS() - startMS) > timeoutMS;
    718c:	bl	6fa4 <SysCall::curTimeMS()>
  }
  return false;
#else  // WDT_YIELD_TIME_MILLIS
  // Check not busy first since yield is not called in isTimedOut.
  while (spiReceive() != 0XFF) {
    if (isTimedOut(t0, timeoutMS)) {
    7190:	subs	r0, r0, r5
    7192:	cmp	r0, r4
    7194:	ble.n	7182 <SdSpiCard::waitNotBusy(unsigned short)+0xc>
      return false;
    7196:	movs	r0, #0
    7198:	pop	{r4, r5, r6, pc}
    }
  }
  return true;
    719a:	movs	r0, #1
#endif  // WDT_YIELD_TIME_MILLIS
}
    719c:	pop	{r4, r5, r6, pc}

0000719e <SdSpiCard::cardCommand(unsigned char, unsigned long)>:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send command and return error code.  Return zero for OK
uint8_t SdSpiCard::cardCommand(uint8_t cmd, uint32_t arg) {
    719e:	push	{r0, r1, r2, r4, r5, r6, r7, lr}
#if ENABLE_DEDICATED_SPI
  if (m_curState != IDLE_STATE && !syncDevice()) {
    71a0:	ldrb	r3, [r0, #12]
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send command and return error code.  Return zero for OK
uint8_t SdSpiCard::cardCommand(uint8_t cmd, uint32_t arg) {
    71a2:	str	r2, [sp, #4]
    71a4:	mov	r4, r0
    71a6:	mov	r5, r1
#if ENABLE_DEDICATED_SPI
  if (m_curState != IDLE_STATE && !syncDevice()) {
    71a8:	cbz	r3, 71b6 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x18>
    71aa:	ldr	r3, [r0, #0]
    71ac:	ldr	r3, [r3, #28]
    71ae:	blx	r3
    71b0:	cbnz	r0, 71b6 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x18>
    return 0XFF;
    71b2:	movs	r0, #255	; 0xff
    71b4:	b.n	7216 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x78>
  }
#endif  // ENABLE_DEDICATED_SPI
  // select card
  if (!m_spiActive) {
    71b6:	ldrb	r3, [r4, #16]
    71b8:	cbnz	r3, 71c0 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x22>
    spiStart();
    71ba:	mov	r0, r4
    71bc:	bl	6fb8 <SdSpiCard::spiStart()>
  }
  // wait if busy unless CMD0
  if (cmd != CMD0) {
    71c0:	cbz	r5, 71cc <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x2e>
    DBG_BEGIN_TIME(DBG_CMD_BUSY);
    waitNotBusy(SD_CMD_TIMEOUT);
    71c2:	mov.w	r1, #300	; 0x12c
    71c6:	mov	r0, r4
    71c8:	bl	7176 <SdSpiCard::waitNotBusy(unsigned short)>

  // send message
  spiSend(buf, 6);
#else  // USE_SD_CRC
  // send command
  spiSend(cmd | 0x40);
    71cc:	orr.w	r1, r5, #64	; 0x40
    71d0:	ldr	r0, [r4, #4]
    71d2:	bl	6f98 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
    71d6:	add.w	r6, sp, #7
    71da:	add.w	r7, sp, #3

  // send argument
  uint8_t* pa = reinterpret_cast<uint8_t*>(&arg);
  for (int8_t i = 3; i >= 0; i--) {
    spiSend(pa[i]);
    71de:	ldrb.w	r1, [r6], #-1
    71e2:	ldr	r0, [r4, #4]
    71e4:	bl	6f98 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
  // send command
  spiSend(cmd | 0x40);

  // send argument
  uint8_t* pa = reinterpret_cast<uint8_t*>(&arg);
  for (int8_t i = 3; i >= 0; i--) {
    71e8:	cmp	r7, r6
    71ea:	bne.n	71de <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x40>
    spiSend(pa[i]);
  }

  // send CRC - correct for CMD0 with arg zero or CMD8 with arg 0X1AA
  spiSend(cmd == CMD0 ? 0X95 : 0X87);
    71ec:	cmp	r5, #0
    71ee:	ite	eq
    71f0:	moveq	r1, #149	; 0x95
    71f2:	movne	r1, #135	; 0x87
    71f4:	ldr	r0, [r4, #4]
    71f6:	bl	6f98 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
#endif  // USE_SD_CRC

  // discard first fill byte to avoid MISO pull-up problem.
  spiReceive();
    71fa:	ldr	r0, [r4, #4]
    71fc:	bl	6f9e <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7200:	movs	r5, #11

  // there are 1-8 fill bytes before response.  fill bytes should be 0XFF.
  for (uint8_t i = 0; ((m_status = spiReceive()) & 0X80) && i < 10; i++) {
    7202:	ldr	r0, [r4, #4]
    7204:	bl	6f9e <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7208:	lsls	r3, r0, #24
    720a:	strb	r0, [r4, #17]
    720c:	bpl.n	7216 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x78>
    720e:	subs	r5, #1
    7210:	ands.w	r5, r5, #255	; 0xff
    7214:	bne.n	7202 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x64>
  }
  return m_status;
}
    7216:	add	sp, #12
    7218:	pop	{r4, r5, r6, r7, pc}

0000721a <SdSpiCard::cardAcmd(unsigned char, unsigned long)>:
  /** Set CS high and deactivate the card. */
  void spiStop();

 private:
  // private functions
  uint8_t cardAcmd(uint8_t cmd, uint32_t arg) {
    721a:	push	{r4, r5, r6, lr}
    721c:	mov	r4, r0
    721e:	mov	r5, r1
    7220:	mov	r6, r2
    cardCommand(CMD55, 0);
    7222:	movs	r1, #55	; 0x37
    7224:	movs	r2, #0
    7226:	bl	719e <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    return cardCommand(cmd, arg);
    722a:	mov	r2, r6
    722c:	mov	r1, r5
    722e:	mov	r0, r4
  }
    7230:	ldmia.w	sp!, {r4, r5, r6, lr}

 private:
  // private functions
  uint8_t cardAcmd(uint8_t cmd, uint32_t arg) {
    cardCommand(CMD55, 0);
    return cardCommand(cmd, arg);
    7234:	b.w	719e <SdSpiCard::cardCommand(unsigned char, unsigned long)>

00007238 <SdSpiCard::begin(SdSpiConfig)>:
#endif  // CRC_CCITT
#endif  // USE_SD_CRC
//==============================================================================
// SdSpiCard member functions
//------------------------------------------------------------------------------
bool SdSpiCard::begin(SdSpiConfig spiConfig) {
    7238:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    723c:	sub	sp, #36	; 0x24
    723e:	add	r5, sp, #4
    7240:	stmia.w	r5, {r1, r2, r3}
    7244:	mov	r4, r0
    7246:	ldrb.w	sl, [sp, #4]
    724a:	ldr.w	fp, [sp, #12]
    724e:	ldrb.w	r8, [sp, #5]
    7252:	ldr	r6, [sp, #8]
  SdMillis_t t0 = SysCall::curTimeMS();
    7254:	bl	6fa4 <SysCall::curTimeMS()>
  m_spiActive = false;
    7258:	mov.w	r9, #0
#endif  // USE_SD_CRC
//==============================================================================
// SdSpiCard member functions
//------------------------------------------------------------------------------
bool SdSpiCard::begin(SdSpiConfig spiConfig) {
  SdMillis_t t0 = SysCall::curTimeMS();
    725c:	mov	r7, r0
  m_spiActive = false;
    725e:	strb.w	r9, [r4, #16]
  m_errorCode = SD_CARD_ERROR_NONE;
    7262:	strb.w	r9, [r4, #15]
  m_type = 0;
    7266:	strb.w	r9, [r4, #18]
  m_csPin = spiConfig.csPin;
    726a:	strb.w	sl, [r4, #14]
#if SPI_DRIVER_SELECT >= 2
  m_spiDriverPtr = spiConfig.spiPort;
    726e:	str.w	fp, [r4, #4]
  if (!m_spiDriverPtr) {
    7272:	cmp.w	fp, #0
    7276:	bne.n	727c <SdSpiCard::begin(SdSpiConfig)+0x44>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7278:	movs	r3, #42	; 0x2a
    727a:	b.n	73b0 <SdSpiCard::begin(SdSpiConfig)+0x178>
    error(SD_CARD_ERROR_INVALID_CARD_CONFIG);
    goto fail;
  }
#endif  // SPI_DRIVER_SELECT
  sdCsInit(m_csPin);
    727c:	mov	r0, sl
    727e:	bl	194c <sdCsInit(unsigned char)>
  }
  void type(uint8_t value) {
    m_type = value;
  }
  void spiUnselect() {
    sdCsWrite(m_csPin, true);
    7282:	movs	r1, #1
    7284:	ldrb	r0, [r4, #14]
    7286:	bl	1968 <sdCsWrite(unsigned char, bool)>
    728a:	ldr	r0, [r4, #4]
  }
  void spiSend(const uint8_t* buf, size_t n) {
    m_spiDriverPtr->send(buf, n);
  }
  void spiSetSckSpeed(uint32_t maxSck) {
    m_spiDriverPtr->setSckSpeed(maxSck);
    728c:	ldr	r1, [pc, #344]	; (73e8 <SdSpiCard::begin(SdSpiConfig)+0x1b0>)
    728e:	ldr	r3, [r0, #0]
    7290:	ldr	r3, [r3, #28]
    7292:	blx	r3
    7294:	ldmia.w	r5, {r0, r1, r2}
    7298:	add	r3, sp, #20
    729a:	ldr.w	lr, [r4, #4]
    729e:	stmia.w	r3, {r0, r1, r2}
#else  // SPI_DRIVER_SELECT < 2
  void spiActivate() {
    m_spiDriverPtr->activate();
  }
  void spiBegin(SdSpiConfig spiConfig) {
    m_spiDriverPtr->begin(spiConfig);
    72a2:	ldr.w	r2, [lr]
  spiSetSckSpeed(1000UL*SD_MAX_INIT_RATE_KHZ);
  spiBegin(spiConfig);
  uint32_t arg;
#if ENABLE_DEDICATED_SPI
  m_curState = IDLE_STATE;
  m_sharedSpi = spiOptionShared(spiConfig.options);
    72a6:	and.w	r8, r8, #1
    72aa:	mov	r0, lr
    72ac:	ldr	r5, [r2, #4]
    72ae:	eor.w	r8, r8, #1
    72b2:	ldmia	r3, {r1, r2, r3}
    72b4:	blx	r5
#else  // ENABLE_DEDICATED_SPI
  // m_sharedSpi is a static const bool in this case.
  static_assert(m_sharedSpi == true, "m_sharedSpi bug");
#endif  // ENABLE_DEDICATED_SPI
  spiStart();
    72b6:	mov	r0, r4
  spiUnselect();
  spiSetSckSpeed(1000UL*SD_MAX_INIT_RATE_KHZ);
  spiBegin(spiConfig);
  uint32_t arg;
#if ENABLE_DEDICATED_SPI
  m_curState = IDLE_STATE;
    72b8:	strb.w	r9, [r4, #12]
  m_sharedSpi = spiOptionShared(spiConfig.options);
    72bc:	strb.w	r8, [r4, #13]
#else  // ENABLE_DEDICATED_SPI
  // m_sharedSpi is a static const bool in this case.
  static_assert(m_sharedSpi == true, "m_sharedSpi bug");
#endif  // ENABLE_DEDICATED_SPI
  spiStart();
    72c0:	bl	6fb8 <SdSpiCard::spiStart()>
  }
  void type(uint8_t value) {
    m_type = value;
  }
  void spiUnselect() {
    sdCsWrite(m_csPin, true);
    72c4:	movs	r1, #1
    72c6:	ldrb	r0, [r4, #14]
    72c8:	bl	1968 <sdCsWrite(unsigned char, bool)>
    72cc:	movs	r5, #10

  // must supply min of 74 clock cycles with CS high.
  spiUnselect();
  for (uint8_t i = 0; i < 10; i++) {
    spiSend(0XFF);
    72ce:	movs	r1, #255	; 0xff
    72d0:	ldr	r0, [r4, #4]
    72d2:	subs	r5, #1
    72d4:	bl	6f98 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
#endif  // ENABLE_DEDICATED_SPI
  spiStart();

  // must supply min of 74 clock cycles with CS high.
  spiUnselect();
  for (uint8_t i = 0; i < 10; i++) {
    72d8:	ands.w	r5, r5, #255	; 0xff
    72dc:	bne.n	72ce <SdSpiCard::begin(SdSpiConfig)+0x96>
  uint8_t cardCommand(uint8_t cmd, uint32_t arg);
  bool isTimedOut(SdMillis_t startMS, SdMillis_t timeoutMS);
  bool readData(uint8_t* dst, size_t count);
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
    72de:	mov	r1, r5
    72e0:	ldrb	r0, [r4, #14]
    72e2:	bl	1968 <sdCsWrite(unsigned char, bool)>
    72e6:	movs	r5, #10
  spiSelect();
  DBG_BEGIN_TIME(DBG_CMD0_TIME);
  // command to go idle in SPI mode
  for (uint8_t i = 1;; i++) {
    DBG_EVENT_COUNT(DBG_CMD0_COUNT);
    if (cardCommand(CMD0, 0) == R1_IDLE_STATE) {
    72e8:	movs	r2, #0
    72ea:	mov	r1, r2
    72ec:	mov	r0, r4
    72ee:	bl	719e <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    72f2:	cmp	r0, #1
    72f4:	mov	r8, r0
    72f6:	beq.n	731e <SdSpiCard::begin(SdSpiConfig)+0xe6>
    72f8:	subs	r5, #1
      break;
    }
    if (i == SD_CMD0_RETRY) {
    72fa:	ands.w	r5, r5, #255	; 0xff
    72fe:	bne.n	7304 <SdSpiCard::begin(SdSpiConfig)+0xcc>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7300:	movs	r3, #1
    7302:	b.n	73b0 <SdSpiCard::begin(SdSpiConfig)+0x178>
      error(SD_CARD_ERROR_CMD0);
      goto fail;
    }
    // stop multi-block write
    spiSend(STOP_TRAN_TOKEN);
    7304:	movs	r1, #253	; 0xfd
    7306:	ldr	r0, [r4, #4]
    7308:	bl	6f98 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
    730c:	mov.w	r8, #520	; 0x208
    // finish block transfer
    for (int i = 0; i < 520; i++) {
      spiReceive();
    7310:	ldr	r0, [r4, #4]
    7312:	bl	6f9e <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
      goto fail;
    }
    // stop multi-block write
    spiSend(STOP_TRAN_TOKEN);
    // finish block transfer
    for (int i = 0; i < 520; i++) {
    7316:	subs.w	r8, r8, #1
    731a:	bne.n	7310 <SdSpiCard::begin(SdSpiConfig)+0xd8>
    731c:	b.n	72e8 <SdSpiCard::begin(SdSpiConfig)+0xb0>
    goto fail;
  }
#endif  // USE_SD_CRC

  // check SD version
  if (!(cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
    731e:	mov.w	r2, #426	; 0x1aa
    7322:	movs	r1, #8
    7324:	mov	r0, r4
    7326:	bl	719e <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    732a:	lsls	r3, r0, #29
    732c:	bmi.n	734c <SdSpiCard::begin(SdSpiConfig)+0x114>
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
  }
  void type(uint8_t value) {
    m_type = value;
    732e:	movs	r3, #2
    7330:	strb	r3, [r4, #18]
    7332:	movs	r5, #4
    type(SD_CARD_TYPE_SD2);
    for (uint8_t i = 0; i < 4; i++) {
      m_status = spiReceive();
    7334:	ldr	r0, [r4, #4]
    7336:	bl	6f9e <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    733a:	subs	r5, #1
#endif  // USE_SD_CRC

  // check SD version
  if (!(cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
    type(SD_CARD_TYPE_SD2);
    for (uint8_t i = 0; i < 4; i++) {
    733c:	ands.w	r5, r5, #255	; 0xff
      m_status = spiReceive();
    7340:	strb	r0, [r4, #17]
#endif  // USE_SD_CRC

  // check SD version
  if (!(cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
    type(SD_CARD_TYPE_SD2);
    for (uint8_t i = 0; i < 4; i++) {
    7342:	bne.n	7334 <SdSpiCard::begin(SdSpiConfig)+0xfc>
      m_status = spiReceive();
    }
    if (m_status != 0XAA) {
    7344:	cmp	r0, #170	; 0xaa
    7346:	beq.n	7350 <SdSpiCard::begin(SdSpiConfig)+0x118>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7348:	movs	r3, #6
    734a:	b.n	73b0 <SdSpiCard::begin(SdSpiConfig)+0x178>
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
  }
  void type(uint8_t value) {
    m_type = value;
    734c:	strb.w	r8, [r4, #18]
    }
  } else {
    type(SD_CARD_TYPE_SD1);
  }
  // initialize card and send host supports SDHC if SD2
  arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;
    7350:	ldr	r3, [r4, #0]
    7352:	mov	r0, r4
    7354:	ldr	r3, [r3, #72]	; 0x48
    7356:	blx	r3
    7358:	cmp	r0, #2
    735a:	ite	eq
    735c:	moveq.w	r8, #1073741824	; 0x40000000
    7360:	movne.w	r8, #0
  DBG_BEGIN_TIME(DBG_ACMD41_TIME);
  while (cardAcmd(ACMD41, arg) != R1_READY_STATE) {
    7364:	mov	r2, r8
    7366:	movs	r1, #41	; 0x29
    7368:	mov	r0, r4
    736a:	bl	721a <SdSpiCard::cardAcmd(unsigned char, unsigned long)>
    736e:	mov	r5, r0
    7370:	cbz	r0, 7382 <SdSpiCard::begin(SdSpiConfig)+0x14a>
  if ((SysCall::curTimeMS() - last) > WDT_YIELD_TIME_MILLIS) {
    SysCall::yield();
    last = SysCall::curTimeMS();
  }
#endif  // WDT_YIELD_TIME_MILLIS
  return (SysCall::curTimeMS() - startMS) > timeoutMS;
    7372:	bl	6fa4 <SysCall::curTimeMS()>
  arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;
  DBG_BEGIN_TIME(DBG_ACMD41_TIME);
  while (cardAcmd(ACMD41, arg) != R1_READY_STATE) {
    DBG_EVENT_COUNT(DBG_ACMD41_COUNT);
    // check for timeout
    if (isTimedOut(t0, SD_INIT_TIMEOUT)) {
    7376:	subs	r0, r0, r7
    7378:	cmp.w	r0, #2000	; 0x7d0
    737c:	ble.n	7364 <SdSpiCard::begin(SdSpiConfig)+0x12c>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    737e:	movs	r3, #23
    7380:	b.n	73b0 <SdSpiCard::begin(SdSpiConfig)+0x178>
    }
  }
  DBG_END_TIME(DBG_ACMD41_TIME);

  // if SD2 read OCR register to check for SDHC card
  if (type() == SD_CARD_TYPE_SD2) {
    7382:	ldr	r3, [r4, #0]
    7384:	mov	r0, r4
    7386:	ldr	r3, [r3, #72]	; 0x48
    7388:	blx	r3
    738a:	cmp	r0, #2
    738c:	beq.n	73a2 <SdSpiCard::begin(SdSpiConfig)+0x16a>
    // Discard rest of ocr - contains allowed voltage range.
    for (uint8_t i = 0; i < 3; i++) {
      spiReceive();
    }
  }
  spiStop();
    738e:	mov	r0, r4
    7390:	bl	6fde <SdSpiCard::spiStop()>
    7394:	ldr	r0, [r4, #4]
  }
  void spiSend(const uint8_t* buf, size_t n) {
    m_spiDriverPtr->send(buf, n);
  }
  void spiSetSckSpeed(uint32_t maxSck) {
    m_spiDriverPtr->setSckSpeed(maxSck);
    7396:	ldr	r3, [r0, #0]
    7398:	mov	r1, r6
    739a:	ldr	r3, [r3, #28]
    739c:	blx	r3
  spiSetSckSpeed(spiConfig.maxSck);
  return true;
    739e:	movs	r0, #1
    73a0:	b.n	73e2 <SdSpiCard::begin(SdSpiConfig)+0x1aa>
  }
  DBG_END_TIME(DBG_ACMD41_TIME);

  // if SD2 read OCR register to check for SDHC card
  if (type() == SD_CARD_TYPE_SD2) {
    if (cardCommand(CMD58, 0)) {
    73a2:	mov	r2, r5
    73a4:	movs	r1, #58	; 0x3a
    73a6:	mov	r0, r4
    73a8:	bl	719e <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    73ac:	cbz	r0, 73bc <SdSpiCard::begin(SdSpiConfig)+0x184>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    73ae:	movs	r3, #18
  spiStop();
  spiSetSckSpeed(spiConfig.maxSck);
  return true;

 fail:
  spiStop();
    73b0:	mov	r0, r4
    73b2:	strb	r3, [r4, #15]
    73b4:	bl	6fde <SdSpiCard::spiStop()>
  return false;
    73b8:	movs	r0, #0
    73ba:	b.n	73e2 <SdSpiCard::begin(SdSpiConfig)+0x1aa>
  if (type() == SD_CARD_TYPE_SD2) {
    if (cardCommand(CMD58, 0)) {
      error(SD_CARD_ERROR_CMD58);
      goto fail;
    }
    if ((spiReceive() & 0XC0) == 0XC0) {
    73bc:	ldr	r0, [r4, #4]
    73be:	bl	6f9e <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    73c2:	and.w	r0, r0, #192	; 0xc0
    73c6:	cmp	r0, #192	; 0xc0
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
  }
  void type(uint8_t value) {
    m_type = value;
    73c8:	itt	eq
    73ca:	moveq	r3, #3
    73cc:	strbeq	r3, [r4, #18]
      type(SD_CARD_TYPE_SDHC);
    }
    // Discard rest of ocr - contains allowed voltage range.
    for (uint8_t i = 0; i < 3; i++) {
      spiReceive();
    73ce:	ldr	r0, [r4, #4]
    73d0:	bl	6f9e <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    73d4:	ldr	r0, [r4, #4]
    73d6:	bl	6f9e <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    73da:	ldr	r0, [r4, #4]
    73dc:	bl	6f9e <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    73e0:	b.n	738e <SdSpiCard::begin(SdSpiConfig)+0x156>
  return true;

 fail:
  spiStop();
  return false;
}
    73e2:	add	sp, #36	; 0x24
    73e4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    73e8:	.word	0x00061a80

000073ec <SdSpiCard::readOCR(unsigned long*)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readOCR(uint32_t* ocr) {
    73ec:	push	{r4, r5, r6, lr}
  uint8_t* p = reinterpret_cast<uint8_t*>(ocr);
  if (cardCommand(CMD58, 0)) {
    73ee:	movs	r2, #0
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readOCR(uint32_t* ocr) {
    73f0:	mov	r6, r1
  uint8_t* p = reinterpret_cast<uint8_t*>(ocr);
  if (cardCommand(CMD58, 0)) {
    73f2:	movs	r1, #58	; 0x3a
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readOCR(uint32_t* ocr) {
    73f4:	mov	r4, r0
  uint8_t* p = reinterpret_cast<uint8_t*>(ocr);
  if (cardCommand(CMD58, 0)) {
    73f6:	bl	719e <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    73fa:	cbz	r0, 740a <SdSpiCard::readOCR(unsigned long*)+0x1e>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    73fc:	movs	r3, #18
  }
  spiStop();
  return true;

 fail:
  spiStop();
    73fe:	mov	r0, r4
    7400:	strb	r3, [r4, #15]
    7402:	bl	6fde <SdSpiCard::spiStop()>
  return false;
    7406:	movs	r0, #0
    7408:	pop	{r4, r5, r6, pc}
    740a:	adds	r5, r6, #4
  if (cardCommand(CMD58, 0)) {
    error(SD_CARD_ERROR_CMD58);
    goto fail;
  }
  for (uint8_t i = 0; i < 4; i++) {
    p[3 - i] = spiReceive();
    740c:	ldr	r0, [r4, #4]
    740e:	bl	6f9e <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7412:	strb.w	r0, [r5, #-1]!
  uint8_t* p = reinterpret_cast<uint8_t*>(ocr);
  if (cardCommand(CMD58, 0)) {
    error(SD_CARD_ERROR_CMD58);
    goto fail;
  }
  for (uint8_t i = 0; i < 4; i++) {
    7416:	cmp	r5, r6
    7418:	bne.n	740c <SdSpiCard::readOCR(unsigned long*)+0x20>
    p[3 - i] = spiReceive();
  }
  spiStop();
    741a:	mov	r0, r4
    741c:	bl	6fde <SdSpiCard::spiStop()>
  return true;
    7420:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    7422:	pop	{r4, r5, r6, pc}

00007424 <SdSpiCard::readRegister(unsigned char, void*)>:
//------------------------------------------------------------------------------
/** read CID or CSR register */
bool SdSpiCard::readRegister(uint8_t cmd, void* buf) {
    7424:	push	{r3, r4, r5, lr}
    7426:	mov	r5, r2
  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
  if (cardCommand(cmd, 0)) {
    7428:	movs	r2, #0
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
/** read CID or CSR register */
bool SdSpiCard::readRegister(uint8_t cmd, void* buf) {
    742a:	mov	r4, r0
  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
  if (cardCommand(cmd, 0)) {
    742c:	bl	719e <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7430:	cbz	r0, 7438 <SdSpiCard::readRegister(unsigned char, void*)+0x14>
    7432:	movs	r3, #27
    7434:	strb	r3, [r4, #15]
    7436:	b.n	744e <SdSpiCard::readRegister(unsigned char, void*)+0x2a>
    error(SD_CARD_ERROR_READ_REG);
    goto fail;
  }
  if (!readData(dst, 16)) {
    7438:	mov	r1, r5
    743a:	movs	r2, #16
    743c:	mov	r0, r4
    743e:	bl	7036 <SdSpiCard::readData(unsigned char*, unsigned int)>
    7442:	mov	r5, r0
    7444:	cbz	r0, 744e <SdSpiCard::readRegister(unsigned char, void*)+0x2a>
    goto fail;
  }
  spiStop();
    7446:	mov	r0, r4
    7448:	bl	6fde <SdSpiCard::spiStop()>
  return true;
    744c:	b.n	7456 <SdSpiCard::readRegister(unsigned char, void*)+0x32>

 fail:
  spiStop();
    744e:	mov	r0, r4
    7450:	bl	6fde <SdSpiCard::spiStop()>
  return false;
    7454:	movs	r5, #0
}
    7456:	mov	r0, r5
    7458:	pop	{r3, r4, r5, pc}

0000745a <SdSpiCard::readCSD(csd_t*)>:
   * \param[out] csd pointer to area for returned data.
   *
   * \return true for success or false for failure.
   */
  bool readCSD(csd_t* csd) {
    return readRegister(CMD9, csd);
    745a:	mov	r2, r1
    745c:	movs	r1, #9
    745e:	b.w	7424 <SdSpiCard::readRegister(unsigned char, void*)>

00007462 <SdSpiCard::readCID(CID*)>:
   * \param[out] cid pointer to area for returned data.
   *
   * \return true for success or false for failure.
   */
  bool readCID(cid_t* cid) {
    return readRegister(CMD10, cid);
    7462:	mov	r2, r1
    7464:	movs	r1, #10
    7466:	b.w	7424 <SdSpiCard::readRegister(unsigned char, void*)>

0000746a <SdSpiCard::readStart(unsigned long)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStart(uint32_t sector) {
    746a:	push	{r3, r4, r5, lr}
  if (type() != SD_CARD_TYPE_SDHC) {
    746c:	ldr	r3, [r0, #0]
    746e:	ldr	r3, [r3, #72]	; 0x48
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStart(uint32_t sector) {
    7470:	mov	r5, r1
    7472:	mov	r4, r0
  if (type() != SD_CARD_TYPE_SDHC) {
    7474:	blx	r3
    7476:	cmp	r0, #3
    sector <<= 9;
    7478:	it	ne
    747a:	lslne	r5, r5, #9
  }
  if (cardCommand(CMD18, sector)) {
    747c:	mov	r2, r5
    747e:	movs	r1, #18
    7480:	mov	r0, r4
    7482:	bl	719e <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7486:	cbz	r0, 7496 <SdSpiCard::readStart(unsigned long)+0x2c>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7488:	movs	r3, #12
    goto fail;
  }
  return true;

 fail:
  spiStop();
    748a:	mov	r0, r4
    748c:	strb	r3, [r4, #15]
    748e:	bl	6fde <SdSpiCard::spiStop()>
  return false;
    7492:	movs	r0, #0
    7494:	pop	{r3, r4, r5, pc}
  }
  if (cardCommand(CMD18, sector)) {
    error(SD_CARD_ERROR_CMD18);
    goto fail;
  }
  return true;
    7496:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    7498:	pop	{r3, r4, r5, pc}

0000749a <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectors(uint32_t sector, uint8_t* dst, size_t ns) {
    749a:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    749e:	mov	r7, r3
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    74a0:	ldrb	r3, [r0, #12]
    74a2:	cmp	r3, #1
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectors(uint32_t sector, uint8_t* dst, size_t ns) {
    74a4:	mov	r4, r0
    74a6:	mov	r5, r1
    74a8:	mov	r6, r2
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    74aa:	bne.n	74b2 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x18>
    74ac:	ldr	r3, [r0, #8]
    74ae:	cmp	r3, r1
    74b0:	beq.n	74c8 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x2e>
    if (!readStart(sector)) {
    74b2:	mov	r1, r5
    74b4:	mov	r0, r4
    74b6:	bl	746a <SdSpiCard::readStart(unsigned long)>
    74ba:	cbnz	r0, 74c2 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x28>
    }
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
    74bc:	movs	r0, #0
    74be:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (m_curState != READ_STATE || sector != m_curSector) {
    if (!readStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
    74c2:	movs	r3, #1
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    if (!readStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    74c4:	str	r5, [r4, #8]
    m_curState = READ_STATE;
    74c6:	strb	r3, [r4, #12]
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectors(uint32_t sector, uint8_t* dst, size_t ns) {
    74c8:	movs	r5, #0
      goto fail;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
  }
  for (size_t i = 0; i < ns; i++, dst += 512) {
    74ca:	cmp	r5, r7
    74cc:	add.w	r1, r6, r5, lsl #9
    74d0:	beq.n	74e4 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x4a>
    if (!readData(dst, 512)) {
    74d2:	mov.w	r2, #512	; 0x200
    74d6:	mov	r0, r4
    74d8:	bl	7036 <SdSpiCard::readData(unsigned char*, unsigned int)>
    74dc:	cmp	r0, #0
    74de:	beq.n	74bc <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x22>
      goto fail;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
  }
  for (size_t i = 0; i < ns; i++, dst += 512) {
    74e0:	adds	r5, #1
    74e2:	b.n	74ca <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x30>
    if (!readData(dst, 512)) {
      goto fail;
    }
  }
  m_curSector += ns;
    74e4:	ldr	r3, [r4, #8]
    74e6:	add	r5, r3
  return m_sharedSpi ? syncDevice() : true;
    74e8:	ldrb	r3, [r4, #13]
  for (size_t i = 0; i < ns; i++, dst += 512) {
    if (!readData(dst, 512)) {
      goto fail;
    }
  }
  m_curSector += ns;
    74ea:	str	r5, [r4, #8]
  return m_sharedSpi ? syncDevice() : true;
    74ec:	cbz	r3, 74fa <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x60>
    74ee:	ldr	r3, [r4, #0]
    74f0:	mov	r0, r4
    74f2:	ldr	r3, [r3, #28]
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
    74f4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    if (!readData(dst, 512)) {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    74f8:	bx	r3
    74fa:	movs	r0, #1
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
    74fc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00007500 <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)>:
//------------------------------------------------------------------------------
bool SdSpiCard::readSectorsCallback(uint32_t sector, uint8_t* dst, size_t ns,
 void (*callback)(uint32_t sector, uint8_t *buf, void *context), void *context) {
    7500:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    7504:	mov	r6, r3
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    7506:	ldrb	r3, [r0, #12]
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectorsCallback(uint32_t sector, uint8_t* dst, size_t ns,
 void (*callback)(uint32_t sector, uint8_t *buf, void *context), void *context) {
    7508:	ldr.w	r8, [sp, #32]
    750c:	ldr.w	r9, [sp, #36]	; 0x24
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    7510:	cmp	r3, #1
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectorsCallback(uint32_t sector, uint8_t* dst, size_t ns,
 void (*callback)(uint32_t sector, uint8_t *buf, void *context), void *context) {
    7512:	mov	r4, r0
    7514:	mov	r5, r1
    7516:	mov	r7, r2
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    7518:	bne.n	7520 <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x20>
    751a:	ldr	r3, [r0, #8]
    751c:	cmp	r3, r1
    751e:	beq.n	7536 <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x36>
    if (!readStart(sector)) {
    7520:	mov	r1, r5
    7522:	mov	r0, r4
    7524:	bl	746a <SdSpiCard::readStart(unsigned long)>
    7528:	cbnz	r0, 7530 <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x30>
    }
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
    752a:	movs	r0, #0
    752c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  if (m_curState != READ_STATE || sector != m_curSector) {
    if (!readStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
    7530:	movs	r3, #1
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    if (!readStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    7532:	str	r5, [r4, #8]
    m_curState = READ_STATE;
    7534:	strb	r3, [r4, #12]
    7536:	add.w	sl, r5, r6
  }
  for (size_t i = 0; i < ns; i++) {
    753a:	cmp	r5, sl
    753c:	beq.n	755a <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x5a>
    if (readData(dst, 512)) {
    753e:	mov.w	r2, #512	; 0x200
    7542:	mov	r1, r7
    7544:	mov	r0, r4
    7546:	bl	7036 <SdSpiCard::readData(unsigned char*, unsigned int)>
    754a:	cmp	r0, #0
    754c:	beq.n	752a <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x2a>
      callback(sector + i, dst, context);
    754e:	mov	r0, r5
    7550:	mov	r2, r9
    7552:	mov	r1, r7
    7554:	blx	r8
    7556:	adds	r5, #1
      goto fail;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
  }
  for (size_t i = 0; i < ns; i++) {
    7558:	b.n	753a <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x3a>
      callback(sector + i, dst, context);
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
    755a:	ldr	r3, [r4, #8]
    755c:	add	r6, r3
  return m_sharedSpi ? syncDevice() : true;
    755e:	ldrb	r3, [r4, #13]
      callback(sector + i, dst, context);
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
    7560:	str	r6, [r4, #8]
  return m_sharedSpi ? syncDevice() : true;
    7562:	cbz	r3, 7570 <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x70>
    7564:	ldr	r3, [r4, #0]
    7566:	mov	r0, r4
    7568:	ldr	r3, [r3, #28]
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
    756a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    756e:	bx	r3
    7570:	movs	r0, #1
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
    7572:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

00007576 <SdSpiCard::readStop()>:
//------------------------------------------------------------------------------
bool SdSpiCard::readStop() {
    7576:	push	{r4, lr}
  if (cardCommand(CMD12, 0)) {
    7578:	movs	r2, #0
    757a:	movs	r1, #12
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStop() {
    757c:	mov	r4, r0
  if (cardCommand(CMD12, 0)) {
    757e:	bl	719e <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7582:	cbz	r0, 7592 <SdSpiCard::readStop()+0x1c>
    7584:	movs	r3, #9
  }
  spiStop();
  return true;

 fail:
  spiStop();
    7586:	mov	r0, r4
    7588:	strb	r3, [r4, #15]
    758a:	bl	6fde <SdSpiCard::spiStop()>
  return false;
    758e:	movs	r0, #0
    7590:	pop	{r4, pc}
bool SdSpiCard::readStop() {
  if (cardCommand(CMD12, 0)) {
    error(SD_CARD_ERROR_CMD12);
    goto fail;
  }
  spiStop();
    7592:	mov	r0, r4
    7594:	bl	6fde <SdSpiCard::spiStop()>
  return true;
    7598:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    759a:	pop	{r4, pc}

0000759c <SdSpiCard::syncDevice()>:
}
//------------------------------------------------------------------------------
bool SdSpiCard::syncDevice() {
#if ENABLE_DEDICATED_SPI
  // Insure no recursive loop with cardCommand().
  uint8_t state = m_curState;
    759c:	ldrb	r2, [r0, #12]
  m_curState = IDLE_STATE;
    759e:	movs	r1, #0
  if (state == WRITE_STATE) {
    75a0:	cmp	r2, #2
//------------------------------------------------------------------------------
bool SdSpiCard::syncDevice() {
#if ENABLE_DEDICATED_SPI
  // Insure no recursive loop with cardCommand().
  uint8_t state = m_curState;
  m_curState = IDLE_STATE;
    75a2:	strb	r1, [r0, #12]
  if (state == WRITE_STATE) {
    75a4:	bne.n	75ac <SdSpiCard::syncDevice()+0x10>
    return writeStop();
    75a6:	ldr	r3, [r0, #0]
    75a8:	ldr	r3, [r3, #84]	; 0x54
    75aa:	bx	r3
  }
  if (state == READ_STATE) {
    75ac:	cmp	r2, #1
    75ae:	bne.n	75b4 <SdSpiCard::syncDevice()+0x18>
    return readStop();
    75b0:	b.w	7576 <SdSpiCard::readStop()>
  }
#endif  // ENABLE_DEDICATED_SPI
  return true;
}
    75b4:	movs	r0, #1
    75b6:	bx	lr

000075b8 <SdSpiCard::writeStart(unsigned long)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStart(uint32_t sector) {
    75b8:	push	{r3, r4, r5, lr}
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    75ba:	ldr	r3, [r0, #0]
    75bc:	ldr	r3, [r3, #72]	; 0x48
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStart(uint32_t sector) {
    75be:	mov	r5, r1
    75c0:	mov	r4, r0
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    75c2:	blx	r3
    75c4:	cmp	r0, #3
    sector <<= 9;
    75c6:	it	ne
    75c8:	lslne	r5, r5, #9
  }
  if (cardCommand(CMD25, sector)) {
    75ca:	mov	r2, r5
    75cc:	movs	r1, #25
    75ce:	mov	r0, r4
    75d0:	bl	719e <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    75d4:	cbz	r0, 75e4 <SdSpiCard::writeStart(unsigned long)+0x2c>
    75d6:	movs	r3, #14
    goto fail;
  }
  return true;

 fail:
  spiStop();
    75d8:	mov	r0, r4
    75da:	strb	r3, [r4, #15]
    75dc:	bl	6fde <SdSpiCard::spiStop()>
  return false;
    75e0:	movs	r0, #0
    75e2:	pop	{r3, r4, r5, pc}
  }
  if (cardCommand(CMD25, sector)) {
    error(SD_CARD_ERROR_CMD25);
    goto fail;
  }
  return true;
    75e4:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    75e6:	pop	{r3, r4, r5, pc}

000075e8 <SdSpiCard::erase(unsigned long, unsigned long)>:
//------------------------------------------------------------------------------
void SdSpiCard::dbgClearStats() {::dbgClearStats();}
//------------------------------------------------------------------------------
void SdSpiCard::dbgPrintStats() {::dbgPrintStats();}
//------------------------------------------------------------------------------
bool SdSpiCard::erase(uint32_t firstSector, uint32_t lastSector) {
    75e8:	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  csd_t csd;
  if (!readCSD(&csd)) {
    75ea:	ldr	r3, [r0, #0]
//------------------------------------------------------------------------------
void SdSpiCard::dbgClearStats() {::dbgClearStats();}
//------------------------------------------------------------------------------
void SdSpiCard::dbgPrintStats() {::dbgPrintStats();}
//------------------------------------------------------------------------------
bool SdSpiCard::erase(uint32_t firstSector, uint32_t lastSector) {
    75ec:	mov	r6, r1
  csd_t csd;
  if (!readCSD(&csd)) {
    75ee:	ldr	r3, [r3, #60]	; 0x3c
    75f0:	mov	r1, sp
//------------------------------------------------------------------------------
void SdSpiCard::dbgClearStats() {::dbgClearStats();}
//------------------------------------------------------------------------------
void SdSpiCard::dbgPrintStats() {::dbgPrintStats();}
//------------------------------------------------------------------------------
bool SdSpiCard::erase(uint32_t firstSector, uint32_t lastSector) {
    75f2:	mov	r4, r0
    75f4:	mov	r5, r2
  csd_t csd;
  if (!readCSD(&csd)) {
    75f6:	blx	r3
    75f8:	cbz	r0, 7660 <SdSpiCard::erase(unsigned long, unsigned long)+0x78>
    goto fail;
  }
  // check for single sector erase
  if (!csd.v1.erase_blk_en) {
    75fa:	ldrb.w	r3, [sp, #10]
    75fe:	lsls	r2, r3, #25
    7600:	bmi.n	761c <SdSpiCard::erase(unsigned long, unsigned long)+0x34>
    // erase size mask
    uint8_t m = (csd.v1.sector_size_high << 1) | csd.v1.sector_size_low;
    7602:	ldrb.w	r2, [sp, #11]
    if ((firstSector & m) != 0 || ((lastSector + 1) & m) != 0) {
    7606:	and.w	r3, r3, #63	; 0x3f
    760a:	lsls	r3, r3, #1
    760c:	orr.w	r3, r3, r2, lsr #7
    7610:	adds	r2, r5, #1
    7612:	orrs	r2, r6
    7614:	tst	r3, r2
    7616:	beq.n	761c <SdSpiCard::erase(unsigned long, unsigned long)+0x34>
    7618:	movs	r3, #39	; 0x27
    761a:	b.n	765e <SdSpiCard::erase(unsigned long, unsigned long)+0x76>
      // error card can't erase specified area
      error(SD_CARD_ERROR_ERASE_SINGLE_SECTOR);
      goto fail;
    }
  }
  if (m_type != SD_CARD_TYPE_SDHC) {
    761c:	ldrb	r3, [r4, #18]
    761e:	cmp	r3, #3
    firstSector <<= 9;
    7620:	it	ne
    7622:	lslne	r6, r6, #9
    lastSector <<= 9;
  }
  if (cardCommand(CMD32, firstSector)
    7624:	mov	r2, r6
    7626:	mov.w	r1, #32
    762a:	mov	r0, r4
      goto fail;
    }
  }
  if (m_type != SD_CARD_TYPE_SDHC) {
    firstSector <<= 9;
    lastSector <<= 9;
    762c:	it	ne
    762e:	lslne	r5, r5, #9
  }
  if (cardCommand(CMD32, firstSector)
    7630:	bl	719e <SdSpiCard::cardCommand(unsigned char, unsigned long)>
      || cardCommand(CMD33, lastSector)
      || cardCommand(CMD38, 0)) {
    7634:	cbnz	r0, 766a <SdSpiCard::erase(unsigned long, unsigned long)+0x82>
  if (m_type != SD_CARD_TYPE_SDHC) {
    firstSector <<= 9;
    lastSector <<= 9;
  }
  if (cardCommand(CMD32, firstSector)
      || cardCommand(CMD33, lastSector)
    7636:	mov	r2, r5
    7638:	movs	r1, #33	; 0x21
    763a:	mov	r0, r4
    763c:	bl	719e <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7640:	mov	r2, r0
    7642:	cbnz	r0, 766a <SdSpiCard::erase(unsigned long, unsigned long)+0x82>
      || cardCommand(CMD38, 0)) {
    7644:	movs	r1, #38	; 0x26
    7646:	mov	r0, r4
    7648:	bl	719e <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    764c:	cbnz	r0, 766a <SdSpiCard::erase(unsigned long, unsigned long)+0x82>
    error(SD_CARD_ERROR_ERASE);
    goto fail;
  }
  DBG_BEGIN_TIME(DBG_ERASE_BUSY);
  if (!waitNotBusy(SD_ERASE_TIMEOUT)) {
    764e:	movw	r1, #10000	; 0x2710
    7652:	mov	r0, r4
    7654:	bl	7176 <SdSpiCard::waitNotBusy(unsigned short)>
    7658:	mov	r5, r0
    765a:	cbnz	r0, 766e <SdSpiCard::erase(unsigned long, unsigned long)+0x86>
    765c:	movs	r3, #40	; 0x28
    765e:	strb	r3, [r4, #15]
  DBG_END_TIME(DBG_ERASE_BUSY);
  spiStop();
  return true;

 fail:
  spiStop();
    7660:	mov	r0, r4
    7662:	bl	6fde <SdSpiCard::spiStop()>
  return false;
    7666:	movs	r5, #0
    7668:	b.n	7674 <SdSpiCard::erase(unsigned long, unsigned long)+0x8c>
    766a:	movs	r3, #38	; 0x26
    766c:	b.n	765e <SdSpiCard::erase(unsigned long, unsigned long)+0x76>
  if (!waitNotBusy(SD_ERASE_TIMEOUT)) {
    error(SD_CARD_ERROR_ERASE_TIMEOUT);
    goto fail;
  }
  DBG_END_TIME(DBG_ERASE_BUSY);
  spiStop();
    766e:	mov	r0, r4
    7670:	bl	6fde <SdSpiCard::spiStop()>
  return true;

 fail:
  spiStop();
  return false;
}
    7674:	mov	r0, r5
    7676:	add	sp, #16
    7678:	pop	{r4, r5, r6, pc}

0000767a <SdSpiCard::writeStop()>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStop() {
    767a:	push	{r3, r4, r5, lr}
  DBG_BEGIN_TIME(DBG_WRITE_STOP);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    767c:	mov.w	r1, #600	; 0x258
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStop() {
    7680:	mov	r4, r0
  DBG_BEGIN_TIME(DBG_WRITE_STOP);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    7682:	bl	7176 <SdSpiCard::waitNotBusy(unsigned short)>
    7686:	mov	r5, r0
    7688:	cbz	r0, 7694 <SdSpiCard::writeStop()+0x1a>
    goto fail;
  }
  DBG_END_TIME(DBG_WRITE_STOP);
  spiSend(STOP_TRAN_TOKEN);
    768a:	movs	r1, #253	; 0xfd
    768c:	ldr	r0, [r4, #4]
    768e:	bl	6f98 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
    7692:	b.n	7698 <SdSpiCard::writeStop()+0x1e>
    7694:	movs	r3, #30
    7696:	strb	r3, [r4, #15]
  spiStop();
  return true;

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  spiStop();
    7698:	mov	r0, r4
    769a:	bl	6fde <SdSpiCard::spiStop()>
  return false;
}
    769e:	mov	r0, r5
    76a0:	pop	{r3, r4, r5, pc}

000076a2 <SdSpiCard::writeData(unsigned char, unsigned char const*)>:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send one sector of data for write sector or write multiple sectors
bool SdSpiCard::writeData(uint8_t token, const uint8_t* src) {
    76a2:	push	{r3, r4, r5, lr}
    76a4:	mov	r4, r0
#if USE_SD_CRC
  uint16_t crc = CRC_CCITT(src, 512);
#else  // USE_SD_CRC
  uint16_t crc = 0XFFFF;
#endif  // USE_SD_CRC
  spiSend(token);
    76a6:	ldr	r0, [r0, #4]
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send one sector of data for write sector or write multiple sectors
bool SdSpiCard::writeData(uint8_t token, const uint8_t* src) {
    76a8:	mov	r5, r2
#if USE_SD_CRC
  uint16_t crc = CRC_CCITT(src, 512);
#else  // USE_SD_CRC
  uint16_t crc = 0XFFFF;
#endif  // USE_SD_CRC
  spiSend(token);
    76aa:	bl	6f98 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
    76ae:	ldr	r0, [r4, #4]
  }
  void spiSend(uint8_t data) {
    m_spiDriverPtr->send(data);
  }
  void spiSend(const uint8_t* buf, size_t n) {
    m_spiDriverPtr->send(buf, n);
    76b0:	ldr	r3, [r0, #0]
    76b2:	mov.w	r2, #512	; 0x200
    76b6:	ldr	r3, [r3, #24]
    76b8:	mov	r1, r5
    76ba:	blx	r3
  spiSend(src, 512);
  spiSend(crc >> 8);
    76bc:	movs	r1, #255	; 0xff
    76be:	ldr	r0, [r4, #4]
    76c0:	bl	6f98 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
  spiSend(crc & 0XFF);
    76c4:	movs	r1, #255	; 0xff
    76c6:	ldr	r0, [r4, #4]
    76c8:	bl	6f98 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>

  m_status = spiReceive();
    76cc:	ldr	r0, [r4, #4]
    76ce:	bl	6f9e <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    76d2:	strb	r0, [r4, #17]
  if ((m_status & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
    76d4:	and.w	r0, r0, #31
    76d8:	cmp	r0, #5
    76da:	beq.n	76ea <SdSpiCard::writeData(unsigned char, unsigned char const*)+0x48>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    76dc:	movs	r3, #32
    goto fail;
  }
  return true;

 fail:
  spiStop();
    76de:	mov	r0, r4
    76e0:	strb	r3, [r4, #15]
    76e2:	bl	6fde <SdSpiCard::spiStop()>
  return false;
    76e6:	movs	r0, #0
    76e8:	pop	{r3, r4, r5, pc}
  m_status = spiReceive();
  if ((m_status & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
    error(SD_CARD_ERROR_WRITE_DATA);
    goto fail;
  }
  return true;
    76ea:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    76ec:	pop	{r3, r4, r5, pc}

000076ee <SdSpiCard::writeData(unsigned char const*)>:
  }
  return true;
#endif  // WDT_YIELD_TIME_MILLIS
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeData(const uint8_t* src) {
    76ee:	push	{r3, r4, r5, lr}
    76f0:	mov	r5, r1
  // wait for previous write to finish
  DBG_BEGIN_TIME(DBG_WRITE_BUSY);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    76f2:	mov.w	r1, #600	; 0x258
  }
  return true;
#endif  // WDT_YIELD_TIME_MILLIS
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeData(const uint8_t* src) {
    76f6:	mov	r4, r0
  // wait for previous write to finish
  DBG_BEGIN_TIME(DBG_WRITE_BUSY);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    76f8:	bl	7176 <SdSpiCard::waitNotBusy(unsigned short)>
    76fc:	cbnz	r0, 7704 <SdSpiCard::writeData(unsigned char const*)+0x16>
    76fe:	movs	r3, #36	; 0x24
    7700:	strb	r3, [r4, #15]
    7702:	b.n	7710 <SdSpiCard::writeData(unsigned char const*)+0x22>
    error(SD_CARD_ERROR_WRITE_TIMEOUT);
    goto fail;
  }
  DBG_END_TIME(DBG_WRITE_BUSY);
  if (!writeData(WRITE_MULTIPLE_TOKEN, src)) {
    7704:	mov	r2, r5
    7706:	movs	r1, #252	; 0xfc
    7708:	mov	r0, r4
    770a:	bl	76a2 <SdSpiCard::writeData(unsigned char, unsigned char const*)>
    770e:	cbnz	r0, 7718 <SdSpiCard::writeData(unsigned char const*)+0x2a>
    goto fail;
  }
  return true;

 fail:
  spiStop();
    7710:	mov	r0, r4
    7712:	bl	6fde <SdSpiCard::spiStop()>
  return false;
    7716:	movs	r0, #0
}
    7718:	pop	{r3, r4, r5, pc}

0000771a <SdSpiCard::writeSingle(unsigned long, unsigned char const*)>:
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSingle(uint32_t sector, const uint8_t* src) {
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    771a:	ldr	r3, [r0, #0]
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSingle(uint32_t sector, const uint8_t* src) {
    771c:	push	{r4, r5, r6, lr}
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    771e:	ldr	r3, [r3, #72]	; 0x48
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSingle(uint32_t sector, const uint8_t* src) {
    7720:	mov	r5, r1
    7722:	mov	r4, r0
    7724:	mov	r6, r2
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    7726:	blx	r3
    7728:	cmp	r0, #3
    sector <<= 9;
    772a:	it	ne
    772c:	lslne	r5, r5, #9
  }
  if (cardCommand(CMD24, sector)) {
    772e:	mov	r2, r5
    7730:	movs	r1, #24
    7732:	mov	r0, r4
    7734:	bl	719e <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7738:	cbz	r0, 7740 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x26>
    773a:	movs	r3, #13
    773c:	strb	r3, [r4, #15]
    773e:	b.n	7756 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x3c>
    error(SD_CARD_ERROR_CMD24);
    goto fail;
  }
  if (!writeData(DATA_START_SECTOR, src)) {
    7740:	mov	r2, r6
    7742:	movs	r1, #254	; 0xfe
    7744:	mov	r0, r4
    7746:	bl	76a2 <SdSpiCard::writeData(unsigned char, unsigned char const*)>
    774a:	mov	r5, r0
    774c:	cbz	r0, 7756 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x3c>
    error(SD_CARD_ERROR_CMD13);
    goto fail;
  }
#endif  // CHECK_FLASH_PROGRAMMING

  spiStop();
    774e:	mov	r0, r4
    7750:	bl	6fde <SdSpiCard::spiStop()>
  return true;
    7754:	b.n	775e <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x44>

 fail:
  spiStop();
    7756:	mov	r0, r4
    7758:	bl	6fde <SdSpiCard::spiStop()>
  return false;
    775c:	movs	r5, #0
}
    775e:	mov	r0, r5
    7760:	pop	{r4, r5, r6, pc}

00007762 <SdSpiCard::writeSector(unsigned long, unsigned char const*)>:
   *
   * \param[in] sector Logical sector to be written.
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool writeSector(uint32_t sector, const uint8_t* src) {
    7762:	push	{r4}
    if (m_sharedSpi) {
    7764:	ldrb	r4, [r0, #13]
    7766:	cbz	r4, 7770 <SdSpiCard::writeSector(unsigned long, unsigned char const*)+0xe>
      return writeSingle(sector, src);
    } else {
      return writeSectors(sector, src, 1);
    }
  }
    7768:	ldr.w	r4, [sp], #4
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool writeSector(uint32_t sector, const uint8_t* src) {
    if (m_sharedSpi) {
      return writeSingle(sector, src);
    776c:	b.w	771a <SdSpiCard::writeSingle(unsigned long, unsigned char const*)>
    } else {
      return writeSectors(sector, src, 1);
    7770:	ldr	r3, [r0, #0]
    7772:	ldr	r4, [r3, #36]	; 0x24
    7774:	movs	r3, #1
    7776:	mov	ip, r4
    }
  }
    7778:	ldr.w	r4, [sp], #4
   */
  bool writeSector(uint32_t sector, const uint8_t* src) {
    if (m_sharedSpi) {
      return writeSingle(sector, src);
    } else {
      return writeSectors(sector, src, 1);
    777c:	bx	ip
    777e:	Address 0x0000777e is out of bounds.


00007780 <sdIrs()>:
  return false;
}
//==============================================================================
// ISR
static void sdIrs() {
  SDHC_IRQSIGEN = 0;
    7780:	ldr	r2, [pc, #24]	; (779c <sdIrs()+0x1c>)
  m_irqstat = SDHC_IRQSTAT;
    7782:	ldr	r1, [pc, #28]	; (77a0 <sdIrs()+0x20>)
  return false;
}
//==============================================================================
// ISR
static void sdIrs() {
  SDHC_IRQSIGEN = 0;
    7784:	movs	r3, #0
    7786:	str	r3, [r2, #0]
  m_irqstat = SDHC_IRQSTAT;
    7788:	ldr.w	r0, [r2, #-8]
    778c:	str	r0, [r1, #0]
  SDHC_IRQSTAT = m_irqstat;
    778e:	ldr	r1, [r1, #0]
    7790:	str.w	r1, [r2, #-8]
#if defined(__IMXRT1062__)
  SDHC_MIX_CTRL &= ~(SDHC_MIX_CTRL_AC23EN | SDHC_MIX_CTRL_DMAEN);
#endif
  m_dmaBusy = false;
    7794:	ldr	r2, [pc, #12]	; (77a4 <sdIrs()+0x24>)
    7796:	strb	r3, [r2, #0]
    7798:	bx	lr
    779a:	nop
    779c:	.word	0x400b1038
    77a0:	.word	0x1fff8450
    77a4:	.word	0x1fff8465

000077a8 <isBusyCommandComplete()>:
static bool isBusyCMD13() {
  return !(statusCMD13() & CARD_STATUS_READY_FOR_DATA);
}
//------------------------------------------------------------------------------
static bool isBusyCommandComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_CC | SDHC_IRQSTAT_CMD_ERROR));
    77a8:	ldr	r3, [pc, #12]	; (77b8 <isBusyCommandComplete()+0x10>)
    77aa:	ldr	r0, [pc, #16]	; (77bc <isBusyCommandComplete()+0x14>)
    77ac:	ldr	r3, [r3, #0]
    77ae:	ands	r0, r3
}
    77b0:	clz	r0, r0
    77b4:	lsrs	r0, r0, #5
    77b6:	bx	lr
    77b8:	.word	0x400b1030
    77bc:	.word	0x000f0001

000077c0 <isBusyCommandInhibit()>:
//------------------------------------------------------------------------------
static bool isBusyCommandInhibit() {
  return SDHC_PRSSTAT & SDHC_PRSSTAT_CIHB;
    77c0:	ldr	r3, [pc, #8]	; (77cc <isBusyCommandInhibit()+0xc>)
    77c2:	ldr	r0, [r3, #0]
}
    77c4:	and.w	r0, r0, #1
    77c8:	bx	lr
    77ca:	nop
    77cc:	.word	0x400b1024

000077d0 <isBusyDat()>:
//------------------------------------------------------------------------------
static bool isBusyDat() {
  return SDHC_PRSSTAT & (1 << 24) ? false : true;
    77d0:	ldr	r3, [pc, #12]	; (77e0 <isBusyDat()+0x10>)
    77d2:	ldr	r0, [r3, #0]
    77d4:	eor.w	r0, r0, #16777216	; 0x1000000
}
    77d8:	ubfx	r0, r0, #24, #1
    77dc:	bx	lr
    77de:	nop
    77e0:	.word	0x400b1024

000077e4 <isBusyDMA()>:
//------------------------------------------------------------------------------
static bool isBusyDMA() {
  return m_dmaBusy;
    77e4:	ldr	r3, [pc, #4]	; (77ec <isBusyDMA()+0x8>)
    77e6:	ldrb	r0, [r3, #0]
}
    77e8:	bx	lr
    77ea:	nop
    77ec:	.word	0x1fff8465

000077f0 <isBusyFifoRead()>:
//------------------------------------------------------------------------------
static bool isBusyFifoRead() {
  return !(SDHC_PRSSTAT & SDHC_PRSSTAT_BREN);
    77f0:	ldr	r3, [pc, #12]	; (7800 <isBusyFifoRead()+0x10>)
    77f2:	ldr	r0, [r3, #0]
    77f4:	eor.w	r0, r0, #2048	; 0x800
}
    77f8:	ubfx	r0, r0, #11, #1
    77fc:	bx	lr
    77fe:	nop
    7800:	.word	0x400b1024

00007804 <isBusyFifoWrite()>:
//------------------------------------------------------------------------------
static bool isBusyFifoWrite() {
  return !(SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN);
    7804:	ldr	r3, [pc, #12]	; (7814 <isBusyFifoWrite()+0x10>)
    7806:	ldr	r0, [r3, #0]
    7808:	eor.w	r0, r0, #1024	; 0x400
}
    780c:	ubfx	r0, r0, #10, #1
    7810:	bx	lr
    7812:	nop
    7814:	.word	0x400b1024

00007818 <isBusyTransferComplete()>:
//------------------------------------------------------------------------------
static bool isBusyTransferComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_TC | SDHC_IRQSTAT_ERROR));
    7818:	ldr	r3, [pc, #12]	; (7828 <isBusyTransferComplete()+0x10>)
    781a:	ldr	r0, [pc, #16]	; (782c <isBusyTransferComplete()+0x14>)
    781c:	ldr	r3, [r3, #0]
    781e:	ands	r0, r3
}
    7820:	clz	r0, r0
    7824:	lsrs	r0, r0, #5
    7826:	bx	lr
    7828:	.word	0x400b1030
    782c:	.word	0x117f0002

00007830 <setSdclk(unsigned long)>:
static void setSdclk(uint32_t kHzMax) {
  const uint32_t DVS_LIMIT = 0X10;
  const uint32_t SDCLKFS_LIMIT = 0X100;
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
    7830:	mov.w	r3, #1000	; 0x3e8
  }
  d[15] = 0;
  return true;
}
//------------------------------------------------------------------------------
static void setSdclk(uint32_t kHzMax) {
    7834:	push	{r4, r5, lr}
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    7836:	ldr	r4, [pc, #128]	; (78b8 <setSdclk(unsigned long)+0x88>)
static void setSdclk(uint32_t kHzMax) {
  const uint32_t DVS_LIMIT = 0X10;
  const uint32_t SDCLKFS_LIMIT = 0X100;
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
    7838:	muls	r0, r3
//------------------------------------------------------------------------------
static void setSdclk(uint32_t kHzMax) {
  const uint32_t DVS_LIMIT = 0X10;
  const uint32_t SDCLKFS_LIMIT = 0X100;
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
    783a:	movs	r2, #1
  uint32_t maxSdclk = 1000*kHzMax;
    783c:	movs	r3, #9
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    783e:	lsls	r1, r2, #4
    7840:	udiv	r1, r4, r1
    7844:	cmp	r0, r1
    7846:	bcc.n	7850 <setSdclk(unsigned long)+0x20>
    7848:	movs	r4, #1
    784a:	mov	r3, r2
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    784c:	ldr	r5, [pc, #104]	; (78b8 <setSdclk(unsigned long)+0x88>)
    784e:	b.n	7864 <setSdclk(unsigned long)+0x34>
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    7850:	subs	r3, #1
    7852:	beq.n	7848 <setSdclk(unsigned long)+0x18>
    sdclkfs <<= 1;
    7854:	lsls	r2, r2, #1
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    7856:	b.n	783e <setSdclk(unsigned long)+0xe>
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    7858:	cmp	r4, #16
    785a:	add.w	r1, r3, r2
    785e:	beq.n	786c <setSdclk(unsigned long)+0x3c>
    dvs++;
    7860:	adds	r4, #1
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    7862:	mov	r3, r1
    7864:	udiv	r1, r5, r3
    7868:	cmp	r0, r1
    786a:	bcc.n	7858 <setSdclk(unsigned long)+0x28>
    dvs++;
  }
  m_sdClkKhz = base/(1000*sdclkfs*dvs);
    786c:	mov.w	r1, #1000	; 0x3e8
    7870:	muls	r3, r1
    7872:	ldr	r1, [pc, #68]	; (78b8 <setSdclk(unsigned long)+0x88>)
    7874:	udiv	r3, r1, r3
    7878:	ldr	r1, [pc, #64]	; (78bc <setSdclk(unsigned long)+0x8c>)
  sdclkfs >>= 1;
  dvs--;
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
  // Disable SDHC clock.
  SDHC_SYSCTL &= ~SDHC_SYSCTL_SDCLKEN;
    787a:	ldr	r0, [pc, #68]	; (78c0 <setSdclk(unsigned long)+0x90>)
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    dvs++;
  }
  m_sdClkKhz = base/(1000*sdclkfs*dvs);
    787c:	str	r3, [r1, #0]
  sdclkfs >>= 1;
  dvs--;
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
  // Disable SDHC clock.
  SDHC_SYSCTL &= ~SDHC_SYSCTL_SDCLKEN;
    787e:	ldr	r3, [r0, #0]
    7880:	bic.w	r3, r3, #8
    7884:	str	r3, [r0, #0]
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)

  // Change dividers.
  uint32_t sysctl = SDHC_SYSCTL & ~(SDHC_SYSCTL_DTOCV_MASK
    7886:	ldr	r1, [r0, #0]
                    | SDHC_SYSCTL_DVS_MASK | SDHC_SYSCTL_SDCLKFS_MASK);

  SDHC_SYSCTL = sysctl | SDHC_SYSCTL_DTOCV(0x0E) | SDHC_SYSCTL_DVS(dvs)
                | SDHC_SYSCTL_SDCLKFS(sdclkfs);
    7888:	bic.w	r3, r1, #1044480	; 0xff000
    788c:	lsls	r2, r2, #7
    788e:	bic.w	r3, r3, #4080	; 0xff0
    7892:	orr.w	r3, r3, #917504	; 0xe0000
    7896:	and.w	r2, r2, #65280	; 0xff00
    789a:	orrs	r2, r3
    789c:	subs	r3, r4, #1
    789e:	orr.w	r3, r2, r3, lsl #4

  // Wait until the SDHC clock is stable.
  while (!(SDHC_PRSSTAT & SDHC_PRSSTAT_SDSTB)) {
    78a2:	ldr	r2, [pc, #32]	; (78c4 <setSdclk(unsigned long)+0x94>)
  // Change dividers.
  uint32_t sysctl = SDHC_SYSCTL & ~(SDHC_SYSCTL_DTOCV_MASK
                    | SDHC_SYSCTL_DVS_MASK | SDHC_SYSCTL_SDCLKFS_MASK);

  SDHC_SYSCTL = sysctl | SDHC_SYSCTL_DTOCV(0x0E) | SDHC_SYSCTL_DVS(dvs)
                | SDHC_SYSCTL_SDCLKFS(sdclkfs);
    78a4:	str	r3, [r0, #0]

  // Wait until the SDHC clock is stable.
  while (!(SDHC_PRSSTAT & SDHC_PRSSTAT_SDSTB)) {
    78a6:	ldr	r3, [r2, #0]
    78a8:	lsls	r3, r3, #28
    78aa:	bpl.n	78a6 <setSdclk(unsigned long)+0x76>
  }

#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
  // Enable the SDHC clock.
  SDHC_SYSCTL |= SDHC_SYSCTL_SDCLKEN;
    78ac:	ldr	r3, [r0, #0]
    78ae:	orr.w	r3, r3, #8
    78b2:	str	r3, [r0, #0]
    78b4:	pop	{r4, r5, pc}
    78b6:	nop
    78b8:	.word	0x05b8d800
    78bc:	.word	0x1fff8468
    78c0:	.word	0x400b102c
    78c4:	.word	0x400b1024

000078c8 <SdioCard::errorCode() const>:
  return true;
}
//------------------------------------------------------------------------------
uint8_t SdioCard::errorCode() const {
  return m_errorCode;
}
    78c8:	ldr	r3, [pc, #4]	; (78d0 <SdioCard::errorCode() const+0x8>)
    78ca:	ldrb	r0, [r3, #0]
    78cc:	bx	lr
    78ce:	nop
    78d0:	.word	0x1fff1358

000078d4 <SdioCard::errorData() const>:
//------------------------------------------------------------------------------
uint32_t SdioCard::errorData() const {
  return m_irqstat;
    78d4:	ldr	r3, [pc, #4]	; (78dc <SdioCard::errorData() const+0x8>)
    78d6:	ldr	r0, [r3, #0]
}
    78d8:	bx	lr
    78da:	nop
    78dc:	.word	0x1fff8450

000078e0 <SdioCard::readCID(CID*)>:
uint32_t SdioCard::kHzSdClk() {
  return m_sdClkKhz;
}
//------------------------------------------------------------------------------
bool SdioCard::readCID(cid_t* cid) {
  memcpy(cid, &m_cid, 16);
    78e0:	ldr	r3, [pc, #20]	; (78f8 <SdioCard::readCID(CID*)+0x18>)
    78e2:	add.w	r2, r3, #16
    78e6:	ldr.w	r0, [r3], #4
    78ea:	str.w	r0, [r1], #4
    78ee:	cmp	r3, r2
    78f0:	bne.n	78e6 <SdioCard::readCID(CID*)+0x6>
  return true;
}
    78f2:	movs	r0, #1
    78f4:	bx	lr
    78f6:	nop
    78f8:	.word	0x1fff8429

000078fc <SdioCard::readCSD(csd_t*)>:
//------------------------------------------------------------------------------
bool SdioCard::readCSD(csd_t* csd) {
  memcpy(csd, &m_csd, 16);
    78fc:	ldr	r3, [pc, #20]	; (7914 <SdioCard::readCSD(csd_t*)+0x18>)
    78fe:	add.w	r2, r3, #16
    7902:	ldr.w	r0, [r3], #4
    7906:	str.w	r0, [r1], #4
    790a:	cmp	r3, r2
    790c:	bne.n	7902 <SdioCard::readCSD(csd_t*)+0x6>
  return true;
}
    790e:	movs	r0, #1
    7910:	bx	lr
    7912:	nop
    7914:	.word	0x1fff8455

00007918 <SdioCard::readOCR(unsigned long*)>:
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
//------------------------------------------------------------------------------
bool SdioCard::readOCR(uint32_t* ocr) {
  *ocr = m_ocr;
    7918:	ldr	r3, [pc, #8]	; (7924 <SdioCard::readOCR(unsigned long*)+0xc>)
    791a:	ldr	r3, [r3, #0]
    791c:	str	r3, [r1, #0]
  return true;
}
    791e:	movs	r0, #1
    7920:	bx	lr
    7922:	nop
    7924:	.word	0x1fff8444

00007928 <SdioCard::~SdioCard()>:
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    7928:	bx	lr
    792a:	Address 0x0000792a is out of bounds.


0000792c <waitTimeout(bool (*)())>:
  }
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool waitTimeout(bool (*fcn)()) {
    792c:	push	{r3, r4, r5, r6, r7, lr}
    792e:	mov	r7, r0
  uint32_t m = micros();
    7930:	bl	8d98 <micros>
  while (fcn()) {
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    7934:	ldr	r5, [pc, #20]	; (794c <waitTimeout(bool (*)())+0x20>)
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool waitTimeout(bool (*fcn)()) {
  uint32_t m = micros();
    7936:	mov	r6, r0
  while (fcn()) {
    7938:	blx	r7
    793a:	mov	r4, r0
    793c:	cbz	r0, 7948 <waitTimeout(bool (*)())+0x1c>
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    793e:	bl	8d98 <micros>
    7942:	subs	r0, r0, r6
    7944:	cmp	r0, r5
    7946:	bls.n	7938 <waitTimeout(bool (*)())+0xc>
      return true;
    }
  }
  return false;  // Caller will set errorCode.
}
    7948:	mov	r0, r4
    794a:	pop	{r3, r4, r5, r6, r7, pc}
    794c:	.word	0x000f4240

00007950 <yieldTimeout(bool (*)())>:
  }
  return true;
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool yieldTimeout(bool (*fcn)()) {
    7950:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  m_busyFcn = fcn;
    7954:	ldr	r4, [pc, #48]	; (7988 <yieldTimeout(bool (*)())+0x38>)
  uint32_t m = micros();
  while (fcn()) {
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    7956:	ldr.w	r8, [pc, #52]	; 798c <yieldTimeout(bool (*)())+0x3c>
  return true;
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool yieldTimeout(bool (*fcn)()) {
  m_busyFcn = fcn;
    795a:	str	r0, [r4, #0]
  }
  return true;
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool yieldTimeout(bool (*fcn)()) {
    795c:	mov	r6, r0
  m_busyFcn = fcn;
  uint32_t m = micros();
    795e:	bl	8d98 <micros>
    7962:	mov	r7, r0
  while (fcn()) {
    7964:	blx	r6
    7966:	mov	r5, r0
    7968:	cbz	r0, 7980 <yieldTimeout(bool (*)())+0x30>
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    796a:	bl	8d98 <micros>
    796e:	subs	r0, r0, r7
    7970:	cmp	r0, r8
    7972:	bls.n	797a <yieldTimeout(bool (*)())+0x2a>
      m_busyFcn = 0;
    7974:	movs	r3, #0
    7976:	str	r3, [r4, #0]
      return true;
    7978:	b.n	7982 <yieldTimeout(bool (*)())+0x32>
  }
}
#elif defined(ARDUINO)
inline void SysCall::yield() {
  // Use the external Arduino yield() function.
  ::yield();
    797a:	bl	97d8 <yield>
    797e:	b.n	7964 <yieldTimeout(bool (*)())+0x14>
    }
    SysCall::yield();
  }
  m_busyFcn = 0;
    7980:	str	r0, [r4, #0]
  return false;  // Caller will set errorCode.
}
    7982:	mov	r0, r5
    7984:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    7988:	.word	0x1fff843c
    798c:	.word	0x000f4240

00007990 <SdioCard::~SdioCard()>:
    7990:	push	{r4, lr}
    7992:	movs	r1, #12
    7994:	mov	r4, r0
    7996:	bl	9c08 <operator delete(void*, unsigned int)>
    799a:	mov	r0, r4
    799c:	pop	{r4, pc}
    799e:	Address 0x0000799e is out of bounds.


000079a0 <SdioCard::type() const>:
  return true;
}
//------------------------------------------------------------------------------
uint8_t SdioCard::type() const {
  return  m_version2 ? m_highCapacity ?
          SD_CARD_TYPE_SDHC : SD_CARD_TYPE_SD2 : SD_CARD_TYPE_SD1;
    79a0:	ldr	r3, [pc, #20]	; (79b8 <SdioCard::type() const+0x18>)
    79a2:	ldrb	r3, [r3, #0]
    79a4:	cbz	r3, 79b4 <SdioCard::type() const+0x14>
    79a6:	ldr	r3, [pc, #20]	; (79bc <SdioCard::type() const+0x1c>)
    79a8:	ldrb	r3, [r3, #0]
    79aa:	cmp	r3, #0
    79ac:	ite	ne
    79ae:	movne	r0, #3
    79b0:	moveq	r0, #2
    79b2:	bx	lr
    79b4:	movs	r0, #1
}
    79b6:	bx	lr
    79b8:	.word	0x1fff8428
    79bc:	.word	0x1fff8440

000079c0 <cardCommand(unsigned long, unsigned long)>:
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
}
//------------------------------------------------------------------------------
static bool cardCommand(uint32_t xfertyp, uint32_t arg) {
    79c0:	push	{r3, r4, r5, lr}
    79c2:	mov	r4, r0
  DBG_IRQSTAT();
  if (waitTimeout(isBusyCommandInhibit)) {
    79c4:	ldr	r0, [pc, #56]	; (7a00 <cardCommand(unsigned long, unsigned long)+0x40>)
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
}
//------------------------------------------------------------------------------
static bool cardCommand(uint32_t xfertyp, uint32_t arg) {
    79c6:	mov	r5, r1
  DBG_IRQSTAT();
  if (waitTimeout(isBusyCommandInhibit)) {
    79c8:	bl	792c <waitTimeout(bool (*)())>
    79cc:	cbnz	r0, 79f6 <cardCommand(unsigned long, unsigned long)+0x36>
    return false;  // Caller will set errorCode.
  }
  SDHC_CMDARG = arg;
    79ce:	ldr	r3, [pc, #52]	; (7a04 <cardCommand(unsigned long, unsigned long)+0x44>)
    SDHC_MIX_CTRL |= xfertyp & SDHC_MIX_CTRL_MASK;
  }
  xfertyp &= ~SDHC_MIX_CTRL_MASK;
#endif  // defined(__IMXRT1062__)
  SDHC_XFERTYP = xfertyp;
  if (waitTimeout(isBusyCommandComplete)) {
    79d0:	ldr	r0, [pc, #52]	; (7a08 <cardCommand(unsigned long, unsigned long)+0x48>)
static bool cardCommand(uint32_t xfertyp, uint32_t arg) {
  DBG_IRQSTAT();
  if (waitTimeout(isBusyCommandInhibit)) {
    return false;  // Caller will set errorCode.
  }
  SDHC_CMDARG = arg;
    79d2:	str	r5, [r3, #0]
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_MASK;
    SDHC_MIX_CTRL |= xfertyp & SDHC_MIX_CTRL_MASK;
  }
  xfertyp &= ~SDHC_MIX_CTRL_MASK;
#endif  // defined(__IMXRT1062__)
  SDHC_XFERTYP = xfertyp;
    79d4:	str	r4, [r3, #4]
  if (waitTimeout(isBusyCommandComplete)) {
    79d6:	bl	792c <waitTimeout(bool (*)())>
    79da:	cbnz	r0, 79f6 <cardCommand(unsigned long, unsigned long)+0x36>
    return false;  // Caller will set errorCode.
  }
  m_irqstat = SDHC_IRQSTAT;
    79dc:	ldr	r2, [pc, #44]	; (7a0c <cardCommand(unsigned long, unsigned long)+0x4c>)
    79de:	ldr	r3, [pc, #48]	; (7a10 <cardCommand(unsigned long, unsigned long)+0x50>)
    79e0:	ldr	r1, [r2, #0]
    79e2:	str	r1, [r3, #0]
  SDHC_IRQSTAT = m_irqstat;
    79e4:	ldr	r1, [r3, #0]
    79e6:	str	r1, [r2, #0]

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
    79e8:	ldr	r2, [r3, #0]
    79ea:	lsls	r2, r2, #31
    79ec:	bpl.n	79f6 <cardCommand(unsigned long, unsigned long)+0x36>
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
    79ee:	ldr	r3, [r3, #0]
    return false;  // Caller will set errorCode.
  }
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
    79f0:	tst.w	r3, #983040	; 0xf0000
    79f4:	beq.n	79fa <cardCommand(unsigned long, unsigned long)+0x3a>
    79f6:	movs	r0, #0
    79f8:	pop	{r3, r4, r5, pc}
    79fa:	movs	r0, #1
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
}
    79fc:	pop	{r3, r4, r5, pc}
    79fe:	nop
    7a00:	.word	0x000077c1
    7a04:	.word	0x400b1008
    7a08:	.word	0x000077a9
    7a0c:	.word	0x400b1030
    7a10:	.word	0x1fff8450

00007a14 <statusCMD13()>:
  SDHC_SYSCTL |= SDHC_SYSCTL_INITA;
  while (SDHC_SYSCTL & SDHC_SYSCTL_INITA) {
  }
}
//------------------------------------------------------------------------------
static uint32_t statusCMD13() {
    7a14:	push	{r3, lr}
  return cardCommand(CMD13_XFERTYP, m_rca) ? SDHC_CMDRSP0 : 0;
    7a16:	ldr	r3, [pc, #16]	; (7a28 <statusCMD13()+0x14>)
    7a18:	ldr	r0, [pc, #16]	; (7a2c <statusCMD13()+0x18>)
    7a1a:	ldr	r1, [r3, #0]
    7a1c:	bl	79c0 <cardCommand(unsigned long, unsigned long)>
    7a20:	cbz	r0, 7a26 <statusCMD13()+0x12>
    7a22:	ldr	r3, [pc, #12]	; (7a30 <statusCMD13()+0x1c>)
    7a24:	ldr	r0, [r3, #0]
}
    7a26:	pop	{r3, pc}
    7a28:	.word	0x1fff8448
    7a2c:	.word	0x0d1a0000
    7a30:	.word	0x400b1010

00007a34 <isBusyCMD13()>:
//------------------------------------------------------------------------------
static bool isBusyCMD13() {
    7a34:	push	{r3, lr}
  return !(statusCMD13() & CARD_STATUS_READY_FOR_DATA);
    7a36:	bl	7a14 <statusCMD13()>
    7a3a:	eor.w	r0, r0, #256	; 0x100
}
    7a3e:	ubfx	r0, r0, #8, #1
    7a42:	pop	{r3, pc}

00007a44 <SdioCard::status()>:
uint32_t SdioCard::sectorCount() {
  return sdCardCapacity(&m_csd);
}
//------------------------------------------------------------------------------
uint32_t SdioCard::status() {
  return statusCMD13();
    7a44:	b.w	7a14 <statusCMD13()>

00007a48 <readReg16(unsigned long, void*)>:
  }
  return waitDmaStatus();
}
//------------------------------------------------------------------------------
// Read 16 byte CID or CSD register.
static bool readReg16(uint32_t xfertyp, void* data) {
    7a48:	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    7a4a:	ldr	r3, [pc, #80]	; (7a9c <readReg16(unsigned long, void*)+0x54>)
  }
  return waitDmaStatus();
}
//------------------------------------------------------------------------------
// Read 16 byte CID or CSD register.
static bool readReg16(uint32_t xfertyp, void* data) {
    7a4c:	mov	r5, r1
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    7a4e:	ldr	r1, [r3, #0]
    7a50:	bl	79c0 <cardCommand(unsigned long, unsigned long)>
    7a54:	cbz	r0, 7a96 <readReg16(unsigned long, void*)+0x4e>
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
    7a56:	ldr	r3, [pc, #72]	; (7aa0 <readReg16(unsigned long, void*)+0x58>)
    7a58:	ldr	r3, [r3, #0]
    7a5a:	str	r3, [sp, #0]
    7a5c:	ldr	r3, [pc, #68]	; (7aa4 <readReg16(unsigned long, void*)+0x5c>)
    7a5e:	ldr	r3, [r3, #0]
    7a60:	str	r3, [sp, #4]
    7a62:	ldr	r3, [pc, #68]	; (7aa8 <readReg16(unsigned long, void*)+0x60>)
    7a64:	ldr	r3, [r3, #0]
    7a66:	str	r3, [sp, #8]
    7a68:	ldr	r3, [pc, #64]	; (7aac <readReg16(unsigned long, void*)+0x64>)
    7a6a:	ldr	r3, [r3, #0]
    7a6c:	str	r3, [sp, #12]
    7a6e:	add.w	r6, r5, #15
  for (int i = 0; i < 15; i++) {
    7a72:	movs	r3, #0
    d[14 - i] = sr[i/4] >> 8*(i%4);
    7a74:	bic.w	r4, r3, #3
    7a78:	add	r2, sp, #16
    7a7a:	add	r4, r2
    7a7c:	and.w	r2, r3, #3
    7a80:	lsls	r1, r2, #3
    7a82:	ldr.w	r2, [r4, #-16]
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
  for (int i = 0; i < 15; i++) {
    7a86:	adds	r3, #1
    d[14 - i] = sr[i/4] >> 8*(i%4);
    7a88:	lsrs	r2, r1
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
  for (int i = 0; i < 15; i++) {
    7a8a:	cmp	r3, #15
    d[14 - i] = sr[i/4] >> 8*(i%4);
    7a8c:	strb.w	r2, [r6, #-1]!
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
  for (int i = 0; i < 15; i++) {
    7a90:	bne.n	7a74 <readReg16(unsigned long, void*)+0x2c>
    d[14 - i] = sr[i/4] >> 8*(i%4);
  }
  d[15] = 0;
    7a92:	movs	r3, #0
    7a94:	strb	r3, [r5, #15]
  return true;
}
    7a96:	add	sp, #16
    7a98:	pop	{r4, r5, r6, pc}
    7a9a:	nop
    7a9c:	.word	0x1fff8448
    7aa0:	.word	0x400b1010
    7aa4:	.word	0x400b1014
    7aa8:	.word	0x400b1018
    7aac:	.word	0x400b101c

00007ab0 <waitDmaStatus() [clone .part.4]>:
//------------------------------------------------------------------------------
static bool waitDmaStatus() {
  if (yieldTimeout(isBusyDMA)) {
    return false;  // Caller will set errorCode.
  }
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
    7ab0:	ldr	r3, [pc, #20]	; (7ac8 <waitDmaStatus() [clone .part.4]+0x18>)
    7ab2:	ldr	r0, [r3, #0]
    7ab4:	ands.w	r0, r0, #2
    7ab8:	beq.n	7ac6 <waitDmaStatus() [clone .part.4]+0x16>
    7aba:	ldr	r3, [r3, #0]
    7abc:	ldr	r0, [pc, #12]	; (7acc <waitDmaStatus() [clone .part.4]+0x1c>)
    7abe:	ands	r0, r3
    7ac0:	clz	r0, r0
    7ac4:	lsrs	r0, r0, #5
}
    7ac6:	bx	lr
    7ac8:	.word	0x1fff8450
    7acc:	.word	0x117f0000

00007ad0 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>:
static bool isBusyTransferComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_TC | SDHC_IRQSTAT_ERROR));
}
//------------------------------------------------------------------------------
static bool rdWrSectors(uint32_t xfertyp,
                       uint32_t sector, uint8_t* buf, size_t n) {
    7ad0:	push	{r3, r4, r5, r6, r7, lr}
    7ad2:	mov	r4, r3
  if ((3 & (uint32_t)buf) || n == 0) {
    7ad4:	lsls	r3, r2, #30
static bool isBusyTransferComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_TC | SDHC_IRQSTAT_ERROR));
}
//------------------------------------------------------------------------------
static bool rdWrSectors(uint32_t xfertyp,
                       uint32_t sector, uint8_t* buf, size_t n) {
    7ad6:	mov	r7, r0
    7ad8:	mov	r5, r1
    7ada:	mov	r6, r2
  if ((3 & (uint32_t)buf) || n == 0) {
    7adc:	bne.n	7ae0 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x10>
    7ade:	cbnz	r4, 7aec <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x1c>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    7ae0:	ldr	r3, [pc, #100]	; (7b48 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x78>)
    7ae2:	movs	r2, #37	; 0x25
    7ae4:	strb	r2, [r3, #0]
  m_errorLine = line;
    7ae6:	mov.w	r2, #506	; 0x1fa
    7aea:	b.n	7afe <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x2e>
static bool rdWrSectors(uint32_t xfertyp,
                       uint32_t sector, uint8_t* buf, size_t n) {
  if ((3 & (uint32_t)buf) || n == 0) {
    return sdError(SD_CARD_ERROR_DMA);
  }
  if (yieldTimeout(isBusyCMD13)) {
    7aec:	ldr	r0, [pc, #92]	; (7b4c <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x7c>)
    7aee:	bl	7950 <yieldTimeout(bool (*)())>
    7af2:	cbz	r0, 7b04 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x34>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    7af4:	ldr	r3, [pc, #80]	; (7b48 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x78>)
    7af6:	movs	r2, #10
    7af8:	strb	r2, [r3, #0]
  m_errorLine = line;
    7afa:	movw	r2, #509	; 0x1fd
    7afe:	ldr	r3, [pc, #80]	; (7b50 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x80>)
    7b00:	str	r2, [r3, #0]
                       uint32_t sector, uint8_t* buf, size_t n) {
  if ((3 & (uint32_t)buf) || n == 0) {
    return sdError(SD_CARD_ERROR_DMA);
  }
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
    7b02:	b.n	7b42 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x72>
  }
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
    7b04:	ldr	r3, [pc, #76]	; (7b54 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x84>)
    7b06:	movs	r2, #1
    7b08:	strb	r2, [r3, #0]
  m_irqstat = 0;
    7b0a:	ldr	r3, [pc, #76]	; (7b58 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x88>)
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
    7b0c:	ldr	r2, [pc, #76]	; (7b5c <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x8c>)
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
  m_irqstat = 0;
    7b0e:	str	r0, [r3, #0]
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
    7b10:	lsls	r4, r4, #16
  }
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
    7b12:	ldr	r3, [pc, #76]	; (7b60 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x90>)
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
    7b14:	orr.w	r4, r4, #512	; 0x200
  }
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
    7b18:	str	r6, [r3, #0]
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
    7b1a:	str	r4, [r3, #4]
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
    7b1c:	str	r2, [r3, #56]	; 0x38
  if (!cardCommand(xfertyp, m_highCapacity ? sector : 512*sector)) {
    7b1e:	ldr	r3, [pc, #68]	; (7b64 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x94>)
    7b20:	ldrb	r3, [r3, #0]
    7b22:	cbnz	r3, 7b28 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x58>
    7b24:	lsls	r1, r5, #9
    7b26:	b.n	7b2a <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x5a>
    7b28:	mov	r1, r5
    7b2a:	mov	r0, r7
    7b2c:	bl	79c0 <cardCommand(unsigned long, unsigned long)>
    7b30:	cbz	r0, 7b42 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x72>
  m_busyFcn = 0;
  return false;  // Caller will set errorCode.
}
//------------------------------------------------------------------------------
static bool waitDmaStatus() {
  if (yieldTimeout(isBusyDMA)) {
    7b32:	ldr	r0, [pc, #52]	; (7b68 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x98>)
    7b34:	bl	7950 <yieldTimeout(bool (*)())>
    7b38:	cbnz	r0, 7b42 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x72>
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(xfertyp, m_highCapacity ? sector : 512*sector)) {
    return false;
  }
  return waitDmaStatus();
}
    7b3a:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    7b3e:	b.w	7ab0 <waitDmaStatus() [clone .part.4]>
    7b42:	movs	r0, #0
    7b44:	pop	{r3, r4, r5, r6, r7, pc}
    7b46:	nop
    7b48:	.word	0x1fff1358
    7b4c:	.word	0x00007a35
    7b50:	.word	0x1fff846c
    7b54:	.word	0x1fff8465
    7b58:	.word	0x1fff8450
    7b5c:	.word	0x117f0002
    7b60:	.word	0x400b1000
    7b64:	.word	0x1fff8440
    7b68:	.word	0x000077e5

00007b6c <SdioCard::sectorCount()>:
  csd1_t v1;
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    7b6c:	ldr	r2, [pc, #92]	; (7bcc <SdioCard::sectorCount()+0x60>)
    7b6e:	ldrb	r3, [r2, #0]
    7b70:	ands.w	r3, r3, #192	; 0xc0
    7b74:	bne.n	7baa <SdioCard::sectorCount()+0x3e>
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
    7b76:	ldrb	r0, [r2, #6]
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    7b78:	ldrb	r3, [r2, #7]
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    7b7a:	ldrb	r1, [r2, #10]
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    7b7c:	and.w	r0, r0, #3
    7b80:	lsls	r3, r3, #2
    7b82:	orr.w	r3, r3, r0, lsl #10
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    7b86:	ldrb	r0, [r2, #8]
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    7b88:	orr.w	r0, r3, r0, lsr #6
    7b8c:	adds	r3, r0, #1
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
    7b8e:	ldrb	r0, [r2, #9]
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    7b90:	ldrb	r2, [r2, #5]
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    7b92:	and.w	r0, r0, #3
    7b96:	lsls	r0, r0, #1
    7b98:	orr.w	r0, r0, r1, lsr #7
    7b9c:	and.w	r2, r2, #15
    7ba0:	add	r0, r2
    7ba2:	subs	r0, #7
    7ba4:	lsl.w	r0, r3, r0
    7ba8:	bx	lr
  } else if (csd->v2.csd_ver == 1) {
    7baa:	cmp	r3, #64	; 0x40
    7bac:	bne.n	7bc6 <SdioCard::sectorCount()+0x5a>
    return (((uint32_t)csd->v2.c_size_high << 16) +
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    7bae:	ldrb	r0, [r2, #9]
    7bb0:	adds	r3, r0, #1
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
  } else if (csd->v2.csd_ver == 1) {
    return (((uint32_t)csd->v2.c_size_high << 16) +
    7bb2:	ldrb	r0, [r2, #7]
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    7bb4:	and.w	r0, r0, #63	; 0x3f
    7bb8:	add.w	r0, r3, r0, lsl #16
    7bbc:	ldrb	r3, [r2, #8]
    7bbe:	add.w	r0, r0, r3, lsl #8
    7bc2:	lsls	r0, r0, #10
    7bc4:	bx	lr
  } else {
    return 0;
    7bc6:	movs	r0, #0
  return transferStop();
}
//------------------------------------------------------------------------------
uint32_t SdioCard::sectorCount() {
  return sdCardCapacity(&m_csd);
}
    7bc8:	bx	lr
    7bca:	nop
    7bcc:	.word	0x1fff8455

00007bd0 <SdioCard::erase(unsigned long, unsigned long)>:
  enableGPIO(true);
  m_initDone = true;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::erase(uint32_t firstSector, uint32_t lastSector) {
    7bd0:	push	{r4, r5, r6, lr}
    7bd2:	mov	r6, r2
#if ENABLE_TEENSY_SDIO_MOD
  if (m_curState != IDLE_STATE && !syncDevice()) {
    7bd4:	ldrb	r2, [r0, #9]
  enableGPIO(true);
  m_initDone = true;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::erase(uint32_t firstSector, uint32_t lastSector) {
    7bd6:	mov	r5, r1
#if ENABLE_TEENSY_SDIO_MOD
  if (m_curState != IDLE_STATE && !syncDevice()) {
    7bd8:	cbz	r2, 7be6 <SdioCard::erase(unsigned long, unsigned long)+0x16>
    7bda:	ldr	r3, [r0, #0]
    7bdc:	ldr	r3, [r3, #28]
    7bde:	blx	r3
    7be0:	mov	r4, r0
    7be2:	cmp	r0, #0
    7be4:	beq.n	7c82 <SdioCard::erase(unsigned long, unsigned long)+0xb2>
    return false;
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  // check for single sector erase
  if (!m_csd.v1.erase_blk_en) {
    7be6:	ldr	r1, [pc, #160]	; (7c88 <SdioCard::erase(unsigned long, unsigned long)+0xb8>)
    7be8:	ldrb	r3, [r1, #10]
    7bea:	and.w	r2, r3, #64	; 0x40
    7bee:	and.w	r4, r2, #255	; 0xff
    7bf2:	cbnz	r2, 7c14 <SdioCard::erase(unsigned long, unsigned long)+0x44>
    // erase size mask
    uint8_t m = (m_csd.v1.sector_size_high << 1) | m_csd.v1.sector_size_low;
    7bf4:	ldrb	r2, [r1, #11]
    if ((firstSector & m) != 0 || ((lastSector + 1) & m) != 0) {
    7bf6:	and.w	r3, r3, #63	; 0x3f
    7bfa:	lsls	r3, r3, #1
    7bfc:	orr.w	r3, r3, r2, lsr #7
    7c00:	adds	r2, r6, #1
    7c02:	orrs	r2, r5
    7c04:	tst	r3, r2
    7c06:	beq.n	7c14 <SdioCard::erase(unsigned long, unsigned long)+0x44>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    7c08:	ldr	r3, [pc, #128]	; (7c8c <SdioCard::erase(unsigned long, unsigned long)+0xbc>)
    7c0a:	movs	r2, #39	; 0x27
    7c0c:	strb	r2, [r3, #0]
  m_errorLine = line;
    7c0e:	movw	r2, #747	; 0x2eb
    7c12:	b.n	7c64 <SdioCard::erase(unsigned long, unsigned long)+0x94>
    if ((firstSector & m) != 0 || ((lastSector + 1) & m) != 0) {
      // error card can't erase specified area
      return sdError(SD_CARD_ERROR_ERASE_SINGLE_SECTOR);
    }
  }
  if (!m_highCapacity) {
    7c14:	ldr	r3, [pc, #120]	; (7c90 <SdioCard::erase(unsigned long, unsigned long)+0xc0>)
    7c16:	ldrb	r3, [r3, #0]
    7c18:	cbnz	r3, 7c1e <SdioCard::erase(unsigned long, unsigned long)+0x4e>
    firstSector <<= 9;
    7c1a:	lsls	r5, r5, #9
    lastSector <<= 9;
    7c1c:	lsls	r6, r6, #9
  }
  if (!cardCommand(CMD32_XFERTYP, firstSector)) {
    7c1e:	mov	r1, r5
    7c20:	ldr	r0, [pc, #112]	; (7c94 <SdioCard::erase(unsigned long, unsigned long)+0xc4>)
    7c22:	bl	79c0 <cardCommand(unsigned long, unsigned long)>
    7c26:	mov	r4, r0
    7c28:	cbnz	r0, 7c36 <SdioCard::erase(unsigned long, unsigned long)+0x66>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    7c2a:	ldr	r3, [pc, #96]	; (7c8c <SdioCard::erase(unsigned long, unsigned long)+0xbc>)
    7c2c:	movs	r2, #15
    7c2e:	strb	r2, [r3, #0]
  m_errorLine = line;
    7c30:	movw	r2, #755	; 0x2f3
    7c34:	b.n	7c64 <SdioCard::erase(unsigned long, unsigned long)+0x94>
    lastSector <<= 9;
  }
  if (!cardCommand(CMD32_XFERTYP, firstSector)) {
    return sdError(SD_CARD_ERROR_CMD32);
  }
  if (!cardCommand(CMD33_XFERTYP, lastSector)) {
    7c36:	mov	r1, r6
    7c38:	ldr	r0, [pc, #92]	; (7c98 <SdioCard::erase(unsigned long, unsigned long)+0xc8>)
    7c3a:	bl	79c0 <cardCommand(unsigned long, unsigned long)>
    7c3e:	mov	r4, r0
    7c40:	cbnz	r0, 7c4e <SdioCard::erase(unsigned long, unsigned long)+0x7e>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    7c42:	ldr	r3, [pc, #72]	; (7c8c <SdioCard::erase(unsigned long, unsigned long)+0xbc>)
    7c44:	movs	r2, #16
    7c46:	strb	r2, [r3, #0]
  m_errorLine = line;
    7c48:	movw	r2, #758	; 0x2f6
    7c4c:	b.n	7c64 <SdioCard::erase(unsigned long, unsigned long)+0x94>
    return sdError(SD_CARD_ERROR_CMD32);
  }
  if (!cardCommand(CMD33_XFERTYP, lastSector)) {
     return sdError(SD_CARD_ERROR_CMD33);
  }
  if (!cardCommand(CMD38_XFERTYP, 0)) {
    7c4e:	movs	r1, #0
    7c50:	ldr	r0, [pc, #72]	; (7c9c <SdioCard::erase(unsigned long, unsigned long)+0xcc>)
    7c52:	bl	79c0 <cardCommand(unsigned long, unsigned long)>
    7c56:	mov	r4, r0
    7c58:	cbnz	r0, 7c6a <SdioCard::erase(unsigned long, unsigned long)+0x9a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    7c5a:	ldr	r3, [pc, #48]	; (7c8c <SdioCard::erase(unsigned long, unsigned long)+0xbc>)
    7c5c:	movs	r2, #17
    7c5e:	strb	r2, [r3, #0]
  m_errorLine = line;
    7c60:	movw	r2, #761	; 0x2f9
    7c64:	ldr	r3, [pc, #56]	; (7ca0 <SdioCard::erase(unsigned long, unsigned long)+0xd0>)
    7c66:	str	r2, [r3, #0]
    7c68:	b.n	7c82 <SdioCard::erase(unsigned long, unsigned long)+0xb2>
     return sdError(SD_CARD_ERROR_CMD33);
  }
  if (!cardCommand(CMD38_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD38);
  }
  if (waitTimeout(isBusyCMD13)) {
    7c6a:	ldr	r0, [pc, #56]	; (7ca4 <SdioCard::erase(unsigned long, unsigned long)+0xd4>)
    7c6c:	bl	792c <waitTimeout(bool (*)())>
    7c70:	cbz	r0, 7c82 <SdioCard::erase(unsigned long, unsigned long)+0xb2>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    7c72:	ldr	r3, [pc, #24]	; (7c8c <SdioCard::erase(unsigned long, unsigned long)+0xbc>)
    7c74:	movs	r2, #40	; 0x28
    7c76:	strb	r2, [r3, #0]
  m_errorLine = line;
    7c78:	ldr	r3, [pc, #36]	; (7ca0 <SdioCard::erase(unsigned long, unsigned long)+0xd0>)
    7c7a:	mov.w	r2, #764	; 0x2fc
    7c7e:	str	r2, [r3, #0]
  }
  if (!cardCommand(CMD38_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD38);
  }
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_ERASE_TIMEOUT);
    7c80:	movs	r4, #0
  }
  return true;
}
    7c82:	mov	r0, r4
    7c84:	pop	{r4, r5, r6, pc}
    7c86:	nop
    7c88:	.word	0x1fff8455
    7c8c:	.word	0x1fff1358
    7c90:	.word	0x1fff8440
    7c94:	.word	0x201a0000
    7c98:	.word	0x211a0000
    7c9c:	.word	0x261b0000
    7ca0:	.word	0x1fff846c
    7ca4:	.word	0x00007a35

00007ca8 <waitTransferComplete()>:
  }
  return false;  // Caller will set errorCode.
}
#if ENABLE_TEENSY_SDIO_MOD
//------------------------------------------------------------------------------
static bool waitTransferComplete() {
    7ca8:	push	{r4, lr}
  if (!m_transferActive) {
    7caa:	ldr	r4, [pc, #60]	; (7ce8 <waitTransferComplete()+0x40>)
    7cac:	ldrb	r3, [r4, #0]
    7cae:	cbnz	r3, 7cb4 <waitTransferComplete()+0xc>
    return true;
    7cb0:	movs	r0, #1
    7cb2:	pop	{r4, pc}
  }
  bool timeOut = waitTimeout(isBusyTransferComplete);
    7cb4:	ldr	r0, [pc, #52]	; (7cec <waitTransferComplete()+0x44>)
    7cb6:	bl	792c <waitTimeout(bool (*)())>
  m_transferActive = false;
    7cba:	movs	r3, #0
  m_irqstat = SDHC_IRQSTAT;
    7cbc:	ldr	r2, [pc, #48]	; (7cf0 <waitTransferComplete()+0x48>)
static bool waitTransferComplete() {
  if (!m_transferActive) {
    return true;
  }
  bool timeOut = waitTimeout(isBusyTransferComplete);
  m_transferActive = false;
    7cbe:	strb	r3, [r4, #0]
  m_irqstat = SDHC_IRQSTAT;
    7cc0:	ldr	r3, [pc, #48]	; (7cf4 <waitTransferComplete()+0x4c>)
    7cc2:	ldr	r1, [r2, #0]
    7cc4:	str	r1, [r3, #0]
  SDHC_IRQSTAT = m_irqstat;
    7cc6:	ldr	r1, [r3, #0]
    7cc8:	str	r1, [r2, #0]
  if (timeOut || (m_irqstat & SDHC_IRQSTAT_ERROR)) {
    7cca:	cbnz	r0, 7cd6 <waitTransferComplete()+0x2e>
    7ccc:	ldr	r2, [r3, #0]
    7cce:	ldr	r3, [pc, #40]	; (7cf8 <waitTransferComplete()+0x50>)
    7cd0:	ands	r3, r2
    7cd2:	cmp	r3, #0
    7cd4:	beq.n	7cb0 <waitTransferComplete()+0x8>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    7cd6:	ldr	r3, [pc, #36]	; (7cfc <waitTransferComplete()+0x54>)
    7cd8:	movs	r2, #31
    7cda:	strb	r2, [r3, #0]
  m_errorLine = line;
    7cdc:	ldr	r3, [pc, #32]	; (7d00 <waitTransferComplete()+0x58>)
    7cde:	movw	r2, #641	; 0x281
    7ce2:	str	r2, [r3, #0]
  bool timeOut = waitTimeout(isBusyTransferComplete);
  m_transferActive = false;
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
  if (timeOut || (m_irqstat & SDHC_IRQSTAT_ERROR)) {
    return sdError(SD_CARD_ERROR_TRANSFER_COMPLETE);
    7ce4:	movs	r0, #0
  }
  return true;
}
    7ce6:	pop	{r4, pc}
    7ce8:	.word	0x1fff844c
    7cec:	.word	0x00007819
    7cf0:	.word	0x400b1030
    7cf4:	.word	0x1fff8450
    7cf8:	.word	0x117f0000
    7cfc:	.word	0x1fff1358
    7d00:	.word	0x1fff846c

00007d04 <SdioCard::readStop()>:
    return sdError(SD_CARD_ERROR_CMD25);
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStop() {
    7d04:	push	{r4, r5, r6, lr}
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
}
//------------------------------------------------------------------------------
static bool transferStop() {
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    7d06:	ldr	r4, [pc, #100]	; (7d6c <SdioCard::readStop()+0x68>)
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    7d08:	ldr	r0, [pc, #100]	; (7d70 <SdioCard::readStop()+0x6c>)
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
}
//------------------------------------------------------------------------------
static bool transferStop() {
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    7d0a:	ldr	r3, [r4, #0]
    7d0c:	bic.w	r3, r3, #65536	; 0x10000
    7d10:	str	r3, [r4, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    7d12:	movs	r1, #0
    7d14:	bl	79c0 <cardCommand(unsigned long, unsigned long)>
    7d18:	mov	r5, r0
    7d1a:	cbnz	r0, 7d2c <SdioCard::readStop()+0x28>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    7d1c:	ldr	r3, [pc, #84]	; (7d74 <SdioCard::readStop()+0x70>)
    7d1e:	movs	r2, #9
    7d20:	strb	r2, [r3, #0]
  m_errorLine = line;
    7d22:	ldr	r3, [pc, #84]	; (7d78 <SdioCard::readStop()+0x74>)
    7d24:	movw	r2, #578	; 0x242
    7d28:	str	r2, [r3, #0]
    7d2a:	b.n	7d66 <SdioCard::readStop()+0x62>
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD12);
  }
//  if (yieldTimeout(isBusyCMD13)) {
  if (yieldTimeout(isBusyDat)) {
    7d2c:	ldr	r0, [pc, #76]	; (7d7c <SdioCard::readStop()+0x78>)
    7d2e:	bl	7950 <yieldTimeout(bool (*)())>
    7d32:	cbz	r0, 7d46 <SdioCard::readStop()+0x42>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    7d34:	ldr	r3, [pc, #60]	; (7d74 <SdioCard::readStop()+0x70>)
    7d36:	movs	r2, #10
    7d38:	strb	r2, [r3, #0]
  m_errorLine = line;
    7d3a:	ldr	r3, [pc, #60]	; (7d78 <SdioCard::readStop()+0x74>)
    7d3c:	movw	r2, #582	; 0x246
    7d40:	str	r2, [r3, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD12);
  }
//  if (yieldTimeout(isBusyCMD13)) {
  if (yieldTimeout(isBusyDat)) {
    return sdError(SD_CARD_ERROR_CMD13);
    7d42:	movs	r5, #0
    7d44:	b.n	7d66 <SdioCard::readStop()+0x62>
  }
  if (SDHC_PRSSTAT & SDHC_PRSSTAT_CDIHB) {
    7d46:	ldr	r3, [pc, #56]	; (7d80 <SdioCard::readStop()+0x7c>)
    7d48:	ldr	r3, [r3, #0]
    7d4a:	lsls	r3, r3, #30
    7d4c:	bpl.n	7d66 <SdioCard::readStop()+0x62>
    // This should not happen after above fix.
    // Save registers before reset DAT lines.
    uint32_t irqsststen = SDHC_IRQSTATEN;
    7d4e:	ldr	r1, [pc, #52]	; (7d84 <SdioCard::readStop()+0x80>)
    uint32_t proctl = SDHC_PROCTL & ~SDHC_PROCTL_SABGREQ;
    // Do reset to clear CDIHB.  Should be a better way!
    SDHC_SYSCTL |= SDHC_SYSCTL_RSTD;
    7d50:	ldr	r0, [pc, #52]	; (7d88 <SdioCard::readStop()+0x84>)
    return sdError(SD_CARD_ERROR_CMD13);
  }
  if (SDHC_PRSSTAT & SDHC_PRSSTAT_CDIHB) {
    // This should not happen after above fix.
    // Save registers before reset DAT lines.
    uint32_t irqsststen = SDHC_IRQSTATEN;
    7d52:	ldr	r6, [r1, #0]
    uint32_t proctl = SDHC_PROCTL & ~SDHC_PROCTL_SABGREQ;
    7d54:	ldr	r3, [r4, #0]
    // Do reset to clear CDIHB.  Should be a better way!
    SDHC_SYSCTL |= SDHC_SYSCTL_RSTD;
    7d56:	ldr	r2, [r0, #0]
  }
  if (SDHC_PRSSTAT & SDHC_PRSSTAT_CDIHB) {
    // This should not happen after above fix.
    // Save registers before reset DAT lines.
    uint32_t irqsststen = SDHC_IRQSTATEN;
    uint32_t proctl = SDHC_PROCTL & ~SDHC_PROCTL_SABGREQ;
    7d58:	bic.w	r3, r3, #65536	; 0x10000
    // Do reset to clear CDIHB.  Should be a better way!
    SDHC_SYSCTL |= SDHC_SYSCTL_RSTD;
    7d5c:	orr.w	r2, r2, #67108864	; 0x4000000
    7d60:	str	r2, [r0, #0]
    // Restore registers.
    SDHC_IRQSTATEN = irqsststen;
    7d62:	str	r6, [r1, #0]
    SDHC_PROCTL = proctl;
    7d64:	str	r3, [r4, #0]
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStop() {
  return transferStop();
}
    7d66:	mov	r0, r5
    7d68:	pop	{r4, r5, r6, pc}
    7d6a:	nop
    7d6c:	.word	0x400b1028
    7d70:	.word	0x0cdb0000
    7d74:	.word	0x1fff1358
    7d78:	.word	0x1fff846c
    7d7c:	.word	0x000077d1
    7d80:	.word	0x400b1024
    7d84:	.word	0x400b1034
    7d88:	.word	0x400b102c

00007d8c <SdioCard::writeData(unsigned char const*)>:
uint8_t SdioCard::type() const {
  return  m_version2 ? m_highCapacity ?
          SD_CARD_TYPE_SDHC : SD_CARD_TYPE_SD2 : SD_CARD_TYPE_SD1;
}
//------------------------------------------------------------------------------
bool SdioCard::writeData(const uint8_t* src) {
    7d8c:	push	{r4, r5, r6, lr}
    7d8e:	mov	r4, r1
  DBG_IRQSTAT();
#if ENABLE_TEENSY_SDIO_MOD
  if (!waitTransferComplete()) {
    7d90:	bl	7ca8 <waitTransferComplete()>
    7d94:	mov	r6, r0
    7d96:	cmp	r0, #0
    7d98:	beq.n	7e00 <SdioCard::writeData(unsigned char const*)+0x74>
    return false;
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  const uint32_t* p32 = reinterpret_cast<const uint32_t*>(src);
  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_WTA)) {
    7d9a:	ldr	r5, [pc, #104]	; (7e04 <SdioCard::writeData(unsigned char const*)+0x78>)
    7d9c:	ldr	r3, [r5, #0]
    7d9e:	tst.w	r3, #256	; 0x100
    7da2:	ldr	r3, [pc, #100]	; (7e08 <SdioCard::writeData(unsigned char const*)+0x7c>)
    7da4:	bne.n	7db6 <SdioCard::writeData(unsigned char const*)+0x2a>
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    7da6:	ldr	r2, [r3, #0]
    7da8:	bic.w	r2, r2, #65536	; 0x10000
    7dac:	str	r2, [r3, #0]
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
    7dae:	ldr	r2, [r3, #0]
    7db0:	orr.w	r2, r2, #131072	; 0x20000
    7db4:	str	r2, [r3, #0]
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    7db6:	ldr	r2, [r3, #0]
  if (waitTimeout(isBusyFifoWrite)) {
    7db8:	ldr	r0, [pc, #80]	; (7e0c <SdioCard::writeData(unsigned char const*)+0x80>)
  const uint32_t* p32 = reinterpret_cast<const uint32_t*>(src);
  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_WTA)) {
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    7dba:	orr.w	r2, r2, #65536	; 0x10000
    7dbe:	str	r2, [r3, #0]
  if (waitTimeout(isBusyFifoWrite)) {
    7dc0:	bl	792c <waitTimeout(bool (*)())>
    7dc4:	cbnz	r0, 7df0 <SdioCard::writeData(unsigned char const*)+0x64>
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN)) {
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      SDHC_DATPORT = p32[i];
    7dc6:	ldr	r1, [pc, #72]	; (7e10 <SdioCard::writeData(unsigned char const*)+0x84>)
    7dc8:	subs	r3, r4, #4
    7dca:	add.w	r4, r4, #508	; 0x1fc
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
  if (waitTimeout(isBusyFifoWrite)) {
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN)) {
    7dce:	ldr	r2, [r5, #0]
    7dd0:	lsls	r2, r2, #21
    7dd2:	bpl.n	7dce <SdioCard::writeData(unsigned char const*)+0x42>
    7dd4:	add.w	r2, r3, #64	; 0x40
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      SDHC_DATPORT = p32[i];
    7dd8:	ldr.w	r0, [r3, #4]!
    7ddc:	str	r0, [r1, #0]
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN)) {
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
    7dde:	cmp	r2, r3
    7de0:	bne.n	7dd8 <SdioCard::writeData(unsigned char const*)+0x4c>
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
  if (waitTimeout(isBusyFifoWrite)) {
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    7de2:	cmp	r4, r2
    7de4:	mov	r3, r2
    7de6:	bne.n	7dce <SdioCard::writeData(unsigned char const*)+0x42>
      SDHC_DATPORT = p32[i];
    }
    p32 += FIFO_WML;
  }
#if ENABLE_TEENSY_SDIO_MOD
  m_transferActive = true;
    7de8:	ldr	r3, [pc, #40]	; (7e14 <SdioCard::writeData(unsigned char const*)+0x88>)
    7dea:	movs	r2, #1
    7dec:	strb	r2, [r3, #0]
    7dee:	b.n	7e00 <SdioCard::writeData(unsigned char const*)+0x74>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    7df0:	ldr	r3, [pc, #36]	; (7e18 <SdioCard::writeData(unsigned char const*)+0x8c>)
    7df2:	movs	r2, #33	; 0x21
    7df4:	strb	r2, [r3, #0]
  m_errorLine = line;
    7df6:	ldr	r3, [pc, #36]	; (7e1c <SdioCard::writeData(unsigned char const*)+0x90>)
    7df8:	movw	r2, #1015	; 0x3f7
    7dfc:	str	r2, [r3, #0]
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
  if (waitTimeout(isBusyFifoWrite)) {
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
    7dfe:	movs	r6, #0
  }
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    7e00:	mov	r0, r6
    7e02:	pop	{r4, r5, r6, pc}
    7e04:	.word	0x400b1024
    7e08:	.word	0x400b1028
    7e0c:	.word	0x00007805
    7e10:	.word	0x400b1020
    7e14:	.word	0x1fff844c
    7e18:	.word	0x1fff1358
    7e1c:	.word	0x1fff846c

00007e20 <SdioCard::writeStart(unsigned long)>:
    }
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStart(uint32_t sector) {
    7e20:	push	{r4, lr}
  if (yieldTimeout(isBusyCMD13)) {
    7e22:	ldr	r0, [pc, #80]	; (7e74 <SdioCard::writeStart(unsigned long)+0x54>)
    }
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStart(uint32_t sector) {
    7e24:	mov	r4, r1
  if (yieldTimeout(isBusyCMD13)) {
    7e26:	bl	7950 <yieldTimeout(bool (*)())>
    7e2a:	cbz	r0, 7e3e <SdioCard::writeStart(unsigned long)+0x1e>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    7e2c:	ldr	r3, [pc, #72]	; (7e78 <SdioCard::writeStart(unsigned long)+0x58>)
    7e2e:	movs	r2, #10
    7e30:	strb	r2, [r3, #0]
  m_errorLine = line;
    7e32:	ldr	r3, [pc, #72]	; (7e7c <SdioCard::writeStart(unsigned long)+0x5c>)
    7e34:	movw	r2, #1119	; 0x45f
    7e38:	str	r2, [r3, #0]
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStart(uint32_t sector) {
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
    7e3a:	movs	r0, #0
    7e3c:	pop	{r4, pc}
  }
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    7e3e:	ldr	r2, [pc, #64]	; (7e80 <SdioCard::writeStart(unsigned long)+0x60>)
    7e40:	ldr	r3, [r2, #0]
    7e42:	bic.w	r3, r3, #65536	; 0x10000
    7e46:	str	r3, [r2, #0]
#if defined(__IMXRT1062__)
  // Infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKSIZE(512);
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
    7e48:	ldr	r3, [pc, #56]	; (7e84 <SdioCard::writeStart(unsigned long)+0x64>)
    7e4a:	ldr	r2, [pc, #60]	; (7e88 <SdioCard::writeStart(unsigned long)+0x68>)
    7e4c:	str	r2, [r3, #0]
#endif  // defined(__IMXRT1062__)
  if (!cardCommand(CMD25_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    7e4e:	ldr	r3, [pc, #60]	; (7e8c <SdioCard::writeStart(unsigned long)+0x6c>)
    7e50:	ldrb	r3, [r3, #0]
    7e52:	cbnz	r3, 7e58 <SdioCard::writeStart(unsigned long)+0x38>
    7e54:	lsls	r1, r4, #9
    7e56:	b.n	7e5a <SdioCard::writeStart(unsigned long)+0x3a>
    7e58:	mov	r1, r4
    7e5a:	ldr	r0, [pc, #52]	; (7e90 <SdioCard::writeStart(unsigned long)+0x70>)
    7e5c:	bl	79c0 <cardCommand(unsigned long, unsigned long)>
    7e60:	cbnz	r0, 7e70 <SdioCard::writeStart(unsigned long)+0x50>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    7e62:	ldr	r3, [pc, #20]	; (7e78 <SdioCard::writeStart(unsigned long)+0x58>)
    7e64:	movs	r2, #14
    7e66:	strb	r2, [r3, #0]
  m_errorLine = line;
    7e68:	ldr	r3, [pc, #16]	; (7e7c <SdioCard::writeStart(unsigned long)+0x5c>)
    7e6a:	movw	r2, #1131	; 0x46b
    7e6e:	str	r2, [r3, #0]
#endif  // defined(__IMXRT1062__)
  if (!cardCommand(CMD25_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    return sdError(SD_CARD_ERROR_CMD25);
  }
  return true;
}
    7e70:	pop	{r4, pc}
    7e72:	nop
    7e74:	.word	0x00007a35
    7e78:	.word	0x1fff1358
    7e7c:	.word	0x1fff846c
    7e80:	.word	0x400b1028
    7e84:	.word	0x400b1004
    7e88:	.word	0xffff0200
    7e8c:	.word	0x1fff8440
    7e90:	.word	0x193a0022

00007e94 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)>:
#endif  // !ENABLE_TEENSY_SDIO_MOD
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeSectors(uint32_t sector, const uint8_t* src, size_t n) {
    7e94:	push	{r3, r4, r5, r6, r7, lr}
    7e96:	mov	r7, r0
    7e98:	mov	r4, r1
  if (m_sdioConfig.useDma()) {
    7e9a:	ldrb	r6, [r7, #8]
    7e9c:	lsls	r6, r6, #31
#endif  // !ENABLE_TEENSY_SDIO_MOD
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeSectors(uint32_t sector, const uint8_t* src, size_t n) {
    7e9e:	mov	r5, r2
  if (m_sdioConfig.useDma()) {
    7ea0:	bpl.n	7ede <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x4a>
    uint8_t* ptr = const_cast<uint8_t*>(src);
    if (3 & (uint32_t)ptr) {
    7ea2:	lsls	r6, r2, #30
    7ea4:	beq.n	7ec6 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x32>
    7ea6:	adds	r6, r1, r3
      for (size_t i = 0; i < n; i++, sector++, ptr += 512) {
    7ea8:	cmp	r4, r6
    7eaa:	beq.n	7efc <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x68>
        if (!writeSector(sector, ptr)) {
    7eac:	ldr	r3, [r7, #0]
    7eae:	mov	r2, r5
    7eb0:	ldr	r3, [r3, #32]
    7eb2:	mov	r1, r4
    7eb4:	mov	r0, r7
    7eb6:	blx	r3
    7eb8:	cbnz	r0, 7ebe <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x2a>
          return false;  // writeSector will set errorCode.
    7eba:	movs	r0, #0
    7ebc:	pop	{r3, r4, r5, r6, r7, pc}
//------------------------------------------------------------------------------
bool SdioCard::writeSectors(uint32_t sector, const uint8_t* src, size_t n) {
  if (m_sdioConfig.useDma()) {
    uint8_t* ptr = const_cast<uint8_t*>(src);
    if (3 & (uint32_t)ptr) {
      for (size_t i = 0; i < n; i++, sector++, ptr += 512) {
    7ebe:	adds	r4, #1
    7ec0:	add.w	r5, r5, #512	; 0x200
    7ec4:	b.n	7ea8 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x14>
          return false;  // writeSector will set errorCode.
        }
      }
      return true;
    }
    if (!rdWrSectors(CMD25_DMA_XFERTYP, sector, ptr, n)) {
    7ec6:	ldr	r0, [pc, #56]	; (7f00 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x6c>)
    7ec8:	bl	7ad0 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    7ecc:	cbnz	r0, 7efc <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x68>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    7ece:	ldr	r3, [pc, #52]	; (7f04 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x70>)
    7ed0:	movs	r2, #14
    7ed2:	strb	r2, [r3, #0]
  m_errorLine = line;
    7ed4:	ldr	r3, [pc, #48]	; (7f08 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x74>)
    7ed6:	movw	r2, #1105	; 0x451
    7eda:	str	r2, [r3, #0]
    7edc:	pop	{r3, r4, r5, r6, r7, pc}
    7ede:	adds	r6, r1, r3
    }
    if (!rdWrSectors(CMD25_DMA_XFERTYP, sector, ptr, n)) {
      return sdError(SD_CARD_ERROR_CMD25);
    }
  } else {
    for (size_t i = 0; i < n; i++) {
    7ee0:	cmp	r4, r6
    7ee2:	beq.n	7efc <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x68>
      if (!writeSector(sector + i, src + i*512UL)) {
    7ee4:	ldr	r3, [r7, #0]
    7ee6:	mov	r2, r5
    7ee8:	mov	r1, r4
    7eea:	ldr	r3, [r3, #32]
    7eec:	mov	r0, r7
    7eee:	blx	r3
    7ef0:	adds	r4, #1
    7ef2:	add.w	r5, r5, #512	; 0x200
    7ef6:	cmp	r0, #0
    7ef8:	bne.n	7ee0 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x4c>
    7efa:	b.n	7eba <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x26>
      for (size_t i = 0; i < n; i++, sector++, ptr += 512) {
        if (!writeSector(sector, ptr)) {
          return false;  // writeSector will set errorCode.
        }
      }
      return true;
    7efc:	movs	r0, #1
        return false;
      }
    }
  }
  return true;
}
    7efe:	pop	{r3, r4, r5, r6, r7, pc}
    7f00:	.word	0x193a0027
    7f04:	.word	0x1fff1358
    7f08:	.word	0x1fff846c

00007f0c <SdioCard::writeSector(unsigned long, unsigned char const*)>:
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
#endif  // ENABLE_TEENSY_SDIO_MOD
}
//------------------------------------------------------------------------------
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
    7f0c:	push	{r4, r5, r6, lr}
  if (m_sdioConfig.useDma()) {
    7f0e:	ldrb	r3, [r0, #8]
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
#endif  // ENABLE_TEENSY_SDIO_MOD
}
//------------------------------------------------------------------------------
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
    7f10:	mov	r5, r2
  if (m_sdioConfig.useDma()) {
    7f12:	lsls	r2, r3, #31
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
#endif  // ENABLE_TEENSY_SDIO_MOD
}
//------------------------------------------------------------------------------
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
    7f14:	sub.w	sp, sp, #512	; 0x200
    7f18:	mov	r4, r0
    7f1a:	mov	r6, r1
  if (m_sdioConfig.useDma()) {
    7f1c:	bpl.n	7f50 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x44>
    uint8_t* ptr;
    uint8_t aligned[512];
    if (3 & (uint32_t)src) {
    7f1e:	lsls	r3, r5, #30
    7f20:	beq.n	7f30 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x24>
      ptr = aligned;
      memcpy(aligned, src, 512);
    7f22:	mov	r1, r5
    7f24:	mov.w	r2, #512	; 0x200
    7f28:	mov	r0, sp
    7f2a:	bl	8720 <memcpy>
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
  if (m_sdioConfig.useDma()) {
    uint8_t* ptr;
    uint8_t aligned[512];
    if (3 & (uint32_t)src) {
      ptr = aligned;
    7f2e:	mov	r5, sp
      memcpy(aligned, src, 512);
    } else {
      ptr = const_cast<uint8_t*>(src);
    }
    if (!rdWrSectors(CMD24_DMA_XFERTYP, sector, ptr, 1)) {
    7f30:	movs	r3, #1
    7f32:	mov	r2, r5
    7f34:	mov	r1, r6
    7f36:	ldr	r0, [pc, #132]	; (7fbc <SdioCard::writeSector(unsigned long, unsigned char const*)+0xb0>)
    7f38:	bl	7ad0 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    7f3c:	cmp	r0, #0
    7f3e:	bne.n	7fb4 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xa8>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    7f40:	ldr	r3, [pc, #124]	; (7fc0 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xb4>)
    7f42:	movs	r2, #13
    7f44:	strb	r2, [r3, #0]
  m_errorLine = line;
    7f46:	ldr	r3, [pc, #124]	; (7fc4 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xb8>)
    7f48:	movw	r2, #1049	; 0x419
    7f4c:	str	r2, [r3, #0]
    7f4e:	b.n	7fb4 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xa8>
    if (!rdWrSectors(CMD24_DMA_XFERTYP, sector, ptr, 1)) {
      return sdError(SD_CARD_ERROR_CMD24);
    }
  } else {
#if ENABLE_TEENSY_SDIO_MOD
    if (!waitTransferComplete()) {
    7f50:	bl	7ca8 <waitTransferComplete()>
    7f54:	cbnz	r0, 7f5a <SdioCard::writeSector(unsigned long, unsigned char const*)+0x4e>
      return false;
    7f56:	movs	r0, #0
    7f58:	b.n	7fb4 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xa8>
    }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    // End transfer with CMD12 if required.
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
    7f5a:	ldr	r3, [pc, #108]	; (7fc8 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xbc>)
    7f5c:	ldr	r3, [r3, #0]
    7f5e:	lsrs	r3, r3, #16
    7f60:	lsls	r3, r3, #16
    7f62:	cbz	r3, 7f6c <SdioCard::writeSector(unsigned long, unsigned char const*)+0x60>
        return false;
      }
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
#endif  // ENABLE_TEENSY_SDIO_MOD
    if (m_curState != WRITE_STATE || m_curSector != sector) {
    7f64:	ldrb	r3, [r4, #9]
    7f66:	cmp	r3, #2
    7f68:	bne.n	7f80 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x74>
    7f6a:	b.n	7f7a <SdioCard::writeSector(unsigned long, unsigned char const*)+0x6e>
      return false;
    }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    // End transfer with CMD12 if required.
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
      if (!syncDevice()) {
    7f6c:	ldr	r3, [r4, #0]
    7f6e:	mov	r0, r4
    7f70:	ldr	r3, [r3, #28]
    7f72:	blx	r3
    7f74:	cmp	r0, #0
    7f76:	bne.n	7f64 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x58>
    7f78:	b.n	7f56 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x4a>
        return false;
      }
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
#endif  // ENABLE_TEENSY_SDIO_MOD
    if (m_curState != WRITE_STATE || m_curSector != sector) {
    7f7a:	ldr	r3, [r4, #4]
    7f7c:	cmp	r6, r3
    7f7e:	beq.n	7fa0 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x94>
      if (!syncDevice()) {
    7f80:	ldr	r3, [r4, #0]
    7f82:	mov	r0, r4
    7f84:	ldr	r3, [r3, #28]
    7f86:	blx	r3
    7f88:	cmp	r0, #0
    7f8a:	beq.n	7f56 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x4a>
        return false;
      }
      if (!writeStart(sector )) {
    7f8c:	ldr	r3, [r4, #0]
    7f8e:	mov	r1, r6
    7f90:	ldr	r3, [r3, #80]	; 0x50
    7f92:	mov	r0, r4
    7f94:	blx	r3
    7f96:	cmp	r0, #0
    7f98:	beq.n	7f56 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x4a>
        return false;
      }
      m_curSector = sector;
      m_curState = WRITE_STATE;
    7f9a:	movs	r3, #2
        return false;
      }
      if (!writeStart(sector )) {
        return false;
      }
      m_curSector = sector;
    7f9c:	str	r6, [r4, #4]
      m_curState = WRITE_STATE;
    7f9e:	strb	r3, [r4, #9]
    }
    if (!writeData(src)) {
    7fa0:	ldr	r3, [r4, #0]
    7fa2:	mov	r1, r5
    7fa4:	ldr	r3, [r3, #76]	; 0x4c
    7fa6:	mov	r0, r4
    7fa8:	blx	r3
    7faa:	cmp	r0, #0
    7fac:	beq.n	7f56 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x4a>
      return false;
    }
    m_curSector++;
    7fae:	ldr	r3, [r4, #4]
    7fb0:	adds	r3, #1
    7fb2:	str	r3, [r4, #4]
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
#endif  // !ENABLE_TEENSY_SDIO_MOD
  }
  return true;
}
    7fb4:	add.w	sp, sp, #512	; 0x200
    7fb8:	pop	{r4, r5, r6, pc}
    7fba:	nop
    7fbc:	.word	0x183a0001
    7fc0:	.word	0x1fff1358
    7fc4:	.word	0x1fff846c
    7fc8:	.word	0x400b1004

00007fcc <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)>:
    m_curSector++;
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSectors(uint32_t sector, uint8_t* dst, size_t n) {
    7fcc:	push	{r3, r4, r5, r6, r7, lr}
    7fce:	mov	r7, r0
    7fd0:	mov	r4, r1
  if (m_sdioConfig.useDma()) {
    7fd2:	ldrb	r6, [r7, #8]
    7fd4:	lsls	r6, r6, #31
    m_curSector++;
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSectors(uint32_t sector, uint8_t* dst, size_t n) {
    7fd6:	mov	r5, r2
  if (m_sdioConfig.useDma()) {
    7fd8:	bpl.n	8016 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x4a>
    if ((uint32_t)dst & 3) {
    7fda:	lsls	r6, r2, #30
    7fdc:	beq.n	7ffe <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x32>
    7fde:	adds	r6, r1, r3
      for (size_t i = 0; i < n; i++, sector++, dst += 512) {
    7fe0:	cmp	r4, r6
    7fe2:	beq.n	8034 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x68>
        if (!readSector(sector, dst)) {
    7fe4:	ldr	r3, [r7, #0]
    7fe6:	mov	r2, r5
    7fe8:	ldr	r3, [r3, #12]
    7fea:	mov	r1, r4
    7fec:	mov	r0, r7
    7fee:	blx	r3
    7ff0:	cbnz	r0, 7ff6 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x2a>
          return false;  // readSector will set errorCode.
    7ff2:	movs	r0, #0
    7ff4:	pop	{r3, r4, r5, r6, r7, pc}
}
//------------------------------------------------------------------------------
bool SdioCard::readSectors(uint32_t sector, uint8_t* dst, size_t n) {
  if (m_sdioConfig.useDma()) {
    if ((uint32_t)dst & 3) {
      for (size_t i = 0; i < n; i++, sector++, dst += 512) {
    7ff6:	adds	r4, #1
    7ff8:	add.w	r5, r5, #512	; 0x200
    7ffc:	b.n	7fe0 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x14>
          return false;  // readSector will set errorCode.
        }
      }
      return true;
    }
    if (!rdWrSectors(CMD18_DMA_XFERTYP, sector, dst, n)) {
    7ffe:	ldr	r0, [pc, #56]	; (8038 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x6c>)
    8000:	bl	7ad0 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    8004:	cbnz	r0, 8034 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x68>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8006:	ldr	r3, [pc, #52]	; (803c <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x70>)
    8008:	movs	r2, #12
    800a:	strb	r2, [r3, #0]
  m_errorLine = line;
    800c:	ldr	r3, [pc, #48]	; (8040 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x74>)
    800e:	mov.w	r2, #912	; 0x390
    8012:	str	r2, [r3, #0]
    8014:	pop	{r3, r4, r5, r6, r7, pc}
    8016:	adds	r6, r1, r3
    }
    if (!rdWrSectors(CMD18_DMA_XFERTYP, sector, dst, n)) {
      return sdError(SD_CARD_ERROR_CMD18);
    }
  } else {
    for (size_t i = 0; i < n; i++) {
    8018:	cmp	r4, r6
    801a:	beq.n	8034 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x68>
      if (!readSector(sector + i, dst + i*512UL)) {
    801c:	ldr	r3, [r7, #0]
    801e:	mov	r2, r5
    8020:	mov	r1, r4
    8022:	ldr	r3, [r3, #12]
    8024:	mov	r0, r7
    8026:	blx	r3
    8028:	adds	r4, #1
    802a:	add.w	r5, r5, #512	; 0x200
    802e:	cmp	r0, #0
    8030:	bne.n	8018 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x4c>
    8032:	b.n	7ff2 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x26>
      for (size_t i = 0; i < n; i++, sector++, dst += 512) {
        if (!readSector(sector, dst)) {
          return false;  // readSector will set errorCode.
        }
      }
      return true;
    8034:	movs	r0, #1
        return false;
      }
    }
  }
  return true;
}
    8036:	pop	{r3, r4, r5, r6, r7, pc}
    8038:	.word	0x123a0037
    803c:	.word	0x1fff1358
    8040:	.word	0x1fff846c

00008044 <cardCMD6(unsigned long, unsigned char*)>:

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
}
//------------------------------------------------------------------------------
static bool cardCMD6(uint32_t arg, uint8_t* status) {
    8044:	push	{r3, r4, r5, lr}
    8046:	mov	r4, r0
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    8048:	ldr	r0, [pc, #104]	; (80b4 <cardCMD6(unsigned long, unsigned char*)+0x70>)

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
}
//------------------------------------------------------------------------------
static bool cardCMD6(uint32_t arg, uint8_t* status) {
    804a:	mov	r5, r1
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    804c:	bl	792c <waitTimeout(bool (*)())>
    8050:	cbz	r0, 805e <cardCMD6(unsigned long, unsigned char*)+0x1a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8052:	ldr	r3, [pc, #100]	; (80b8 <cardCMD6(unsigned long, unsigned char*)+0x74>)
    8054:	movs	r2, #10
    8056:	strb	r2, [r3, #0]
  m_errorLine = line;
    8058:	movw	r2, #413	; 0x19d
    805c:	b.n	80a0 <cardCMD6(unsigned long, unsigned char*)+0x5c>
  }
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
    805e:	ldr	r3, [pc, #92]	; (80bc <cardCMD6(unsigned long, unsigned char*)+0x78>)
    8060:	movs	r2, #1
    8062:	strb	r2, [r3, #0]
  m_irqstat = 0;
    8064:	ldr	r3, [pc, #88]	; (80c0 <cardCMD6(unsigned long, unsigned char*)+0x7c>)
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
    8066:	ldr	r2, [pc, #92]	; (80c4 <cardCMD6(unsigned long, unsigned char*)+0x80>)
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
  m_irqstat = 0;
    8068:	str	r0, [r3, #0]
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
    806a:	ldr	r3, [pc, #92]	; (80c8 <cardCMD6(unsigned long, unsigned char*)+0x84>)
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    806c:	ldr	r0, [pc, #92]	; (80cc <cardCMD6(unsigned long, unsigned char*)+0x88>)
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
    806e:	str	r5, [r3, #0]
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
    8070:	str	r2, [r3, #4]
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
    8072:	ldr	r2, [pc, #92]	; (80d0 <cardCMD6(unsigned long, unsigned char*)+0x8c>)
    8074:	str	r2, [r3, #56]	; 0x38
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    8076:	mov	r1, r4
    8078:	bl	79c0 <cardCommand(unsigned long, unsigned long)>
    807c:	cbnz	r0, 808e <cardCMD6(unsigned long, unsigned char*)+0x4a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    807e:	ldr	r3, [pc, #56]	; (80b8 <cardCMD6(unsigned long, unsigned char*)+0x74>)
    8080:	movs	r2, #4
    8082:	strb	r2, [r3, #0]
  m_errorLine = line;
    8084:	ldr	r3, [pc, #76]	; (80d4 <cardCMD6(unsigned long, unsigned char*)+0x90>)
    8086:	mov.w	r2, #420	; 0x1a4
    808a:	str	r2, [r3, #0]
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    return sdError(SD_CARD_ERROR_CMD6);
    808c:	pop	{r3, r4, r5, pc}
  m_busyFcn = 0;
  return false;  // Caller will set errorCode.
}
//------------------------------------------------------------------------------
static bool waitDmaStatus() {
  if (yieldTimeout(isBusyDMA)) {
    808e:	ldr	r0, [pc, #72]	; (80d8 <cardCMD6(unsigned long, unsigned char*)+0x94>)
    8090:	bl	7950 <yieldTimeout(bool (*)())>
    8094:	cbz	r0, 80a8 <cardCMD6(unsigned long, unsigned char*)+0x64>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8096:	ldr	r3, [pc, #32]	; (80b8 <cardCMD6(unsigned long, unsigned char*)+0x74>)
    8098:	movs	r2, #37	; 0x25
    809a:	strb	r2, [r3, #0]
  m_errorLine = line;
    809c:	movw	r2, #423	; 0x1a7
    80a0:	ldr	r3, [pc, #48]	; (80d4 <cardCMD6(unsigned long, unsigned char*)+0x90>)
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    return sdError(SD_CARD_ERROR_CMD6);
  }
  if (!waitDmaStatus()) {
    return sdError(SD_CARD_ERROR_DMA);
    80a2:	movs	r0, #0
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    80a4:	str	r2, [r3, #0]
    80a6:	pop	{r3, r4, r5, pc}
    80a8:	bl	7ab0 <waitDmaStatus() [clone .part.4]>
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    return sdError(SD_CARD_ERROR_CMD6);
  }
  if (!waitDmaStatus()) {
    80ac:	cmp	r0, #0
    80ae:	beq.n	8096 <cardCMD6(unsigned long, unsigned char*)+0x52>
    return sdError(SD_CARD_ERROR_DMA);
  }
  return true;
}
    80b0:	pop	{r3, r4, r5, pc}
    80b2:	nop
    80b4:	.word	0x00007a35
    80b8:	.word	0x1fff1358
    80bc:	.word	0x1fff8465
    80c0:	.word	0x1fff8450
    80c4:	.word	0x00010040
    80c8:	.word	0x400b1000
    80cc:	.word	0x063a0011
    80d0:	.word	0x117f0002
    80d4:	.word	0x1fff846c
    80d8:	.word	0x000077e5

000080dc <SdioCard::begin(SdioConfig)>:
}
#endif  // ENABLE_TEENSY_SDIO_MOD
//==============================================================================
// Start of SdioCard member functions.
//==============================================================================
bool SdioCard::begin(SdioConfig sdioConfig) {
    80dc:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
  m_curState = IDLE_STATE;
  m_initDone = false;
  m_errorCode = SD_CARD_ERROR_NONE;
    80e0:	ldr	r4, [pc, #712]	; (83ac <SdioCard::begin(SdioConfig)+0x2d0>)
}
//------------------------------------------------------------------------------
static void initClock() {
#ifdef HAS_KINETIS_MPU
  // Allow SDHC Bus Master access.
  MPU_RGDAAC0 |= 0x0C000000;
    80e2:	ldr	r2, [pc, #716]	; (83b0 <SdioCard::begin(SdioConfig)+0x2d4>)
bool SdioCard::begin(SdioConfig sdioConfig) {
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
  m_curState = IDLE_STATE;
  m_initDone = false;
    80e4:	ldr.w	ip, [pc, #828]	; 8424 <SdioCard::begin(SdioConfig)+0x348>
  m_errorCode = SD_CARD_ERROR_NONE;
  m_highCapacity = false;
    80e8:	ldr.w	lr, [pc, #828]	; 8428 <SdioCard::begin(SdioConfig)+0x34c>
  m_version2 = false;
    80ec:	ldr.w	sl, [pc, #828]	; 842c <SdioCard::begin(SdioConfig)+0x350>
// Start of SdioCard member functions.
//==============================================================================
bool SdioCard::begin(SdioConfig sdioConfig) {
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
    80f0:	strb	r1, [r0, #8]
  m_curState = IDLE_STATE;
    80f2:	movs	r3, #0
    80f4:	strb	r3, [r0, #9]
  m_initDone = false;
  m_errorCode = SD_CARD_ERROR_NONE;
    80f6:	strb	r3, [r4, #0]
bool SdioCard::begin(SdioConfig sdioConfig) {
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
  m_curState = IDLE_STATE;
  m_initDone = false;
    80f8:	strb.w	r3, [ip]
  m_errorCode = SD_CARD_ERROR_NONE;
  m_highCapacity = false;
    80fc:	strb.w	r3, [lr]
  m_version2 = false;
    8100:	strb.w	r3, [sl]
}
//------------------------------------------------------------------------------
static void initClock() {
#ifdef HAS_KINETIS_MPU
  // Allow SDHC Bus Master access.
  MPU_RGDAAC0 |= 0x0C000000;
    8104:	ldr	r3, [r2, #0]
  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    8106:	ldr	r0, [pc, #684]	; (83b4 <SdioCard::begin(SdioConfig)+0x2d8>)
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    8108:	ldr	r5, [pc, #684]	; (83b8 <SdioCard::begin(SdioConfig)+0x2dc>)
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    810a:	ldr	r6, [pc, #688]	; (83bc <SdioCard::begin(SdioConfig)+0x2e0>)
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    810c:	ldr	r7, [pc, #688]	; (83c0 <SdioCard::begin(SdioConfig)+0x2e4>)
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    810e:	ldr.w	r8, [pc, #800]	; 8430 <SdioCard::begin(SdioConfig)+0x354>
#if defined (__IMXRT1062__)
  SDHC_MIX_CTRL |= 0x80000000;
#endif  //  (__IMXRT1062__)

  // Reset SDHC. Use default Water Mark Level of 16.
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTA | SDHC_SYSCTL_SDCLKFS(0x80);
    8112:	ldr	r1, [pc, #688]	; (83c4 <SdioCard::begin(SdioConfig)+0x2e8>)
}
//------------------------------------------------------------------------------
static void initClock() {
#ifdef HAS_KINETIS_MPU
  // Allow SDHC Bus Master access.
  MPU_RGDAAC0 |= 0x0C000000;
    8114:	orr.w	r3, r3, #201326592	; 0xc000000
    8118:	str	r3, [r2, #0]
#endif  // HAS_KINETIS_MPU
  // Enable SDHC clock.
  SIM_SCGC3 |= SIM_SCGC3_SDHC;
    811a:	add.w	r2, r2, #239616	; 0x3a800
    811e:	adds	r2, #48	; 0x30
    8120:	ldr	r3, [r2, #0]
    8122:	orr.w	r3, r3, #131072	; 0x20000
    8126:	str	r3, [r2, #0]
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    8128:	ldr	r2, [pc, #668]	; (83c8 <SdioCard::begin(SdioConfig)+0x2ec>)
    812a:	movw	r3, #259	; 0x103
    812e:	str	r3, [r2, #0]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    8130:	str	r3, [r5, #0]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    8132:	str	r3, [r6, #0]
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    8134:	str	r3, [r7, #0]
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    8136:	str.w	r3, [r8]
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    813a:	str	r3, [r0, #0]
#if defined (__IMXRT1062__)
  SDHC_MIX_CTRL |= 0x80000000;
#endif  //  (__IMXRT1062__)

  // Reset SDHC. Use default Water Mark Level of 16.
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTA | SDHC_SYSCTL_SDCLKFS(0x80);
    813c:	ldr	r3, [r1, #0]
}
#endif  // ENABLE_TEENSY_SDIO_MOD
//==============================================================================
// Start of SdioCard member functions.
//==============================================================================
bool SdioCard::begin(SdioConfig sdioConfig) {
    813e:	sub	sp, #84	; 0x54
#if defined (__IMXRT1062__)
  SDHC_MIX_CTRL |= 0x80000000;
#endif  //  (__IMXRT1062__)

  // Reset SDHC. Use default Water Mark Level of 16.
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTA | SDHC_SYSCTL_SDCLKFS(0x80);
    8140:	orr.w	r3, r3, #16777216	; 0x1000000
    8144:	orr.w	r3, r3, #32768	; 0x8000
    8148:	str	r3, [r1, #0]
    814a:	mov	r9, r0
    814c:	str.w	ip, [sp, #4]
    8150:	str.w	lr, [sp, #8]
    8154:	mov	fp, r1

  while (SDHC_SYSCTL & SDHC_SYSCTL_RSTA) {
    8156:	ldr.w	r1, [fp]
    815a:	ldr	r3, [pc, #616]	; (83c4 <SdioCard::begin(SdioConfig)+0x2e8>)
    815c:	lsls	r1, r1, #7
    815e:	bmi.n	8156 <SdioCard::begin(SdioConfig)+0x7a>
  }

  // Set initial SCK rate.
  setSdclk(SD_MAX_INIT_RATE_KHZ);
    8160:	mov.w	r0, #400	; 0x190
    8164:	str	r3, [sp, #0]
    8166:	str	r2, [sp, #12]
    8168:	bl	7830 <setSdclk(unsigned long)>
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    816c:	ldr	r2, [sp, #12]
    816e:	movw	r1, #1091	; 0x443
    8172:	str	r1, [r2, #0]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    8174:	mov.w	r2, #1088	; 0x440
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    8178:	str	r1, [r5, #0]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    817a:	str	r2, [r6, #0]
  setSdclk(SD_MAX_INIT_RATE_KHZ);

  enableGPIO(true);

  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;
    817c:	ldr	r2, [pc, #588]	; (83cc <SdioCard::begin(SdioConfig)+0x2f0>)
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    817e:	str	r1, [r7, #0]
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    8180:	str.w	r1, [r8]
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    8184:	str.w	r1, [r9]
  setSdclk(SD_MAX_INIT_RATE_KHZ);

  enableGPIO(true);

  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;
    8188:	ldr	r1, [pc, #580]	; (83d0 <SdioCard::begin(SdioConfig)+0x2f4>)
    818a:	str	r1, [r2, #0]

  attachInterruptVector(IRQ_SDHC, sdIrs);
    818c:	movs	r0, #81	; 0x51
    818e:	ldr	r1, [pc, #580]	; (83d4 <SdioCard::begin(SdioConfig)+0x2f8>)
    8190:	bl	8cf4 <attachInterruptVector>
  NVIC_SET_PRIORITY(IRQ_SDHC, 6*16);
    8194:	ldr	r2, [pc, #576]	; (83d8 <SdioCard::begin(SdioConfig)+0x2fc>)
    8196:	movs	r1, #96	; 0x60
  NVIC_ENABLE_IRQ(IRQ_SDHC);
    8198:	mvn.w	r0, #840	; 0x348

  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;

  attachInterruptVector(IRQ_SDHC, sdIrs);
  NVIC_SET_PRIORITY(IRQ_SDHC, 6*16);
    819c:	strb	r1, [r2, #0]
  NVIC_ENABLE_IRQ(IRQ_SDHC);
    819e:	add	r2, r0

  // Send 80 clocks to card.
  SDHC_SYSCTL |= SDHC_SYSCTL_INITA;
    81a0:	ldr	r3, [sp, #0]
  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;

  attachInterruptVector(IRQ_SDHC, sdIrs);
  NVIC_SET_PRIORITY(IRQ_SDHC, 6*16);
  NVIC_ENABLE_IRQ(IRQ_SDHC);
    81a2:	mov.w	r1, #131072	; 0x20000
    81a6:	str	r1, [r2, #0]

  // Send 80 clocks to card.
  SDHC_SYSCTL |= SDHC_SYSCTL_INITA;
    81a8:	ldr	r2, [r3, #0]
    81aa:	orr.w	r2, r2, #134217728	; 0x8000000
    81ae:	str	r2, [r3, #0]
  while (SDHC_SYSCTL & SDHC_SYSCTL_INITA) {
    81b0:	ldr.w	r1, [fp]
    81b4:	ands.w	r1, r1, #134217728	; 0x8000000
    81b8:	bne.n	81b0 <SdioCard::begin(SdioConfig)+0xd4>
  m_highCapacity = false;
  m_version2 = false;

  // initialize controller.
  initSDHC();
  if (!cardCommand(CMD0_XFERTYP, 0)) {
    81ba:	mov	r0, r1
    81bc:	bl	79c0 <cardCommand(unsigned long, unsigned long)>
    81c0:	mov	fp, r0
    81c2:	cbnz	r0, 81ce <SdioCard::begin(SdioConfig)+0xf2>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    81c4:	movs	r3, #1
    81c6:	strb	r3, [r4, #0]
  m_errorLine = line;
    81c8:	movw	r2, #662	; 0x296
    81cc:	b.n	8276 <SdioCard::begin(SdioConfig)+0x19a>
    81ce:	mov.w	fp, #3
  if (!cardCommand(CMD0_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD0);
  }
  // Try several times for case of reset delay.
  for (uint32_t i = 0; i < CMD8_RETRIES; i++) {
    if (cardCommand(CMD8_XFERTYP, 0X1AA)) {
    81d2:	mov.w	r1, #426	; 0x1aa
    81d6:	ldr	r0, [pc, #516]	; (83dc <SdioCard::begin(SdioConfig)+0x300>)
    81d8:	bl	79c0 <cardCommand(unsigned long, unsigned long)>
    81dc:	cbz	r0, 81fa <SdioCard::begin(SdioConfig)+0x11e>
      if (SDHC_CMDRSP0 != 0X1AA) {
    81de:	ldr	r3, [pc, #512]	; (83e0 <SdioCard::begin(SdioConfig)+0x304>)
    81e0:	ldr	r3, [r3, #0]
    81e2:	cmp.w	r3, #426	; 0x1aa
    81e6:	beq.n	81f2 <SdioCard::begin(SdioConfig)+0x116>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    81e8:	movs	r3, #6
    81ea:	strb	r3, [r4, #0]
  m_errorLine = line;
    81ec:	mov.w	r2, #668	; 0x29c
    81f0:	b.n	8312 <SdioCard::begin(SdioConfig)+0x236>
  for (uint32_t i = 0; i < CMD8_RETRIES; i++) {
    if (cardCommand(CMD8_XFERTYP, 0X1AA)) {
      if (SDHC_CMDRSP0 != 0X1AA) {
        return sdError(SD_CARD_ERROR_CMD8);
      }
      m_version2 = true;
    81f2:	movs	r3, #1
    81f4:	strb.w	r3, [sl]
      break;
    81f8:	b.n	8200 <SdioCard::begin(SdioConfig)+0x124>
  initSDHC();
  if (!cardCommand(CMD0_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD0);
  }
  // Try several times for case of reset delay.
  for (uint32_t i = 0; i < CMD8_RETRIES; i++) {
    81fa:	subs.w	fp, fp, #1
    81fe:	bne.n	81d2 <SdioCard::begin(SdioConfig)+0xf6>
      }
      m_version2 = true;
      break;
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
    8200:	ldrb.w	r3, [sl]
    8204:	cmp	r3, #0
    8206:	ldr	r3, [pc, #476]	; (83e4 <SdioCard::begin(SdioConfig)+0x308>)
    8208:	ite	eq
    820a:	moveq.w	fp, #3145728	; 0x300000
    820e:	movne	fp, r3
  int m = micros();
    8210:	bl	8d98 <micros>
    8214:	str	r0, [sp, #0]
}
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
//==============================================================================
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
    8216:	movs	r1, #0
    8218:	ldr	r0, [pc, #460]	; (83e8 <SdioCard::begin(SdioConfig)+0x30c>)
    821a:	bl	79c0 <cardCommand(unsigned long, unsigned long)>
    821e:	cmp	r0, #0
    8220:	beq.n	8300 <SdioCard::begin(SdioConfig)+0x224>
    8222:	mov	r1, fp
    8224:	ldr	r0, [pc, #452]	; (83ec <SdioCard::begin(SdioConfig)+0x310>)
    8226:	bl	79c0 <cardCommand(unsigned long, unsigned long)>
    822a:	cmp	r0, #0
    822c:	beq.n	8300 <SdioCard::begin(SdioConfig)+0x224>
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
  do {
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
    822e:	bl	8d98 <micros>
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
  do {
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
    8232:	ldr	r3, [sp, #0]
    8234:	subs	r0, r0, r3
    8236:	ldr	r3, [pc, #440]	; (83f0 <SdioCard::begin(SdioConfig)+0x314>)
    8238:	cmp	r0, r3
    823a:	bhi.n	8300 <SdioCard::begin(SdioConfig)+0x224>
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
    823c:	ldr	r3, [pc, #416]	; (83e0 <SdioCard::begin(SdioConfig)+0x304>)
    823e:	ldr.w	sl, [pc, #416]	; 83e0 <SdioCard::begin(SdioConfig)+0x304>
    8242:	ldr	r3, [r3, #0]
      break;
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
  do {
    8244:	cmp	r3, #0
    8246:	bge.n	8216 <SdioCard::begin(SdioConfig)+0x13a>
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
  m_ocr = SDHC_CMDRSP0;
    8248:	ldr	r2, [pc, #424]	; (83f4 <SdioCard::begin(SdioConfig)+0x318>)
    824a:	ldr.w	r1, [sl]
    824e:	str	r1, [r2, #0]
  if (SDHC_CMDRSP0 & 0x40000000) {
    8250:	ldr.w	r2, [sl]
    // Is high capacity.
    m_highCapacity = true;
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    8254:	ldr	r0, [pc, #416]	; (83f8 <SdioCard::begin(SdioConfig)+0x31c>)
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
  m_ocr = SDHC_CMDRSP0;
  if (SDHC_CMDRSP0 & 0x40000000) {
    8256:	lsls	r2, r2, #1
    // Is high capacity.
    m_highCapacity = true;
    8258:	itt	mi
    825a:	ldrmi	r3, [sp, #8]
    825c:	movmi	r2, #1
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    825e:	mov.w	r1, #0
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
  m_ocr = SDHC_CMDRSP0;
  if (SDHC_CMDRSP0 & 0x40000000) {
    // Is high capacity.
    m_highCapacity = true;
    8262:	it	mi
    8264:	strbmi	r2, [r3, #0]
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    8266:	bl	79c0 <cardCommand(unsigned long, unsigned long)>
    826a:	mov	fp, r0
    826c:	cbnz	r0, 827c <SdioCard::begin(SdioConfig)+0x1a0>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    826e:	movs	r3, #2
    8270:	strb	r3, [r4, #0]
  m_errorLine = line;
    8272:	mov.w	r2, #688	; 0x2b0
    8276:	ldr	r3, [pc, #388]	; (83fc <SdioCard::begin(SdioConfig)+0x320>)
    8278:	str	r2, [r3, #0]
  if (SDHC_CMDRSP0 & 0x40000000) {
    // Is high capacity.
    m_highCapacity = true;
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD2);
    827a:	b.n	83a2 <SdioCard::begin(SdioConfig)+0x2c6>
  }
  if (!cardCommand(CMD3_XFERTYP, 0)) {
    827c:	movs	r1, #0
    827e:	ldr	r0, [pc, #384]	; (8400 <SdioCard::begin(SdioConfig)+0x324>)
    8280:	bl	79c0 <cardCommand(unsigned long, unsigned long)>
    8284:	mov	fp, r0
    8286:	cbnz	r0, 8292 <SdioCard::begin(SdioConfig)+0x1b6>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8288:	movs	r3, #3
    828a:	strb	r3, [r4, #0]
  m_errorLine = line;
    828c:	movw	r2, #691	; 0x2b3
    8290:	b.n	8276 <SdioCard::begin(SdioConfig)+0x19a>
    return sdError(SD_CARD_ERROR_CMD2);
  }
  if (!cardCommand(CMD3_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD3);
  }
  m_rca = SDHC_CMDRSP0 & 0xFFFF0000;
    8292:	ldr.w	r3, [sl]
    8296:	ldr.w	sl, [pc, #412]	; 8434 <SdioCard::begin(SdioConfig)+0x358>

  if (!readReg16(CMD9_XFERTYP, &m_csd)) {
    829a:	ldr	r1, [pc, #360]	; (8404 <SdioCard::begin(SdioConfig)+0x328>)
    829c:	ldr	r0, [pc, #360]	; (8408 <SdioCard::begin(SdioConfig)+0x32c>)
    return sdError(SD_CARD_ERROR_CMD2);
  }
  if (!cardCommand(CMD3_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD3);
  }
  m_rca = SDHC_CMDRSP0 & 0xFFFF0000;
    829e:	lsrs	r3, r3, #16
    82a0:	lsls	r3, r3, #16
    82a2:	str.w	r3, [sl]

  if (!readReg16(CMD9_XFERTYP, &m_csd)) {
    82a6:	bl	7a48 <readReg16(unsigned long, void*)>
    82aa:	mov	fp, r0
    82ac:	cbnz	r0, 82b8 <SdioCard::begin(SdioConfig)+0x1dc>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    82ae:	movs	r3, #7
    82b0:	strb	r3, [r4, #0]
  m_errorLine = line;
    82b2:	mov.w	r2, #696	; 0x2b8
    82b6:	b.n	8276 <SdioCard::begin(SdioConfig)+0x19a>
  m_rca = SDHC_CMDRSP0 & 0xFFFF0000;

  if (!readReg16(CMD9_XFERTYP, &m_csd)) {
    return sdError(SD_CARD_ERROR_CMD9);
  }
  if (!readReg16(CMD10_XFERTYP, &m_cid)) {
    82b8:	ldr	r1, [pc, #336]	; (840c <SdioCard::begin(SdioConfig)+0x330>)
    82ba:	ldr	r0, [pc, #340]	; (8410 <SdioCard::begin(SdioConfig)+0x334>)
    82bc:	bl	7a48 <readReg16(unsigned long, void*)>
    82c0:	mov	fp, r0
    82c2:	cbnz	r0, 82ce <SdioCard::begin(SdioConfig)+0x1f2>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    82c4:	movs	r3, #8
    82c6:	strb	r3, [r4, #0]
  m_errorLine = line;
    82c8:	movw	r2, #699	; 0x2bb
    82cc:	b.n	8276 <SdioCard::begin(SdioConfig)+0x19a>
    return sdError(SD_CARD_ERROR_CMD9);
  }
  if (!readReg16(CMD10_XFERTYP, &m_cid)) {
    return sdError(SD_CARD_ERROR_CMD10);
  }
  if (!cardCommand(CMD7_XFERTYP, m_rca)) {
    82ce:	ldr.w	r1, [sl]
    82d2:	ldr	r0, [pc, #320]	; (8414 <SdioCard::begin(SdioConfig)+0x338>)
    82d4:	bl	79c0 <cardCommand(unsigned long, unsigned long)>
    82d8:	mov	fp, r0
    82da:	cbnz	r0, 82e6 <SdioCard::begin(SdioConfig)+0x20a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    82dc:	movs	r3, #5
    82de:	strb	r3, [r4, #0]
  m_errorLine = line;
    82e0:	movw	r2, #702	; 0x2be
    82e4:	b.n	8276 <SdioCard::begin(SdioConfig)+0x19a>
}
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
//==============================================================================
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
    82e6:	ldr.w	r1, [sl]
    82ea:	ldr	r0, [pc, #252]	; (83e8 <SdioCard::begin(SdioConfig)+0x30c>)
    82ec:	bl	79c0 <cardCommand(unsigned long, unsigned long)>
    82f0:	cbz	r0, 830a <SdioCard::begin(SdioConfig)+0x22e>
    82f2:	movs	r1, #2
    82f4:	ldr	r0, [pc, #288]	; (8418 <SdioCard::begin(SdioConfig)+0x33c>)
    82f6:	bl	79c0 <cardCommand(unsigned long, unsigned long)>
    82fa:	mov	fp, r0
    82fc:	cbz	r0, 830a <SdioCard::begin(SdioConfig)+0x22e>
    82fe:	b.n	831c <SdioCard::begin(SdioConfig)+0x240>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8300:	movs	r3, #23
    8302:	strb	r3, [r4, #0]
  m_errorLine = line;
    8304:	movw	r2, #679	; 0x2a7
    8308:	b.n	8312 <SdioCard::begin(SdioConfig)+0x236>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    830a:	movs	r3, #20
    830c:	strb	r3, [r4, #0]
  m_errorLine = line;
    830e:	movw	r2, #706	; 0x2c2
    8312:	ldr	r3, [pc, #232]	; (83fc <SdioCard::begin(SdioConfig)+0x320>)
  if (!cardCommand(CMD7_XFERTYP, m_rca)) {
    return sdError(SD_CARD_ERROR_CMD7);
  }
  // Set card to bus width four.
  if (!cardAcmd(m_rca, ACMD6_XFERTYP, 2)) {
    return sdError(SD_CARD_ERROR_ACMD6);
    8314:	mov.w	fp, #0
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    8318:	str	r2, [r3, #0]
  if (!cardCommand(CMD7_XFERTYP, m_rca)) {
    return sdError(SD_CARD_ERROR_CMD7);
  }
  // Set card to bus width four.
  if (!cardAcmd(m_rca, ACMD6_XFERTYP, 2)) {
    return sdError(SD_CARD_ERROR_ACMD6);
    831a:	b.n	83a2 <SdioCard::begin(SdioConfig)+0x2c6>
  }
  // Set SDHC to bus width four.
  SDHC_PROCTL &= ~SDHC_PROCTL_DTW_MASK;
    831c:	ldr	r3, [pc, #252]	; (841c <SdioCard::begin(SdioConfig)+0x340>)
    831e:	ldr	r2, [r3, #0]
    8320:	bic.w	r2, r2, #6
    8324:	str	r2, [r3, #0]
  SDHC_PROCTL |= SDHC_PROCTL_DTW(SDHC_PROCTL_DTW_4BIT);
    8326:	ldr	r2, [r3, #0]
    8328:	orr.w	r2, r2, #2
    832c:	str	r2, [r3, #0]

  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);
    832e:	mov.w	r2, #1048592	; 0x100010
    8332:	str	r2, [r3, #28]

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
    8334:	add	r1, sp, #16
    8336:	mvn.w	r0, #4278190080	; 0xff000000
    833a:	bl	8044 <cardCMD6(unsigned long, unsigned char*)>
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    833e:	cbz	r0, 8348 <SdioCard::begin(SdioConfig)+0x26c>
  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
    8340:	ldrb.w	r3, [sp, #29]
    8344:	lsls	r3, r3, #30
    8346:	bmi.n	834e <SdioCard::begin(SdioConfig)+0x272>
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    kHzSdClk = 50000;
  } else {
    kHzSdClk = 25000;
    8348:	movw	r0, #25000	; 0x61a8
    834c:	b.n	836a <SdioCard::begin(SdioConfig)+0x28e>

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    834e:	add	r1, sp, #16
    8350:	ldr	r0, [pc, #204]	; (8420 <SdioCard::begin(SdioConfig)+0x344>)
    8352:	bl	8044 <cardCMD6(unsigned long, unsigned char*)>
  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
    8356:	cmp	r0, #0
    8358:	beq.n	8348 <SdioCard::begin(SdioConfig)+0x26c>
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    835a:	ldrb.w	r3, [sp, #32]
    835e:	and.w	r3, r3, #15
    8362:	cmp	r3, #1
    8364:	bne.n	8348 <SdioCard::begin(SdioConfig)+0x26c>
    kHzSdClk = 50000;
    8366:	movw	r0, #50000	; 0xc350
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    836a:	ldr	r4, [pc, #92]	; (83c8 <SdioCard::begin(SdioConfig)+0x2ec>)
    836c:	movw	r3, #259	; 0x103
    8370:	str	r3, [r4, #0]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    8372:	str	r3, [r5, #0]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    8374:	str	r3, [r6, #0]
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    8376:	str	r3, [r7, #0]
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    8378:	str.w	r3, [r8]
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    837c:	str.w	r3, [r9]
  }
  // Disable GPIO.
  enableGPIO(false);

  // Set the SDHC SCK frequency.
  setSdclk(kHzSdClk);
    8380:	bl	7830 <setSdclk(unsigned long)>
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    8384:	movw	r3, #1091	; 0x443
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    8388:	mov.w	r2, #1088	; 0x440
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    838c:	str	r3, [r4, #0]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    838e:	str	r3, [r5, #0]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    8390:	str	r2, [r6, #0]
  // Set the SDHC SCK frequency.
  setSdclk(kHzSdClk);

  // Enable GPIO.
  enableGPIO(true);
  m_initDone = true;
    8392:	ldr	r2, [sp, #4]
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    8394:	str	r3, [r7, #0]
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    8396:	str.w	r3, [r8]
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    839a:	str.w	r3, [r9]
  // Set the SDHC SCK frequency.
  setSdclk(kHzSdClk);

  // Enable GPIO.
  enableGPIO(true);
  m_initDone = true;
    839e:	movs	r3, #1
    83a0:	strb	r3, [r2, #0]
  return true;
}
    83a2:	mov	r0, fp
    83a4:	add	sp, #84	; 0x54
    83a6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    83aa:	nop
    83ac:	.word	0x1fff1358
    83b0:	.word	0x4000d800
    83b4:	.word	0x4004d014
    83b8:	.word	0x4004d004
    83bc:	.word	0x4004d008
    83c0:	.word	0x4004d00c
    83c4:	.word	0x400b102c
    83c8:	.word	0x4004d000
    83cc:	.word	0x400b1034
    83d0:	.word	0x117f000b
    83d4:	.word	0x00007781
    83d8:	.word	0xe000e451
    83dc:	.word	0x081a0000
    83e0:	.word	0x400b1010
    83e4:	.word	0x40300000
    83e8:	.word	0x371a0000
    83ec:	.word	0x29020000
    83f0:	.word	0x000f4240
    83f4:	.word	0x1fff8444
    83f8:	.word	0x02090000
    83fc:	.word	0x1fff846c
    8400:	.word	0x031a0000
    8404:	.word	0x1fff8455
    8408:	.word	0x09090000
    840c:	.word	0x1fff8429
    8410:	.word	0x0a090000
    8414:	.word	0x071b0000
    8418:	.word	0x061a0000
    841c:	.word	0x400b1028
    8420:	.word	0x80fffff1
    8424:	.word	0x1fff8454
    8428:	.word	0x1fff8440
    842c:	.word	0x1fff8428
    8430:	.word	0x4004d010
    8434:	.word	0x1fff8448

00008438 <SdioCard::readData(unsigned char*)>:
bool SdioCard::readCSD(csd_t* csd) {
  memcpy(csd, &m_csd, 16);
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readData(uint8_t* dst) {
    8438:	push	{r3, r4, r5, lr}
  DBG_IRQSTAT();
  uint32_t* p32 = reinterpret_cast<uint32_t*>(dst);

  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_RTA)) {
    843a:	ldr	r5, [pc, #152]	; (84d4 <SdioCard::readData(unsigned char*)+0x9c>)
    843c:	ldr	r3, [r5, #0]
    843e:	lsls	r3, r3, #22
bool SdioCard::readCSD(csd_t* csd) {
  memcpy(csd, &m_csd, 16);
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readData(uint8_t* dst) {
    8440:	mov	r4, r1
  DBG_IRQSTAT();
  uint32_t* p32 = reinterpret_cast<uint32_t*>(dst);

  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_RTA)) {
    8442:	bmi.n	8462 <SdioCard::readData(unsigned char*)+0x2a>
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8444:	ldr	r3, [pc, #144]	; (84d8 <SdioCard::readData(unsigned char*)+0xa0>)
    8446:	ldr	r2, [r3, #0]
    8448:	bic.w	r2, r2, #65536	; 0x10000
    844c:	str	r2, [r3, #0]
    noInterrupts();
    844e:	cpsid	i
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
    8450:	ldr	r2, [r3, #0]
    8452:	orr.w	r2, r2, #131072	; 0x20000
    8456:	str	r2, [r3, #0]
    SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    8458:	ldr	r2, [r3, #0]
    845a:	orr.w	r2, r2, #65536	; 0x10000
    845e:	str	r2, [r3, #0]
    interrupts();
    8460:	cpsie	i
  }
  if (waitTimeout(isBusyFifoRead)) {
    8462:	ldr	r0, [pc, #120]	; (84dc <SdioCard::readData(unsigned char*)+0xa4>)
    8464:	bl	792c <waitTimeout(bool (*)())>
    8468:	cbnz	r0, 84c0 <SdioCard::readData(unsigned char*)+0x88>
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BREN)) {
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      p32[i] = SDHC_DATPORT;
    846a:	ldr	r1, [pc, #116]	; (84e0 <SdioCard::readData(unsigned char*)+0xa8>)
    846c:	subs	r3, r4, #4
    846e:	add.w	r4, r4, #508	; 0x1fc
  }
  if (waitTimeout(isBusyFifoRead)) {
    return sdError(SD_CARD_ERROR_READ_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BREN)) {
    8472:	ldr	r2, [r5, #0]
    8474:	lsls	r0, r2, #20
    8476:	bpl.n	8472 <SdioCard::readData(unsigned char*)+0x3a>
    8478:	add.w	r2, r3, #64	; 0x40
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      p32[i] = SDHC_DATPORT;
    847c:	ldr	r0, [r1, #0]
    847e:	str.w	r0, [r3, #4]!
    return sdError(SD_CARD_ERROR_READ_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BREN)) {
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
    8482:	cmp	r2, r3
    8484:	bne.n	847c <SdioCard::readData(unsigned char*)+0x44>
    interrupts();
  }
  if (waitTimeout(isBusyFifoRead)) {
    return sdError(SD_CARD_ERROR_READ_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    8486:	cmp	r4, r2
    8488:	mov	r3, r2
    848a:	bne.n	8472 <SdioCard::readData(unsigned char*)+0x3a>
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      p32[i] = SDHC_DATPORT;
    }
    p32 += FIFO_WML;
  }
  if (waitTimeout(isBusyTransferComplete)) {
    848c:	ldr	r0, [pc, #84]	; (84e4 <SdioCard::readData(unsigned char*)+0xac>)
    848e:	bl	792c <waitTimeout(bool (*)())>
    8492:	cbz	r0, 84a0 <SdioCard::readData(unsigned char*)+0x68>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8494:	ldr	r3, [pc, #80]	; (84e8 <SdioCard::readData(unsigned char*)+0xb0>)
    8496:	movs	r2, #29
    8498:	strb	r2, [r3, #0]
  m_errorLine = line;
    849a:	movw	r2, #846	; 0x34e
    849e:	b.n	84ca <SdioCard::readData(unsigned char*)+0x92>
    p32 += FIFO_WML;
  }
  if (waitTimeout(isBusyTransferComplete)) {
    return sdError(SD_CARD_ERROR_READ_TIMEOUT);
  }
  m_irqstat = SDHC_IRQSTAT;
    84a0:	ldr	r2, [pc, #72]	; (84ec <SdioCard::readData(unsigned char*)+0xb4>)
    84a2:	ldr	r3, [pc, #76]	; (84f0 <SdioCard::readData(unsigned char*)+0xb8>)
    84a4:	ldr	r1, [r2, #0]
    84a6:	str	r1, [r3, #0]
  SDHC_IRQSTAT = m_irqstat;
    84a8:	ldr	r1, [r3, #0]
    84aa:	str	r1, [r2, #0]
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
    84ac:	ldr	r2, [r3, #0]
    84ae:	lsls	r2, r2, #30
    84b0:	bpl.n	84d0 <SdioCard::readData(unsigned char*)+0x98>
    84b2:	ldr	r3, [r3, #0]
    84b4:	ldr	r0, [pc, #60]	; (84f4 <SdioCard::readData(unsigned char*)+0xbc>)
    84b6:	ands	r0, r3
    84b8:	clz	r0, r0
    84bc:	lsrs	r0, r0, #5
    84be:	pop	{r3, r4, r5, pc}
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    84c0:	ldr	r3, [pc, #36]	; (84e8 <SdioCard::readData(unsigned char*)+0xb0>)
    84c2:	movs	r2, #26
    84c4:	strb	r2, [r3, #0]
  m_errorLine = line;
    84c6:	movw	r2, #835	; 0x343
    84ca:	ldr	r3, [pc, #44]	; (84f8 <SdioCard::readData(unsigned char*)+0xc0>)
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
    SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    interrupts();
  }
  if (waitTimeout(isBusyFifoRead)) {
    return sdError(SD_CARD_ERROR_READ_FIFO);
    84cc:	movs	r0, #0
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    84ce:	str	r2, [r3, #0]
    return sdError(SD_CARD_ERROR_READ_TIMEOUT);
  }
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
    84d0:	pop	{r3, r4, r5, pc}
    84d2:	nop
    84d4:	.word	0x400b1024
    84d8:	.word	0x400b1028
    84dc:	.word	0x000077f1
    84e0:	.word	0x400b1020
    84e4:	.word	0x00007819
    84e8:	.word	0x1fff1358
    84ec:	.word	0x400b1030
    84f0:	.word	0x1fff8450
    84f4:	.word	0x117f0000
    84f8:	.word	0x1fff846c

000084fc <SdioCard::readStart(unsigned long)>:
  }
  return true;
}
//------------------------------------------------------------------------------
// SDHC will do Auto CMD12 after count sectors.
bool SdioCard::readStart(uint32_t sector) {
    84fc:	push	{r4, lr}
  DBG_IRQSTAT();
  if (yieldTimeout(isBusyCMD13)) {
    84fe:	ldr	r0, [pc, #80]	; (8550 <SdioCard::readStart(unsigned long)+0x54>)
  }
  return true;
}
//------------------------------------------------------------------------------
// SDHC will do Auto CMD12 after count sectors.
bool SdioCard::readStart(uint32_t sector) {
    8500:	mov	r4, r1
  DBG_IRQSTAT();
  if (yieldTimeout(isBusyCMD13)) {
    8502:	bl	7950 <yieldTimeout(bool (*)())>
    8506:	cbz	r0, 851a <SdioCard::readStart(unsigned long)+0x1e>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8508:	ldr	r3, [pc, #72]	; (8554 <SdioCard::readStart(unsigned long)+0x58>)
    850a:	movs	r2, #10
    850c:	strb	r2, [r3, #0]
  m_errorLine = line;
    850e:	ldr	r3, [pc, #72]	; (8558 <SdioCard::readStart(unsigned long)+0x5c>)
    8510:	mov.w	r2, #928	; 0x3a0
    8514:	str	r2, [r3, #0]
//------------------------------------------------------------------------------
// SDHC will do Auto CMD12 after count sectors.
bool SdioCard::readStart(uint32_t sector) {
  DBG_IRQSTAT();
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
    8516:	movs	r0, #0
    8518:	pop	{r4, pc}
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    851a:	ldr	r2, [pc, #64]	; (855c <SdioCard::readStart(unsigned long)+0x60>)
    851c:	ldr	r3, [r2, #0]
    851e:	orr.w	r3, r3, #65536	; 0x10000
    8522:	str	r3, [r2, #0]
#if defined(__IMXRT1062__)
  // Infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKSIZE(512);
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
    8524:	ldr	r3, [pc, #56]	; (8560 <SdioCard::readStart(unsigned long)+0x64>)
    8526:	ldr	r2, [pc, #60]	; (8564 <SdioCard::readStart(unsigned long)+0x68>)
    8528:	str	r2, [r3, #0]
#endif  // defined(__IMXRT1062__)

  if (!cardCommand(CMD18_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    852a:	ldr	r3, [pc, #60]	; (8568 <SdioCard::readStart(unsigned long)+0x6c>)
    852c:	ldrb	r3, [r3, #0]
    852e:	cbnz	r3, 8534 <SdioCard::readStart(unsigned long)+0x38>
    8530:	lsls	r1, r4, #9
    8532:	b.n	8536 <SdioCard::readStart(unsigned long)+0x3a>
    8534:	mov	r1, r4
    8536:	ldr	r0, [pc, #52]	; (856c <SdioCard::readStart(unsigned long)+0x70>)
    8538:	bl	79c0 <cardCommand(unsigned long, unsigned long)>
    853c:	cbnz	r0, 854c <SdioCard::readStart(unsigned long)+0x50>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    853e:	ldr	r3, [pc, #20]	; (8554 <SdioCard::readStart(unsigned long)+0x58>)
    8540:	movs	r2, #12
    8542:	strb	r2, [r3, #0]
  m_errorLine = line;
    8544:	ldr	r3, [pc, #16]	; (8558 <SdioCard::readStart(unsigned long)+0x5c>)
    8546:	mov.w	r2, #940	; 0x3ac
    854a:	str	r2, [r3, #0]

  if (!cardCommand(CMD18_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    return sdError(SD_CARD_ERROR_CMD18);
  }
  return true;
}
    854c:	pop	{r4, pc}
    854e:	nop
    8550:	.word	0x00007a35
    8554:	.word	0x1fff1358
    8558:	.word	0x1fff846c
    855c:	.word	0x400b1028
    8560:	.word	0x400b1004
    8564:	.word	0xffff0200
    8568:	.word	0x1fff8440
    856c:	.word	0x123a0032

00008570 <SdioCard::readSector(unsigned long, unsigned char*)>:
bool SdioCard::readOCR(uint32_t* ocr) {
  *ocr = m_ocr;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSector(uint32_t sector, uint8_t* dst) {
    8570:	push	{r4, r5, r6, lr}
  if (m_sdioConfig.useDma()) {
    8572:	ldrb	r3, [r0, #8]
bool SdioCard::readOCR(uint32_t* ocr) {
  *ocr = m_ocr;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSector(uint32_t sector, uint8_t* dst) {
    8574:	mov	r6, r2
  if (m_sdioConfig.useDma()) {
    8576:	lsls	r2, r3, #31
bool SdioCard::readOCR(uint32_t* ocr) {
  *ocr = m_ocr;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSector(uint32_t sector, uint8_t* dst) {
    8578:	sub.w	sp, sp, #512	; 0x200
    857c:	mov	r4, r0
    857e:	mov	r5, r1
  if (m_sdioConfig.useDma()) {
    8580:	bpl.n	85ba <SdioCard::readSector(unsigned long, unsigned char*)+0x4a>
    uint8_t aligned[512];

    uint8_t* ptr = (uint32_t)dst & 3 ? aligned : dst;
    8582:	lsls	r3, r6, #30
    8584:	ite	eq
    8586:	moveq	r4, r6
    8588:	movne	r4, sp

    if (!rdWrSectors(CMD17_DMA_XFERTYP, sector, ptr, 1)) {
    858a:	movs	r3, #1
    858c:	mov	r2, r4
    858e:	ldr	r0, [pc, #148]	; (8624 <SdioCard::readSector(unsigned long, unsigned char*)+0xb4>)
    8590:	bl	7ad0 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    8594:	mov	r5, r0
    8596:	cbnz	r0, 85a8 <SdioCard::readSector(unsigned long, unsigned char*)+0x38>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8598:	ldr	r3, [pc, #140]	; (8628 <SdioCard::readSector(unsigned long, unsigned char*)+0xb8>)
    859a:	movs	r2, #11
    859c:	strb	r2, [r3, #0]
  m_errorLine = line;
    859e:	ldr	r3, [pc, #140]	; (862c <SdioCard::readSector(unsigned long, unsigned char*)+0xbc>)
    85a0:	movw	r2, #865	; 0x361
    85a4:	str	r2, [r3, #0]
    85a6:	b.n	861c <SdioCard::readSector(unsigned long, unsigned char*)+0xac>
    uint8_t* ptr = (uint32_t)dst & 3 ? aligned : dst;

    if (!rdWrSectors(CMD17_DMA_XFERTYP, sector, ptr, 1)) {
      return sdError(SD_CARD_ERROR_CMD17);
    }
    if (ptr != dst) {
    85a8:	cmp	r4, r6
    85aa:	beq.n	861c <SdioCard::readSector(unsigned long, unsigned char*)+0xac>
      memcpy(dst, aligned, 512);
    85ac:	mov.w	r2, #512	; 0x200
    85b0:	mov	r1, sp
    85b2:	mov	r0, r6
    85b4:	bl	8720 <memcpy>
    85b8:	b.n	861c <SdioCard::readSector(unsigned long, unsigned char*)+0xac>
    }
  } else {
#if ENABLE_TEENSY_SDIO_MOD
    if (!waitTransferComplete()) {
    85ba:	bl	7ca8 <waitTransferComplete()>
    85be:	cbnz	r0, 85c4 <SdioCard::readSector(unsigned long, unsigned char*)+0x54>
      return false;
    85c0:	movs	r5, #0
    85c2:	b.n	861c <SdioCard::readSector(unsigned long, unsigned char*)+0xac>
    }
#endif  // ENABLE_TEENSY_SDIO_MOD
    if (m_curState != READ_STATE || sector != m_curSector) {
    85c4:	ldrb	r3, [r4, #9]
    85c6:	cmp	r3, #1
    85c8:	bne.n	85d0 <SdioCard::readSector(unsigned long, unsigned char*)+0x60>
    85ca:	ldr	r3, [r4, #4]
    85cc:	cmp	r5, r3
    85ce:	beq.n	85ee <SdioCard::readSector(unsigned long, unsigned char*)+0x7e>
      if (!syncDevice()) {
    85d0:	ldr	r3, [r4, #0]
    85d2:	mov	r0, r4
    85d4:	ldr	r3, [r3, #28]
    85d6:	blx	r3
    85d8:	cmp	r0, #0
    85da:	beq.n	85c0 <SdioCard::readSector(unsigned long, unsigned char*)+0x50>
        return false;
      }
      if (!readStart(sector)) {
    85dc:	mov	r1, r5
    85de:	mov	r0, r4
    85e0:	bl	84fc <SdioCard::readStart(unsigned long)>
    85e4:	cmp	r0, #0
    85e6:	beq.n	85c0 <SdioCard::readSector(unsigned long, unsigned char*)+0x50>
        return false;
      }
      m_curSector = sector;
      m_curState = READ_STATE;
    85e8:	movs	r3, #1
        return false;
      }
      if (!readStart(sector)) {
        return false;
      }
      m_curSector = sector;
    85ea:	str	r5, [r4, #4]
      m_curState = READ_STATE;
    85ec:	strb	r3, [r4, #9]
    }
    if (!readData(dst)) {
    85ee:	mov	r1, r6
    85f0:	mov	r0, r4
    85f2:	bl	8438 <SdioCard::readData(unsigned char*)>
    85f6:	mov	r5, r0
    85f8:	cmp	r0, #0
    85fa:	beq.n	85c0 <SdioCard::readSector(unsigned long, unsigned char*)+0x50>
      return false;
    }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
    85fc:	ldr	r3, [pc, #48]	; (8630 <SdioCard::readSector(unsigned long, unsigned char*)+0xc0>)
    85fe:	ldr	r3, [r3, #0]
    8600:	lsrs	r3, r3, #16
    8602:	lsls	r3, r3, #16
    8604:	cbz	r3, 860e <SdioCard::readSector(unsigned long, unsigned char*)+0x9e>
      if (!syncDevice()) {
        return false;
      }
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
    m_curSector++;
    8606:	ldr	r3, [r4, #4]
    8608:	adds	r3, #1
    860a:	str	r3, [r4, #4]
    860c:	b.n	861c <SdioCard::readSector(unsigned long, unsigned char*)+0xac>
    if (!readData(dst)) {
      return false;
    }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
      if (!syncDevice()) {
    860e:	ldr	r3, [r4, #0]
    8610:	mov	r0, r4
    8612:	ldr	r3, [r3, #28]
    8614:	blx	r3
    8616:	cmp	r0, #0
    8618:	bne.n	8606 <SdioCard::readSector(unsigned long, unsigned char*)+0x96>
    861a:	b.n	85c0 <SdioCard::readSector(unsigned long, unsigned char*)+0x50>
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
    m_curSector++;
  }
  return true;
}
    861c:	mov	r0, r5
    861e:	add.w	sp, sp, #512	; 0x200
    8622:	pop	{r4, r5, r6, pc}
    8624:	.word	0x113a0011
    8628:	.word	0x1fff1358
    862c:	.word	0x1fff846c
    8630:	.word	0x400b1004

00008634 <SdioCard::stopTransmission(bool)>:
//------------------------------------------------------------------------------
uint32_t SdioCard::status() {
  return statusCMD13();
}
//------------------------------------------------------------------------------
bool SdioCard::stopTransmission(bool blocking) {
    8634:	push	{r4, r5, r6, lr}
  m_curState = IDLE_STATE;
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8636:	ldr	r2, [pc, #72]	; (8680 <SdioCard::stopTransmission(bool)+0x4c>)
uint32_t SdioCard::status() {
  return statusCMD13();
}
//------------------------------------------------------------------------------
bool SdioCard::stopTransmission(bool blocking) {
  m_curState = IDLE_STATE;
    8638:	movs	r5, #0
    863a:	strb	r5, [r0, #9]
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    863c:	ldr	r3, [r2, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    863e:	ldr	r0, [pc, #68]	; (8684 <SdioCard::stopTransmission(bool)+0x50>)
}
//------------------------------------------------------------------------------
bool SdioCard::stopTransmission(bool blocking) {
  m_curState = IDLE_STATE;
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8640:	bic.w	r3, r3, #65536	; 0x10000
//------------------------------------------------------------------------------
uint32_t SdioCard::status() {
  return statusCMD13();
}
//------------------------------------------------------------------------------
bool SdioCard::stopTransmission(bool blocking) {
    8644:	mov	r6, r1
  m_curState = IDLE_STATE;
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8646:	str	r3, [r2, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    8648:	mov	r1, r5
    864a:	bl	79c0 <cardCommand(unsigned long, unsigned long)>
    864e:	mov	r4, r0
    8650:	cbnz	r0, 8662 <SdioCard::stopTransmission(bool)+0x2e>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8652:	ldr	r3, [pc, #52]	; (8688 <SdioCard::stopTransmission(bool)+0x54>)
    8654:	movs	r2, #9
    8656:	strb	r2, [r3, #0]
  m_errorLine = line;
    8658:	ldr	r3, [pc, #48]	; (868c <SdioCard::stopTransmission(bool)+0x58>)
    865a:	movw	r2, #962	; 0x3c2
    865e:	str	r2, [r3, #0]
bool SdioCard::stopTransmission(bool blocking) {
  m_curState = IDLE_STATE;
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD12);
    8660:	b.n	867c <SdioCard::stopTransmission(bool)+0x48>
  }
  if (blocking) {
    8662:	cbz	r6, 867c <SdioCard::stopTransmission(bool)+0x48>
    if (yieldTimeout(isBusyDat)) {
    8664:	ldr	r0, [pc, #40]	; (8690 <SdioCard::stopTransmission(bool)+0x5c>)
    8666:	bl	7950 <yieldTimeout(bool (*)())>
    866a:	cbz	r0, 867c <SdioCard::stopTransmission(bool)+0x48>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    866c:	ldr	r3, [pc, #24]	; (8688 <SdioCard::stopTransmission(bool)+0x54>)
    866e:	movs	r2, #10
    8670:	strb	r2, [r3, #0]
  m_errorLine = line;
    8672:	ldr	r3, [pc, #24]	; (868c <SdioCard::stopTransmission(bool)+0x58>)
    8674:	movw	r2, #966	; 0x3c6
    8678:	str	r2, [r3, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD12);
  }
  if (blocking) {
    if (yieldTimeout(isBusyDat)) {
      return sdError(SD_CARD_ERROR_CMD13);
    867a:	mov	r4, r5
    }
  }
  return true;
}
    867c:	mov	r0, r4
    867e:	pop	{r4, r5, r6, pc}
    8680:	.word	0x400b1028
    8684:	.word	0x0cdb0000
    8688:	.word	0x1fff1358
    868c:	.word	0x1fff846c
    8690:	.word	0x000077d1

00008694 <SdioCard::syncDevice()>:
//------------------------------------------------------------------------------
bool SdioCard::syncDevice() {
    8694:	push	{r4, lr}
    8696:	mov	r4, r0
#if ENABLE_TEENSY_SDIO_MOD
  if (!waitTransferComplete()) {
    8698:	bl	7ca8 <waitTransferComplete()>
    869c:	cbz	r0, 86ae <SdioCard::syncDevice()+0x1a>
    return false;
  }
  if (m_curState != IDLE_STATE) {
    869e:	ldrb	r3, [r4, #9]
    86a0:	cbz	r3, 86ae <SdioCard::syncDevice()+0x1a>
    return stopTransmission(true);
    86a2:	mov	r0, r4
    86a4:	movs	r1, #1
      return false;
    }
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  return true;
}
    86a6:	ldmia.w	sp!, {r4, lr}
#if ENABLE_TEENSY_SDIO_MOD
  if (!waitTransferComplete()) {
    return false;
  }
  if (m_curState != IDLE_STATE) {
    return stopTransmission(true);
    86aa:	b.w	8634 <SdioCard::stopTransmission(bool)>
      return false;
    }
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  return true;
}
    86ae:	pop	{r4, pc}

000086b0 <SdioCard::isBusy()>:
//------------------------------------------------------------------------------
uint32_t SdioCard::errorLine() const {
  return m_errorLine;
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
    86b0:	push	{r4, lr}
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    86b2:	ldrb	r3, [r0, #8]
    86b4:	lsls	r3, r3, #31
//------------------------------------------------------------------------------
uint32_t SdioCard::errorLine() const {
  return m_errorLine;
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
    86b6:	mov	r2, r0
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    86b8:	bpl.n	86d8 <SdioCard::isBusy()+0x28>
    return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
    86ba:	ldr	r3, [pc, #80]	; (870c <SdioCard::isBusy()+0x5c>)
    86bc:	ldr	r3, [r3, #0]
    86be:	cbz	r3, 86c6 <SdioCard::isBusy()+0x16>
    return SDHC_PRSSTAT & (1 << 24) ? false : true;
  }
#else  // ENABLE_TEENSY_SDIO_MOD
  return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    86c0:	ldmia.w	sp!, {r4, lr}
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
    86c4:	bx	r3
    86c6:	ldr	r3, [pc, #72]	; (8710 <SdioCard::isBusy()+0x60>)
    86c8:	ldrb	r3, [r3, #0]
    86ca:	cbnz	r3, 86d0 <SdioCard::isBusy()+0x20>
    86cc:	movs	r0, #0
    86ce:	pop	{r4, pc}
    return SDHC_PRSSTAT & (1 << 24) ? false : true;
  }
#else  // ENABLE_TEENSY_SDIO_MOD
  return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    86d0:	ldmia.w	sp!, {r4, lr}
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
    86d4:	b.w	7a34 <isBusyCMD13()>
  } else {
    if (m_transferActive) {
    86d8:	ldr	r1, [pc, #56]	; (8714 <SdioCard::isBusy()+0x64>)
    86da:	ldrb	r4, [r1, #0]
    86dc:	cbz	r4, 86fe <SdioCard::isBusy()+0x4e>
      if (isBusyTransferComplete()) {
    86de:	bl	7818 <isBusyTransferComplete()>
    86e2:	cbnz	r0, 870a <SdioCard::isBusy()+0x5a>
        return true;
      }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
      if ((SDHC_BLKATTR & 0XFFFF0000) != 0) {
    86e4:	ldr	r3, [pc, #48]	; (8718 <SdioCard::isBusy()+0x68>)
    86e6:	ldr	r3, [r3, #0]
    86e8:	lsrs	r3, r3, #16
    86ea:	lsls	r3, r3, #16
    86ec:	cmp	r3, #0
    86ee:	bne.n	86cc <SdioCard::isBusy()+0x1c>
        return false;
      }
      m_transferActive = false;
    86f0:	strb	r0, [r1, #0]
      stopTransmission(false);
    86f2:	mov	r1, r0
    86f4:	mov	r0, r2
    86f6:	bl	8634 <SdioCard::stopTransmission(bool)>
    86fa:	mov	r0, r4
    86fc:	pop	{r4, pc}
#else  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
      return false;
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
    }
    // Use DAT0 low as busy.
    return SDHC_PRSSTAT & (1 << 24) ? false : true;
    86fe:	ldr	r3, [pc, #28]	; (871c <SdioCard::isBusy()+0x6c>)
    8700:	ldr	r0, [r3, #0]
    8702:	eor.w	r0, r0, #16777216	; 0x1000000
    8706:	ubfx	r0, r0, #24, #1
  }
#else  // ENABLE_TEENSY_SDIO_MOD
  return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    870a:	pop	{r4, pc}
    870c:	.word	0x1fff843c
    8710:	.word	0x1fff8454
    8714:	.word	0x1fff844c
    8718:	.word	0x400b1004
    871c:	.word	0x400b1024

00008720 <memcpy>:
#ifdef __ARM_FEATURE_UNALIGNED
	/* In case of UNALIGNED access supported, ip is not used in
	   function body.  */
	mov	ip, r0
#else
	push	{r0}
    8720:	push	{r0}
#endif
	orr	r3, r1, r0
    8722:	orr.w	r3, r1, r0
	ands	r3, r3, #3
    8726:	ands.w	r3, r3, #3
	bne	.Lmisaligned_copy
    872a:	bne.n	880c <memcpy+0xec>

.Lbig_block:
	subs	r2, __OPT_BIG_BLOCK_SIZE
    872c:	subs	r2, #64	; 0x40
	blo	.Lmid_block
    872e:	bcc.n	87b4 <memcpy+0x94>
.Lbig_block_loop:
	BEGIN_UNROLL_BIG_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    8730:	ldr.w	r3, [r1], #4
    8734:	str.w	r3, [r0], #4
    8738:	ldr.w	r3, [r1], #4
    873c:	str.w	r3, [r0], #4
    8740:	ldr.w	r3, [r1], #4
    8744:	str.w	r3, [r0], #4
    8748:	ldr.w	r3, [r1], #4
    874c:	str.w	r3, [r0], #4
    8750:	ldr.w	r3, [r1], #4
    8754:	str.w	r3, [r0], #4
    8758:	ldr.w	r3, [r1], #4
    875c:	str.w	r3, [r0], #4
    8760:	ldr.w	r3, [r1], #4
    8764:	str.w	r3, [r0], #4
    8768:	ldr.w	r3, [r1], #4
    876c:	str.w	r3, [r0], #4
    8770:	ldr.w	r3, [r1], #4
    8774:	str.w	r3, [r0], #4
    8778:	ldr.w	r3, [r1], #4
    877c:	str.w	r3, [r0], #4
    8780:	ldr.w	r3, [r1], #4
    8784:	str.w	r3, [r0], #4
    8788:	ldr.w	r3, [r1], #4
    878c:	str.w	r3, [r0], #4
    8790:	ldr.w	r3, [r1], #4
    8794:	str.w	r3, [r0], #4
    8798:	ldr.w	r3, [r1], #4
    879c:	str.w	r3, [r0], #4
    87a0:	ldr.w	r3, [r1], #4
    87a4:	str.w	r3, [r0], #4
    87a8:	ldr.w	r3, [r1], #4
    87ac:	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds	r0, __OPT_BIG_BLOCK_SIZE
	adds	r1, __OPT_BIG_BLOCK_SIZE
#endif
	subs	r2, __OPT_BIG_BLOCK_SIZE
    87b0:	subs	r2, #64	; 0x40
	bhs .Lbig_block_loop
    87b2:	bcs.n	8730 <memcpy+0x10>

.Lmid_block:
	adds	r2, __OPT_BIG_BLOCK_SIZE - __OPT_MID_BLOCK_SIZE
    87b4:	adds	r2, #48	; 0x30
	blo	.Lcopy_word_by_word
    87b6:	bcc.n	87dc <memcpy+0xbc>
.Lmid_block_loop:
	BEGIN_UNROLL_MID_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    87b8:	ldr.w	r3, [r1], #4
    87bc:	str.w	r3, [r0], #4
    87c0:	ldr.w	r3, [r1], #4
    87c4:	str.w	r3, [r0], #4
    87c8:	ldr.w	r3, [r1], #4
    87cc:	str.w	r3, [r0], #4
    87d0:	ldr.w	r3, [r1], #4
    87d4:	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds    r0, __OPT_MID_BLOCK_SIZE
	adds    r1, __OPT_MID_BLOCK_SIZE
#endif
	subs	r2, __OPT_MID_BLOCK_SIZE
    87d8:	subs	r2, #16
	bhs	.Lmid_block_loop
    87da:	bcs.n	87b8 <memcpy+0x98>

.Lcopy_word_by_word:
	adds	r2, __OPT_MID_BLOCK_SIZE - 4
    87dc:	adds	r2, #12
	blo	.Lcopy_less_than_4
    87de:	bcc.n	87ec <memcpy+0xcc>

	/* Kernel loop for small block copy */
	.align 2
.Lcopy_word_by_word_loop:
	ldr	r3, [r1], #4
    87e0:	ldr.w	r3, [r1], #4
	str	r3, [r0], #4
    87e4:	str.w	r3, [r0], #4
	subs	r2, #4
    87e8:	subs	r2, #4
	bhs	.Lcopy_word_by_word_loop
    87ea:	bcs.n	87e0 <memcpy+0xc0>

.Lcopy_less_than_4:
	adds	r2, #4
    87ec:	adds	r2, #4
	beq	.Ldone
    87ee:	beq.n	8806 <memcpy+0xe6>

	lsls	r2, r2, #31
    87f0:	lsls	r2, r2, #31
	itt ne
    87f2:	itt	ne
	ldrbne  r3, [r1], #1
    87f4:	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    87f8:	strbne.w	r3, [r0], #1

	bcc	.Ldone
    87fc:	bcc.n	8806 <memcpy+0xe6>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh	r3, [r1]
	strh	r3, [r0]
#else
	ldrb	r3, [r1]
    87fe:	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    8800:	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    8802:	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    8804:	strb	r3, [r0, #1]

.Ldone:
#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
#else
	pop	{r0}
    8806:	pop	{r0}
#endif
	bx	lr
    8808:	bx	lr
    880a:	nop
	beq	.Ldst_aligned
#else
	/* if len < 12, misalignment adjustment has more overhead than
	just byte-to-byte copy.  Also, len must >=8 to guarantee code
	afterward work correctly.  */
	cmp	r2, #12
    880c:	cmp	r2, #12
	blo	.Lbyte_copy
    880e:	bcc.n	88a6 <memcpy+0x186>
	handling of aligned src and misaligned dst need more overhead than
	otherwise.  By doing this the worst case is when initial src is aligned,
	additional up to 4 byte additional copy will executed, which is
	acceptable.  */

	ands	r3, r0, #3
    8810:	ands.w	r3, r0, #3
	beq	.Ldst_aligned
    8814:	beq.n	883a <memcpy+0x11a>

	rsb	r3, #4
    8816:	rsb	r3, r3, #4
	subs	r2, r3
    881a:	subs	r2, r2, r3

	lsls    r3, r3, #31
    881c:	lsls	r3, r3, #31
	itt ne
    881e:	itt	ne
	ldrbne  r3, [r1], #1
    8820:	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    8824:	strbne.w	r3, [r0], #1

	bcc .Ldst_aligned
    8828:	bcc.n	883a <memcpy+0x11a>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh    r3, [r1], #2
	strh    r3, [r0], #2
	b	.Ldst_aligned
#else
	ldrb    r3, [r1], #1
    882a:	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    882e:	strb.w	r3, [r0], #1
	ldrb    r3, [r1], #1
    8832:	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    8836:	strb.w	r3, [r0], #1
	/* Now that dst is aligned */
.Ldst_aligned:
	/* if r1 is aligned now, it means r0/r1 has the same misalignment,
	and they are both aligned now.  Go aligned copy.  */
	ands	r3, r1, #3
    883a:	ands.w	r3, r1, #3
	beq	.Lbig_block
    883e:	beq.w	872c <memcpy+0xc>

	/* dst is aligned, but src isn't.  Misaligned copy.  */

	push	{r4, r5}
    8842:	push	{r4, r5}
	subs	r2, #4
    8844:	subs	r2, #4

	/* Backward r1 by misaligned bytes, to make r1 aligned.
	Since we need to restore r1 to unaligned address after the loop,
	we need keep the offset bytes to ip and sub it from r1 afterward.  */
	subs	r1, r3
    8846:	subs	r1, r1, r3
	rsb	ip, r3, #4
    8848:	rsb	ip, r3, #4

	/* Pre-load on word */
	ldr	r4, [r1], #4
    884c:	ldr.w	r4, [r1], #4

	cmp	r3, #2
    8850:	cmp	r3, #2
	beq	.Lmisaligned_copy_2_2
    8852:	beq.n	8888 <memcpy+0x168>
	cmp	r3, #3
    8854:	cmp	r3, #3
	beq	.Lmisaligned_copy_3_1
    8856:	beq.n	8870 <memcpy+0x150>
	subs	r2, #4
	bhs	1b
	.endm

.Lmisaligned_copy_1_3:
	mis_src_copy shift=8
    8858:	lsrs	r4, r4, #8
    885a:	ldr.w	r3, [r1], #4
    885e:	lsls	r5, r3, #24
    8860:	orr.w	r4, r4, r5
    8864:	str.w	r4, [r0], #4
    8868:	mov	r4, r3
    886a:	subs	r2, #4
    886c:	bcs.n	8858 <memcpy+0x138>
	b	.Lsrc_misaligned_tail
    886e:	b.n	889e <memcpy+0x17e>

.Lmisaligned_copy_3_1:
	mis_src_copy shift=24
    8870:	lsrs	r4, r4, #24
    8872:	ldr.w	r3, [r1], #4
    8876:	lsls	r5, r3, #8
    8878:	orr.w	r4, r4, r5
    887c:	str.w	r4, [r0], #4
    8880:	mov	r4, r3
    8882:	subs	r2, #4
    8884:	bcs.n	8870 <memcpy+0x150>
	b	.Lsrc_misaligned_tail
    8886:	b.n	889e <memcpy+0x17e>

.Lmisaligned_copy_2_2:
	/* For 2_2 misalignment, ldr is still faster than 2 x ldrh.  */
	mis_src_copy shift=16
    8888:	lsrs	r4, r4, #16
    888a:	ldr.w	r3, [r1], #4
    888e:	lsls	r5, r3, #16
    8890:	orr.w	r4, r4, r5
    8894:	str.w	r4, [r0], #4
    8898:	mov	r4, r3
    889a:	subs	r2, #4
    889c:	bcs.n	8888 <memcpy+0x168>

.Lsrc_misaligned_tail:
	adds	r2, #4
    889e:	adds	r2, #4
	subs	r1, ip
    88a0:	subs.w	r1, r1, ip
	pop	{r4, r5}
    88a4:	pop	{r4, r5}

#endif /* __ARM_FEATURE_UNALIGNED */

.Lbyte_copy:
	subs	r2, #4
    88a6:	subs	r2, #4
	blo	.Lcopy_less_than_4
    88a8:	bcc.n	87ec <memcpy+0xcc>

.Lbyte_copy_loop:
	subs    r2, #1
    88aa:	subs	r2, #1
	ldrb    r3, [r1], #1
    88ac:	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    88b0:	strb.w	r3, [r0], #1
	bhs	.Lbyte_copy_loop
    88b4:	bcs.n	88aa <memcpy+0x18a>

	ldrb	r3, [r1]
    88b6:	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    88b8:	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    88ba:	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    88bc:	strb	r3, [r0, #1]
	ldrb	r3, [r1, #2]
    88be:	ldrb	r3, [r1, #2]
	strb	r3, [r0, #2]
    88c0:	strb	r3, [r0, #2]

#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
#else
	pop	{r0}
    88c2:	pop	{r0}
#endif
	bx	lr
    88c4:	bx	lr
    88c6:	nop

000088c8 <memset>:
	.type	memset, %function
	.thumb_func
	memset:
//FUNCTION(memset)
    // save the original pointer
    push    { r0, lr }
    88c8:	push	{r0, lr}

    // check for zero length
    cbz     r2, .L_done
    88ca:	cbz	r2, 8908 <memset+0x40>

    // short memsets aren't worth optimizing and make sure we have
    // enough headroom to try to do dwordwise move optimization
    cmp     r2, #16
    88cc:	cmp	r2, #16
    blt     .L_bytewise
    88ce:	blt.n	8900 <memset+0x38>

    // see how many bytes we need to move to align to dword boundaries
    and     r3, r0, #7
    88d0:	and.w	r3, r0, #7
    cbz     r3, .L_prepare_dwordwise
    88d4:	cbz	r3, 88e4 <memset+0x1c>
    rsb     r3, #8
    88d6:	rsb	r3, r3, #8
    subs    r2, r3
    88da:	subs	r2, r2, r3

.L_bytewise_align:
    // bytewise to align memset
    subs    r3, r3, #1
    88dc:	subs	r3, #1
    strb    r1, [r0], #1
    88de:	strb.w	r1, [r0], #1
    bgt     .L_bytewise_align
    88e2:	bgt.n	88dc <memset+0x14>

.L_prepare_dwordwise:
    // fill a pair of 32 bit registers with the 8 bit value
    uxtb    r1, r1
    88e4:	uxtb	r1, r1
    orr     r1, r1, r1, lsl #8
    88e6:	orr.w	r1, r1, r1, lsl #8
    orr     r1, r1, r1, lsl #16
    88ea:	orr.w	r1, r1, r1, lsl #16
    mov     r12, r1
    88ee:	mov	ip, r1

    // load the number of dwords left
    lsrs    r3, r2, #3
    88f0:	lsrs	r3, r2, #3

.L_dwordwise:
    // dwordwise memset
		
    subs    r3, r3, #1
    88f2:	subs	r3, #1
    strd    r1, r12, [r0], #8
    88f4:	strd	r1, ip, [r0], #8
    bgt     .L_dwordwise
    88f8:	bgt.n	88f2 <memset+0x2a>

    // remaining bytes
    ands     r2, #7
    88fa:	ands.w	r2, r2, #7
    beq     .L_done
    88fe:	beq.n	8908 <memset+0x40>

.L_bytewise:
    // bytewise memset
    subs    r2, r2, #1
    8900:	subs	r2, #1
    strb    r1, [r0], #1
    8902:	strb.w	r1, [r0], #1
    bgt     .L_bytewise
    8906:	bgt.n	8900 <memset+0x38>

.L_done:
    // restore the base pointer as return value
    pop     { r0, pc }
    8908:	pop	{r0, pc}
    890a:	nop

0000890c <usb_serial_getchar>:

#define TRANSMIT_FLUSH_TIMEOUT	5   /* in milliseconds */

// get the next character, or -1 if nothing received
int usb_serial_getchar(void)
{
    890c:	push	{r4, lr}
	unsigned int i;
	int c;

	if (!rx_packet) {
    890e:	ldr	r4, [pc, #64]	; (8950 <usb_serial_getchar+0x44>)
    8910:	ldr	r3, [r4, #0]
    8912:	cbz	r3, 8930 <usb_serial_getchar+0x24>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
    8914:	ldr	r0, [r4, #0]
    8916:	ldrh	r3, [r0, #2]
	c = rx_packet->buf[i++];
    8918:	adds	r2, r3, #1
    891a:	add	r3, r0
    891c:	ldrb	r4, [r3, #8]
	if (i >= rx_packet->len) {
    891e:	ldrh	r3, [r0, #0]
    8920:	cmp	r2, r3
    8922:	bcc.n	894a <usb_serial_getchar+0x3e>
		usb_free(rx_packet);
    8924:	bl	8f48 <usb_free>
		rx_packet = NULL;
    8928:	ldr	r3, [pc, #36]	; (8950 <usb_serial_getchar+0x44>)
    892a:	movs	r2, #0
    892c:	str	r2, [r3, #0]
    892e:	b.n	894c <usb_serial_getchar+0x40>
{
	unsigned int i;
	int c;

	if (!rx_packet) {
		if (!usb_configuration) return -1;
    8930:	ldr	r3, [pc, #32]	; (8954 <usb_serial_getchar+0x48>)
    8932:	ldrb	r3, [r3, #0]
    8934:	cbnz	r3, 893c <usb_serial_getchar+0x30>
    8936:	mov.w	r0, #4294967295
    893a:	pop	{r4, pc}
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    893c:	movs	r0, #3
    893e:	bl	8fcc <usb_rx>
    8942:	str	r0, [r4, #0]
		if (!rx_packet) return -1;
    8944:	cmp	r0, #0
    8946:	bne.n	8914 <usb_serial_getchar+0x8>
    8948:	b.n	8936 <usb_serial_getchar+0x2a>
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
		usb_free(rx_packet);
		rx_packet = NULL;
	} else {
		rx_packet->index = i;
    894a:	strh	r2, [r0, #2]
	}
	return c;
    894c:	mov	r0, r4
}
    894e:	pop	{r4, pc}
    8950:	.word	0x1fff847c
    8954:	.word	0x1fff8567

00008958 <usb_serial_peekchar>:

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
    8958:	push	{r4, lr}
	if (!rx_packet) {
    895a:	ldr	r4, [pc, #44]	; (8988 <usb_serial_peekchar+0x30>)
    895c:	ldr	r3, [r4, #0]
    895e:	cbz	r3, 8966 <usb_serial_peekchar+0xe>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	if (!rx_packet) return -1;
    8960:	ldr	r2, [r4, #0]
    8962:	cbnz	r2, 8980 <usb_serial_peekchar+0x28>
    8964:	b.n	896c <usb_serial_peekchar+0x14>

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	if (!rx_packet) {
		if (!usb_configuration) return -1;
    8966:	ldr	r3, [pc, #36]	; (898c <usb_serial_peekchar+0x34>)
    8968:	ldrb	r3, [r3, #0]
    896a:	cbnz	r3, 8972 <usb_serial_peekchar+0x1a>
    896c:	mov.w	r0, #4294967295
    8970:	pop	{r4, pc}
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    8972:	movs	r0, #3
    8974:	bl	8fcc <usb_rx>
    8978:	str	r0, [r4, #0]
		if (!rx_packet) return -1;
    897a:	cmp	r0, #0
    897c:	bne.n	8960 <usb_serial_peekchar+0x8>
    897e:	b.n	896c <usb_serial_peekchar+0x14>
	}
	if (!rx_packet) return -1;
	return rx_packet->buf[rx_packet->index];
    8980:	ldrh	r3, [r2, #2]
    8982:	add	r3, r2
    8984:	ldrb	r0, [r3, #8]
}
    8986:	pop	{r4, pc}
    8988:	.word	0x1fff847c
    898c:	.word	0x1fff8567

00008990 <usb_serial_available>:
static inline uint32_t usb_rx_byte_count(uint32_t endpoint) __attribute__((always_inline));
static inline uint32_t usb_rx_byte_count(uint32_t endpoint)
{
        endpoint--;
        if (endpoint >= NUM_ENDPOINTS) return 0;
        return usb_rx_byte_count_data[endpoint];
    8990:	ldr	r3, [pc, #16]	; (89a4 <usb_serial_available+0x14>)

// number of bytes available in the receive buffer
int usb_serial_available(void)
{
	int count;
	count = usb_rx_byte_count(CDC_RX_ENDPOINT);
    8992:	ldrh	r0, [r3, #4]
	if (rx_packet) count += rx_packet->len - rx_packet->index;
    8994:	ldr	r3, [pc, #16]	; (89a8 <usb_serial_available+0x18>)
    8996:	ldr	r2, [r3, #0]
    8998:	cbz	r2, 89a2 <usb_serial_available+0x12>
    899a:	ldrh	r3, [r2, #0]
    899c:	ldrh	r2, [r2, #2]
    899e:	subs	r3, r3, r2
    89a0:	add	r0, r3
	return count;
}
    89a2:	bx	lr
    89a4:	.word	0x1fff85e4
    89a8:	.word	0x1fff847c

000089ac <usb_serial_flush_input>:
	return count;
}

// discard any buffered input
void usb_serial_flush_input(void)
{
    89ac:	push	{r4, lr}
	usb_packet_t *rx;

	if (!usb_configuration) return;
    89ae:	ldr	r3, [pc, #36]	; (89d4 <usb_serial_flush_input+0x28>)
    89b0:	ldrb	r3, [r3, #0]
    89b2:	cbz	r3, 89d0 <usb_serial_flush_input+0x24>
	if (rx_packet) {
    89b4:	ldr	r4, [pc, #32]	; (89d8 <usb_serial_flush_input+0x2c>)
    89b6:	ldr	r0, [r4, #0]
    89b8:	cbz	r0, 89c2 <usb_serial_flush_input+0x16>
		usb_free(rx_packet);
    89ba:	bl	8f48 <usb_free>
		rx_packet = NULL;
    89be:	movs	r3, #0
    89c0:	str	r3, [r4, #0]
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    89c2:	movs	r0, #3
    89c4:	bl	8fcc <usb_rx>
		if (!rx) break;
    89c8:	cbz	r0, 89d0 <usb_serial_flush_input+0x24>
		usb_free(rx);
    89ca:	bl	8f48 <usb_free>
	}
    89ce:	b.n	89c2 <usb_serial_flush_input+0x16>
    89d0:	pop	{r4, pc}
    89d2:	nop
    89d4:	.word	0x1fff8567
    89d8:	.word	0x1fff847c

000089dc <usb_serial_write>:
	return usb_serial_write(&c, 1);
}


int usb_serial_write(const void *buffer, uint32_t size)
{
    89dc:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    89e0:	ldr	r5, [pc, #196]	; (8aa8 <usb_serial_write+0xcc>)
	while (size > 0) {
		if (!tx_packet) {
    89e2:	ldr.w	r9, [pc, #212]	; 8ab8 <usb_serial_write+0xdc>
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    89e6:	movs	r3, #1
	return usb_serial_write(&c, 1);
}


int usb_serial_write(const void *buffer, uint32_t size)
{
    89e8:	mov	sl, r0
    89ea:	mov	r4, r1
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    89ec:	strb	r3, [r5, #0]
	while (size > 0) {
    89ee:	mov	r6, r1
    89f0:	mov	r7, r9
    89f2:	cmp	r6, #0
    89f4:	beq.n	8a9e <usb_serial_write+0xc2>
		if (!tx_packet) {
    89f6:	ldr.w	r3, [r9]
    89fa:	cbnz	r3, 8a4c <usb_serial_write+0x70>
    89fc:	ldr.w	fp, [pc, #176]	; 8ab0 <usb_serial_write+0xd4>
    8a00:	movw	r8, #41721	; 0xa2f9
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    8a04:	ldr	r3, [pc, #164]	; (8aac <usb_serial_write+0xd0>)
    8a06:	ldrb	r3, [r3, #0]
    8a08:	and.w	r1, r3, #255	; 0xff
    8a0c:	cbnz	r3, 8a12 <usb_serial_write+0x36>
					tx_noautoflush = 0;
    8a0e:	strb	r1, [r5, #0]
    8a10:	b.n	8a3e <usb_serial_write+0x62>
					return -1;
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
    8a12:	movs	r0, #4
    8a14:	bl	9004 <usb_tx_packet_count>
    8a18:	cmp	r0, #7
    8a1a:	bhi.n	8a2c <usb_serial_write+0x50>
					tx_noautoflush = 1;
    8a1c:	movs	r3, #1
    8a1e:	strb	r3, [r5, #0]
					tx_packet = usb_malloc();
    8a20:	bl	8f0c <usb_malloc>
    8a24:	str	r0, [r7, #0]
					if (tx_packet) break;
    8a26:	cbnz	r0, 8a4c <usb_serial_write+0x70>
					tx_noautoflush = 0;
    8a28:	ldr	r3, [pc, #124]	; (8aa8 <usb_serial_write+0xcc>)
    8a2a:	strb	r0, [r3, #0]
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    8a2c:	subs.w	r8, r8, #1
    8a30:	beq.n	8a38 <usb_serial_write+0x5c>
    8a32:	ldrb.w	r3, [fp]
    8a36:	cbz	r3, 8a46 <usb_serial_write+0x6a>
					transmit_previous_timeout = 1;
    8a38:	ldr	r3, [pc, #116]	; (8ab0 <usb_serial_write+0xd4>)
    8a3a:	movs	r2, #1
    8a3c:	strb	r2, [r3, #0]
					return -1;
    8a3e:	mov.w	r0, #4294967295
    8a42:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				}
				yield();
    8a46:	bl	97d8 <yield>
			}
    8a4a:	b.n	8a04 <usb_serial_write+0x28>
		}
		transmit_previous_timeout = 0;
    8a4c:	ldr	r3, [pc, #96]	; (8ab0 <usb_serial_write+0xd4>)
    8a4e:	movs	r1, #0
    8a50:	strb	r1, [r3, #0]
		len = CDC_TX_SIZE - tx_packet->index;
    8a52:	ldr	r1, [r7, #0]
    8a54:	ldrh	r3, [r1, #2]
    8a56:	rsb	r0, r3, #64	; 0x40
    8a5a:	cmp	r0, r6
    8a5c:	it	cs
    8a5e:	movcs	r0, r6
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    8a60:	add.w	lr, r3, r0
    8a64:	add	r3, r1
    8a66:	strh.w	lr, [r1, #2]
		size -= len;
    8a6a:	subs	r6, r6, r0
    8a6c:	adds	r3, #7
    8a6e:	add.w	r8, sl, r0
		while (len-- > 0) *dest++ = *src++;
    8a72:	cmp	sl, r8
    8a74:	beq.n	8a80 <usb_serial_write+0xa4>
    8a76:	ldrb.w	r0, [sl], #1
    8a7a:	strb.w	r0, [r3, #1]!
    8a7e:	b.n	8a72 <usb_serial_write+0x96>
		if (tx_packet->index >= CDC_TX_SIZE) {
    8a80:	ldrh	r3, [r1, #2]
    8a82:	cmp	r3, #63	; 0x3f
    8a84:	bls.n	8a94 <usb_serial_write+0xb8>
			tx_packet->len = CDC_TX_SIZE;
    8a86:	movs	r3, #64	; 0x40
    8a88:	strh	r3, [r1, #0]
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
    8a8a:	movs	r0, #4
    8a8c:	bl	90a0 <usb_tx>
			tx_packet = NULL;
    8a90:	movs	r3, #0
    8a92:	str	r3, [r7, #0]
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
    8a94:	ldr	r3, [pc, #28]	; (8ab4 <usb_serial_write+0xd8>)
    8a96:	movs	r2, #5
    8a98:	strb	r2, [r3, #0]
    8a9a:	mov	sl, r8
    8a9c:	b.n	89f2 <usb_serial_write+0x16>
	}
	tx_noautoflush = 0;
    8a9e:	strb	r6, [r5, #0]
	return ret;
    8aa0:	mov	r0, r4
}
    8aa2:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8aa6:	nop
    8aa8:	.word	0x1fff8471
    8aac:	.word	0x1fff8567
    8ab0:	.word	0x1fff8478
    8ab4:	.word	0x1fff8470
    8ab8:	.word	0x1fff8474

00008abc <usb_serial_putchar>:
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    8abc:	push	{r0, r1, r2, lr}
    8abe:	add	r3, sp, #8
	return usb_serial_write(&c, 1);
    8ac0:	movs	r1, #1
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    8ac2:	strb.w	r0, [r3, #-1]!
	return usb_serial_write(&c, 1);
    8ac6:	mov	r0, r3
    8ac8:	bl	89dc <usb_serial_write>
}
    8acc:	add	sp, #12
    8ace:	ldr.w	pc, [sp], #4
    8ad2:	Address 0x00008ad2 is out of bounds.


00008ad4 <usb_serial_write_buffer_free>:
	tx_noautoflush = 0;
	return ret;
}

int usb_serial_write_buffer_free(void)
{
    8ad4:	push	{r3, r4, r5, lr}
	uint32_t len;

	tx_noautoflush = 1;
    8ad6:	ldr	r4, [pc, #56]	; (8b10 <usb_serial_write_buffer_free+0x3c>)
	if (!tx_packet) {
    8ad8:	ldr	r5, [pc, #56]	; (8b14 <usb_serial_write_buffer_free+0x40>)

int usb_serial_write_buffer_free(void)
{
	uint32_t len;

	tx_noautoflush = 1;
    8ada:	movs	r3, #1
    8adc:	strb	r3, [r4, #0]
	if (!tx_packet) {
    8ade:	ldr	r3, [r5, #0]
    8ae0:	cbnz	r3, 8b02 <usb_serial_write_buffer_free+0x2e>
		if (!usb_configuration ||
    8ae2:	ldr	r3, [pc, #52]	; (8b18 <usb_serial_write_buffer_free+0x44>)
    8ae4:	ldrb	r3, [r3, #0]
    8ae6:	cbnz	r3, 8aee <usb_serial_write_buffer_free+0x1a>
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
    8ae8:	movs	r0, #0
    8aea:	strb	r0, [r4, #0]
			return 0;
    8aec:	pop	{r3, r4, r5, pc}
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    8aee:	movs	r0, #4
    8af0:	bl	9004 <usb_tx_packet_count>
{
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
    8af4:	cmp	r0, #7
    8af6:	bhi.n	8ae8 <usb_serial_write_buffer_free+0x14>
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
		  (tx_packet = usb_malloc()) == NULL) {
    8af8:	bl	8f0c <usb_malloc>
    8afc:	str	r0, [r5, #0]
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    8afe:	cmp	r0, #0
    8b00:	beq.n	8ae8 <usb_serial_write_buffer_free+0x14>
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
			return 0;
		}
	}
	len = CDC_TX_SIZE - tx_packet->index;
    8b02:	ldr	r3, [r5, #0]
    8b04:	ldrh	r0, [r3, #2]
	// space we just promised the user could write without blocking?
	// But does this come with other performance downsides?  Could it lead to
	// buffer data never actually transmitting in some usage cases?  More
	// investigation is needed.
	// https://github.com/PaulStoffregen/cores/issues/10#issuecomment-61514955
	tx_noautoflush = 0;
    8b06:	movs	r3, #0
    8b08:	strb	r3, [r4, #0]
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
			return 0;
		}
	}
	len = CDC_TX_SIZE - tx_packet->index;
    8b0a:	rsb	r0, r0, #64	; 0x40
	// buffer data never actually transmitting in some usage cases?  More
	// investigation is needed.
	// https://github.com/PaulStoffregen/cores/issues/10#issuecomment-61514955
	tx_noautoflush = 0;
	return len;
}
    8b0e:	pop	{r3, r4, r5, pc}
    8b10:	.word	0x1fff8471
    8b14:	.word	0x1fff8474
    8b18:	.word	0x1fff8567

00008b1c <usb_serial_flush_output>:

void usb_serial_flush_output(void)
{
    8b1c:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (!usb_configuration) return;
    8b20:	ldr	r3, [pc, #68]	; (8b68 <usb_serial_flush_output+0x4c>)
    8b22:	ldrb	r3, [r3, #0]
    8b24:	cbz	r3, 8b64 <usb_serial_flush_output+0x48>
	tx_noautoflush = 1;
	if (tx_packet) {
    8b26:	ldr	r7, [pc, #68]	; (8b6c <usb_serial_flush_output+0x50>)
}

void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
    8b28:	ldr	r3, [pc, #68]	; (8b70 <usb_serial_flush_output+0x54>)
	if (tx_packet) {
    8b2a:	ldr	r4, [r7, #0]
    8b2c:	ldr	r5, [pc, #68]	; (8b74 <usb_serial_flush_output+0x58>)
}

void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
    8b2e:	movs	r6, #1
    8b30:	strb	r6, [r3, #0]
    8b32:	mov	r8, r3
	if (tx_packet) {
    8b34:	cbz	r4, 8b4a <usb_serial_flush_output+0x2e>
		usb_cdc_transmit_flush_timer = 0;
    8b36:	movs	r6, #0
		tx_packet->len = tx_packet->index;
    8b38:	ldrh	r3, [r4, #2]
void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
	if (tx_packet) {
		usb_cdc_transmit_flush_timer = 0;
    8b3a:	strb	r6, [r5, #0]
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    8b3c:	mov	r1, r4
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
	if (tx_packet) {
		usb_cdc_transmit_flush_timer = 0;
		tx_packet->len = tx_packet->index;
    8b3e:	strh	r3, [r4, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    8b40:	movs	r0, #4
    8b42:	bl	90a0 <usb_tx>
		tx_packet = NULL;
    8b46:	str	r6, [r7, #0]
    8b48:	b.n	8b5e <usb_serial_flush_output+0x42>
	} else {
		usb_packet_t *tx = usb_malloc();
    8b4a:	bl	8f0c <usb_malloc>
		if (tx) {
    8b4e:	mov	r1, r0
    8b50:	cbz	r0, 8b5c <usb_serial_flush_output+0x40>
			usb_cdc_transmit_flush_timer = 0;
			usb_tx(CDC_TX_ENDPOINT, tx);
    8b52:	movs	r0, #4
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_cdc_transmit_flush_timer = 0;
    8b54:	strb	r4, [r5, #0]
			usb_tx(CDC_TX_ENDPOINT, tx);
    8b56:	bl	90a0 <usb_tx>
    8b5a:	b.n	8b5e <usb_serial_flush_output+0x42>
		} else {
			usb_cdc_transmit_flush_timer = 1;
    8b5c:	strb	r6, [r5, #0]
		}
	}
	tx_noautoflush = 0;
    8b5e:	movs	r3, #0
    8b60:	strb.w	r3, [r8]
    8b64:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    8b68:	.word	0x1fff8567
    8b6c:	.word	0x1fff8474
    8b70:	.word	0x1fff8471
    8b74:	.word	0x1fff8470

00008b78 <usb_serial_flush_callback>:
}

void usb_serial_flush_callback(void)
{
    8b78:	push	{r3, r4, r5, lr}
	if (tx_noautoflush) return;
    8b7a:	ldr	r3, [pc, #56]	; (8bb4 <usb_serial_flush_callback+0x3c>)
    8b7c:	ldrb	r3, [r3, #0]
    8b7e:	and.w	r5, r3, #255	; 0xff
    8b82:	cbnz	r3, 8bb0 <usb_serial_flush_callback+0x38>
	if (tx_packet) {
    8b84:	ldr	r4, [pc, #48]	; (8bb8 <usb_serial_flush_callback+0x40>)
    8b86:	ldr	r1, [r4, #0]
    8b88:	cbz	r1, 8b98 <usb_serial_flush_callback+0x20>
		tx_packet->len = tx_packet->index;
    8b8a:	ldrh	r3, [r1, #2]
    8b8c:	strh	r3, [r1, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    8b8e:	movs	r0, #4
    8b90:	bl	90a0 <usb_tx>
		tx_packet = NULL;
    8b94:	str	r5, [r4, #0]
    8b96:	pop	{r3, r4, r5, pc}
	} else {
		usb_packet_t *tx = usb_malloc();
    8b98:	bl	8f0c <usb_malloc>
		if (tx) {
    8b9c:	mov	r1, r0
    8b9e:	cbz	r0, 8baa <usb_serial_flush_callback+0x32>
			usb_tx(CDC_TX_ENDPOINT, tx);
    8ba0:	movs	r0, #4
		} else {
			usb_cdc_transmit_flush_timer = 1;
		}
	}
}
    8ba2:	ldmia.w	sp!, {r3, r4, r5, lr}
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_tx(CDC_TX_ENDPOINT, tx);
    8ba6:	b.w	90a0 <usb_tx>
		} else {
			usb_cdc_transmit_flush_timer = 1;
    8baa:	ldr	r3, [pc, #16]	; (8bbc <usb_serial_flush_callback+0x44>)
    8bac:	movs	r2, #1
    8bae:	strb	r2, [r3, #0]
    8bb0:	pop	{r3, r4, r5, pc}
    8bb2:	nop
    8bb4:	.word	0x1fff8471
    8bb8:	.word	0x1fff8474
    8bbc:	.word	0x1fff8470

00008bc0 <analog_init>:
#else
#error "F_BUS must be 128, 120, 108, 96, 90, 80, 72, 64, 60, 56, 54, 48, 40, 36, 24, 4 or 2 MHz"
#endif

void analog_init(void)
{
    8bc0:	push	{r4, lr}
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    8bc2:	ldr	r3, [pc, #128]	; (8c44 <analog_init+0x84>)
    8bc4:	ldr	r0, [pc, #128]	; (8c48 <analog_init+0x88>)
    8bc6:	ldr	r1, [pc, #132]	; (8c4c <analog_init+0x8c>)
    8bc8:	movs	r2, #96	; 0x60
    8bca:	strb	r2, [r3, #0]
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    8bcc:	movs	r2, #225	; 0xe1
    8bce:	strb	r2, [r3, #1]
	#endif

	if (analog_config_bits == 8) {
    8bd0:	ldr	r3, [pc, #124]	; (8c50 <analog_init+0x90>)
    8bd2:	ldr	r2, [pc, #128]	; (8c54 <analog_init+0x94>)
    8bd4:	ldrb	r4, [r3, #0]
    8bd6:	ldr	r3, [pc, #128]	; (8c58 <analog_init+0x98>)
    8bd8:	cmp	r4, #8
    8bda:	bne.n	8be0 <analog_init+0x20>
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    8bdc:	movs	r4, #1
    8bde:	b.n	8be6 <analog_init+0x26>
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
    8be0:	cmp	r4, #10
    8be2:	bne.n	8bec <analog_init+0x2c>
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    8be4:	movs	r4, #57	; 0x39
    8be6:	str	r4, [r0, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    8be8:	movs	r0, #19
    8bea:	b.n	8bf8 <analog_init+0x38>
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 12) {
    8bec:	cmp	r4, #12
		ADC0_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
    8bee:	ite	eq
    8bf0:	moveq	r4, #53	; 0x35
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
		#endif
	} else {
		ADC0_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    8bf2:	movne	r4, #61	; 0x3d
    8bf4:	str	r4, [r0, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    8bf6:	movs	r0, #18
    8bf8:	str	r0, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    8bfa:	str	r4, [r2, #0]
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    8bfc:	str	r0, [r3, #0]
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    8bfe:	ldr	r3, [pc, #92]	; (8c5c <analog_init+0x9c>)
    8c00:	ldr	r1, [pc, #92]	; (8c60 <analog_init+0xa0>)
    8c02:	ldrb	r3, [r3, #0]
    8c04:	ldr	r2, [pc, #92]	; (8c64 <analog_init+0xa4>)
    8c06:	cbz	r3, 8c0a <analog_init+0x4a>
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    8c08:	movs	r3, #1
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    8c0a:	str	r3, [r1, #0]
		ADC1_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    8c0c:	str	r3, [r2, #0]
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
    8c0e:	ldr	r3, [pc, #88]	; (8c68 <analog_init+0xa8>)
    8c10:	ldr	r2, [pc, #88]	; (8c6c <analog_init+0xac>)
    8c12:	ldrb	r1, [r3, #0]
    8c14:	ldr	r3, [pc, #88]	; (8c70 <analog_init+0xb0>)
	if (num <= 1) {
    8c16:	cmp	r1, #1
    8c18:	bhi.n	8c1e <analog_init+0x5e>
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
    8c1a:	movs	r1, #128	; 0x80
    8c1c:	b.n	8c36 <analog_init+0x76>
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
		#endif
	} else if (num <= 4) {
    8c1e:	cmp	r1, #4
    8c20:	bhi.n	8c26 <analog_init+0x66>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
    8c22:	movs	r1, #132	; 0x84
    8c24:	b.n	8c36 <analog_init+0x76>
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#endif
	} else if (num <= 8) {
    8c26:	cmp	r1, #8
    8c28:	bhi.n	8c2e <analog_init+0x6e>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
    8c2a:	movs	r1, #133	; 0x85
    8c2c:	b.n	8c36 <analog_init+0x76>
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
		#endif
	} else if (num <= 16) {
    8c2e:	cmp	r1, #16
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
    8c30:	ite	ls
    8c32:	movls	r1, #134	; 0x86
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
		#endif
	} else {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    8c34:	movhi	r1, #135	; 0x87
    8c36:	str	r1, [r2, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    8c38:	str	r1, [r3, #0]
		#endif
	}
	calibrating = 1;
    8c3a:	ldr	r3, [pc, #56]	; (8c74 <analog_init+0xb4>)
    8c3c:	movs	r2, #1
    8c3e:	strb	r2, [r3, #0]
    8c40:	pop	{r4, pc}
    8c42:	nop
    8c44:	.word	0x40074000
    8c48:	.word	0x4003b008
    8c4c:	.word	0x4003b00c
    8c50:	.word	0x1fff1359
    8c54:	.word	0x400bb008
    8c58:	.word	0x400bb00c
    8c5c:	.word	0x1fff8482
    8c60:	.word	0x4003b020
    8c64:	.word	0x400bb020
    8c68:	.word	0x1fff135a
    8c6c:	.word	0x4003b024
    8c70:	.word	0x400bb024
    8c74:	.word	0x1fff8481

00008c78 <fault_isr>:
void _init_Teensyduino_internal_(void) __attribute__((noinline));
void __libc_init_array(void);


void fault_isr(void)
{
    8c78:	push	{r3, lr}
        asm("ldr %0, [sp, #0]" : "=r" (addr) ::);
#endif
	while (1) {
		// keep polling some communication while in fault
		// mode, so we don't completely die.
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
    8c7a:	ldr	r5, [pc, #44]	; (8ca8 <fault_isr+0x30>)
    8c7c:	mov	r4, r5
    8c7e:	ldr	r3, [r5, #0]
    8c80:	lsls	r0, r3, #13
    8c82:	bpl.n	8c88 <fault_isr+0x10>
    8c84:	bl	9120 <usb_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART0) uart0_status_isr();
    8c88:	ldr	r3, [r4, #0]
    8c8a:	lsls	r1, r3, #21
    8c8c:	bpl.n	8c92 <fault_isr+0x1a>
    8c8e:	bl	8cac <unused_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART1) uart1_status_isr();
    8c92:	ldr	r3, [r4, #0]
    8c94:	lsls	r2, r3, #20
    8c96:	bpl.n	8c9c <fault_isr+0x24>
    8c98:	bl	8cac <unused_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART2) uart2_status_isr();
    8c9c:	ldr	r3, [r4, #0]
    8c9e:	lsls	r3, r3, #19
    8ca0:	bpl.n	8c7e <fault_isr+0x6>
    8ca2:	bl	8cac <unused_isr>
    8ca6:	b.n	8c7e <fault_isr+0x6>
    8ca8:	.word	0x40048034

00008cac <unused_isr>:
	}
}

void unused_isr(void)
{
    8cac:	push	{r3, lr}
	fault_isr();
    8cae:	bl	8c78 <fault_isr>
    8cb2:	Address 0x00008cb2 is out of bounds.


00008cb4 <startup_early_hook>:
extern void rtc_set(unsigned long t);


static void startup_default_early_hook(void) {
#if defined(KINETISK)
	WDOG_STCTRLH = WDOG_STCTRLH_ALLOWUPDATE;
    8cb4:	ldr	r3, [pc, #4]	; (8cbc <startup_early_hook+0x8>)
    8cb6:	movs	r2, #16
    8cb8:	strh	r2, [r3, #0]
    8cba:	bx	lr
    8cbc:	.word	0x40052000

00008cc0 <startup_late_hook>:
#elif defined(KINETISL)
	SIM_COPC = 0;  // disable the watchdog
#endif
}
static void startup_default_late_hook(void) {}
    8cc0:	bx	lr
    8cc2:	Address 0x00008cc2 is out of bounds.


00008cc4 <_sbrk>:

void * _sbrk(int incr)
{
	char *prev, *stack;

	prev = __brkval;
    8cc4:	ldr	r1, [pc, #36]	; (8cec <_sbrk+0x28>)

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"

void * _sbrk(int incr)
{
    8cc6:	push	{r3, lr}
	char *prev, *stack;

	prev = __brkval;
    8cc8:	ldr	r3, [r1, #0]
	if (incr != 0) {
    8cca:	cbz	r0, 8ce8 <_sbrk+0x24>
		__asm__ volatile("mov %0, sp" : "=r" (stack) ::);
    8ccc:	mov	r2, sp
		if (prev + incr >= stack - STACK_MARGIN) {
    8cce:	add	r0, r3
    8cd0:	sub.w	r2, r2, #8192	; 0x2000
    8cd4:	cmp	r0, r2
    8cd6:	bcc.n	8ce6 <_sbrk+0x22>
			errno = ENOMEM;
    8cd8:	bl	aa10 <__errno>
    8cdc:	movs	r3, #12
    8cde:	str	r3, [r0, #0]
			return (void *)-1;
    8ce0:	mov.w	r0, #4294967295
    8ce4:	pop	{r3, pc}
		}
		__brkval = prev + incr;
    8ce6:	str	r0, [r1, #0]
	}
	return prev;
    8ce8:	mov	r0, r3
}
    8cea:	pop	{r3, pc}
    8cec:	.word	0x1fff135c

00008cf0 <__cxa_pure_virtual>:
	while (1);
}

__attribute__((weak)) 
void __cxa_pure_virtual()
{
    8cf0:	b.n	8cf0 <__cxa_pure_virtual>
    8cf2:	Address 0x00008cf2 is out of bounds.


00008cf4 <attachInterruptVector>:
static void portcd_interrupt(void);
#endif

void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void))
{
	_VectorsRam[irq + 16] = function;
    8cf4:	adds	r0, #16
    8cf6:	ldr	r3, [pc, #8]	; (8d00 <attachInterruptVector+0xc>)
    8cf8:	str.w	r1, [r3, r0, lsl #2]
    8cfc:	bx	lr
    8cfe:	nop
    8d00:	.word	0x1fff0a00

00008d04 <rtc_get>:

#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)

unsigned long rtc_get(void)
{
	return RTC_TSR;
    8d04:	ldr	r3, [pc, #4]	; (8d0c <rtc_get+0x8>)
    8d06:	ldr	r0, [r3, #0]
}
    8d08:	bx	lr
    8d0a:	nop
    8d0c:	.word	0x4003d000

00008d10 <rtc_set>:

void rtc_set(unsigned long t)
{
	RTC_SR = 0;
    8d10:	ldr	r3, [pc, #16]	; (8d24 <rtc_set+0x14>)
	RTC_TPR = 0;
    8d12:	ldr	r1, [pc, #20]	; (8d28 <rtc_set+0x18>)
	return RTC_TSR;
}

void rtc_set(unsigned long t)
{
	RTC_SR = 0;
    8d14:	movs	r2, #0
    8d16:	str	r2, [r3, #0]
	RTC_TPR = 0;
    8d18:	str	r2, [r1, #0]
	RTC_TSR = t;
    8d1a:	ldr	r2, [pc, #16]	; (8d2c <rtc_set+0x1c>)
    8d1c:	str	r0, [r2, #0]
	RTC_SR = RTC_SR_TCE;
    8d1e:	movs	r2, #16
    8d20:	str	r2, [r3, #0]
    8d22:	bx	lr
    8d24:	.word	0x4003d014
    8d28:	.word	0x4003d004
    8d2c:	.word	0x4003d000

00008d30 <startup_middle_hook>:
}
#endif

extern void usb_init(void);

static void startup_default_middle_hook(void) {}
    8d30:	bx	lr
    8d32:	Address 0x00008d32 is out of bounds.


00008d34 <pinMode>:

void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
    8d34:	cmp	r0, #63	; 0x3f
}



void pinMode(uint8_t pin, uint8_t mode)
{
    8d36:	push	{r4, lr}
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
    8d38:	bhi.n	8d92 <pinMode+0x5e>
	config = portConfigRegister(pin);
    8d3a:	ldr	r2, [pc, #88]	; (8d94 <pinMode+0x60>)
    8d3c:	add.w	r3, r2, r0, lsl #3

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    8d40:	cmp	r1, #1
void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);
    8d42:	ldr	r3, [r3, #4]
    8d44:	mov	r4, r2

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    8d46:	beq.n	8d4c <pinMode+0x18>
    8d48:	cmp	r1, #4
    8d4a:	bne.n	8d6c <pinMode+0x38>
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    8d4c:	ldr.w	r2, [r4, r0, lsl #3]
    8d50:	movs	r0, #1
    8d52:	strb.w	r0, [r2, #640]	; 0x280
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    8d56:	mov.w	r2, #324	; 0x144
    8d5a:	str	r2, [r3, #0]
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
    8d5c:	ldr	r2, [r3, #0]
		*portModeRegister(pin) = 1;
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
		if (mode == OUTPUT_OPENDRAIN) {
    8d5e:	cmp	r1, #4
		    *config |= PORT_PCR_ODE;
    8d60:	ite	eq
    8d62:	orreq.w	r2, r2, #32
		} else {
		    *config &= ~PORT_PCR_ODE;
    8d66:	bicne.w	r2, r2, #32
    8d6a:	b.n	8d90 <pinMode+0x5c>
                }
	} else {
#ifdef KINETISK
		*portModeRegister(pin) = 0;
    8d6c:	ldr.w	r0, [r2, r0, lsl #3]
    8d70:	movs	r2, #0
    8d72:	strb.w	r2, [r0, #640]	; 0x280
#else
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
    8d76:	cbnz	r1, 8d7e <pinMode+0x4a>
			*config = PORT_PCR_MUX(1);
    8d78:	mov.w	r2, #256	; 0x100
    8d7c:	b.n	8d90 <pinMode+0x5c>
		} else if (mode == INPUT_PULLUP) {
    8d7e:	cmp	r1, #2
    8d80:	bne.n	8d88 <pinMode+0x54>
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
    8d82:	movw	r2, #259	; 0x103
    8d86:	b.n	8d90 <pinMode+0x5c>
		} else if (mode == INPUT_PULLDOWN) {
    8d88:	cmp	r1, #3
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE;
    8d8a:	it	eq
    8d8c:	moveq.w	r2, #258	; 0x102
		} else { // INPUT_DISABLE
			*config = 0;
    8d90:	str	r2, [r3, #0]
    8d92:	pop	{r4, pc}
    8d94:	.word	0x00012620

00008d98 <micros>:

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    8d98:	cpsid	i
	current = SYST_CVR;
    8d9a:	ldr	r3, [pc, #44]	; (8dc8 <micros+0x30>)
	count = systick_millis_count;
    8d9c:	ldr	r2, [pc, #44]	; (8dcc <micros+0x34>)
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    8d9e:	ldr	r1, [pc, #48]	; (8dd0 <micros+0x38>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    8da0:	ldr	r3, [r3, #0]
	count = systick_millis_count;
    8da2:	ldr	r2, [r2, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    8da4:	ldr	r1, [r1, #0]
	__enable_irq();
    8da6:	cpsie	i
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    8da8:	lsls	r1, r1, #5
    8daa:	bpl.n	8db2 <micros+0x1a>
    8dac:	cmp	r3, #50	; 0x32
    8dae:	it	hi
    8db0:	addhi	r2, #1
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    8db2:	rsb	r3, r3, #95744	; 0x17600
    8db6:	movs	r0, #96	; 0x60
    8db8:	adds	r3, #255	; 0xff
    8dba:	udiv	r3, r3, r0
}
    8dbe:	mov.w	r0, #1000	; 0x3e8
    8dc2:	mla	r0, r0, r2, r3
    8dc6:	bx	lr
    8dc8:	.word	0xe000e018
    8dcc:	.word	0x1fff8484
    8dd0:	.word	0xe000ed04

00008dd4 <delay>:

void delay(uint32_t ms)
{
    8dd4:	push	{r3, r4, r5, lr}
    8dd6:	mov	r4, r0
	uint32_t start = micros();
    8dd8:	bl	8d98 <micros>
    8ddc:	mov	r5, r0

	if (ms > 0) {
    8dde:	cbnz	r4, 8dea <delay+0x16>
    8de0:	pop	{r3, r4, r5, pc}
		while (1) {
			while ((micros() - start) >= 1000) {
				ms--;
				if (ms == 0) return;
    8de2:	subs	r4, #1
    8de4:	beq.n	8dfc <delay+0x28>
				start += 1000;
    8de6:	add.w	r5, r5, #1000	; 0x3e8
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    8dea:	bl	8d98 <micros>
    8dee:	subs	r0, r0, r5
    8df0:	cmp.w	r0, #1000	; 0x3e8
    8df4:	bcs.n	8de2 <delay+0xe>
				ms--;
				if (ms == 0) return;
				start += 1000;
			}
			yield();
    8df6:	bl	97d8 <yield>
		}
    8dfa:	b.n	8dea <delay+0x16>
    8dfc:	pop	{r3, r4, r5, pc}
    8dfe:	Address 0x00008dfe is out of bounds.


00008e00 <_init_Teensyduino_internal_>:
//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    8e00:	ldr	r3, [pc, #224]	; (8ee4 <_init_Teensyduino_internal_+0xe4>)
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    8e02:	ldr	r1, [pc, #228]	; (8ee8 <_init_Teensyduino_internal_+0xe8>)
//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    8e04:	mov.w	r2, #134217728	; 0x8000000
#endif

//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
    8e08:	push	{r4, r5, r6, lr}
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    8e0a:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTB);
    8e0c:	mov.w	r2, #268435456	; 0x10000000
    8e10:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTC);
    8e12:	mov.w	r2, #536870912	; 0x20000000
    8e16:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTD);
    8e18:	mov.w	r2, #1073741824	; 0x40000000
    8e1c:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTE);
    8e1e:	mov.w	r2, #2147483648	; 0x80000000
    8e22:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    8e24:	ldr	r3, [pc, #196]	; (8eec <_init_Teensyduino_internal_+0xec>)
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
    8e26:	ldr	r5, [pc, #200]	; (8ef0 <_init_Teensyduino_internal_+0xf0>)
	FTM3_C1SC = 0x28;
    8e28:	ldr	r4, [pc, #200]	; (8ef4 <_init_Teensyduino_internal_+0xf4>)
	FTM3_C4SC = 0x28;
	FTM3_C5SC = 0x28;
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    8e2a:	ldr	r6, [pc, #204]	; (8ef8 <_init_Teensyduino_internal_+0xf8>)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    8e2c:	movs	r2, #0
	FTM0_MOD = DEFAULT_FTM_MOD;
    8e2e:	movw	r0, #49151	; 0xbfff
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    8e32:	str	r2, [r3, #0]
	FTM0_MOD = DEFAULT_FTM_MOD;
    8e34:	str	r0, [r3, #4]
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    8e36:	movs	r3, #40	; 0x28
    8e38:	str	r3, [r1, #0]
	FTM0_C1SC = 0x28;
    8e3a:	str	r3, [r1, #8]
	FTM0_C2SC = 0x28;
    8e3c:	str	r3, [r1, #16]
	FTM0_C3SC = 0x28;
    8e3e:	str	r3, [r1, #24]
	FTM0_C4SC = 0x28;
    8e40:	str	r3, [r1, #32]
	FTM0_C5SC = 0x28;
    8e42:	str	r3, [r1, #40]	; 0x28
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
    8e44:	str	r3, [r1, #48]	; 0x30
	FTM0_C7SC = 0x28;
    8e46:	str	r3, [r1, #56]	; 0x38
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
	FTM0_C1SC = 0x28;
	FTM0_C2SC = 0x28;
    8e48:	adds	r1, #16
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
    8e4a:	add.w	r1, r1, #528384	; 0x81000
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
    8e4e:	str	r3, [r5, #0]
	FTM3_C1SC = 0x28;
    8e50:	str	r3, [r4, #0]
	FTM3_C2SC = 0x28;
    8e52:	str	r3, [r1, #0]
	FTM3_C3SC = 0x28;
    8e54:	str	r3, [r1, #8]
	FTM3_C4SC = 0x28;
    8e56:	str	r3, [r1, #16]
	FTM3_C5SC = 0x28;
    8e58:	str	r3, [r1, #24]
	FTM3_C6SC = 0x28;
    8e5a:	str	r3, [r1, #32]
	FTM3_C7SC = 0x28;
    8e5c:	str	r3, [r1, #40]	; 0x28
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    8e5e:	movs	r1, #9
    8e60:	str	r1, [r6, #0]
	FTM1_CNT = 0;
    8e62:	add.w	r6, r6, #4096	; 0x1000
    8e66:	adds	r6, #4
    8e68:	str	r2, [r6, #0]
	FTM1_MOD = DEFAULT_FTM_MOD;
    8e6a:	str	r0, [r6, #4]
	FTM1_C0SC = 0x28;
    8e6c:	str	r3, [r6, #8]
	FTM1_C1SC = 0x28;
    8e6e:	str	r3, [r6, #16]
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    8e70:	str.w	r1, [r6, #-4]
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
    8e74:	add.w	r6, r6, #520192	; 0x7f000
    8e78:	str	r2, [r6, #0]
	FTM2_MOD = DEFAULT_FTM_MOD;
    8e7a:	str	r0, [r6, #4]
	FTM2_C0SC = 0x28;
    8e7c:	str	r3, [r6, #8]
	FTM2_C1SC = 0x28;
    8e7e:	str	r3, [r6, #16]
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    8e80:	str.w	r1, [r6, #-4]
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_CNT = 0;
    8e84:	add.w	r6, r6, #4096	; 0x1000
    8e88:	str	r2, [r6, #0]
	FTM3_MOD = DEFAULT_FTM_MOD;
    8e8a:	str	r0, [r6, #4]
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    8e8c:	ldr	r0, [pc, #108]	; (8efc <_init_Teensyduino_internal_+0xfc>)
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_CNT = 0;
	FTM3_MOD = DEFAULT_FTM_MOD;
	FTM3_C0SC = 0x28;
    8e8e:	str	r3, [r5, #0]
	FTM3_C1SC = 0x28;
    8e90:	str	r3, [r4, #0]
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    8e92:	str	r1, [r0, #0]
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
    8e94:	sub.w	r0, r0, #460800	; 0x70800
    8e98:	subw	r0, r0, #2004	; 0x7d4
    8e9c:	ldr	r1, [r0, #0]
    8e9e:	orr.w	r1, r1, #512	; 0x200
    8ea2:	str	r1, [r0, #0]
	SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2);
    8ea4:	ldr.w	r1, [r0, #-40]
    8ea8:	orr.w	r1, r1, #33554432	; 0x2000000
    8eac:	str.w	r1, [r0, #-40]
	TPM1_CNT = 0;
    8eb0:	ldr	r1, [pc, #76]	; (8f00 <_init_Teensyduino_internal_+0x100>)
    8eb2:	str	r2, [r1, #0]
	TPM1_MOD = 32767;
    8eb4:	ldr	r2, [pc, #76]	; (8f04 <_init_Teensyduino_internal_+0x104>)
    8eb6:	movw	r1, #32767	; 0x7fff
    8eba:	str	r1, [r2, #0]
	TPM1_C0SC = 0x28;
    8ebc:	str	r3, [r2, #4]
	TPM1_C1SC = 0x28;
    8ebe:	str	r3, [r2, #12]
	TPM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(0);
    8ec0:	ldr	r3, [pc, #68]	; (8f08 <_init_Teensyduino_internal_+0x108>)
    8ec2:	movs	r2, #8
    8ec4:	str	r2, [r3, #0]
#endif
	analog_init();
    8ec6:	bl	8bc0 <analog_init>

	// for background about this startup delay, please see these conversations
	// https://forum.pjrc.com/threads/36606-startup-time-(400ms)?p=113980&viewfull=1#post113980
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	startup_middle_hook();
    8eca:	bl	8d30 <startup_middle_hook>
	delay(TEENSY_INIT_USB_DELAY_BEFORE);
    8ece:	movs	r0, #20
    8ed0:	bl	8dd4 <delay>
	usb_init();
    8ed4:	bl	9744 <usb_init>
	delay(TEENSY_INIT_USB_DELAY_AFTER);
    8ed8:	mov.w	r0, #280	; 0x118
}
    8edc:	ldmia.w	sp!, {r4, r5, r6, lr}
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	startup_middle_hook();
	delay(TEENSY_INIT_USB_DELAY_BEFORE);
	usb_init();
	delay(TEENSY_INIT_USB_DELAY_AFTER);
    8ee0:	b.w	8dd4 <delay>
    8ee4:	.word	0xe000e104
    8ee8:	.word	0x4003800c
    8eec:	.word	0x40038004
    8ef0:	.word	0x400b900c
    8ef4:	.word	0x400b9014
    8ef8:	.word	0x40038000
    8efc:	.word	0x400b9000
    8f00:	.word	0x400c9004
    8f04:	.word	0x400c9008
    8f08:	.word	0x400c9000

00008f0c <usb_malloc>:
// http://www.archivum.info/gnu.gcc.help/2006-08/00148/Re-GCC-Inline-Assembly.html
// http://gcc.gnu.org/ml/gcc/2012-06/msg00015.html
// __builtin_clz()

usb_packet_t * usb_malloc(void)
{
    8f0c:	push	{r4, lr}
	unsigned int n, avail;
	uint8_t *p;

	__disable_irq();
    8f0e:	cpsid	i
	avail = usb_buffer_available;
    8f10:	ldr	r0, [pc, #44]	; (8f40 <usb_malloc+0x34>)
    8f12:	ldr	r2, [r0, #0]
	n = __builtin_clz(avail); // clz = count leading zeros
    8f14:	clz	r1, r2
	if (n >= NUM_USB_BUFFERS) {
    8f18:	cmp	r1, #11
    8f1a:	ble.n	8f22 <usb_malloc+0x16>
		__enable_irq();
    8f1c:	cpsie	i
		return NULL;
    8f1e:	movs	r0, #0
    8f20:	pop	{r4, pc}
	}
	//serial_print("malloc:");
	//serial_phex(n);
	//serial_print("\n");

	usb_buffer_available = avail & ~(0x80000000 >> n);
    8f22:	mov.w	r3, #2147483648	; 0x80000000
    8f26:	lsrs	r3, r1
    8f28:	bic.w	r2, r2, r3
    8f2c:	str	r2, [r0, #0]
	__enable_irq();
    8f2e:	cpsie	i
	p = usb_buffer_memory + (n * sizeof(usb_packet_t));
    8f30:	ldr	r4, [pc, #16]	; (8f44 <usb_malloc+0x38>)
    8f32:	movs	r3, #72	; 0x48
    8f34:	muls	r3, r1
    8f36:	adds	r0, r4, r3
	//serial_print("malloc:");
	//serial_phex32((int)p);
	//serial_print("\n");
	*(uint32_t *)p = 0;
    8f38:	movs	r2, #0
    8f3a:	str	r2, [r4, r3]
	*(uint32_t *)(p + 4) = 0;
    8f3c:	str	r2, [r0, #4]
	return (usb_packet_t *)p;
}
    8f3e:	pop	{r4, pc}
    8f40:	.word	0x1fff1360
    8f44:	.word	0x1fff0bd0

00008f48 <usb_free>:
void usb_free(usb_packet_t *p)
{
	unsigned int n, mask;

	//serial_print("free:");
	n = ((uint8_t *)p - usb_buffer_memory) / sizeof(usb_packet_t);
    8f48:	ldr	r3, [pc, #48]	; (8f7c <usb_free+0x34>)
    8f4a:	movs	r2, #72	; 0x48
    8f4c:	subs	r3, r0, r3
    8f4e:	udiv	r3, r3, r2
	if (n >= NUM_USB_BUFFERS) return;
    8f52:	cmp	r3, #11
    8f54:	bhi.n	8f7a <usb_free+0x32>
	//serial_phex(n);
	//serial_print("\n");

	// if any endpoints are starving for memory to receive
	// packets, give this memory to them immediately!
	if (usb_rx_memory_needed && usb_configuration) {
    8f56:	ldr	r2, [pc, #40]	; (8f80 <usb_free+0x38>)
    8f58:	ldrb	r2, [r2, #0]
    8f5a:	cbz	r2, 8f66 <usb_free+0x1e>
    8f5c:	ldr	r2, [pc, #36]	; (8f84 <usb_free+0x3c>)
    8f5e:	ldrb	r2, [r2, #0]
    8f60:	cbz	r2, 8f66 <usb_free+0x1e>
		//serial_print("give to rx:");
		//serial_phex32((int)p);
		//serial_print("\n");
		usb_rx_memory(p);
    8f62:	b.w	9028 <usb_rx_memory>
		return;
	}

	mask = (0x80000000 >> n);
	__disable_irq();
    8f66:	cpsid	i
	usb_buffer_available |= mask;
    8f68:	ldr	r1, [pc, #28]	; (8f88 <usb_free+0x40>)
    8f6a:	mov.w	r2, #2147483648	; 0x80000000
    8f6e:	lsr.w	r3, r2, r3
    8f72:	ldr	r2, [r1, #0]
    8f74:	orrs	r2, r3
    8f76:	str	r2, [r1, #0]
	__enable_irq();
    8f78:	cpsie	i
    8f7a:	bx	lr
    8f7c:	.word	0x1fff0bd0
    8f80:	.word	0x1fff855e
    8f84:	.word	0x1fff8567
    8f88:	.word	0x1fff1360

00008f8c <endpoint0_transmit>:
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
}


static void endpoint0_transmit(const void *data, uint32_t len)
{
    8f8c:	push	{r4, r5, r6, r7, lr}
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    8f8e:	ldr	r4, [pc, #48]	; (8fc0 <endpoint0_transmit+0x34>)
    8f90:	ldr	r6, [pc, #48]	; (8fc4 <endpoint0_transmit+0x38>)
    8f92:	ldrb	r3, [r4, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    8f94:	ldr	r5, [pc, #48]	; (8fc8 <endpoint0_transmit+0x3c>)
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    8f96:	orr.w	r7, r3, #2
    8f9a:	add.w	r2, r6, r7, lsl #3
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    8f9e:	eor.w	r3, r3, #1
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    8fa2:	str	r0, [r2, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    8fa4:	ldrb	r2, [r5, #0]
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    8fa6:	strb	r3, [r4, #0]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    8fa8:	cmp	r2, #0
    8faa:	ite	ne
    8fac:	movne	r0, #200	; 0xc8
    8fae:	moveq	r0, #136	; 0x88
	ep0_tx_data_toggle ^= 1;
    8fb0:	eor.w	r2, r2, #1
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    8fb4:	orr.w	r1, r0, r1, lsl #16
	ep0_tx_data_toggle ^= 1;
    8fb8:	strb	r2, [r5, #0]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    8fba:	str.w	r1, [r6, r7, lsl #3]
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    8fbe:	pop	{r4, r5, r6, r7, pc}
    8fc0:	.word	0x1fff84f0
    8fc4:	.word	0x1fff0000
    8fc8:	.word	0x1fff8568

00008fcc <usb_rx>:


usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
    8fcc:	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    8fce:	cmp	r3, #3




usb_packet_t *usb_rx(uint32_t endpoint)
{
    8fd0:	push	{r4, lr}
	usb_packet_t *ret;
	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    8fd2:	bhi.n	8ff6 <usb_rx+0x2a>
	__disable_irq();
    8fd4:	cpsid	i
	ret = rx_first[endpoint];
    8fd6:	ldr	r2, [pc, #36]	; (8ffc <usb_rx+0x30>)
    8fd8:	ldr.w	r0, [r2, r3, lsl #2]
	if (ret) {
    8fdc:	cbz	r0, 8ff2 <usb_rx+0x26>
		rx_first[endpoint] = ret->next;
    8fde:	ldr	r1, [r0, #4]
    8fe0:	str.w	r1, [r2, r3, lsl #2]
		usb_rx_byte_count_data[endpoint] -= ret->len;
    8fe4:	ldr	r1, [pc, #24]	; (9000 <usb_rx+0x34>)
    8fe6:	ldrh	r4, [r0, #0]
    8fe8:	ldrh.w	r2, [r1, r3, lsl #1]
    8fec:	subs	r2, r2, r4
    8fee:	strh.w	r2, [r1, r3, lsl #1]
	}
	__enable_irq();
    8ff2:	cpsie	i
	//serial_print("rx, epidx=");
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
    8ff4:	pop	{r4, pc}

usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    8ff6:	movs	r0, #0
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
}
    8ff8:	pop	{r4, pc}
    8ffa:	nop
    8ffc:	.word	0x1fff84e0
    9000:	.word	0x1fff85e4

00009004 <usb_tx_packet_count>:
uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
    9004:	subs	r0, #1
	if (endpoint >= NUM_ENDPOINTS) return 0;
    9006:	cmp	r0, #3
    9008:	bhi.n	9020 <usb_tx_packet_count+0x1c>
	__disable_irq();
    900a:	cpsid	i
	for (p = tx_first[endpoint]; p; p = p->next) count++;
    900c:	ldr	r3, [pc, #20]	; (9024 <usb_tx_packet_count+0x20>)
    900e:	ldr.w	r3, [r3, r0, lsl #2]
// https://forum.pjrc.com/threads/58663?p=223513&viewfull=1#post223513
//
uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;
    9012:	movs	r0, #0

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return 0;
	__disable_irq();
	for (p = tx_first[endpoint]; p; p = p->next) count++;
    9014:	cbz	r3, 901c <usb_tx_packet_count+0x18>
    9016:	adds	r0, #1
    9018:	ldr	r3, [r3, #4]
    901a:	b.n	9014 <usb_tx_packet_count+0x10>
	__enable_irq();
    901c:	cpsie	i
	return count;
    901e:	bx	lr
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return 0;
    9020:	movs	r0, #0
	__disable_irq();
	for (p = tx_first[endpoint]; p; p = p->next) count++;
	__enable_irq();
	return count;
}
    9022:	bx	lr
    9024:	.word	0x1fff8534

00009028 <usb_rx_memory>:
// user is creating data very quickly, their consumption could starve reception
// without this prioritization.  The packet buffer (input) is assigned to the
// first endpoint needing memory.
//
void usb_rx_memory(usb_packet_t *packet)
{
    9028:	push	{r4, r5, r6}
	unsigned int i;
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
    902a:	cpsid	i
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    902c:	ldr	r5, [pc, #92]	; (908c <usb_rx_memory+0x64>)
			if (table[index(i, RX, EVEN)].desc == 0) {
    902e:	ldr	r4, [pc, #96]	; (9090 <usb_rx_memory+0x68>)
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
    9030:	movs	r3, #1
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    9032:	adds	r2, r3, r5
    9034:	ldrb.w	r2, [r2, #-1]
    9038:	lsls	r2, r2, #28
    903a:	bpl.n	9078 <usb_rx_memory+0x50>
			if (table[index(i, RX, EVEN)].desc == 0) {
    903c:	lsls	r2, r3, #2
    903e:	ldr	r1, [pc, #80]	; (9090 <usb_rx_memory+0x68>)
    9040:	ldr.w	r6, [r4, r2, lsl #3]
    9044:	cbnz	r6, 9052 <usb_rx_memory+0x2a>
				table[index(i, RX, EVEN)].addr = packet->buf;
    9046:	add.w	r3, r1, r3, lsl #5
    904a:	adds	r0, #8
    904c:	str	r0, [r3, #4]
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    904e:	ldr	r3, [pc, #68]	; (9094 <usb_rx_memory+0x6c>)
    9050:	b.n	9066 <usb_rx_memory+0x3e>
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    9052:	orr.w	r2, r2, #1
    9056:	ldr.w	r6, [r4, r2, lsl #3]
    905a:	cbnz	r6, 9078 <usb_rx_memory+0x50>
				table[index(i, RX, ODD)].addr = packet->buf;
    905c:	add.w	r3, r1, r2, lsl #3
    9060:	adds	r0, #8
    9062:	str	r0, [r3, #4]
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    9064:	ldr	r3, [pc, #48]	; (9098 <usb_rx_memory+0x70>)
    9066:	str.w	r3, [r1, r2, lsl #3]
				usb_rx_memory_needed--;
    906a:	ldr	r2, [pc, #48]	; (909c <usb_rx_memory+0x74>)
    906c:	ldrb	r3, [r2, #0]
    906e:	subs	r3, #1
    9070:	strb	r3, [r2, #0]
				__enable_irq();
    9072:	cpsie	i
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free(packet);
	return;
}
    9074:	pop	{r4, r5, r6}
    9076:	bx	lr
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
    9078:	adds	r3, #1
    907a:	cmp	r3, #5
    907c:	bne.n	9032 <usb_rx_memory+0xa>
				//serial_print(",odd\n");
				return;
			}
		}
	}
	__enable_irq();
    907e:	cpsie	i
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
    9080:	ldr	r3, [pc, #24]	; (909c <usb_rx_memory+0x74>)
    9082:	movs	r2, #0
    9084:	strb	r2, [r3, #0]
	usb_free(packet);
	return;
}
    9086:	pop	{r4, r5, r6}
	__enable_irq();
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free(packet);
    9088:	b.w	8f48 <usb_free>
    908c:	.word	0x0001284a
    9090:	.word	0x1fff0000
    9094:	.word	0x00400088
    9098:	.word	0x004000c8
    909c:	.word	0x1fff855e

000090a0 <usb_tx>:
void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
	uint8_t next;

	endpoint--;
    90a0:	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return;
    90a2:	cmp	r3, #3

//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
    90a4:	push	{r4, lr}
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
	uint8_t next;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return;
    90a6:	bhi.n	910e <usb_tx+0x6e>
//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
    90a8:	ldr	r2, [pc, #100]	; (9110 <usb_tx+0x70>)
    90aa:	lsls	r0, r0, #5
    90ac:	orr.w	r0, r0, #16
    90b0:	add	r0, r2
	uint8_t next;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return;
	__disable_irq();
    90b2:	cpsid	i
	//serial_print("txstate=");
	//serial_phex(tx_state[endpoint]);
	//serial_print("\n");
	switch (tx_state[endpoint]) {
    90b4:	ldr	r2, [pc, #92]	; (9114 <usb_tx+0x74>)
    90b6:	ldrb	r4, [r2, r3]
    90b8:	cmp	r4, #3
    90ba:	bhi.n	90d4 <usb_tx+0x34>
    90bc:	tbb	[pc, r4]
    90c0:	.word	0x07020418
	  case TX_STATE_BOTH_FREE_ODD_FIRST:
		b++;
		next = TX_STATE_EVEN_FREE;
		break;
	  case TX_STATE_EVEN_FREE:
		next = TX_STATE_NONE_FREE_ODD_FIRST;
    90c4:	movs	r4, #5
    90c6:	b.n	90f2 <usb_tx+0x52>
	switch (tx_state[endpoint]) {
	  case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
		break;
	  case TX_STATE_BOTH_FREE_ODD_FIRST:
		b++;
    90c8:	adds	r0, #8
		next = TX_STATE_EVEN_FREE;
    90ca:	movs	r4, #2
		break;
    90cc:	b.n	90f2 <usb_tx+0x52>
	  case TX_STATE_EVEN_FREE:
		next = TX_STATE_NONE_FREE_ODD_FIRST;
		break;
	  case TX_STATE_ODD_FREE:
		b++;
    90ce:	adds	r0, #8
		next = TX_STATE_NONE_FREE_EVEN_FIRST;
    90d0:	movs	r4, #4
		break;
    90d2:	b.n	90f2 <usb_tx+0x52>
	  default:
		if (tx_first[endpoint] == NULL) {
    90d4:	ldr	r0, [pc, #64]	; (9118 <usb_tx+0x78>)
    90d6:	ldr	r2, [pc, #68]	; (911c <usb_tx+0x7c>)
    90d8:	ldr.w	r4, [r0, r3, lsl #2]
    90dc:	cbnz	r4, 90e4 <usb_tx+0x44>
			tx_first[endpoint] = packet;
    90de:	str.w	r1, [r0, r3, lsl #2]
    90e2:	b.n	90ea <usb_tx+0x4a>
		} else {
			tx_last[endpoint]->next = packet;
    90e4:	ldr.w	r0, [r2, r3, lsl #2]
    90e8:	str	r1, [r0, #4]
		}
		tx_last[endpoint] = packet;
    90ea:	str.w	r1, [r2, r3, lsl #2]
    90ee:	b.n	910c <usb_tx+0x6c>
	//serial_print("txstate=");
	//serial_phex(tx_state[endpoint]);
	//serial_print("\n");
	switch (tx_state[endpoint]) {
	  case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
    90f0:	movs	r4, #3
		}
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
    90f2:	strb	r4, [r2, r3]
	b->addr = packet->buf;
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    90f4:	tst.w	r0, #8
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
	b->addr = packet->buf;
    90f8:	add.w	r3, r1, #8
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    90fc:	ldrh	r2, [r1, #0]
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
	b->addr = packet->buf;
    90fe:	str	r3, [r0, #4]
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    9100:	ite	ne
    9102:	movne	r3, #200	; 0xc8
    9104:	moveq	r3, #136	; 0x88
    9106:	orr.w	r3, r3, r2, lsl #16
    910a:	str	r3, [r0, #0]
	__enable_irq();
    910c:	cpsie	i
    910e:	pop	{r4, pc}
    9110:	.word	0x1fff0000
    9114:	.word	0x1fff849c
    9118:	.word	0x1fff8534
    911c:	.word	0x1fff8544

00009120 <usb_isr>:
}



void usb_isr(void)
{
    9120:	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9124:	ldr.w	r8, [pc, #680]	; 93d0 <usb_isr+0x2b0>
	//serial_print("isr");
	//status = USB0_ISTAT;
	//serial_phex(status);
	//serial_print("\n");
	restart:
	status = USB0_ISTAT;
    9128:	ldr	r3, [pc, #676]	; (93d0 <usb_isr+0x2b0>)
    912a:	ldrb	r4, [r3, #0]
    912c:	uxtb	r4, r4

	if ((status & USB_ISTAT_SOFTOK /* 04 */ )) {
    912e:	tst.w	r4, #4
    9132:	mov	r5, r3
    9134:	beq.n	916c <usb_isr+0x4c>
		if (usb_configuration) {
    9136:	ldr	r3, [pc, #668]	; (93d4 <usb_isr+0x2b4>)
    9138:	ldrb	r3, [r3, #0]
    913a:	cbz	r3, 9166 <usb_isr+0x46>
			t = usb_reboot_timer;
    913c:	ldr	r2, [pc, #664]	; (93d8 <usb_isr+0x2b8>)
    913e:	ldrb	r1, [r2, #0]
			if (t) {
    9140:	and.w	r3, r1, #255	; 0xff
    9144:	cbz	r1, 9150 <usb_isr+0x30>
				usb_reboot_timer = --t;
    9146:	subs	r3, #1
    9148:	uxtb	r3, r3
    914a:	strb	r3, [r2, #0]
				if (!t) _reboot_Teensyduino_();
    914c:	cbnz	r3, 9150 <usb_isr+0x30>


void _reboot_Teensyduino_(void)
{
	// TODO: initialize R0 with a code....
	__asm__ volatile("bkpt");
    914e:	bkpt	0x0000
			if (t) {
				usb_reboot_timer = --t;
				if (!t) _reboot_Teensyduino_();
			}
#ifdef CDC_DATA_INTERFACE
			t = usb_cdc_transmit_flush_timer;
    9150:	ldr	r2, [pc, #648]	; (93dc <usb_isr+0x2bc>)
    9152:	ldrb	r1, [r2, #0]
			if (t) {
    9154:	and.w	r3, r1, #255	; 0xff
    9158:	cbz	r1, 9166 <usb_isr+0x46>
				usb_cdc_transmit_flush_timer = --t;
    915a:	subs	r3, #1
    915c:	uxtb	r3, r3
    915e:	strb	r3, [r2, #0]
				if (t == 0) usb_serial_flush_callback();
    9160:	cbnz	r3, 9166 <usb_isr+0x46>
    9162:	bl	8b78 <usb_serial_flush_callback>
#endif
#ifdef MULTITOUCH_INTERFACE
			usb_touchscreen_update_callback();
#endif
		}
		USB0_ISTAT = USB_ISTAT_SOFTOK;
    9166:	movs	r3, #4
    9168:	strb.w	r3, [r8]
	}

	if ((status & USB_ISTAT_TOKDNE /* 08 */ )) {
    916c:	and.w	r3, r4, #8
    9170:	and.w	r2, r3, #255	; 0xff
    9174:	cmp	r3, #0
    9176:	beq.w	9660 <usb_isr+0x540>
		uint8_t endpoint;
		stat = USB0_STAT;
    917a:	ldr	r3, [pc, #612]	; (93e0 <usb_isr+0x2c0>)
    917c:	ldr	r4, [pc, #612]	; (93e4 <usb_isr+0x2c4>)
    917e:	ldrb	r3, [r3, #0]
    9180:	uxtb	r3, r3
		//serial_print("token: ep=");
		//serial_phex(stat >> 4);
		//serial_print(stat & 0x08 ? ",tx" : ",rx");
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if (endpoint == 0) {
    9182:	lsrs	r7, r3, #4
    9184:	mov.w	r6, r3, lsr #2
    9188:	bne.w	9568 <usb_isr+0x448>
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
	pid = BDT_PID(b->desc);
    918c:	ldr.w	r3, [r4, r6, lsl #3]
	bdt_t *b;
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
    9190:	add.w	r2, r4, r6, lsl #3
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    9194:	ubfx	r3, r3, #2, #4
    9198:	subs	r3, #1
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
	pid = BDT_PID(b->desc);
	//count = b->desc >> 16;
	buf = b->addr;
    919a:	ldr	r2, [r2, #4]
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    919c:	cmp	r3, #12
    919e:	bhi.w	9560 <usb_isr+0x440>
    91a2:	tbh	[pc, r3, lsl #1]
    91a6:	.short	0x019e
    91a8:	.word	0x01dd019e
    91ac:	.word	0x01dd01dd
    91b0:	.word	0x01dd01dd
    91b4:	.word	0x01bb01dd
    91b8:	.word	0x01dd01dd
    91bc:	.word	0x000d01dd
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    91c0:	ldr	r5, [pc, #548]	; (93e8 <usb_isr+0x2c8>)
		setup.word2 = *(uint32_t *)(buf + 4);
    91c2:	ldr	r3, [r2, #4]
	switch (pid) {
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    91c4:	ldr	r1, [r2, #0]
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    91c6:	ldr	r0, [pc, #548]	; (93ec <usb_isr+0x2cc>)
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);
    91c8:	str	r3, [r5, #4]

		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    91ca:	ldr	r3, [pc, #548]	; (93f0 <usb_isr+0x2d0>)
    91cc:	str.w	r3, [r4, r6, lsl #3]
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    91d0:	movs	r3, #1
	switch (pid) {
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    91d2:	str	r1, [r5, #0]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    91d4:	ldr.w	sl, [pc, #584]	; 9420 <usb_isr+0x300>
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    91d8:	strb	r3, [r0, #0]
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    91da:	uxth	r1, r1
    91dc:	movw	r0, #1665	; 0x681
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    91e0:	movs	r2, #0
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    91e2:	cmp	r1, r0
			//serial_print("leftover tx even\n");
		//}
		//if (table[index(0, TX, ODD)].desc & 0x80) {
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
    91e4:	str	r2, [r4, #16]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    91e6:	str.w	r2, [sl]
		//}
		//if (table[index(0, TX, ODD)].desc & 0x80) {
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
    91ea:	str	r2, [r4, #24]
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    91ec:	bhi.n	921e <usb_isr+0xfe>
    91ee:	cmp.w	r1, #1664	; 0x680
    91f2:	bcs.w	9446 <usb_isr+0x326>
    91f6:	cmp.w	r1, #258	; 0x102
    91fa:	beq.w	93b0 <usb_isr+0x290>
    91fe:	bhi.n	920e <usb_isr+0xee>
    9200:	cmp	r1, #128	; 0x80
    9202:	beq.w	938a <usb_isr+0x26a>
    9206:	cmp	r1, #130	; 0x82
    9208:	beq.w	9392 <usb_isr+0x272>
    920c:	b.n	9480 <usb_isr+0x360>
    920e:	movw	r3, #770	; 0x302
    9212:	cmp	r1, r3
    9214:	beq.w	9428 <usb_isr+0x308>
    9218:	cmp.w	r1, #1280	; 0x500
    921c:	b.n	9256 <usb_isr+0x136>
    921e:	movw	r0, #8225	; 0x2021
    9222:	cmp	r1, r0
    9224:	beq.w	94dc <usb_isr+0x3bc>
    9228:	bhi.n	9246 <usb_isr+0x126>
    922a:	cmp.w	r1, #2176	; 0x880
    922e:	beq.w	9380 <usb_isr+0x260>
    9232:	cmp.w	r1, #2304	; 0x900
    9236:	bne.w	9480 <usb_isr+0x360>
	  case 0x0500: // SET_ADDRESS
		break;
	  case 0x0900: // SET_CONFIGURATION
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
    923a:	ldr	r3, [pc, #408]	; (93d4 <usb_isr+0x2b4>)
    923c:	ldrb	r2, [r5, #2]
    923e:	strb	r2, [r3, #0]
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    9240:	movs	r6, #4
			if (table[i].desc & BDT_OWN) {
    9242:	ldr	r7, [pc, #416]	; (93e4 <usb_isr+0x2c4>)
    9244:	b.n	925c <usb_isr+0x13c>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    9246:	movw	r3, #8737	; 0x2221
    924a:	cmp	r1, r3
    924c:	beq.w	946c <usb_isr+0x34c>
    9250:	movw	r3, #8993	; 0x2321
    9254:	cmp	r1, r3
    9256:	beq.w	9488 <usb_isr+0x368>
    925a:	b.n	9480 <usb_isr+0x360>
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
			if (table[i].desc & BDT_OWN) {
    925c:	ldr.w	r3, [r4, r6, lsl #3]
    9260:	lsls	r3, r3, #24
    9262:	bpl.n	9270 <usb_isr+0x150>
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
    9264:	add.w	r3, r7, r6, lsl #3
    9268:	ldr	r0, [r3, #4]
    926a:	subs	r0, #8
    926c:	bl	8f48 <usb_free>
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    9270:	adds	r6, #1
    9272:	cmp	r6, #20
    9274:	bne.n	925c <usb_isr+0x13c>
    9276:	ldr	r7, [pc, #380]	; (93f4 <usb_isr+0x2d4>)
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
			usb_packet_t *p, *n;
			p = rx_first[i];
    9278:	ldr.w	fp, [pc, #380]	; 93f8 <usb_isr+0x2d8>
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    927c:	movs	r6, #0
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
			usb_packet_t *p, *n;
			p = rx_first[i];
    927e:	ldr.w	r0, [fp, r6, lsl #2]
    9282:	mov.w	r9, r6, lsl #2
			while (p) {
    9286:	cbz	r0, 9296 <usb_isr+0x176>
				n = p->next;
    9288:	ldr	r2, [r0, #4]
    928a:	str	r2, [sp, #0]
				usb_free(p);
    928c:	bl	8f48 <usb_free>
				p = n;
    9290:	ldr	r2, [sp, #0]
    9292:	mov	r0, r2
    9294:	b.n	9286 <usb_isr+0x166>
			}
			rx_first[i] = NULL;
    9296:	ldr	r3, [pc, #352]	; (93f8 <usb_isr+0x2d8>)
			rx_last[i] = NULL;
			p = tx_first[i];
    9298:	ldr	r2, [pc, #352]	; (93fc <usb_isr+0x2dc>)
			while (p) {
				n = p->next;
				usb_free(p);
				p = n;
			}
			rx_first[i] = NULL;
    929a:	str.w	r0, [r3, r9]
			rx_last[i] = NULL;
    929e:	ldr	r3, [pc, #352]	; (9400 <usb_isr+0x2e0>)
    92a0:	str.w	r0, [r9, r3]
			p = tx_first[i];
    92a4:	ldr.w	r0, [r9, r2]
			while (p) {
    92a8:	cbz	r0, 92bc <usb_isr+0x19c>
				n = p->next;
    92aa:	ldr	r1, [r0, #4]
    92ac:	str	r2, [sp, #4]
    92ae:	str	r1, [sp, #0]
				usb_free(p);
    92b0:	bl	8f48 <usb_free>
				p = n;
    92b4:	ldr	r1, [sp, #0]
    92b6:	ldr	r2, [sp, #4]
    92b8:	mov	r0, r1
    92ba:	b.n	92a8 <usb_isr+0x188>
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
    92bc:	ldr	r3, [pc, #324]	; (9404 <usb_isr+0x2e4>)
			while (p) {
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
    92be:	str.w	r0, [r2, r9]
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
    92c2:	strh.w	r0, [r3, r6, lsl #1]
			switch (tx_state[i]) {
    92c6:	ldrb	r3, [r7, #0]
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
    92c8:	ldr	r2, [pc, #316]	; (9408 <usb_isr+0x2e8>)
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
    92ca:	subs	r3, #2
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
    92cc:	str.w	r0, [r9, r2]
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
    92d0:	cmp	r3, #3
    92d2:	bhi.n	92e4 <usb_isr+0x1c4>
    92d4:	tbb	[pc, r3]
    92d8:	.word	0x04020402
			  case TX_STATE_EVEN_FREE:
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    92dc:	movs	r3, #0
    92de:	b.n	92e2 <usb_isr+0x1c2>
				break;
			  case TX_STATE_ODD_FREE:
			  case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    92e0:	movs	r3, #1
    92e2:	strb	r3, [r7, #0]
			if (table[i].desc & BDT_OWN) {
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
    92e4:	adds	r6, #1
    92e6:	cmp	r6, #4
    92e8:	add.w	r7, r7, #1
    92ec:	bne.n	927e <usb_isr+0x15e>
				break;
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
    92ee:	ldr	r1, [pc, #284]	; (940c <usb_isr+0x2ec>)
		for (i=1; i <= NUM_ENDPOINTS; i++) {
			epconf = *cfg++;
    92f0:	ldr.w	r9, [pc, #304]	; 9424 <usb_isr+0x304>
				break;
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
    92f4:	movs	r3, #0
    92f6:	strb	r3, [r1, #0]
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    92f8:	mov.w	fp, #1
    92fc:	mov	r7, r1
    92fe:	ldr	r3, [pc, #272]	; (9410 <usb_isr+0x2f0>)
			epconf = *cfg++;
    9300:	add.w	r0, fp, r9
    9304:	add	r3, fp
    9306:	ldrb.w	r0, [r0, #-1]
    930a:	lsls	r3, r3, #2
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
    930c:	tst.w	r0, #8
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
			epconf = *cfg++;
			*reg = epconf;
    9310:	strb	r0, [r3, #0]
    9312:	mov.w	r6, fp, lsl #2
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
    9316:	beq.n	9360 <usb_isr+0x240>
				usb_packet_t *p;
				p = usb_malloc();
    9318:	bl	8f0c <usb_malloc>
				if (p) {
    931c:	cbz	r0, 9330 <usb_isr+0x210>
					table[index(i, RX, EVEN)].addr = p->buf;
    931e:	add.w	lr, r4, fp, lsl #5
    9322:	adds	r0, #8
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    9324:	ldr	r3, [pc, #236]	; (9414 <usb_isr+0x2f4>)
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
				usb_packet_t *p;
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
    9326:	str.w	r0, [lr, #4]
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    932a:	str.w	r3, [r4, r6, lsl #3]
    932e:	b.n	933a <usb_isr+0x21a>
				} else {
					table[index(i, RX, EVEN)].desc = 0;
    9330:	str.w	r0, [r4, r6, lsl #3]
					usb_rx_memory_needed++;
    9334:	ldrb	r0, [r7, #0]
    9336:	adds	r0, #1
    9338:	strb	r0, [r7, #0]
				}
				p = usb_malloc();
    933a:	bl	8f0c <usb_malloc>
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
    933e:	orr.w	lr, r6, #1
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
				if (p) {
    9342:	cbz	r0, 9356 <usb_isr+0x236>
					table[index(i, RX, ODD)].addr = p->buf;
    9344:	add.w	ip, r4, lr, lsl #3
    9348:	adds	r0, #8
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    934a:	ldr	r3, [pc, #164]	; (93f0 <usb_isr+0x2d0>)
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
    934c:	str.w	r0, [ip, #4]
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    9350:	str.w	r3, [r4, lr, lsl #3]
    9354:	b.n	9360 <usb_isr+0x240>
				} else {
					table[index(i, RX, ODD)].desc = 0;
    9356:	str.w	r0, [r4, lr, lsl #3]
					usb_rx_memory_needed++;
    935a:	ldrb	r0, [r7, #0]
    935c:	adds	r0, #1
    935e:	strb	r0, [r7, #0]
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    9360:	orr.w	lr, r6, #2
			table[index(i, TX, ODD)].desc = 0;
    9364:	orr.w	r3, r6, #3
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    9368:	add.w	fp, fp, #1
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    936c:	movs	r0, #0
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    936e:	cmp.w	fp, #5
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    9372:	str.w	r0, [r4, lr, lsl #3]
			table[index(i, TX, ODD)].desc = 0;
    9376:	str.w	r0, [r4, r3, lsl #3]
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    937a:	bne.n	92fe <usb_isr+0x1de>
static uint8_t reply_buffer[8];

static void usb_setup(void)
{
	const uint8_t *data = NULL;
	uint32_t datalen = 0;
    937c:	mov	r3, r0
    937e:	b.n	9492 <usb_isr+0x372>
			}
#endif
		}
		break;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    9380:	ldr	r2, [pc, #80]	; (93d4 <usb_isr+0x2b4>)
    9382:	ldr	r6, [pc, #148]	; (9418 <usb_isr+0x2f8>)
    9384:	ldrb	r2, [r2, #0]
    9386:	strb	r2, [r6, #0]
    9388:	b.n	9494 <usb_isr+0x374>
		datalen = 1;
		data = reply_buffer;
		break;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    938a:	ldr	r6, [pc, #140]	; (9418 <usb_isr+0x2f8>)
    938c:	strb	r2, [r6, #0]
		reply_buffer[1] = 0;
    938e:	strb	r2, [r6, #1]
    9390:	b.n	948c <usb_isr+0x36c>
    9392:	ldrh	r1, [r5, #4]
    9394:	and.w	r1, r1, #127	; 0x7f
		datalen = 2;
		data = reply_buffer;
		break;
	  case 0x0082: // GET_STATUS (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS) {
    9398:	cmp	r1, #4
    939a:	bhi.n	9480 <usb_isr+0x360>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
    939c:	ldr	r6, [pc, #120]	; (9418 <usb_isr+0x2f8>)
		reply_buffer[1] = 0;
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    939e:	lsls	r1, r1, #2
		if (i > NUM_ENDPOINTS) {
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
    93a0:	strb	r2, [r6, #0]
		reply_buffer[1] = 0;
    93a2:	strb	r2, [r6, #1]
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    93a4:	ldr	r2, [pc, #116]	; (941c <usb_isr+0x2fc>)
    93a6:	ldrb	r2, [r2, r1]
    93a8:	lsls	r4, r2, #30
    93aa:	bpl.n	948c <usb_isr+0x36c>
    93ac:	strb	r3, [r6, #0]
    93ae:	b.n	948c <usb_isr+0x36c>
    93b0:	ldrh	r2, [r5, #4]
    93b2:	and.w	r2, r2, #127	; 0x7f
		data = reply_buffer;
		datalen = 2;
		break;
	  case 0x0102: // CLEAR_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    93b6:	cmp	r2, #4
    93b8:	bhi.n	9480 <usb_isr+0x360>
    93ba:	ldrh	r3, [r5, #2]
    93bc:	cmp	r3, #0
    93be:	bne.n	9480 <usb_isr+0x360>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) &= ~0x02;
    93c0:	ldr	r1, [pc, #88]	; (941c <usb_isr+0x2fc>)
    93c2:	lsls	r2, r2, #2
    93c4:	add	r1, r2
    93c6:	ldrb	r2, [r1, #0]
    93c8:	bic.w	r2, r2, #2
    93cc:	b.n	9442 <usb_isr+0x322>
    93ce:	nop
    93d0:	.word	0x40072080
    93d4:	.word	0x1fff8567
    93d8:	.word	0x1fff84f1
    93dc:	.word	0x1fff8470
    93e0:	.word	0x40072090
    93e4:	.word	0x1fff0000
    93e8:	.word	0x1fff8554
    93ec:	.word	0x1fff8568
    93f0:	.word	0x004000c8
    93f4:	.word	0x1fff849c
    93f8:	.word	0x1fff84e0
    93fc:	.word	0x1fff8534
    9400:	.word	0x1fff848c
    9404:	.word	0x1fff85e4
    9408:	.word	0x1fff8544
    940c:	.word	0x1fff855e
    9410:	.word	0x1001c830
    9414:	.word	0x00400088
    9418:	.word	0x1fff855f
    941c:	.word	0x400720c0
    9420:	.word	0x1fff8488
    9424:	.word	0x0001284a
    9428:	ldrh	r2, [r5, #4]
    942a:	and.w	r2, r2, #127	; 0x7f
		// TODO: do we need to clear the data toggle here?
		break;
	  case 0x0302: // SET_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    942e:	cmp	r2, #4
    9430:	bhi.n	9480 <usb_isr+0x360>
    9432:	ldrh	r3, [r5, #2]
    9434:	cbnz	r3, 9480 <usb_isr+0x360>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) |= 0x02;
    9436:	ldr	r1, [pc, #620]	; (96a4 <usb_isr+0x584>)
    9438:	lsls	r2, r2, #2
    943a:	add	r1, r2
    943c:	ldrb	r2, [r1, #0]
    943e:	orr.w	r2, r2, #2
    9442:	strb	r2, [r1, #0]
    9444:	b.n	9492 <usb_isr+0x372>
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
			if (list->addr == NULL) break;
			//if (setup.wValue == list->wValue &&
			//(setup.wIndex == list->wIndex) || ((setup.wValue >> 8) == 3)) {
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    9446:	ldrh	r2, [r5, #2]
    9448:	ldrh	r1, [r5, #4]
    944a:	ldr	r3, [pc, #604]	; (96a8 <usb_isr+0x588>)
	  case 0x0681:
		//serial_print("desc:");
		//serial_phex16(setup.wValue);
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
			if (list->addr == NULL) break;
    944c:	ldr	r6, [r3, #4]
    944e:	cbz	r6, 9480 <usb_isr+0x360>
			//if (setup.wValue == list->wValue &&
			//(setup.wIndex == list->wIndex) || ((setup.wValue >> 8) == 3)) {
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    9450:	ldrh	r0, [r3, #0]
    9452:	cmp	r0, r2
    9454:	bne.n	9468 <usb_isr+0x348>
    9456:	ldrh	r0, [r3, #2]
    9458:	cmp	r0, r1
    945a:	bne.n	9468 <usb_isr+0x348>
				data = list->addr;
				if ((setup.wValue >> 8) == 3) {
    945c:	lsrs	r2, r2, #8
    945e:	cmp	r2, #3
					// for string descriptors, use the descriptor's
					// length field, allowing runtime configured
					// length.
					datalen = *(list->addr);
    9460:	ite	eq
    9462:	ldrbeq	r3, [r6, #0]
				} else {
					datalen = list->length;
    9464:	ldrhne	r3, [r3, #8]
    9466:	b.n	9494 <usb_isr+0x374>
	  case 0x0680: // GET_DESCRIPTOR
	  case 0x0681:
		//serial_print("desc:");
		//serial_phex16(setup.wValue);
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
    9468:	adds	r3, #12
    946a:	b.n	944c <usb_isr+0x32c>
		}
		//serial_print("desc: not found\n");
		endpoint0_stall();
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
    946c:	ldrh	r3, [r5, #4]
    946e:	cbnz	r3, 9490 <usb_isr+0x370>
#ifdef CDC_STATUS_INTERFACE
		  case CDC_STATUS_INTERFACE:
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    9470:	ldr	r2, [pc, #568]	; (96ac <usb_isr+0x58c>)
    9472:	ldr	r1, [r2, #0]
    9474:	ldr	r2, [pc, #568]	; (96b0 <usb_isr+0x590>)
    9476:	str	r1, [r2, #0]
			usb_cdc_line_rtsdtr = setup.wValue;
    9478:	ldr	r2, [pc, #568]	; (96b4 <usb_isr+0x594>)
    947a:	ldrb	r1, [r5, #2]
    947c:	strb	r1, [r2, #0]
    947e:	b.n	9492 <usb_isr+0x372>
volatile uint8_t usb_reboot_timer = 0;


static void endpoint0_stall(void)
{
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    9480:	ldr	r3, [pc, #544]	; (96a4 <usb_isr+0x584>)
    9482:	movs	r2, #15
    9484:	strb	r2, [r3, #0]
    9486:	b.n	94dc <usb_isr+0x3bc>
static uint8_t reply_buffer[8];

static void usb_setup(void)
{
	const uint8_t *data = NULL;
	uint32_t datalen = 0;
    9488:	movs	r3, #0
    948a:	b.n	9492 <usb_isr+0x372>
		}
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
		data = reply_buffer;
		datalen = 2;
    948c:	movs	r3, #2
    948e:	b.n	9494 <usb_isr+0x374>
static uint8_t reply_buffer[8];

static void usb_setup(void)
{
	const uint8_t *data = NULL;
	uint32_t datalen = 0;
    9490:	mov	r3, r2

static uint8_t reply_buffer[8];

static void usb_setup(void)
{
	const uint8_t *data = NULL;
    9492:	mov	r6, r3
	//serial_phex32(data);
	//serial_print(",");
	//serial_phex16(datalen);
	//serial_print("\n");

	if (datalen > setup.wLength) datalen = setup.wLength;
    9494:	ldrh	r4, [r5, #6]
    9496:	cmp	r4, r3
    9498:	it	cs
    949a:	movcs	r4, r3
    949c:	cmp	r4, #64	; 0x40
    949e:	mov	r5, r4
    94a0:	it	cs
    94a2:	movcs	r5, #64	; 0x40
	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
    94a4:	mov	r0, r6
    94a6:	mov	r1, r5
    94a8:	bl	8f8c <endpoint0_transmit>
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    94ac:	subs	r4, r4, r5

	if (datalen > setup.wLength) datalen = setup.wLength;
	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    94ae:	add	r6, r5
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    94b0:	bne.n	94ba <usb_isr+0x39a>
    94b2:	cmp	r5, #64	; 0x40
    94b4:	bne.n	94dc <usb_isr+0x3bc>
    94b6:	mov	r5, r4
    94b8:	b.n	94c2 <usb_isr+0x3a2>
    94ba:	cmp	r4, #64	; 0x40
    94bc:	mov	r5, r4
    94be:	it	cs
    94c0:	movcs	r5, #64	; 0x40

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
    94c2:	mov	r0, r6
    94c4:	mov	r1, r5
    94c6:	bl	8f8c <endpoint0_transmit>
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    94ca:	subs	r4, r4, r5
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    94cc:	add	r6, r5
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    94ce:	bne.n	94d4 <usb_isr+0x3b4>
    94d0:	cmp	r5, #64	; 0x40
    94d2:	bne.n	94dc <usb_isr+0x3bc>

	ep0_tx_ptr = data;
	ep0_tx_len = datalen;
    94d4:	ldr	r3, [pc, #480]	; (96b8 <usb_isr+0x598>)
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;

	ep0_tx_ptr = data;
    94d6:	str.w	r6, [sl]
	ep0_tx_len = datalen;
    94da:	strh	r4, [r3, #0]
		serial_print("\n");
#endif
		// actually "do" the setup request
		usb_setup();
		// unfreeze the USB, now that we're ready
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    94dc:	movs	r2, #1
    94de:	ldr	r3, [pc, #476]	; (96bc <usb_isr+0x59c>)
    94e0:	b.n	955e <usb_isr+0x43e>
		break;
	case 0x01:  // OUT transaction received from host
	case 0x02:
		//serial_print("PID=OUT\n");
		if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
    94e2:	ldr	r3, [pc, #476]	; (96c0 <usb_isr+0x5a0>)
    94e4:	ldrh	r0, [r3, #0]
    94e6:	movw	r1, #8225	; 0x2021
    94ea:	cmp	r0, r1
    94ec:	bne.n	9514 <usb_isr+0x3f4>
			int i;
			uint32_t *line_coding = NULL;
			switch (setup.wIndex) {
    94ee:	ldrh	r3, [r3, #4]
    94f0:	cbnz	r3, 950c <usb_isr+0x3ec>
			if (line_coding) {
				uint8_t *dst = (uint8_t *)line_coding;
				//serial_print("set line coding ");
				for (i=0; i<7; i++) {
					//serial_phex(*buf);
					*dst++ = *buf++;
    94f2:	ldr	r1, [pc, #464]	; (96c4 <usb_isr+0x5a4>)
    94f4:	ldrb	r0, [r2, r3]
    94f6:	strb	r0, [r3, r1]
#endif
			}
			if (line_coding) {
				uint8_t *dst = (uint8_t *)line_coding;
				//serial_print("set line coding ");
				for (i=0; i<7; i++) {
    94f8:	adds	r3, #1
    94fa:	cmp	r3, #7
    94fc:	bne.n	94f4 <usb_isr+0x3d4>
					//serial_phex(*buf);
					*dst++ = *buf++;
				}
				//serial_phex32(line_coding[0]);
				//serial_print("\n");
				if (line_coding[0] == 134) usb_reboot_timer = 15;
    94fe:	ldr	r3, [pc, #452]	; (96c4 <usb_isr+0x5a4>)
    9500:	ldr	r3, [r3, #0]
    9502:	cmp	r3, #134	; 0x86
    9504:	ittt	eq
    9506:	ldreq	r3, [pc, #448]	; (96c8 <usb_isr+0x5a8>)
    9508:	moveq	r2, #15
    950a:	strbeq	r2, [r3, #0]
			}
			endpoint0_transmit(NULL, 0);
    950c:	movs	r1, #0
    950e:	mov	r0, r1
    9510:	bl	8f8c <endpoint0_transmit>
		if (usb_audio_set_feature(&setup, buf)) {
			endpoint0_transmit(NULL, 0);
		}
#endif
		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    9514:	ldr	r3, [pc, #436]	; (96cc <usb_isr+0x5ac>)
    9516:	str.w	r3, [r4, r6, lsl #3]
    951a:	b.n	9560 <usb_isr+0x440>
		//serial_print("PID=IN:");
		//serial_phex(stat);
		//serial_print("\n");

		// send remaining data, if any...
		data = ep0_tx_ptr;
    951c:	ldr	r7, [pc, #432]	; (96d0 <usb_isr+0x5b0>)
    951e:	ldr	r6, [r7, #0]
		if (data) {
    9520:	cbz	r6, 954c <usb_isr+0x42c>
			size = ep0_tx_len;
    9522:	ldr.w	sl, [pc, #404]	; 96b8 <usb_isr+0x598>
    9526:	ldrh.w	r4, [sl]
    952a:	cmp	r4, #64	; 0x40
    952c:	mov	r5, r4
    952e:	it	cs
    9530:	movcs	r5, #64	; 0x40
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
    9532:	mov	r0, r6
    9534:	mov	r1, r5
    9536:	bl	8f8c <endpoint0_transmit>
			data += size;
			ep0_tx_len -= size;
    953a:	subs	r0, r4, r5
    953c:	uxth	r0, r0
    953e:	strh.w	r0, [sl]
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
    9542:	cbnz	r0, 9548 <usb_isr+0x428>
    9544:	cmp	r5, #64	; 0x40
    9546:	bne.n	954a <usb_isr+0x42a>
		data = ep0_tx_ptr;
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
    9548:	adds	r0, r6, r5
			ep0_tx_len -= size;
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
    954a:	str	r0, [r7, #0]
		}

		if (setup.bRequest == 5 && setup.bmRequestType == 0) {
    954c:	ldr	r3, [pc, #368]	; (96c0 <usb_isr+0x5a0>)
    954e:	ldrh	r2, [r3, #0]
    9550:	cmp.w	r2, #1280	; 0x500
    9554:	bne.n	9560 <usb_isr+0x440>
			setup.bRequest = 0;
    9556:	movs	r2, #0
    9558:	strb	r2, [r3, #1]
			//serial_print("set address: ");
			//serial_phex16(setup.wValue);
			//serial_print("\n");
			USB0_ADDR = setup.wValue;
    955a:	ldrb	r2, [r3, #2]
    955c:	ldr	r3, [pc, #372]	; (96d4 <usb_isr+0x5b4>)
    955e:	strb	r2, [r3, #0]
	//default:
		//serial_print("PID=unknown:");
		//serial_phex(pid);
		//serial_print("\n");
	}
	USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    9560:	ldr	r3, [pc, #344]	; (96bc <usb_isr+0x59c>)
    9562:	movs	r2, #1
    9564:	strb	r2, [r3, #0]
    9566:	b.n	9658 <usb_isr+0x538>
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
    9568:	add.w	r5, r4, r6, lsl #3
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;	// endpoint is index to zero-based arrays
    956c:	subs	r7, #1
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    956e:	ldr	r2, [r5, #4]
				b->addr = &usb_audio_sync_feedback;
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
    9570:	and.w	r3, r3, #8
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    9574:	sub.w	r0, r2, #8
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;	// endpoint is index to zero-based arrays
    9578:	uxtb	r7, r7
				b->addr = &usb_audio_sync_feedback;
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
    957a:	and.w	lr, r3, #255	; 0xff
    957e:	cmp	r3, #0
    9580:	beq.n	95f0 <usb_isr+0x4d0>
				usb_free(packet);
    9582:	bl	8f48 <usb_free>
				packet = tx_first[endpoint];
    9586:	ldr	r0, [pc, #336]	; (96d8 <usb_isr+0x5b8>)
    9588:	ldr	r3, [pc, #336]	; (96dc <usb_isr+0x5bc>)
    958a:	ldr.w	r1, [r0, r7, lsl #2]
				if (packet) {
    958e:	cbz	r1, 95cc <usb_isr+0x4ac>
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
    9590:	ldr	r2, [r1, #4]
    9592:	str.w	r2, [r0, r7, lsl #2]
					b->addr = packet->buf;
    9596:	add.w	r2, r1, #8
    959a:	str	r2, [r5, #4]
					switch (tx_state[endpoint]) {
    959c:	ldrb	r2, [r3, r7]
    959e:	cmp	r2, #3
    95a0:	bhi.n	95ba <usb_isr+0x49a>
    95a2:	tbb	[pc, r2]
    95a6:	.short	0x0402
    95a8:	.short	0x0806
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
						tx_state[endpoint] = TX_STATE_ODD_FREE;
    95aa:	movs	r2, #3
    95ac:	b.n	95b8 <usb_isr+0x498>
						break;
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						tx_state[endpoint] = TX_STATE_EVEN_FREE;
    95ae:	movs	r2, #2
    95b0:	b.n	95b8 <usb_isr+0x498>
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_ODD_FIRST;
    95b2:	movs	r2, #5
    95b4:	b.n	95b8 <usb_isr+0x498>
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_EVEN_FIRST;
    95b6:	movs	r2, #4
    95b8:	strb	r2, [r3, r7]
						break;
					  default:
						break;
					}
					b->desc = BDT_DESC(packet->len,
    95ba:	tst.w	r5, #8
    95be:	ldrh	r2, [r1, #0]
    95c0:	ite	ne
    95c2:	movne	r3, #200	; 0xc8
    95c4:	moveq	r3, #136	; 0x88
    95c6:	orr.w	r3, r3, r2, lsl #16
    95ca:	b.n	9654 <usb_isr+0x534>
						((uint32_t)b & 8) ? DATA1 : DATA0);
				} else {
					//serial_print("tx no packet\n");
					switch (tx_state[endpoint]) {
    95cc:	ldrb	r2, [r3, r7]
    95ce:	cmp	r2, #3
    95d0:	bhi.n	95e2 <usb_isr+0x4c2>
    95d2:	tbb	[pc, r2]
    95d6:	.short	0x4141
    95d8:	.short	0x0402
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    95da:	movs	r2, #0
    95dc:	b.n	95ec <usb_isr+0x4cc>
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_ODD_FIRST;
    95de:	movs	r2, #1
    95e0:	b.n	95ec <usb_isr+0x4cc>
						break;
					  default:
						tx_state[endpoint] = ((uint32_t)b & 8) ?
    95e2:	tst.w	r5, #8
    95e6:	ite	ne
    95e8:	movne	r2, #3
    95ea:	moveq	r2, #2
    95ec:	strb	r2, [r3, r7]
						  TX_STATE_ODD_FREE : TX_STATE_EVEN_FREE;
						break;
    95ee:	b.n	9658 <usb_isr+0x538>
					}
				}
			} else { // receive
				packet->len = b->desc >> 16;
    95f0:	ldr.w	r3, [r4, r6, lsl #3]
    95f4:	lsrs	r3, r3, #16
    95f6:	uxth	r1, r3
    95f8:	strh.w	r1, [r2, #-8]
				if (packet->len > 0) {
    95fc:	cbz	r3, 9648 <usb_isr+0x528>
					packet->index = 0;
					packet->next = NULL;
					if (rx_first[endpoint] == NULL) {
    95fe:	ldr	r3, [pc, #224]	; (96e0 <usb_isr+0x5c0>)
					}
				}
			} else { // receive
				packet->len = b->desc >> 16;
				if (packet->len > 0) {
					packet->index = 0;
    9600:	strh.w	lr, [r2, #-6]
					packet->next = NULL;
    9604:	str.w	lr, [r2, #-4]
					if (rx_first[endpoint] == NULL) {
    9608:	ldr.w	r2, [r3, r7, lsl #2]
    960c:	ldr.w	lr, [pc, #252]	; 970c <usb_isr+0x5ec>
    9610:	cbnz	r2, 9618 <usb_isr+0x4f8>
						//serial_print("rx 1st, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_first[endpoint] = packet;
    9612:	str.w	r0, [r3, r7, lsl #2]
    9616:	b.n	961e <usb_isr+0x4fe>
						//serial_print("rx Nth, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[endpoint]->next = packet;
    9618:	ldr.w	r3, [lr, r7, lsl #2]
    961c:	str	r0, [r3, #4]
					}
					rx_last[endpoint] = packet;
					usb_rx_byte_count_data[endpoint] += packet->len;
    961e:	ldr	r2, [pc, #196]	; (96e4 <usb_isr+0x5c4>)
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[endpoint]->next = packet;
					}
					rx_last[endpoint] = packet;
    9620:	str.w	r0, [lr, r7, lsl #2]
					usb_rx_byte_count_data[endpoint] += packet->len;
    9624:	ldrh.w	r3, [r2, r7, lsl #1]
    9628:	add	r3, r1
    962a:	strh.w	r3, [r2, r7, lsl #1]
					// TODO: implement a per-endpoint maximum # of allocated
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
    962e:	bl	8f0c <usb_malloc>
					if (packet) {
    9632:	cbz	r0, 963a <usb_isr+0x51a>
						b->addr = packet->buf;
    9634:	adds	r0, #8
    9636:	str	r0, [r5, #4]
    9638:	b.n	9648 <usb_isr+0x528>
							((uint32_t)b & 8) ? DATA1 : DATA0);
					} else {
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						b->desc = 0;
						usb_rx_memory_needed++;
    963a:	ldr	r2, [pc, #172]	; (96e8 <usb_isr+0x5c8>)
						b->desc = BDT_DESC(64,
							((uint32_t)b & 8) ? DATA1 : DATA0);
					} else {
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						b->desc = 0;
    963c:	str.w	r0, [r4, r6, lsl #3]
						usb_rx_memory_needed++;
    9640:	ldrb	r3, [r2, #0]
    9642:	adds	r3, #1
    9644:	strb	r3, [r2, #0]
    9646:	b.n	9658 <usb_isr+0x538>
					}
				} else {
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
    9648:	ldr	r2, [pc, #160]	; (96ec <usb_isr+0x5cc>)
    964a:	ldr	r3, [pc, #128]	; (96cc <usb_isr+0x5ac>)
    964c:	tst.w	r5, #8
    9650:	it	eq
    9652:	moveq	r3, r2
    9654:	str.w	r3, [r4, r6, lsl #3]
				}
			}

		}
		USB0_ISTAT = USB_ISTAT_TOKDNE;
    9658:	movs	r3, #8
    965a:	strb.w	r3, [r8]
		goto restart;
    965e:	b.n	9128 <usb_isr+0x8>
	}



	if (status & USB_ISTAT_USBRST /* 01 */ ) {
    9660:	lsls	r0, r4, #31
    9662:	bpl.n	9710 <usb_isr+0x5f0>
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    9664:	ldr	r1, [pc, #84]	; (96bc <usb_isr+0x59c>)
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    9666:	ldr	r0, [pc, #132]	; (96ec <usb_isr+0x5cc>)
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    9668:	ldr	r4, [pc, #132]	; (96f0 <usb_isr+0x5d0>)

	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    966a:	movs	r3, #2
    966c:	strb	r3, [r1, #0]
		ep0_tx_bdt_bank = 0;
    966e:	ldr	r3, [pc, #132]	; (96f4 <usb_isr+0x5d4>)
    9670:	strb	r2, [r3, #0]

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    9672:	ldr	r3, [pc, #132]	; (96f8 <usb_isr+0x5d8>)
    9674:	str	r0, [r3, #0]
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    9676:	str	r4, [r3, #4]
		table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 0);
    9678:	str	r0, [r3, #8]
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
    967a:	ldr	r0, [pc, #128]	; (96fc <usb_isr+0x5dc>)
    967c:	str	r0, [r3, #12]
		table[index(0, TX, EVEN)].desc = 0;
    967e:	str	r2, [r3, #16]
		table[index(0, TX, ODD)].desc = 0;
    9680:	str	r2, [r3, #24]

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    9682:	ldr	r3, [pc, #32]	; (96a4 <usb_isr+0x584>)
    9684:	movs	r0, #13
    9686:	strb	r0, [r3, #0]

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
    9688:	ldr	r0, [pc, #116]	; (9700 <usb_isr+0x5e0>)
    968a:	movs	r3, #255	; 0xff
    968c:	strb	r3, [r0, #0]
		USB0_ISTAT = 0xFF;
    968e:	strb	r3, [r5, #0]

		// set the address to zero during enumeration
		USB0_ADDR = 0;
    9690:	strb	r2, [r0, #16]

		// enable other interrupts
		USB0_ERREN = 0xFF;
    9692:	ldr	r2, [pc, #112]	; (9704 <usb_isr+0x5e4>)
    9694:	strb	r3, [r2, #0]
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    9696:	ldr	r3, [pc, #112]	; (9708 <usb_isr+0x5e8>)
    9698:	movs	r2, #159	; 0x9f
    969a:	strb	r2, [r3, #0]
			USB_INTEN_ERROREN |
			USB_INTEN_USBRSTEN |
			USB_INTEN_SLEEPEN;

		// is this necessary?
		USB0_CTL = USB_CTL_USBENSOFEN;
    969c:	movs	r3, #1
    969e:	strb	r3, [r1, #0]
		return;
    96a0:	b.n	9736 <usb_isr+0x616>
    96a2:	nop
    96a4:	.word	0x400720c0
    96a8:	.word	0x00012850
    96ac:	.word	0x1fff8484
    96b0:	.word	0x1fff85e0
    96b4:	.word	0x1fff8480
    96b8:	.word	0x1fff855c
    96bc:	.word	0x40072094
    96c0:	.word	0x1fff8554
    96c4:	.word	0x1fff85d8
    96c8:	.word	0x1fff84f1
    96cc:	.word	0x004000c8
    96d0:	.word	0x1fff8488
    96d4:	.word	0x40072098
    96d8:	.word	0x1fff8534
    96dc:	.word	0x1fff849c
    96e0:	.word	0x1fff84e0
    96e4:	.word	0x1fff85e4
    96e8:	.word	0x1fff855e
    96ec:	.word	0x00400088
    96f0:	.word	0x1fff84a0
    96f4:	.word	0x1fff84f0
    96f8:	.word	0x1fff0000
    96fc:	.word	0x1fff84f4
    9700:	.word	0x40072088
    9704:	.word	0x4007208c
    9708:	.word	0x40072084
    970c:	.word	0x1fff848c
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
    9710:	lsls	r1, r4, #24
    9712:	bpl.n	971e <usb_isr+0x5fe>
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    9714:	ldr	r3, [pc, #36]	; (973c <usb_isr+0x61c>)
    9716:	movs	r2, #13
    9718:	strb	r2, [r3, #0]
		USB0_ISTAT = USB_ISTAT_STALL;
    971a:	movs	r3, #128	; 0x80
    971c:	strb	r3, [r5, #0]
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
    971e:	lsls	r2, r4, #30
    9720:	bpl.n	972e <usb_isr+0x60e>
		uint8_t err = USB0_ERRSTAT;
    9722:	ldr	r2, [pc, #28]	; (9740 <usb_isr+0x620>)
    9724:	ldrb	r3, [r2, #0]
    9726:	uxtb	r3, r3
		USB0_ERRSTAT = err;
    9728:	strb	r3, [r2, #0]
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    972a:	movs	r3, #2
    972c:	strb	r3, [r5, #0]
	}

	if ((status & USB_ISTAT_SLEEP /* 10 */ )) {
    972e:	lsls	r3, r4, #27
		//serial_print("sleep\n");
		USB0_ISTAT = USB_ISTAT_SLEEP;
    9730:	itt	mi
    9732:	movmi	r3, #16
    9734:	strbmi	r3, [r5, #0]
	}

}
    9736:	add	sp, #12
    9738:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    973c:	.word	0x400720c0
    9740:	.word	0x40072088

00009744 <usb_init>:



void usb_init(void)
{
    9744:	push	{r4, lr}
	int i;

	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();
    9746:	bl	9c0c <usb_init_serialnumber>

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    974a:	movs	r3, #0
		table[i].desc = 0;
    974c:	ldr	r0, [pc, #108]	; (97bc <usb_init+0x78>)
    974e:	mov	r1, r3
    9750:	str.w	r1, [r0, r3, lsl #3]
		table[i].addr = 0;
    9754:	add.w	r4, r0, r3, lsl #3
	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    9758:	adds	r3, #1
    975a:	cmp	r3, #20
		table[i].desc = 0;
    975c:	ldr	r2, [pc, #92]	; (97bc <usb_init+0x78>)
		table[i].addr = 0;
    975e:	str	r1, [r4, #4]
	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    9760:	bne.n	9750 <usb_init+0xc>
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    9762:	ldr	r1, [pc, #92]	; (97c0 <usb_init+0x7c>)
    9764:	ldr	r3, [r1, #0]
    9766:	orr.w	r3, r3, #262144	; 0x40000
    976a:	str	r3, [r1, #0]
#ifdef HAS_KINETIS_MPU
	MPU_RGDAAC0 |= 0x03000000;
    976c:	ldr	r1, [pc, #84]	; (97c4 <usb_init+0x80>)
    976e:	ldr	r3, [r1, #0]
    9770:	orr.w	r3, r3, #50331648	; 0x3000000
    9774:	str	r3, [r1, #0]
	// reset USB module
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    9776:	ldr	r3, [pc, #80]	; (97c8 <usb_init+0x84>)
    9778:	ubfx	r1, r2, #8, #8
    977c:	strb	r1, [r3, #0]
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    977e:	ubfx	r1, r2, #16, #8
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    9782:	lsrs	r2, r2, #24
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    9784:	strb	r1, [r3, #20]
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    9786:	strb	r2, [r3, #24]

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    9788:	ldr	r2, [pc, #64]	; (97cc <usb_init+0x88>)
    978a:	movs	r3, #255	; 0xff
    978c:	strb	r3, [r2, #0]

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
	USB0_USBCTRL = 0;
    978e:	movs	r1, #0
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
    9790:	strb	r3, [r2, #8]
	USB0_OTGISTAT = 0xFF;
    9792:	strb.w	r3, [r2, #-112]

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
    9796:	movs	r3, #1
    9798:	strb	r3, [r2, #20]
	USB0_USBCTRL = 0;
    979a:	strb.w	r1, [r2, #128]	; 0x80

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;
    979e:	strb	r3, [r2, #4]

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    97a0:	ldr	r3, [pc, #44]	; (97d0 <usb_init+0x8c>)
    97a2:	movs	r2, #112	; 0x70
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    97a4:	mvn.w	r1, #816	; 0x330

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    97a8:	strb	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    97aa:	add	r3, r1
    97ac:	mov.w	r2, #2097152	; 0x200000
    97b0:	str	r2, [r3, #0]

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    97b2:	ldr	r3, [pc, #32]	; (97d4 <usb_init+0x90>)
    97b4:	movs	r2, #16
    97b6:	strb	r2, [r3, #0]
    97b8:	pop	{r4, pc}
    97ba:	nop
    97bc:	.word	0x1fff0000
    97c0:	.word	0x40048034
    97c4:	.word	0x4000d800
    97c8:	.word	0x4007209c
    97cc:	.word	0x40072080
    97d0:	.word	0xe000e435
    97d4:	.word	0x40072108

000097d8 <yield>:

extern const uint8_t _serialEvent_default;	

void yield(void) __attribute__ ((weak));
void yield(void)
{
    97d8:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
    97dc:	ldr	r4, [pc, #176]	; (9890 <yield+0xb8>)
    97de:	ldrb	r3, [r4, #0]
    97e0:	cmp	r3, #0
    97e2:	beq.n	988a <yield+0xb2>
	if (running) return; // TODO: does this need to be atomic?
    97e4:	ldr	r5, [pc, #172]	; (9894 <yield+0xbc>)
    97e6:	ldrb	r2, [r5, #0]
    97e8:	cmp	r2, #0
    97ea:	bne.n	988a <yield+0xb2>
	running = 1;
    97ec:	movs	r2, #1


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    97ee:	lsls	r1, r3, #31
void yield(void)
{
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
	if (running) return; // TODO: does this need to be atomic?
	running = 1;
    97f0:	strb	r2, [r5, #0]


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    97f2:	bpl.n	980c <yield+0x34>
				if (elapsed > 750) break;
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    97f4:	bl	8990 <usb_serial_available>
		if (Serial.available()) serialEvent();
    97f8:	cbz	r0, 97fe <yield+0x26>
    97fa:	bl	9c02 <serialEvent()>
		if (_serialEvent_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIAL;
    97fe:	ldr	r3, [pc, #152]	; (9898 <yield+0xc0>)
    9800:	ldrb	r3, [r3, #0]
    9802:	cbz	r3, 980c <yield+0x34>
    9804:	ldrb	r3, [r4, #0]
    9806:	bic.w	r3, r3, #1
    980a:	strb	r3, [r4, #0]
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIALUSB2) {
		if (SerialUSB2.available()) serialEventUSB2();
		if (_serialEventUSB2_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIALUSB2;
	}
#endif
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) {
    980c:	ldrb	r3, [r4, #0]
    980e:	lsls	r2, r3, #30
    9810:	bpl.n	983c <yield+0x64>
					  return len; }
	virtual size_t write9bit(uint32_t c)	{ serial_putchar(c); return 1; }
	operator bool()			{ return true; }

	static inline void processSerialEventsList() {
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    9812:	ldr.w	r8, [pc, #148]	; 98a8 <yield+0xd0>
			s_serials_with_serial_events[i]->doYieldCode();
    9816:	ldr.w	r9, [pc, #148]	; 98ac <yield+0xd4>
    981a:	movs	r6, #0
					  return len; }
	virtual size_t write9bit(uint32_t c)	{ serial_putchar(c); return 1; }
	operator bool()			{ return true; }

	static inline void processSerialEventsList() {
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    981c:	ldrb.w	r2, [r8]
    9820:	uxtb	r3, r6
    9822:	cmp	r2, r3
    9824:	bls.n	983c <yield+0x64>
			s_serials_with_serial_events[i]->doYieldCode();
    9826:	ldr.w	r7, [r9, r3, lsl #2]
	static HardwareSerial 	*s_serials_with_serial_events[CNT_HARDWARE_SERIAL];
	static uint8_t 			s_count_serials_with_serial_events;
	void 		(* const _serialEvent)(); 
	void addToSerialEventsList(); 
	inline void doYieldCode()  {
		if (available()) (*_serialEvent)();
    982a:	ldr	r3, [r7, #0]
    982c:	mov	r0, r7
    982e:	ldr	r3, [r3, #16]
    9830:	blx	r3
    9832:	cbz	r0, 9838 <yield+0x60>
    9834:	ldr	r3, [r7, #16]
    9836:	blx	r3
    9838:	adds	r6, #1
    983a:	b.n	981c <yield+0x44>
		HardwareSerial::processSerialEventsList();
	}
	running = 0;
    983c:	movs	r3, #0
    983e:	strb	r3, [r5, #0]
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    9840:	ldrb	r3, [r4, #0]
    9842:	lsls	r3, r3, #29
    9844:	bpl.n	988a <yield+0xb2>
	// used with a scheduler or RTOS.
	bool waitForEvent(EventResponderRef event, int timeout);
	EventResponder * waitForEvent(EventResponder *list, int listsize, int timeout);

	static void runFromYield() {
		if (!firstYield) return;  
    9846:	ldr	r1, [pc, #84]	; (989c <yield+0xc4>)
    9848:	ldr	r3, [r1, #0]
    984a:	cbz	r3, 988a <yield+0xb2>
		// First, check if yield was called from an interrupt
		// never call normal handler functions from any interrupt context
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
    984c:	mrs	r3, IPSR
		if (ipsr != 0) return;
    9850:	cbnz	r3, 988a <yield+0xb2>
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    9852:	mrs	r2, PRIMASK
		__disable_irq();
    9856:	cpsid	i
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
		if (ipsr != 0) return;
		// Next, check if any events have been triggered
		bool irq = disableInterrupts();
		EventResponder *first = firstYield;
    9858:	ldr	r0, [r1, #0]
		if (first == nullptr) {
    985a:	cbz	r0, 9862 <yield+0x8a>
			return;
		}
		// Finally, make sure we're not being recursively called,
		// which can happen if the user's function does anything
		// that calls yield.
		if (runningFromYield) {
    985c:	ldr	r4, [pc, #64]	; (98a0 <yield+0xc8>)
    985e:	ldrb	r5, [r4, #0]
    9860:	cbz	r5, 986a <yield+0x92>
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    9862:	cbnz	r2, 988a <yield+0xb2>
    9864:	cpsie	i
    9866:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (runningFromYield) {
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
    986a:	movs	r3, #1
    986c:	strb	r3, [r4, #0]
		firstYield = first->_next;
    986e:	ldr	r3, [r0, #20]
    9870:	str	r3, [r1, #0]
		if (firstYield) {
    9872:	cbz	r3, 9878 <yield+0xa0>
			firstYield->_prev = nullptr;
    9874:	str	r5, [r3, #24]
    9876:	b.n	987c <yield+0xa4>
		} else {
			lastYield = nullptr;
    9878:	ldr	r1, [pc, #40]	; (98a4 <yield+0xcc>)
    987a:	str	r3, [r1, #0]
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    987c:	cbnz	r2, 9880 <yield+0xa8>
    987e:	cpsie	i
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
		}
		enableInterrupts(irq);
		first->_triggered = false;
    9880:	movs	r5, #0
    9882:	strb	r5, [r0, #29]
		(*(first->_function))(*first);
    9884:	ldr	r3, [r0, #8]
    9886:	blx	r3
		runningFromYield = false;
    9888:	strb	r5, [r4, #0]
    988a:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    988e:	nop
    9890:	.word	0x1fff1364
    9894:	.word	0x1fff8569
    9898:	.word	0x1fff1378
    989c:	.word	0x1fff8578
    98a0:	.word	0x1fff857c
    98a4:	.word	0x1fff8574
    98a8:	.word	0x1fff85a0
    98ac:	.word	0x1fff8588

000098b0 <DMAChannel::release()>:
	*p++ = 0;
}

void DMAChannel::release(void)
{
	if (channel >= DMA_MAX_CHANNELS) return;
    98b0:	ldrb	r3, [r0, #4]
    98b2:	cmp	r3, #15
    98b4:	bhi.n	98d8 <DMAChannel::release()+0x28>
	DMA_CERQ = channel;
    98b6:	ldr	r2, [pc, #36]	; (98dc <DMAChannel::release()+0x2c>)
    98b8:	strb	r3, [r2, #0]
	__disable_irq();
    98ba:	cpsid	i
	dma_channel_allocated_mask &= ~(1 << channel);
    98bc:	ldr	r1, [pc, #32]	; (98e0 <DMAChannel::release()+0x30>)
    98be:	ldrb	r2, [r0, #4]
    98c0:	movs	r3, #1
    98c2:	lsl.w	r2, r3, r2
    98c6:	ldrh	r3, [r1, #0]
    98c8:	bic.w	r3, r3, r2
    98cc:	strh	r3, [r1, #0]
	__enable_irq();
    98ce:	cpsie	i
	channel = DMA_MAX_CHANNELS;
    98d0:	movs	r3, #16
    98d2:	strb	r3, [r0, #4]
	TCD = (TCD_t *)0;
    98d4:	movs	r3, #0
    98d6:	str	r3, [r0, #0]
    98d8:	bx	lr
    98da:	nop
    98dc:	.word	0x4000801a
    98e0:	.word	0x1fff856a

000098e4 <MillisTimer::disableTimerInterrupt()>:
	volatile TimerStateType _state = TimerOff;
	static MillisTimer *listWaiting; // single linked list of waiting to start timers
	static MillisTimer *listActive;  // double linked list of running timers
	static bool disableTimerInterrupt() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    98e4:	mrs	r0, PRIMASK
		__disable_irq();
    98e8:	cpsid	i
		return (primask == 0) ? true : false;
	}
    98ea:	clz	r0, r0
    98ee:	lsrs	r0, r0, #5
    98f0:	bx	lr

000098f2 <MillisTimer::enableTimerInterrupt(bool)>:
	static void enableTimerInterrupt(bool doit) {
		if (doit) __enable_irq();
    98f2:	cbz	r0, 98f6 <MillisTimer::enableTimerInterrupt(bool)+0x4>
    98f4:	cpsie	i
    98f6:	bx	lr

000098f8 <EventResponder::runFromInterrupt()>:
{
	EventResponder::runFromInterrupt();
}

void EventResponder::runFromInterrupt()
{
    98f8:	push	{r3, r4, r5, r6, r7, lr}
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    98fa:	ldr	r6, [pc, #48]	; (992c <EventResponder::runFromInterrupt()+0x34>)
		if (first) {
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    98fc:	ldr	r7, [pc, #48]	; (9930 <EventResponder::runFromInterrupt()+0x38>)
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
    98fe:	movs	r5, #0
}

void EventResponder::runFromInterrupt()
{
	while (1) {
		bool irq = disableInterrupts();
    9900:	bl	98e4 <MillisTimer::disableTimerInterrupt()>
		EventResponder *first = firstInterrupt;
    9904:	ldr	r4, [r6, #0]
}

void EventResponder::runFromInterrupt()
{
	while (1) {
		bool irq = disableInterrupts();
    9906:	mov	r2, r0
		EventResponder *first = firstInterrupt;
		if (first) {
    9908:	cbz	r4, 9926 <EventResponder::runFromInterrupt()+0x2e>
			firstInterrupt = first->_next;
    990a:	ldr	r3, [r4, #20]
    990c:	str	r3, [r6, #0]
			if (firstInterrupt) {
    990e:	cbz	r3, 9914 <EventResponder::runFromInterrupt()+0x1c>
				firstInterrupt->_prev = nullptr;
    9910:	str	r5, [r3, #24]
    9912:	b.n	9916 <EventResponder::runFromInterrupt()+0x1e>
			} else {
				lastInterrupt = nullptr;
    9914:	str	r3, [r7, #0]
			}
			enableInterrupts(irq);
    9916:	mov	r0, r2
    9918:	bl	98f2 <MillisTimer::enableTimerInterrupt(bool)>
			first->_triggered = false;
    991c:	strb	r5, [r4, #29]
			(*(first->_function))(*first);
    991e:	ldr	r3, [r4, #8]
    9920:	mov	r0, r4
    9922:	blx	r3
	EventResponder::runFromInterrupt();
}

void EventResponder::runFromInterrupt()
{
	while (1) {
    9924:	b.n	9900 <EventResponder::runFromInterrupt()+0x8>
			}
			enableInterrupts(irq);
			first->_triggered = false;
			(*(first->_function))(*first);
		} else {
			enableInterrupts(irq);
    9926:	bl	98f2 <MillisTimer::enableTimerInterrupt(bool)>
    992a:	pop	{r3, r4, r5, r6, r7, pc}
    992c:	.word	0x1fff856c
    9930:	.word	0x1fff8570

00009934 <pendablesrvreq_isr>:
	enableInterrupts(irq);
}

void pendablesrvreq_isr(void)
{
	EventResponder::runFromInterrupt();
    9934:	b.w	98f8 <EventResponder::runFromInterrupt()>

00009938 <systick_isr>:

extern "C" volatile uint32_t systick_millis_count;

void systick_isr(void)
{
	systick_millis_count++;
    9938:	ldr	r2, [pc, #8]	; (9944 <systick_isr+0xc>)
    993a:	ldr	r3, [r2, #0]
    993c:	adds	r3, #1
    993e:	str	r3, [r2, #0]
    9940:	bx	lr
    9942:	nop
    9944:	.word	0x1fff8484

00009948 <usb_serial_class::clear()>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
    9948:	b.w	89ac <usb_serial_flush_input>

0000994c <usb_serial_class::peek()>:
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
    994c:	b.w	8958 <usb_serial_peekchar>

00009950 <usb_serial_class::read()>:
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
    9950:	b.w	890c <usb_serial_getchar>

00009954 <usb_serial_class::available()>:
				if (elapsed > 750) break;
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    9954:	b.w	8990 <usb_serial_available>

00009958 <usb_serial_class::flush()>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
    9958:	b.w	8b1c <usb_serial_flush_output>

0000995c <usb_serial_class::availableForWrite()>:
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
	size_t write(unsigned long n) { return write((uint8_t)n); }
	size_t write(long n) { return write((uint8_t)n); }
	size_t write(unsigned int n) { return write((uint8_t)n); }
	size_t write(int n) { return write((uint8_t)n); }
	virtual int availableForWrite() { return usb_serial_write_buffer_free(); }
    995c:	b.w	8ad4 <usb_serial_write_buffer_free>

00009960 <usb_serial_class::write(unsigned char const*, unsigned int)>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    9960:	mov	r0, r1
    9962:	mov	r1, r2
    9964:	b.w	89dc <usb_serial_write>

00009968 <usb_serial_class::write(unsigned char)>:
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
    9968:	mov	r0, r1
    996a:	b.w	8abc <usb_serial_putchar>

0000996e <Print::write(unsigned char const*, unsigned int)>:

#include <Arduino.h>


size_t Print::write(const uint8_t *buffer, size_t size)
{
    996e:	push	{r3, r4, r5, r6, r7, lr}
    9970:	mov	r7, r0
	if (buffer == nullptr) return 0;
    9972:	mov	r5, r1
    9974:	cbz	r1, 998e <Print::write(unsigned char const*, unsigned int)+0x20>
    9976:	adds	r6, r1, r2
    9978:	movs	r4, #0
	size_t count = 0;
	while (size--) count += write(*buffer++);
    997a:	cmp	r5, r6
    997c:	beq.n	9992 <Print::write(unsigned char const*, unsigned int)+0x24>
    997e:	ldr	r3, [r7, #0]
    9980:	ldrb.w	r1, [r5], #1
    9984:	ldr	r3, [r3, #0]
    9986:	mov	r0, r7
    9988:	blx	r3
    998a:	add	r4, r0
    998c:	b.n	997a <Print::write(unsigned char const*, unsigned int)+0xc>
#include <Arduino.h>


size_t Print::write(const uint8_t *buffer, size_t size)
{
	if (buffer == nullptr) return 0;
    998e:	mov	r0, r1
    9990:	pop	{r3, r4, r5, r6, r7, pc}
    9992:	mov	r0, r4
	size_t count = 0;
	while (size--) count += write(*buffer++);
	return count;
}
    9994:	pop	{r3, r4, r5, r6, r7, pc}
    9996:	Address 0x00009996 is out of bounds.


00009998 <Print::println()>:
	return printNumber(n, 10, sign);
}


size_t Print::println(void)
{
    9998:	push	{r0, r1, r2, lr}
	uint8_t buf[2]={'\r', '\n'};
    999a:	ldr	r3, [pc, #24]	; (99b4 <Print::println()+0x1c>)
    999c:	ldrh	r3, [r3, #0]
    999e:	strh.w	r3, [sp, #4]
	return write(buf, 2);
    99a2:	ldr	r3, [r0, #0]
    99a4:	movs	r2, #2
    99a6:	ldr	r3, [r3, #4]
    99a8:	add	r1, sp, #4
    99aa:	blx	r3
}
    99ac:	add	sp, #12
    99ae:	ldr.w	pc, [sp], #4
    99b2:	nop
    99b4:	.word	0x00012848

000099b8 <Print::printf(char const*, ...)>:
	return len;
}
}

int Print::printf(const char *format, ...)
{
    99b8:	push	{r1, r2, r3}
    99ba:	push	{r0, r1, lr}
    99bc:	add	r2, sp, #12
    99be:	ldr.w	r1, [r2], #4
	va_list ap;
	va_start(ap, format);
    99c2:	str	r2, [sp, #4]
#ifdef __STRICT_ANSI__
	va_end(ap);
	return 0;  // TODO: make this work with -std=c++0x
#else
	int retval = vdprintf((int)this, format, ap);
    99c4:	bl	eec8 <vdprintf>
	va_end(ap);
	return retval;
#endif
}
    99c8:	add	sp, #8
    99ca:	ldr.w	lr, [sp], #4
    99ce:	add	sp, #12
    99d0:	bx	lr

000099d2 <Print::printNumber(unsigned long, unsigned char, unsigned char)>:
}

#else

size_t Print::printNumber(unsigned long n, uint8_t base, uint8_t sign)
{
    99d2:	push	{r4, r5, r6, lr}
    99d4:	mov	r5, r0
    99d6:	sub	sp, #40	; 0x28
	uint8_t digit, i;

	// TODO: make these checks as inline, since base is
	// almost always a constant.  base = 0 (BYTE) should
	// inline as a call directly to write()
	if (base == 0) {
    99d8:	cbnz	r2, 99e4 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x12>
		return write((uint8_t)n);
    99da:	ldr	r3, [r0, #0]
    99dc:	uxtb	r1, r1
    99de:	ldr	r3, [r3, #0]
    99e0:	blx	r3
    99e2:	b.n	9a44 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x72>
	} else if (base == 1) {
		base = 10;
    99e4:	cmp	r2, #1
    99e6:	it	eq
    99e8:	moveq	r2, #10
	}


	if (n == 0) {
    99ea:	cbz	r1, 99f0 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x1e>
    99ec:	movs	r0, #33	; 0x21
    99ee:	b.n	99fa <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x28>
		buf[sizeof(buf) - 1] = '0';
    99f0:	movs	r2, #48	; 0x30
    99f2:	strb.w	r2, [sp, #37]	; 0x25
		i = sizeof(buf) - 1;
    99f6:	movs	r0, #33	; 0x21
    99f8:	b.n	9a24 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x52>
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
    99fa:	udiv	r6, r1, r2
    99fe:	mls	r1, r2, r6, r1
    9a02:	uxtb	r4, r1
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    9a04:	cmp	r1, #9
    9a06:	ite	ls
    9a08:	addls.w	r1, r4, #48	; 0x30
    9a0c:	addhi.w	r1, r4, #55	; 0x37
    9a10:	add	r4, sp, #40	; 0x28
    9a12:	add	r4, r0
    9a14:	uxtb	r1, r1
    9a16:	strb.w	r1, [r4, #-36]
			n /= base;
			if (n == 0) break;
    9a1a:	mov	r1, r6
    9a1c:	cbz	r6, 9a24 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x52>
			i--;
    9a1e:	subs	r0, #1
    9a20:	uxtb	r0, r0
	if (n == 0) {
		buf[sizeof(buf) - 1] = '0';
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
    9a22:	b.n	99fa <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x28>
			n /= base;
			if (n == 0) break;
			i--;
		}
	}
	if (sign) {
    9a24:	cbz	r3, 9a34 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x62>
		i--;
    9a26:	subs	r0, #1
    9a28:	uxtb	r0, r0
		buf[i] = '-';
    9a2a:	add	r3, sp, #40	; 0x28
    9a2c:	add	r3, r0
    9a2e:	movs	r2, #45	; 0x2d
    9a30:	strb.w	r2, [r3, #-36]
	}
	return write(buf + i, sizeof(buf) - i);
    9a34:	ldr	r3, [r5, #0]
    9a36:	add	r1, sp, #4
    9a38:	rsb	r2, r0, #34	; 0x22
    9a3c:	add	r1, r0
    9a3e:	ldr	r3, [r3, #4]
    9a40:	mov	r0, r5
    9a42:	blx	r3
}
    9a44:	add	sp, #40	; 0x28
    9a46:	pop	{r4, r5, r6, pc}

00009a48 <Print::print(long)>:

size_t Print::print(long n)
{
	uint8_t sign=0;

	if (n < 0) {
    9a48:	cmp	r1, #0
		sign = '-';
		n = -n;
    9a4a:	itte	lt
    9a4c:	neglt	r1, r1
size_t Print::print(long n)
{
	uint8_t sign=0;

	if (n < 0) {
		sign = '-';
    9a4e:	movlt	r3, #45	; 0x2d
}


size_t Print::print(long n)
{
	uint8_t sign=0;
    9a50:	movge	r3, #0

	if (n < 0) {
		sign = '-';
		n = -n;
	}
	return printNumber(n, 10, sign);
    9a52:	movs	r2, #10
    9a54:	b.w	99d2 <Print::printNumber(unsigned long, unsigned char, unsigned char)>

00009a58 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)>:
	if (n < 0) return printNumber64(-n, 10, 1);
	return printNumber64(n, 10, 0);
}

size_t Print::printNumber64(uint64_t n, uint8_t base, uint8_t sign)
{
    9a58:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    9a5c:	sub	sp, #72	; 0x48
    9a5e:	mov	r5, r0
    9a60:	ldrb.w	r8, [sp, #104]	; 0x68
    9a64:	ldrb.w	sl, [sp, #108]	; 0x6c
	uint8_t buf[66];
	uint8_t digit, i;

	if (base < 2) return 0;
    9a68:	cmp.w	r8, #1
	if (n < 0) return printNumber64(-n, 10, 1);
	return printNumber64(n, 10, 0);
}

size_t Print::printNumber64(uint64_t n, uint8_t base, uint8_t sign)
{
    9a6c:	mov	r6, r2
    9a6e:	mov	r7, r3
	uint8_t buf[66];
	uint8_t digit, i;

	if (base < 2) return 0;
    9a70:	bls.n	9af6 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x9e>
	if (n == 0) {
    9a72:	orrs.w	r3, r6, r7
    9a76:	beq.n	9a84 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x2c>
    9a78:	movs	r4, #65	; 0x41
		buf[sizeof(buf) - 1] = '0';
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
    9a7a:	uxtb.w	r8, r8
    9a7e:	mov.w	r9, #0
    9a82:	b.n	9a8e <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x36>
	uint8_t buf[66];
	uint8_t digit, i;

	if (base < 2) return 0;
	if (n == 0) {
		buf[sizeof(buf) - 1] = '0';
    9a84:	movs	r3, #48	; 0x30
    9a86:	strb.w	r3, [sp, #69]	; 0x45
		i = sizeof(buf) - 1;
    9a8a:	movs	r4, #65	; 0x41
    9a8c:	b.n	9ad0 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x78>
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
    9a8e:	mov	r0, r6
    9a90:	mov	r1, r7
    9a92:	mov	r2, r8
    9a94:	mov	r3, r9
    9a96:	bl	a6ec <__aeabi_uldivmod>
    9a9a:	mov	r1, r3
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    9a9c:	cmp	r1, #0
    9a9e:	it	eq
    9aa0:	cmpeq	r2, #10
		buf[sizeof(buf) - 1] = '0';
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
    9aa2:	uxtb	r3, r2
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    9aa4:	add	r2, sp, #72	; 0x48
    9aa6:	ite	cc
    9aa8:	addcc	r3, #48	; 0x30
    9aaa:	addcs	r3, #55	; 0x37
    9aac:	add	r2, r4
    9aae:	uxtb	r3, r3
    9ab0:	strb.w	r3, [r2, #-68]
			n /= base;
    9ab4:	mov	r0, r6
    9ab6:	mov	r3, r9
    9ab8:	mov	r1, r7
    9aba:	mov	r2, r8
    9abc:	bl	a6ec <__aeabi_uldivmod>
    9ac0:	mov	r6, r0
    9ac2:	mov	r7, r1
			if (n == 0) break;
    9ac4:	orrs.w	r3, r6, r7
    9ac8:	beq.n	9ad0 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x78>
			i--;
    9aca:	subs	r4, #1
    9acc:	uxtb	r4, r4
	if (n == 0) {
		buf[sizeof(buf) - 1] = '0';
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
    9ace:	b.n	9a8e <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x36>
			n /= base;
			if (n == 0) break;
			i--;
		}
	}
	if (sign) {
    9ad0:	cmp.w	sl, #0
    9ad4:	beq.n	9ae4 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x8c>
		i--;
    9ad6:	subs	r4, #1
    9ad8:	uxtb	r4, r4
		buf[i] = '-';
    9ada:	add	r3, sp, #72	; 0x48
    9adc:	add	r3, r4
    9ade:	movs	r2, #45	; 0x2d
    9ae0:	strb.w	r2, [r3, #-68]
	}
	return write(buf + i, sizeof(buf) - i);
    9ae4:	ldr	r3, [r5, #0]
    9ae6:	add	r1, sp, #4
    9ae8:	ldr	r3, [r3, #4]
    9aea:	rsb	r2, r4, #66	; 0x42
    9aee:	add	r1, r4
    9af0:	mov	r0, r5
    9af2:	blx	r3
    9af4:	b.n	9af8 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0xa0>
size_t Print::printNumber64(uint64_t n, uint8_t base, uint8_t sign)
{
	uint8_t buf[66];
	uint8_t digit, i;

	if (base < 2) return 0;
    9af6:	movs	r0, #0
	if (sign) {
		i--;
		buf[i] = '-';
	}
	return write(buf + i, sizeof(buf) - i);
}
    9af8:	add	sp, #72	; 0x48
    9afa:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

00009afe <main>:
 */

#include <Arduino.h>

extern "C" int main(void)
{
    9afe:	push	{r3, lr}
	}


#else
	// Arduino's main() function just calls setup() and loop()....
	setup();
    9b00:	bl	6f8 <setup>
	while (1) {
		loop();
    9b04:	bl	75c <loop>
		yield();
    9b08:	bl	97d8 <yield>
    9b0c:	b.n	9b04 <main+0x6>
    9b0e:	Address 0x00009b0e is out of bounds.


00009b10 <software_isr>:
void software_isr(void) // AudioStream::update_all()
{
	AudioStream *p;

#if defined(KINETISK)
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
    9b10:	ldr	r2, [pc, #88]	; (9b6c <software_isr+0x5c>)
}

AudioStream * AudioStream::first_update = NULL;

void software_isr(void) // AudioStream::update_all()
{
    9b12:	push	{r3, r4, r5, r6, r7, lr}
	AudioStream *p;

#if defined(KINETISK)
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
    9b14:	ldr	r3, [r2, #0]
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA;
	uint32_t totalcycles = ARM_DWT_CYCCNT;
    9b16:	ldr	r5, [pc, #88]	; (9b70 <software_isr+0x60>)
void software_isr(void) // AudioStream::update_all()
{
	AudioStream *p;

#if defined(KINETISK)
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
    9b18:	orr.w	r3, r3, #16777216	; 0x1000000
    9b1c:	str	r3, [r2, #0]
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA;
    9b1e:	ldr	r2, [pc, #84]	; (9b74 <software_isr+0x64>)
    9b20:	ldr	r3, [r2, #0]
    9b22:	orr.w	r3, r3, #1
    9b26:	str	r3, [r2, #0]
	uint32_t totalcycles = ARM_DWT_CYCCNT;
#elif defined(KINETISL)
	uint32_t totalcycles = micros();
#endif
	//digitalWriteFast(2, HIGH);
	for (p = AudioStream::first_update; p; p = p->next_update) {
    9b28:	ldr	r3, [pc, #76]	; (9b78 <software_isr+0x68>)
	AudioStream *p;

#if defined(KINETISK)
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA;
	uint32_t totalcycles = ARM_DWT_CYCCNT;
    9b2a:	ldr	r6, [r5, #0]
#elif defined(KINETISL)
	uint32_t totalcycles = micros();
#endif
	//digitalWriteFast(2, HIGH);
	for (p = AudioStream::first_update; p; p = p->next_update) {
    9b2c:	ldr	r4, [r3, #0]
    9b2e:	cbz	r4, 9b54 <software_isr+0x44>
		if (p->active) {
    9b30:	ldrb	r3, [r4, #8]
    9b32:	cbz	r3, 9b50 <software_isr+0x40>
			uint32_t cycles = ARM_DWT_CYCCNT;
			p->update();
    9b34:	ldr	r3, [r4, #0]
	uint32_t totalcycles = micros();
#endif
	//digitalWriteFast(2, HIGH);
	for (p = AudioStream::first_update; p; p = p->next_update) {
		if (p->active) {
			uint32_t cycles = ARM_DWT_CYCCNT;
    9b36:	ldr	r7, [r5, #0]
			p->update();
    9b38:	ldr	r3, [r3, #0]
    9b3a:	mov	r0, r4
    9b3c:	blx	r3
			// TODO: traverse inputQueueArray and release
			// any input blocks that weren't consumed?
			cycles = (ARM_DWT_CYCCNT - cycles) >> 4;
    9b3e:	ldr	r2, [r5, #0]
			p->cpu_cycles = cycles;
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
    9b40:	ldrh	r3, [r4, #6]
		if (p->active) {
			uint32_t cycles = ARM_DWT_CYCCNT;
			p->update();
			// TODO: traverse inputQueueArray and release
			// any input blocks that weren't consumed?
			cycles = (ARM_DWT_CYCCNT - cycles) >> 4;
    9b42:	subs	r2, r2, r7
    9b44:	lsrs	r2, r2, #4
			p->cpu_cycles = cycles;
    9b46:	uxth	r1, r2
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
    9b48:	cmp	r2, r3
			uint32_t cycles = ARM_DWT_CYCCNT;
			p->update();
			// TODO: traverse inputQueueArray and release
			// any input blocks that weren't consumed?
			cycles = (ARM_DWT_CYCCNT - cycles) >> 4;
			p->cpu_cycles = cycles;
    9b4a:	strh	r1, [r4, #4]
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
    9b4c:	it	hi
    9b4e:	strhhi	r1, [r4, #6]
	uint32_t totalcycles = ARM_DWT_CYCCNT;
#elif defined(KINETISL)
	uint32_t totalcycles = micros();
#endif
	//digitalWriteFast(2, HIGH);
	for (p = AudioStream::first_update; p; p = p->next_update) {
    9b50:	ldr	r4, [r4, #20]
    9b52:	b.n	9b2e <software_isr+0x1e>
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
		}
	}
	//digitalWriteFast(2, LOW);
#if defined(KINETISK)
	totalcycles = (ARM_DWT_CYCCNT - totalcycles) >> 4;
    9b54:	ldr	r3, [r5, #0]
#elif defined(KINETISL)
	totalcycles = micros() - totalcycles;
#endif
	AudioStream::cpu_cycles_total = totalcycles;
    9b56:	ldr	r2, [pc, #36]	; (9b7c <software_isr+0x6c>)
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
		}
	}
	//digitalWriteFast(2, LOW);
#if defined(KINETISK)
	totalcycles = (ARM_DWT_CYCCNT - totalcycles) >> 4;
    9b58:	subs	r3, r3, r6
    9b5a:	lsrs	r3, r3, #4
#elif defined(KINETISL)
	totalcycles = micros() - totalcycles;
#endif
	AudioStream::cpu_cycles_total = totalcycles;
    9b5c:	uxth	r1, r3
    9b5e:	strh	r1, [r2, #0]
	if (totalcycles > AudioStream::cpu_cycles_total_max)
    9b60:	ldr	r2, [pc, #28]	; (9b80 <software_isr+0x70>)
    9b62:	ldrh	r0, [r2, #0]
    9b64:	cmp	r3, r0
		AudioStream::cpu_cycles_total_max = totalcycles;
    9b66:	it	hi
    9b68:	strhhi	r1, [r2, #0]
    9b6a:	pop	{r3, r4, r5, r6, r7, pc}
    9b6c:	.word	0xe000edfc
    9b70:	.word	0xe0001004
    9b74:	.word	0xe0001000
    9b78:	.word	0x1fff8580
    9b7c:	.word	0x1fff8586
    9b80:	.word	0x1fff8584

00009b84 <Stream::timedRead()>:
#define PARSE_TIMEOUT 1000  // default number of milli-seconds to wait
#define NO_SKIP_CHAR  1  // a magic char not found in a valid ASCII numeric field

// private method to read stream with timeout
int Stream::timedRead()
{
    9b84:	push	{r0, r1, r4, r5, r6, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    9b86:	ldr	r3, [pc, #48]	; (9bb8 <Stream::timedRead()+0x34>)
    9b88:	ldr	r2, [r3, #0]
    9b8a:	str	r2, [sp, #0]
	return ret;
    9b8c:	ldr	r6, [sp, #0]
    9b8e:	mov	r4, r0
    9b90:	mov	r5, r3
  int c;
  unsigned long startMillis = millis();
  do {
    c = read();
    9b92:	ldr	r3, [r4, #0]
    9b94:	mov	r0, r4
    9b96:	ldr	r3, [r3, #20]
    9b98:	blx	r3
    if (c >= 0) return c;
    9b9a:	cmp	r0, #0
    9b9c:	bge.n	9bb4 <Stream::timedRead()+0x30>
    yield();
    9b9e:	bl	97d8 <yield>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    9ba2:	ldr	r3, [r5, #0]
    9ba4:	str	r3, [sp, #4]
	return ret;
    9ba6:	ldr	r3, [sp, #4]
// private method to read stream with timeout
int Stream::timedRead()
{
  int c;
  unsigned long startMillis = millis();
  do {
    9ba8:	ldr	r2, [r4, #8]
    9baa:	subs	r3, r3, r6
    9bac:	cmp	r3, r2
    9bae:	bcc.n	9b92 <Stream::timedRead()+0xe>
    c = read();
    if (c >= 0) return c;
    yield();
  } while(millis() - startMillis < _timeout);
  return -1;     // -1 indicates timeout
    9bb0:	mov.w	r0, #4294967295
}
    9bb4:	add	sp, #8
    9bb6:	pop	{r4, r5, r6, pc}
    9bb8:	.word	0x1fff8484

00009bbc <Stream::readBytesUntil(char, char*, unsigned int)>:
// as readBytes with terminator character
// terminates if length characters have been read, timeout, or if the terminator character  detected
// returns the number of characters placed in the buffer (0 means no valid data found)

size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)
{
    9bbc:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    9bc0:	mov	r7, r0
    9bc2:	mov	r9, r1
	if (buffer == nullptr) return 0;
    9bc4:	mov	r5, r2
    9bc6:	cbz	r2, 9bf6 <Stream::readBytesUntil(char, char*, unsigned int)+0x3a>
	if (length < 1) return 0;
    9bc8:	cbz	r3, 9bfa <Stream::readBytesUntil(char, char*, unsigned int)+0x3e>
	length--;
    9bca:	add.w	r8, r3, #4294967295
    9bce:	mov	r6, r2
    9bd0:	subs	r4, r6, r5
	size_t index = 0;
	while (index < length) {
    9bd2:	cmp	r8, r4
    9bd4:	bls.n	9bf0 <Stream::readBytesUntil(char, char*, unsigned int)+0x34>
		int c = timedRead();
    9bd6:	mov	r0, r7
    9bd8:	bl	9b84 <Stream::timedRead()>
		if (c == terminator) break;
    9bdc:	cmp	r0, r9
    9bde:	beq.n	9bf0 <Stream::readBytesUntil(char, char*, unsigned int)+0x34>
		if (c < 0) {
    9be0:	cmp	r0, #0
    9be2:	bge.n	9bea <Stream::readBytesUntil(char, char*, unsigned int)+0x2e>
	String readString(size_t max = 120);
	String readStringUntil(char terminator, size_t max = 120);
	int getReadError() { return read_error; }
	void clearReadError() { setReadError(0); }
  protected:
	void setReadError(int err = 1) { read_error = err; }
    9be4:	movs	r3, #1
    9be6:	strb	r3, [r7, #12]
    9be8:	b.n	9bf0 <Stream::readBytesUntil(char, char*, unsigned int)+0x34>
			setReadError();
			break;
		}
		*buffer++ = (char)c;
    9bea:	strb.w	r0, [r6], #1
{
	if (buffer == nullptr) return 0;
	if (length < 1) return 0;
	length--;
	size_t index = 0;
	while (index < length) {
    9bee:	b.n	9bd0 <Stream::readBytesUntil(char, char*, unsigned int)+0x14>
			break;
		}
		*buffer++ = (char)c;
		index++;
	}
	*buffer = 0;
    9bf0:	movs	r3, #0
    9bf2:	strb	r3, [r6, #0]
	return index; // return number of characters, not including null terminator
    9bf4:	b.n	9bfc <Stream::readBytesUntil(char, char*, unsigned int)+0x40>
// terminates if length characters have been read, timeout, or if the terminator character  detected
// returns the number of characters placed in the buffer (0 means no valid data found)

size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)
{
	if (buffer == nullptr) return 0;
    9bf6:	mov	r4, r2
    9bf8:	b.n	9bfc <Stream::readBytesUntil(char, char*, unsigned int)+0x40>
    9bfa:	mov	r4, r3
		*buffer++ = (char)c;
		index++;
	}
	*buffer = 0;
	return index; // return number of characters, not including null terminator
}
    9bfc:	mov	r0, r4
    9bfe:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00009c02 <serialEvent()>:

#include <Arduino.h>
void serialEvent() __attribute__((weak));
void serialEvent() {
    9c02:	bx	lr

00009c04 <operator new(unsigned int)>:
    9c04:	b.w	aabc <malloc>

00009c08 <operator delete(void*, unsigned int)>:
    9c08:	b.w	aacc <free>

00009c0c <usb_init_serialnumber>:
	{'M','T','P'}
};
#endif

void usb_init_serialnumber(void)
{
    9c0c:	push	{r0, r1, r2, r3, r4, lr}
	char buf[11];
	uint32_t i, num;

	__disable_irq();
    9c0e:	cpsid	i
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    9c10:	ldr	r3, [pc, #76]	; (9c60 <usb_init_serialnumber+0x54>)
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
    9c12:	ldr	r1, [pc, #80]	; (9c64 <usb_init_serialnumber+0x58>)
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    9c14:	movs	r2, #112	; 0x70
    9c16:	strb	r2, [r3, #0]
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
    9c18:	ldr	r2, [pc, #76]	; (9c68 <usb_init_serialnumber+0x5c>)
    9c1a:	str	r1, [r2, #0]
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
    9c1c:	movs	r2, #128	; 0x80
    9c1e:	strb	r2, [r3, #0]
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
    9c20:	ldrb	r2, [r3, #0]
    9c22:	lsls	r2, r2, #24
    9c24:	bpl.n	9c20 <usb_init_serialnumber+0x14>
	num = *(uint32_t *)&FTFL_FCCOBB;
    9c26:	ldr	r3, [pc, #68]	; (9c6c <usb_init_serialnumber+0x60>)
    9c28:	ldr	r0, [r3, #0]
	kinetis_hsrun_enable();
#endif
	__enable_irq();
    9c2a:	cpsie	i
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    9c2c:	ldr	r3, [pc, #64]	; (9c70 <usb_init_serialnumber+0x64>)
    9c2e:	cmp	r0, r3
    9c30:	it	ls
    9c32:	movls	r3, #10
	ultoa(num, buf, 10);
    9c34:	add	r4, sp, #4
	num = *(uint32_t *)&FTFL_FCCOBB;
	kinetis_hsrun_enable();
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    9c36:	it	ls
    9c38:	mulls	r0, r3
	ultoa(num, buf, 10);
    9c3a:	movs	r2, #10
    9c3c:	mov	r1, r4
    9c3e:	bl	9c7c <ultoa>
    9c42:	ldr	r2, [pc, #48]	; (9c74 <usb_init_serialnumber+0x68>)
	for (i=0; i<10; i++) {
    9c44:	movs	r3, #0
		char c = buf[i];
    9c46:	ldrb	r1, [r4, r3]
		if (!c) break;
    9c48:	cbz	r1, 9c54 <usb_init_serialnumber+0x48>
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    9c4a:	adds	r3, #1
    9c4c:	cmp	r3, #10
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
    9c4e:	strh.w	r1, [r2], #2
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    9c52:	bne.n	9c46 <usb_init_serialnumber+0x3a>
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    9c54:	ldr	r2, [pc, #32]	; (9c78 <usb_init_serialnumber+0x6c>)
    9c56:	adds	r3, #1
    9c58:	lsls	r3, r3, #1
    9c5a:	strb	r3, [r2, #0]
}
    9c5c:	add	sp, #16
    9c5e:	pop	{r4, pc}
    9c60:	.word	0x40020000
    9c64:	.word	0x41070000
    9c68:	.word	0x40020004
    9c6c:	.word	0x4002000c
    9c70:	.word	0x0098967f
    9c74:	.word	0x1fff1404
    9c78:	.word	0x1fff1402

00009c7c <ultoa>:
#include <stdlib.h>
#include <math.h>


char * ultoa(unsigned long val, char *buf, int radix)
{
    9c7c:	push	{r4, r5, lr}
    9c7e:	mov	r3, r0
	unsigned digit;
	int i=0, j;
    9c80:	movs	r0, #0
	char t;

	while (1) {
		digit = val % radix;
    9c82:	udiv	r4, r3, r2
    9c86:	mls	r3, r2, r4, r3
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    9c8a:	cmp	r3, #9
    9c8c:	ite	ls
    9c8e:	addls	r3, #48	; 0x30
    9c90:	addhi	r3, #55	; 0x37
    9c92:	uxtb	r3, r3
    9c94:	strb	r3, [r1, r0]
		val /= radix;
		if (val == 0) break;
    9c96:	mov	r3, r4
    9c98:	cbz	r4, 9c9e <ultoa+0x22>
		i++;
    9c9a:	adds	r0, #1
	}
    9c9c:	b.n	9c82 <ultoa+0x6>
	buf[i + 1] = 0;
    9c9e:	adds	r2, r1, r0
	for (j=0; j < i; j++, i--) {
    9ca0:	mov	r3, r4
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
    9ca2:	strb	r4, [r2, #1]
	for (j=0; j < i; j++, i--) {
    9ca4:	subs	r4, r0, r3
    9ca6:	cmp	r3, r4
    9ca8:	bge.n	9cb8 <ultoa+0x3c>
		t = buf[j];
    9caa:	ldrb	r4, [r1, r3]
		buf[j] = buf[i];
    9cac:	ldrb	r5, [r2, #0]
    9cae:	strb	r5, [r1, r3]
		buf[i] = t;
    9cb0:	strb.w	r4, [r2], #-1
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    9cb4:	adds	r3, #1
    9cb6:	b.n	9ca4 <ultoa+0x28>
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
	}
	return buf;
}
    9cb8:	mov	r0, r1
    9cba:	pop	{r4, r5, pc}

00009cbc <nanf>:
    9cbc:	vldr	s0, [pc, #4]	; 9cc4 <nanf+0x8>
    9cc0:	bx	lr
    9cc2:	nop
    9cc4:	.word	0x7fc00000

00009cc8 <__aeabi_atexit>:
    9cc8:	mov	r3, r1
    9cca:	mov	r1, r0
    9ccc:	mov	r0, r3
    9cce:	b.w	aa04 <__cxa_atexit>
    9cd2:	nop

00009cd4 <__aeabi_llsr>:
    9cd4:	lsrs	r0, r2
    9cd6:	adds	r3, r1, #0
    9cd8:	lsrs	r1, r2
    9cda:	mov	ip, r3
    9cdc:	subs	r2, #32
    9cde:	lsrs	r3, r2
    9ce0:	orrs	r0, r3
    9ce2:	negs	r2, r2
    9ce4:	mov	r3, ip
    9ce6:	lsls	r3, r2
    9ce8:	orrs	r0, r3
    9cea:	bx	lr

00009cec <__aeabi_drsub>:
    9cec:	eor.w	r1, r1, #2147483648	; 0x80000000
    9cf0:	b.n	9cf8 <__adddf3>
    9cf2:	nop

00009cf4 <__aeabi_dsub>:
    9cf4:	eor.w	r3, r3, #2147483648	; 0x80000000

00009cf8 <__adddf3>:
    9cf8:	push	{r4, r5, lr}
    9cfa:	mov.w	r4, r1, lsl #1
    9cfe:	mov.w	r5, r3, lsl #1
    9d02:	teq	r4, r5
    9d06:	it	eq
    9d08:	teqeq	r0, r2
    9d0c:	itttt	ne
    9d0e:	orrsne.w	ip, r4, r0
    9d12:	orrsne.w	ip, r5, r2
    9d16:	mvnsne.w	ip, r4, asr #21
    9d1a:	mvnsne.w	ip, r5, asr #21
    9d1e:	beq.w	9ee6 <__adddf3+0x1ee>
    9d22:	mov.w	r4, r4, lsr #21
    9d26:	rsbs	r5, r4, r5, lsr #21
    9d2a:	it	lt
    9d2c:	neglt	r5, r5
    9d2e:	ble.n	9d4a <__adddf3+0x52>
    9d30:	add	r4, r5
    9d32:	eor.w	r2, r0, r2
    9d36:	eor.w	r3, r1, r3
    9d3a:	eor.w	r0, r2, r0
    9d3e:	eor.w	r1, r3, r1
    9d42:	eor.w	r2, r0, r2
    9d46:	eor.w	r3, r1, r3
    9d4a:	cmp	r5, #54	; 0x36
    9d4c:	it	hi
    9d4e:	pophi	{r4, r5, pc}
    9d50:	tst.w	r1, #2147483648	; 0x80000000
    9d54:	mov.w	r1, r1, lsl #12
    9d58:	mov.w	ip, #1048576	; 0x100000
    9d5c:	orr.w	r1, ip, r1, lsr #12
    9d60:	beq.n	9d68 <__adddf3+0x70>
    9d62:	negs	r0, r0
    9d64:	sbc.w	r1, r1, r1, lsl #1
    9d68:	tst.w	r3, #2147483648	; 0x80000000
    9d6c:	mov.w	r3, r3, lsl #12
    9d70:	orr.w	r3, ip, r3, lsr #12
    9d74:	beq.n	9d7c <__adddf3+0x84>
    9d76:	negs	r2, r2
    9d78:	sbc.w	r3, r3, r3, lsl #1
    9d7c:	teq	r4, r5
    9d80:	beq.w	9ed2 <__adddf3+0x1da>
    9d84:	sub.w	r4, r4, #1
    9d88:	rsbs	lr, r5, #32
    9d8c:	blt.n	9daa <__adddf3+0xb2>
    9d8e:	lsl.w	ip, r2, lr
    9d92:	lsr.w	r2, r2, r5
    9d96:	adds	r0, r0, r2
    9d98:	adc.w	r1, r1, #0
    9d9c:	lsl.w	r2, r3, lr
    9da0:	adds	r0, r0, r2
    9da2:	asr.w	r3, r3, r5
    9da6:	adcs	r1, r3
    9da8:	b.n	9dc8 <__adddf3+0xd0>
    9daa:	sub.w	r5, r5, #32
    9dae:	add.w	lr, lr, #32
    9db2:	cmp	r2, #1
    9db4:	lsl.w	ip, r3, lr
    9db8:	it	cs
    9dba:	orrcs.w	ip, ip, #2
    9dbe:	asr.w	r3, r3, r5
    9dc2:	adds	r0, r0, r3
    9dc4:	adcs.w	r1, r1, r3, asr #31
    9dc8:	and.w	r5, r1, #2147483648	; 0x80000000
    9dcc:	bpl.n	9dde <__adddf3+0xe6>
    9dce:	mov.w	lr, #0
    9dd2:	rsbs	ip, ip, #0
    9dd6:	sbcs.w	r0, lr, r0
    9dda:	sbc.w	r1, lr, r1
    9dde:	cmp.w	r1, #1048576	; 0x100000
    9de2:	bcc.n	9e1c <__adddf3+0x124>
    9de4:	cmp.w	r1, #2097152	; 0x200000
    9de8:	bcc.n	9e04 <__adddf3+0x10c>
    9dea:	lsrs	r1, r1, #1
    9dec:	movs.w	r0, r0, rrx
    9df0:	mov.w	ip, ip, rrx
    9df4:	add.w	r4, r4, #1
    9df8:	mov.w	r2, r4, lsl #21
    9dfc:	cmn.w	r2, #4194304	; 0x400000
    9e00:	bcs.w	9f38 <__adddf3+0x240>
    9e04:	cmp.w	ip, #2147483648	; 0x80000000
    9e08:	it	eq
    9e0a:	movseq.w	ip, r0, lsr #1
    9e0e:	adcs.w	r0, r0, #0
    9e12:	adc.w	r1, r1, r4, lsl #20
    9e16:	orr.w	r1, r1, r5
    9e1a:	pop	{r4, r5, pc}
    9e1c:	movs.w	ip, ip, lsl #1
    9e20:	adcs	r0, r0
    9e22:	adc.w	r1, r1, r1
    9e26:	tst.w	r1, #1048576	; 0x100000
    9e2a:	sub.w	r4, r4, #1
    9e2e:	bne.n	9e04 <__adddf3+0x10c>
    9e30:	teq	r1, #0
    9e34:	itt	eq
    9e36:	moveq	r1, r0
    9e38:	moveq	r0, #0
    9e3a:	clz	r3, r1
    9e3e:	it	eq
    9e40:	addeq	r3, #32
    9e42:	sub.w	r3, r3, #11
    9e46:	subs.w	r2, r3, #32
    9e4a:	bge.n	9e66 <__adddf3+0x16e>
    9e4c:	adds	r2, #12
    9e4e:	ble.n	9e62 <__adddf3+0x16a>
    9e50:	add.w	ip, r2, #20
    9e54:	rsb	r2, r2, #12
    9e58:	lsl.w	r0, r1, ip
    9e5c:	lsr.w	r1, r1, r2
    9e60:	b.n	9e7c <__adddf3+0x184>
    9e62:	add.w	r2, r2, #20
    9e66:	it	le
    9e68:	rsble	ip, r2, #32
    9e6c:	lsl.w	r1, r1, r2
    9e70:	lsr.w	ip, r0, ip
    9e74:	itt	le
    9e76:	orrle.w	r1, r1, ip
    9e7a:	lslle	r0, r2
    9e7c:	subs	r4, r4, r3
    9e7e:	ittt	ge
    9e80:	addge.w	r1, r1, r4, lsl #20
    9e84:	orrge	r1, r5
    9e86:	popge	{r4, r5, pc}
    9e88:	mvn.w	r4, r4
    9e8c:	subs	r4, #31
    9e8e:	bge.n	9eca <__adddf3+0x1d2>
    9e90:	adds	r4, #12
    9e92:	bgt.n	9eb2 <__adddf3+0x1ba>
    9e94:	add.w	r4, r4, #20
    9e98:	rsb	r2, r4, #32
    9e9c:	lsr.w	r0, r0, r4
    9ea0:	lsl.w	r3, r1, r2
    9ea4:	orr.w	r0, r0, r3
    9ea8:	lsr.w	r3, r1, r4
    9eac:	orr.w	r1, r5, r3
    9eb0:	pop	{r4, r5, pc}
    9eb2:	rsb	r4, r4, #12
    9eb6:	rsb	r2, r4, #32
    9eba:	lsr.w	r0, r0, r2
    9ebe:	lsl.w	r3, r1, r4
    9ec2:	orr.w	r0, r0, r3
    9ec6:	mov	r1, r5
    9ec8:	pop	{r4, r5, pc}
    9eca:	lsr.w	r0, r1, r4
    9ece:	mov	r1, r5
    9ed0:	pop	{r4, r5, pc}
    9ed2:	teq	r4, #0
    9ed6:	eor.w	r3, r3, #1048576	; 0x100000
    9eda:	itte	eq
    9edc:	eoreq.w	r1, r1, #1048576	; 0x100000
    9ee0:	addeq	r4, #1
    9ee2:	subne	r5, #1
    9ee4:	b.n	9d84 <__adddf3+0x8c>
    9ee6:	mvns.w	ip, r4, asr #21
    9eea:	it	ne
    9eec:	mvnsne.w	ip, r5, asr #21
    9ef0:	beq.n	9f46 <__adddf3+0x24e>
    9ef2:	teq	r4, r5
    9ef6:	it	eq
    9ef8:	teqeq	r0, r2
    9efc:	beq.n	9f0a <__adddf3+0x212>
    9efe:	orrs.w	ip, r4, r0
    9f02:	itt	eq
    9f04:	moveq	r1, r3
    9f06:	moveq	r0, r2
    9f08:	pop	{r4, r5, pc}
    9f0a:	teq	r1, r3
    9f0e:	ittt	ne
    9f10:	movne	r1, #0
    9f12:	movne	r0, #0
    9f14:	popne	{r4, r5, pc}
    9f16:	movs.w	ip, r4, lsr #21
    9f1a:	bne.n	9f28 <__adddf3+0x230>
    9f1c:	lsls	r0, r0, #1
    9f1e:	adcs	r1, r1
    9f20:	it	cs
    9f22:	orrcs.w	r1, r1, #2147483648	; 0x80000000
    9f26:	pop	{r4, r5, pc}
    9f28:	adds.w	r4, r4, #4194304	; 0x400000
    9f2c:	itt	cc
    9f2e:	addcc.w	r1, r1, #1048576	; 0x100000
    9f32:	popcc	{r4, r5, pc}
    9f34:	and.w	r5, r1, #2147483648	; 0x80000000
    9f38:	orr.w	r1, r5, #2130706432	; 0x7f000000
    9f3c:	orr.w	r1, r1, #15728640	; 0xf00000
    9f40:	mov.w	r0, #0
    9f44:	pop	{r4, r5, pc}
    9f46:	mvns.w	ip, r4, asr #21
    9f4a:	itte	ne
    9f4c:	movne	r1, r3
    9f4e:	movne	r0, r2
    9f50:	mvnseq.w	ip, r5, asr #21
    9f54:	itt	ne
    9f56:	movne	r3, r1
    9f58:	movne	r2, r0
    9f5a:	orrs.w	r4, r0, r1, lsl #12
    9f5e:	itte	eq
    9f60:	orrseq.w	r5, r2, r3, lsl #12
    9f64:	teqeq	r1, r3
    9f68:	orrne.w	r1, r1, #524288	; 0x80000
    9f6c:	pop	{r4, r5, pc}
    9f6e:	nop

00009f70 <__aeabi_ui2d>:
    9f70:	teq	r0, #0
    9f74:	itt	eq
    9f76:	moveq	r1, #0
    9f78:	bxeq	lr
    9f7a:	push	{r4, r5, lr}
    9f7c:	mov.w	r4, #1024	; 0x400
    9f80:	add.w	r4, r4, #50	; 0x32
    9f84:	mov.w	r5, #0
    9f88:	mov.w	r1, #0
    9f8c:	b.n	9e30 <__adddf3+0x138>
    9f8e:	nop

00009f90 <__aeabi_i2d>:
    9f90:	teq	r0, #0
    9f94:	itt	eq
    9f96:	moveq	r1, #0
    9f98:	bxeq	lr
    9f9a:	push	{r4, r5, lr}
    9f9c:	mov.w	r4, #1024	; 0x400
    9fa0:	add.w	r4, r4, #50	; 0x32
    9fa4:	ands.w	r5, r0, #2147483648	; 0x80000000
    9fa8:	it	mi
    9faa:	negmi	r0, r0
    9fac:	mov.w	r1, #0
    9fb0:	b.n	9e30 <__adddf3+0x138>
    9fb2:	nop

00009fb4 <__aeabi_f2d>:
    9fb4:	lsls	r2, r0, #1
    9fb6:	mov.w	r1, r2, asr #3
    9fba:	mov.w	r1, r1, rrx
    9fbe:	mov.w	r0, r2, lsl #28
    9fc2:	itttt	ne
    9fc4:	andsne.w	r3, r2, #4278190080	; 0xff000000
    9fc8:	teqne	r3, #4278190080	; 0xff000000
    9fcc:	eorne.w	r1, r1, #939524096	; 0x38000000
    9fd0:	bxne	lr
    9fd2:	teq	r2, #0
    9fd6:	ite	ne
    9fd8:	teqne	r3, #4278190080	; 0xff000000
    9fdc:	bxeq	lr
    9fde:	push	{r4, r5, lr}
    9fe0:	mov.w	r4, #896	; 0x380
    9fe4:	and.w	r5, r1, #2147483648	; 0x80000000
    9fe8:	bic.w	r1, r1, #2147483648	; 0x80000000
    9fec:	b.n	9e30 <__adddf3+0x138>
    9fee:	nop

00009ff0 <__aeabi_ul2d>:
    9ff0:	orrs.w	r2, r0, r1
    9ff4:	it	eq
    9ff6:	bxeq	lr
    9ff8:	push	{r4, r5, lr}
    9ffa:	mov.w	r5, #0
    9ffe:	b.n	a016 <__aeabi_l2d+0x16>

0000a000 <__aeabi_l2d>:
    a000:	orrs.w	r2, r0, r1
    a004:	it	eq
    a006:	bxeq	lr
    a008:	push	{r4, r5, lr}
    a00a:	ands.w	r5, r1, #2147483648	; 0x80000000
    a00e:	bpl.n	a016 <__aeabi_l2d+0x16>
    a010:	negs	r0, r0
    a012:	sbc.w	r1, r1, r1, lsl #1
    a016:	mov.w	r4, #1024	; 0x400
    a01a:	add.w	r4, r4, #50	; 0x32
    a01e:	movs.w	ip, r1, lsr #22
    a022:	beq.w	9dde <__adddf3+0xe6>
    a026:	mov.w	r2, #3
    a02a:	movs.w	ip, ip, lsr #3
    a02e:	it	ne
    a030:	addne	r2, #3
    a032:	movs.w	ip, ip, lsr #3
    a036:	it	ne
    a038:	addne	r2, #3
    a03a:	add.w	r2, r2, ip, lsr #3
    a03e:	rsb	r3, r2, #32
    a042:	lsl.w	ip, r0, r3
    a046:	lsr.w	r0, r0, r2
    a04a:	lsl.w	lr, r1, r3
    a04e:	orr.w	r0, r0, lr
    a052:	lsr.w	r1, r1, r2
    a056:	add	r4, r2
    a058:	b.n	9dde <__adddf3+0xe6>
    a05a:	nop

0000a05c <__aeabi_dmul>:
    a05c:	push	{r4, r5, r6, lr}
    a05e:	mov.w	ip, #255	; 0xff
    a062:	orr.w	ip, ip, #1792	; 0x700
    a066:	ands.w	r4, ip, r1, lsr #20
    a06a:	ittte	ne
    a06c:	andsne.w	r5, ip, r3, lsr #20
    a070:	teqne	r4, ip
    a074:	teqne	r5, ip
    a078:	bleq	a238 <__aeabi_dmul+0x1dc>
    a07c:	add	r4, r5
    a07e:	eor.w	r6, r1, r3
    a082:	bic.w	r1, r1, ip, lsl #21
    a086:	bic.w	r3, r3, ip, lsl #21
    a08a:	orrs.w	r5, r0, r1, lsl #12
    a08e:	it	ne
    a090:	orrsne.w	r5, r2, r3, lsl #12
    a094:	orr.w	r1, r1, #1048576	; 0x100000
    a098:	orr.w	r3, r3, #1048576	; 0x100000
    a09c:	beq.n	a110 <__aeabi_dmul+0xb4>
    a09e:	umull	ip, lr, r0, r2
    a0a2:	mov.w	r5, #0
    a0a6:	umlal	lr, r5, r1, r2
    a0aa:	and.w	r2, r6, #2147483648	; 0x80000000
    a0ae:	umlal	lr, r5, r0, r3
    a0b2:	mov.w	r6, #0
    a0b6:	umlal	r5, r6, r1, r3
    a0ba:	teq	ip, #0
    a0be:	it	ne
    a0c0:	orrne.w	lr, lr, #1
    a0c4:	sub.w	r4, r4, #255	; 0xff
    a0c8:	cmp.w	r6, #512	; 0x200
    a0cc:	sbc.w	r4, r4, #768	; 0x300
    a0d0:	bcs.n	a0dc <__aeabi_dmul+0x80>
    a0d2:	movs.w	lr, lr, lsl #1
    a0d6:	adcs	r5, r5
    a0d8:	adc.w	r6, r6, r6
    a0dc:	orr.w	r1, r2, r6, lsl #11
    a0e0:	orr.w	r1, r1, r5, lsr #21
    a0e4:	mov.w	r0, r5, lsl #11
    a0e8:	orr.w	r0, r0, lr, lsr #21
    a0ec:	mov.w	lr, lr, lsl #11
    a0f0:	subs.w	ip, r4, #253	; 0xfd
    a0f4:	it	hi
    a0f6:	cmphi.w	ip, #1792	; 0x700
    a0fa:	bhi.n	a13a <__aeabi_dmul+0xde>
    a0fc:	cmp.w	lr, #2147483648	; 0x80000000
    a100:	it	eq
    a102:	movseq.w	lr, r0, lsr #1
    a106:	adcs.w	r0, r0, #0
    a10a:	adc.w	r1, r1, r4, lsl #20
    a10e:	pop	{r4, r5, r6, pc}
    a110:	and.w	r6, r6, #2147483648	; 0x80000000
    a114:	orr.w	r1, r6, r1
    a118:	orr.w	r0, r0, r2
    a11c:	eor.w	r1, r1, r3
    a120:	subs.w	r4, r4, ip, lsr #1
    a124:	ittt	gt
    a126:	rsbsgt	r5, r4, ip
    a12a:	orrgt.w	r1, r1, r4, lsl #20
    a12e:	popgt	{r4, r5, r6, pc}
    a130:	orr.w	r1, r1, #1048576	; 0x100000
    a134:	mov.w	lr, #0
    a138:	subs	r4, #1
    a13a:	bgt.w	a294 <__aeabi_dmul+0x238>
    a13e:	cmn.w	r4, #54	; 0x36
    a142:	ittt	le
    a144:	movle	r0, #0
    a146:	andle.w	r1, r1, #2147483648	; 0x80000000
    a14a:	pople	{r4, r5, r6, pc}
    a14c:	rsb	r4, r4, #0
    a150:	subs	r4, #32
    a152:	bge.n	a1c0 <__aeabi_dmul+0x164>
    a154:	adds	r4, #12
    a156:	bgt.n	a190 <__aeabi_dmul+0x134>
    a158:	add.w	r4, r4, #20
    a15c:	rsb	r5, r4, #32
    a160:	lsl.w	r3, r0, r5
    a164:	lsr.w	r0, r0, r4
    a168:	lsl.w	r2, r1, r5
    a16c:	orr.w	r0, r0, r2
    a170:	and.w	r2, r1, #2147483648	; 0x80000000
    a174:	bic.w	r1, r1, #2147483648	; 0x80000000
    a178:	adds.w	r0, r0, r3, lsr #31
    a17c:	lsr.w	r6, r1, r4
    a180:	adc.w	r1, r2, r6
    a184:	orrs.w	lr, lr, r3, lsl #1
    a188:	it	eq
    a18a:	biceq.w	r0, r0, r3, lsr #31
    a18e:	pop	{r4, r5, r6, pc}
    a190:	rsb	r4, r4, #12
    a194:	rsb	r5, r4, #32
    a198:	lsl.w	r3, r0, r4
    a19c:	lsr.w	r0, r0, r5
    a1a0:	lsl.w	r2, r1, r4
    a1a4:	orr.w	r0, r0, r2
    a1a8:	and.w	r1, r1, #2147483648	; 0x80000000
    a1ac:	adds.w	r0, r0, r3, lsr #31
    a1b0:	adc.w	r1, r1, #0
    a1b4:	orrs.w	lr, lr, r3, lsl #1
    a1b8:	it	eq
    a1ba:	biceq.w	r0, r0, r3, lsr #31
    a1be:	pop	{r4, r5, r6, pc}
    a1c0:	rsb	r5, r4, #32
    a1c4:	lsl.w	r2, r0, r5
    a1c8:	orr.w	lr, lr, r2
    a1cc:	lsr.w	r3, r0, r4
    a1d0:	lsl.w	r2, r1, r5
    a1d4:	orr.w	r3, r3, r2
    a1d8:	lsr.w	r0, r1, r4
    a1dc:	and.w	r1, r1, #2147483648	; 0x80000000
    a1e0:	lsr.w	r2, r1, r4
    a1e4:	bic.w	r0, r0, r2
    a1e8:	add.w	r0, r0, r3, lsr #31
    a1ec:	orrs.w	lr, lr, r3, lsl #1
    a1f0:	it	eq
    a1f2:	biceq.w	r0, r0, r3, lsr #31
    a1f6:	pop	{r4, r5, r6, pc}
    a1f8:	teq	r4, #0
    a1fc:	bne.n	a21e <__aeabi_dmul+0x1c2>
    a1fe:	and.w	r6, r1, #2147483648	; 0x80000000
    a202:	lsls	r0, r0, #1
    a204:	adc.w	r1, r1, r1
    a208:	tst.w	r1, #1048576	; 0x100000
    a20c:	it	eq
    a20e:	subeq	r4, #1
    a210:	beq.n	a202 <__aeabi_dmul+0x1a6>
    a212:	orr.w	r1, r1, r6
    a216:	teq	r5, #0
    a21a:	it	ne
    a21c:	bxne	lr
    a21e:	and.w	r6, r3, #2147483648	; 0x80000000
    a222:	lsls	r2, r2, #1
    a224:	adc.w	r3, r3, r3
    a228:	tst.w	r3, #1048576	; 0x100000
    a22c:	it	eq
    a22e:	subeq	r5, #1
    a230:	beq.n	a222 <__aeabi_dmul+0x1c6>
    a232:	orr.w	r3, r3, r6
    a236:	bx	lr
    a238:	teq	r4, ip
    a23c:	and.w	r5, ip, r3, lsr #20
    a240:	it	ne
    a242:	teqne	r5, ip
    a246:	beq.n	a262 <__aeabi_dmul+0x206>
    a248:	orrs.w	r6, r0, r1, lsl #1
    a24c:	it	ne
    a24e:	orrsne.w	r6, r2, r3, lsl #1
    a252:	bne.n	a1f8 <__aeabi_dmul+0x19c>
    a254:	eor.w	r1, r1, r3
    a258:	and.w	r1, r1, #2147483648	; 0x80000000
    a25c:	mov.w	r0, #0
    a260:	pop	{r4, r5, r6, pc}
    a262:	orrs.w	r6, r0, r1, lsl #1
    a266:	itte	eq
    a268:	moveq	r0, r2
    a26a:	moveq	r1, r3
    a26c:	orrsne.w	r6, r2, r3, lsl #1
    a270:	beq.n	a2a6 <__aeabi_dmul+0x24a>
    a272:	teq	r4, ip
    a276:	bne.n	a27e <__aeabi_dmul+0x222>
    a278:	orrs.w	r6, r0, r1, lsl #12
    a27c:	bne.n	a2a6 <__aeabi_dmul+0x24a>
    a27e:	teq	r5, ip
    a282:	bne.n	a290 <__aeabi_dmul+0x234>
    a284:	orrs.w	r6, r2, r3, lsl #12
    a288:	itt	ne
    a28a:	movne	r0, r2
    a28c:	movne	r1, r3
    a28e:	bne.n	a2a6 <__aeabi_dmul+0x24a>
    a290:	eor.w	r1, r1, r3
    a294:	and.w	r1, r1, #2147483648	; 0x80000000
    a298:	orr.w	r1, r1, #2130706432	; 0x7f000000
    a29c:	orr.w	r1, r1, #15728640	; 0xf00000
    a2a0:	mov.w	r0, #0
    a2a4:	pop	{r4, r5, r6, pc}
    a2a6:	orr.w	r1, r1, #2130706432	; 0x7f000000
    a2aa:	orr.w	r1, r1, #16252928	; 0xf80000
    a2ae:	pop	{r4, r5, r6, pc}

0000a2b0 <__aeabi_ddiv>:
    a2b0:	push	{r4, r5, r6, lr}
    a2b2:	mov.w	ip, #255	; 0xff
    a2b6:	orr.w	ip, ip, #1792	; 0x700
    a2ba:	ands.w	r4, ip, r1, lsr #20
    a2be:	ittte	ne
    a2c0:	andsne.w	r5, ip, r3, lsr #20
    a2c4:	teqne	r4, ip
    a2c8:	teqne	r5, ip
    a2cc:	bleq	a41e <__aeabi_ddiv+0x16e>
    a2d0:	sub.w	r4, r4, r5
    a2d4:	eor.w	lr, r1, r3
    a2d8:	orrs.w	r5, r2, r3, lsl #12
    a2dc:	mov.w	r1, r1, lsl #12
    a2e0:	beq.w	a3f4 <__aeabi_ddiv+0x144>
    a2e4:	mov.w	r3, r3, lsl #12
    a2e8:	mov.w	r5, #268435456	; 0x10000000
    a2ec:	orr.w	r3, r5, r3, lsr #4
    a2f0:	orr.w	r3, r3, r2, lsr #24
    a2f4:	mov.w	r2, r2, lsl #8
    a2f8:	orr.w	r5, r5, r1, lsr #4
    a2fc:	orr.w	r5, r5, r0, lsr #24
    a300:	mov.w	r6, r0, lsl #8
    a304:	and.w	r1, lr, #2147483648	; 0x80000000
    a308:	cmp	r5, r3
    a30a:	it	eq
    a30c:	cmpeq	r6, r2
    a30e:	adc.w	r4, r4, #253	; 0xfd
    a312:	add.w	r4, r4, #768	; 0x300
    a316:	bcs.n	a31e <__aeabi_ddiv+0x6e>
    a318:	lsrs	r3, r3, #1
    a31a:	mov.w	r2, r2, rrx
    a31e:	subs	r6, r6, r2
    a320:	sbc.w	r5, r5, r3
    a324:	lsrs	r3, r3, #1
    a326:	mov.w	r2, r2, rrx
    a32a:	mov.w	r0, #1048576	; 0x100000
    a32e:	mov.w	ip, #524288	; 0x80000
    a332:	subs.w	lr, r6, r2
    a336:	sbcs.w	lr, r5, r3
    a33a:	ittt	cs
    a33c:	subcs	r6, r6, r2
    a33e:	movcs	r5, lr
    a340:	orrcs.w	r0, r0, ip
    a344:	lsrs	r3, r3, #1
    a346:	mov.w	r2, r2, rrx
    a34a:	subs.w	lr, r6, r2
    a34e:	sbcs.w	lr, r5, r3
    a352:	ittt	cs
    a354:	subcs	r6, r6, r2
    a356:	movcs	r5, lr
    a358:	orrcs.w	r0, r0, ip, lsr #1
    a35c:	lsrs	r3, r3, #1
    a35e:	mov.w	r2, r2, rrx
    a362:	subs.w	lr, r6, r2
    a366:	sbcs.w	lr, r5, r3
    a36a:	ittt	cs
    a36c:	subcs	r6, r6, r2
    a36e:	movcs	r5, lr
    a370:	orrcs.w	r0, r0, ip, lsr #2
    a374:	lsrs	r3, r3, #1
    a376:	mov.w	r2, r2, rrx
    a37a:	subs.w	lr, r6, r2
    a37e:	sbcs.w	lr, r5, r3
    a382:	ittt	cs
    a384:	subcs	r6, r6, r2
    a386:	movcs	r5, lr
    a388:	orrcs.w	r0, r0, ip, lsr #3
    a38c:	orrs.w	lr, r5, r6
    a390:	beq.n	a3c4 <__aeabi_ddiv+0x114>
    a392:	mov.w	r5, r5, lsl #4
    a396:	orr.w	r5, r5, r6, lsr #28
    a39a:	mov.w	r6, r6, lsl #4
    a39e:	mov.w	r3, r3, lsl #3
    a3a2:	orr.w	r3, r3, r2, lsr #29
    a3a6:	mov.w	r2, r2, lsl #3
    a3aa:	movs.w	ip, ip, lsr #4
    a3ae:	bne.n	a332 <__aeabi_ddiv+0x82>
    a3b0:	tst.w	r1, #1048576	; 0x100000
    a3b4:	bne.n	a3ce <__aeabi_ddiv+0x11e>
    a3b6:	orr.w	r1, r1, r0
    a3ba:	mov.w	r0, #0
    a3be:	mov.w	ip, #2147483648	; 0x80000000
    a3c2:	b.n	a332 <__aeabi_ddiv+0x82>
    a3c4:	tst.w	r1, #1048576	; 0x100000
    a3c8:	itt	eq
    a3ca:	orreq	r1, r0
    a3cc:	moveq	r0, #0
    a3ce:	subs.w	ip, r4, #253	; 0xfd
    a3d2:	it	hi
    a3d4:	cmphi.w	ip, #1792	; 0x700
    a3d8:	bhi.w	a13a <__aeabi_dmul+0xde>
    a3dc:	subs.w	ip, r5, r3
    a3e0:	itt	eq
    a3e2:	subseq.w	ip, r6, r2
    a3e6:	movseq.w	ip, r0, lsr #1
    a3ea:	adcs.w	r0, r0, #0
    a3ee:	adc.w	r1, r1, r4, lsl #20
    a3f2:	pop	{r4, r5, r6, pc}
    a3f4:	and.w	lr, lr, #2147483648	; 0x80000000
    a3f8:	orr.w	r1, lr, r1, lsr #12
    a3fc:	adds.w	r4, r4, ip, lsr #1
    a400:	ittt	gt
    a402:	rsbsgt	r5, r4, ip
    a406:	orrgt.w	r1, r1, r4, lsl #20
    a40a:	popgt	{r4, r5, r6, pc}
    a40c:	orr.w	r1, r1, #1048576	; 0x100000
    a410:	mov.w	lr, #0
    a414:	subs	r4, #1
    a416:	b.n	a13a <__aeabi_dmul+0xde>
    a418:	orr.w	lr, r5, r6
    a41c:	b.n	a13a <__aeabi_dmul+0xde>
    a41e:	and.w	r5, ip, r3, lsr #20
    a422:	teq	r4, ip
    a426:	it	eq
    a428:	teqeq	r5, ip
    a42c:	beq.w	a2a6 <__aeabi_dmul+0x24a>
    a430:	teq	r4, ip
    a434:	bne.n	a44c <__aeabi_ddiv+0x19c>
    a436:	orrs.w	r4, r0, r1, lsl #12
    a43a:	bne.w	a2a6 <__aeabi_dmul+0x24a>
    a43e:	teq	r5, ip
    a442:	bne.w	a290 <__aeabi_dmul+0x234>
    a446:	mov	r0, r2
    a448:	mov	r1, r3
    a44a:	b.n	a2a6 <__aeabi_dmul+0x24a>
    a44c:	teq	r5, ip
    a450:	bne.n	a460 <__aeabi_ddiv+0x1b0>
    a452:	orrs.w	r5, r2, r3, lsl #12
    a456:	beq.w	a254 <__aeabi_dmul+0x1f8>
    a45a:	mov	r0, r2
    a45c:	mov	r1, r3
    a45e:	b.n	a2a6 <__aeabi_dmul+0x24a>
    a460:	orrs.w	r6, r0, r1, lsl #1
    a464:	it	ne
    a466:	orrsne.w	r6, r2, r3, lsl #1
    a46a:	bne.w	a1f8 <__aeabi_dmul+0x19c>
    a46e:	orrs.w	r4, r0, r1, lsl #1
    a472:	bne.w	a290 <__aeabi_dmul+0x234>
    a476:	orrs.w	r5, r2, r3, lsl #1
    a47a:	bne.w	a254 <__aeabi_dmul+0x1f8>
    a47e:	b.n	a2a6 <__aeabi_dmul+0x24a>

0000a480 <__gedf2>:
    a480:	mov.w	ip, #4294967295
    a484:	b.n	a494 <__cmpdf2+0x4>
    a486:	nop

0000a488 <__ledf2>:
    a488:	mov.w	ip, #1
    a48c:	b.n	a494 <__cmpdf2+0x4>
    a48e:	nop

0000a490 <__cmpdf2>:
    a490:	mov.w	ip, #1
    a494:	str.w	ip, [sp, #-4]!
    a498:	mov.w	ip, r1, lsl #1
    a49c:	mvns.w	ip, ip, asr #21
    a4a0:	mov.w	ip, r3, lsl #1
    a4a4:	it	ne
    a4a6:	mvnsne.w	ip, ip, asr #21
    a4aa:	beq.n	a4e4 <__cmpdf2+0x54>
    a4ac:	add	sp, #4
    a4ae:	orrs.w	ip, r0, r1, lsl #1
    a4b2:	ite	eq
    a4b4:	orrseq.w	ip, r2, r3, lsl #1
    a4b8:	teqne	r1, r3
    a4bc:	ittt	eq
    a4be:	teqeq	r0, r2
    a4c2:	moveq	r0, #0
    a4c4:	bxeq	lr
    a4c6:	cmn.w	r0, #0
    a4ca:	teq	r1, r3
    a4ce:	it	pl
    a4d0:	cmppl	r1, r3
    a4d2:	it	eq
    a4d4:	cmpeq	r0, r2
    a4d6:	ite	cs
    a4d8:	asrcs	r0, r3, #31
    a4da:	mvncc.w	r0, r3, asr #31
    a4de:	orr.w	r0, r0, #1
    a4e2:	bx	lr
    a4e4:	mov.w	ip, r1, lsl #1
    a4e8:	mvns.w	ip, ip, asr #21
    a4ec:	bne.n	a4f4 <__cmpdf2+0x64>
    a4ee:	orrs.w	ip, r0, r1, lsl #12
    a4f2:	bne.n	a504 <__cmpdf2+0x74>
    a4f4:	mov.w	ip, r3, lsl #1
    a4f8:	mvns.w	ip, ip, asr #21
    a4fc:	bne.n	a4ac <__cmpdf2+0x1c>
    a4fe:	orrs.w	ip, r2, r3, lsl #12
    a502:	beq.n	a4ac <__cmpdf2+0x1c>
    a504:	ldr.w	r0, [sp], #4
    a508:	bx	lr
    a50a:	nop

0000a50c <__aeabi_cdrcmple>:
    a50c:	mov	ip, r0
    a50e:	mov	r0, r2
    a510:	mov	r2, ip
    a512:	mov	ip, r1
    a514:	mov	r1, r3
    a516:	mov	r3, ip
    a518:	b.n	a51c <__aeabi_cdcmpeq>
    a51a:	nop

0000a51c <__aeabi_cdcmpeq>:
    a51c:	push	{r0, lr}
    a51e:	bl	a490 <__cmpdf2>
    a522:	cmp	r0, #0
    a524:	it	mi
    a526:	cmnmi.w	r0, #0
    a52a:	pop	{r0, pc}

0000a52c <__aeabi_dcmpeq>:
    a52c:	str.w	lr, [sp, #-8]!
    a530:	bl	a51c <__aeabi_cdcmpeq>
    a534:	ite	eq
    a536:	moveq	r0, #1
    a538:	movne	r0, #0
    a53a:	ldr.w	pc, [sp], #8
    a53e:	nop

0000a540 <__aeabi_dcmplt>:
    a540:	str.w	lr, [sp, #-8]!
    a544:	bl	a51c <__aeabi_cdcmpeq>
    a548:	ite	cc
    a54a:	movcc	r0, #1
    a54c:	movcs	r0, #0
    a54e:	ldr.w	pc, [sp], #8
    a552:	nop

0000a554 <__aeabi_dcmple>:
    a554:	str.w	lr, [sp, #-8]!
    a558:	bl	a51c <__aeabi_cdcmpeq>
    a55c:	ite	ls
    a55e:	movls	r0, #1
    a560:	movhi	r0, #0
    a562:	ldr.w	pc, [sp], #8
    a566:	nop

0000a568 <__aeabi_dcmpge>:
    a568:	str.w	lr, [sp, #-8]!
    a56c:	bl	a50c <__aeabi_cdrcmple>
    a570:	ite	ls
    a572:	movls	r0, #1
    a574:	movhi	r0, #0
    a576:	ldr.w	pc, [sp], #8
    a57a:	nop

0000a57c <__aeabi_dcmpgt>:
    a57c:	str.w	lr, [sp, #-8]!
    a580:	bl	a50c <__aeabi_cdrcmple>
    a584:	ite	cc
    a586:	movcc	r0, #1
    a588:	movcs	r0, #0
    a58a:	ldr.w	pc, [sp], #8
    a58e:	nop

0000a590 <__aeabi_dcmpun>:
    a590:	mov.w	ip, r1, lsl #1
    a594:	mvns.w	ip, ip, asr #21
    a598:	bne.n	a5a0 <__aeabi_dcmpun+0x10>
    a59a:	orrs.w	ip, r0, r1, lsl #12
    a59e:	bne.n	a5b6 <__aeabi_dcmpun+0x26>
    a5a0:	mov.w	ip, r3, lsl #1
    a5a4:	mvns.w	ip, ip, asr #21
    a5a8:	bne.n	a5b0 <__aeabi_dcmpun+0x20>
    a5aa:	orrs.w	ip, r2, r3, lsl #12
    a5ae:	bne.n	a5b6 <__aeabi_dcmpun+0x26>
    a5b0:	mov.w	r0, #0
    a5b4:	bx	lr
    a5b6:	mov.w	r0, #1
    a5ba:	bx	lr

0000a5bc <__aeabi_d2iz>:
    a5bc:	mov.w	r2, r1, lsl #1
    a5c0:	adds.w	r2, r2, #2097152	; 0x200000
    a5c4:	bcs.n	a5f2 <__aeabi_d2iz+0x36>
    a5c6:	bpl.n	a5ec <__aeabi_d2iz+0x30>
    a5c8:	mvn.w	r3, #992	; 0x3e0
    a5cc:	subs.w	r2, r3, r2, asr #21
    a5d0:	bls.n	a5f8 <__aeabi_d2iz+0x3c>
    a5d2:	mov.w	r3, r1, lsl #11
    a5d6:	orr.w	r3, r3, #2147483648	; 0x80000000
    a5da:	orr.w	r3, r3, r0, lsr #21
    a5de:	tst.w	r1, #2147483648	; 0x80000000
    a5e2:	lsr.w	r0, r3, r2
    a5e6:	it	ne
    a5e8:	negne	r0, r0
    a5ea:	bx	lr
    a5ec:	mov.w	r0, #0
    a5f0:	bx	lr
    a5f2:	orrs.w	r0, r0, r1, lsl #12
    a5f6:	bne.n	a604 <__aeabi_d2iz+0x48>
    a5f8:	ands.w	r0, r1, #2147483648	; 0x80000000
    a5fc:	it	eq
    a5fe:	mvneq.w	r0, #2147483648	; 0x80000000
    a602:	bx	lr
    a604:	mov.w	r0, #0
    a608:	bx	lr
    a60a:	nop

0000a60c <__aeabi_d2uiz>:
    a60c:	lsls	r2, r1, #1
    a60e:	bcs.n	a634 <__aeabi_d2uiz+0x28>
    a610:	adds.w	r2, r2, #2097152	; 0x200000
    a614:	bcs.n	a63a <__aeabi_d2uiz+0x2e>
    a616:	bpl.n	a634 <__aeabi_d2uiz+0x28>
    a618:	mvn.w	r3, #992	; 0x3e0
    a61c:	subs.w	r2, r3, r2, asr #21
    a620:	bmi.n	a640 <__aeabi_d2uiz+0x34>
    a622:	mov.w	r3, r1, lsl #11
    a626:	orr.w	r3, r3, #2147483648	; 0x80000000
    a62a:	orr.w	r3, r3, r0, lsr #21
    a62e:	lsr.w	r0, r3, r2
    a632:	bx	lr
    a634:	mov.w	r0, #0
    a638:	bx	lr
    a63a:	orrs.w	r0, r0, r1, lsl #12
    a63e:	bne.n	a646 <__aeabi_d2uiz+0x3a>
    a640:	mov.w	r0, #4294967295
    a644:	bx	lr
    a646:	mov.w	r0, #0
    a64a:	bx	lr

0000a64c <__aeabi_d2f>:
    a64c:	mov.w	r2, r1, lsl #1
    a650:	subs.w	r3, r2, #1879048192	; 0x70000000
    a654:	itt	cs
    a656:	subscs.w	ip, r3, #2097152	; 0x200000
    a65a:	rsbscs	ip, ip, #532676608	; 0x1fc00000
    a65e:	bls.n	a67c <__aeabi_d2f+0x30>
    a660:	and.w	ip, r1, #2147483648	; 0x80000000
    a664:	mov.w	r2, r0, lsl #3
    a668:	orr.w	r0, ip, r0, lsr #29
    a66c:	cmp.w	r2, #2147483648	; 0x80000000
    a670:	adc.w	r0, r0, r3, lsl #2
    a674:	it	eq
    a676:	biceq.w	r0, r0, #1
    a67a:	bx	lr
    a67c:	tst.w	r1, #1073741824	; 0x40000000
    a680:	bne.n	a6c6 <__aeabi_d2f+0x7a>
    a682:	adds.w	r2, r3, #48234496	; 0x2e00000
    a686:	itt	lt
    a688:	andlt.w	r0, r1, #2147483648	; 0x80000000
    a68c:	bxlt	lr
    a68e:	orr.w	r1, r1, #1048576	; 0x100000
    a692:	mov.w	r2, r2, lsr #21
    a696:	rsb	r2, r2, #24
    a69a:	rsb	ip, r2, #32
    a69e:	lsls.w	r3, r0, ip
    a6a2:	lsr.w	r0, r0, r2
    a6a6:	it	ne
    a6a8:	orrne.w	r0, r0, #1
    a6ac:	mov.w	r3, r1, lsl #11
    a6b0:	mov.w	r3, r3, lsr #11
    a6b4:	lsl.w	ip, r3, ip
    a6b8:	orr.w	r0, r0, ip
    a6bc:	lsr.w	r3, r3, r2
    a6c0:	mov.w	r3, r3, lsl #1
    a6c4:	b.n	a660 <__aeabi_d2f+0x14>
    a6c6:	mvns.w	r3, r2, asr #21
    a6ca:	bne.n	a6dc <__aeabi_d2f+0x90>
    a6cc:	orrs.w	r3, r0, r1, lsl #12
    a6d0:	ittt	ne
    a6d2:	movne.w	r0, #2130706432	; 0x7f000000
    a6d6:	orrne.w	r0, r0, #12582912	; 0xc00000
    a6da:	bxne	lr
    a6dc:	and.w	r0, r1, #2147483648	; 0x80000000
    a6e0:	orr.w	r0, r0, #2130706432	; 0x7f000000
    a6e4:	orr.w	r0, r0, #8388608	; 0x800000
    a6e8:	bx	lr
    a6ea:	nop

0000a6ec <__aeabi_uldivmod>:
    a6ec:	cbnz	r3, a704 <__aeabi_uldivmod+0x18>
    a6ee:	cbnz	r2, a704 <__aeabi_uldivmod+0x18>
    a6f0:	cmp	r1, #0
    a6f2:	it	eq
    a6f4:	cmpeq	r0, #0
    a6f6:	itt	ne
    a6f8:	movne.w	r1, #4294967295
    a6fc:	movne.w	r0, #4294967295
    a700:	b.w	aa00 <__aeabi_idiv0>
    a704:	sub.w	ip, sp, #8
    a708:	strd	ip, lr, [sp, #-16]!
    a70c:	bl	a71c <__udivmoddi4>
    a710:	ldr.w	lr, [sp, #4]
    a714:	ldrd	r2, r3, [sp, #8]
    a718:	add	sp, #16
    a71a:	bx	lr

0000a71c <__udivmoddi4>:
    a71c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    a720:	mov	ip, r1
    a722:	mov	r6, r1
    a724:	mov	r4, r0
    a726:	ldr	r5, [sp, #32]
    a728:	cmp	r3, #0
    a72a:	bne.n	a7ce <__udivmoddi4+0xb2>
    a72c:	cmp	r2, r1
    a72e:	mov	r7, r2
    a730:	bls.n	a80c <__udivmoddi4+0xf0>
    a732:	clz	lr, r2
    a736:	cmp.w	lr, #0
    a73a:	beq.n	a754 <__udivmoddi4+0x38>
    a73c:	rsb	r4, lr, #32
    a740:	lsr.w	r4, r0, r4
    a744:	lsl.w	r6, r1, lr
    a748:	orr.w	ip, r4, r6
    a74c:	lsl.w	r7, r2, lr
    a750:	lsl.w	r4, r0, lr
    a754:	mov.w	r9, r7, lsr #16
    a758:	lsrs	r2, r4, #16
    a75a:	udiv	r0, ip, r9
    a75e:	uxth.w	r8, r7
    a762:	mls	r6, r9, r0, ip
    a766:	orr.w	r6, r2, r6, lsl #16
    a76a:	mul.w	r3, r0, r8
    a76e:	cmp	r3, r6
    a770:	bls.n	a786 <__udivmoddi4+0x6a>
    a772:	adds	r6, r6, r7
    a774:	add.w	r2, r0, #4294967295
    a778:	bcs.w	a9c0 <__udivmoddi4+0x2a4>
    a77c:	cmp	r3, r6
    a77e:	bls.w	a9c0 <__udivmoddi4+0x2a4>
    a782:	subs	r0, #2
    a784:	add	r6, r7
    a786:	subs	r6, r6, r3
    a788:	uxth	r2, r4
    a78a:	udiv	r3, r6, r9
    a78e:	mls	r6, r9, r3, r6
    a792:	orr.w	r4, r2, r6, lsl #16
    a796:	mul.w	r8, r3, r8
    a79a:	cmp	r8, r4
    a79c:	bls.n	a7b2 <__udivmoddi4+0x96>
    a79e:	adds	r4, r4, r7
    a7a0:	add.w	r2, r3, #4294967295
    a7a4:	bcs.w	a9bc <__udivmoddi4+0x2a0>
    a7a8:	cmp	r8, r4
    a7aa:	bls.w	a9bc <__udivmoddi4+0x2a0>
    a7ae:	subs	r3, #2
    a7b0:	add	r4, r7
    a7b2:	rsb	r4, r8, r4
    a7b6:	orr.w	r0, r3, r0, lsl #16
    a7ba:	movs	r1, #0
    a7bc:	cmp	r5, #0
    a7be:	beq.n	a886 <__udivmoddi4+0x16a>
    a7c0:	lsr.w	r4, r4, lr
    a7c4:	movs	r3, #0
    a7c6:	str	r4, [r5, #0]
    a7c8:	str	r3, [r5, #4]
    a7ca:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    a7ce:	cmp	r3, r1
    a7d0:	bls.n	a7e2 <__udivmoddi4+0xc6>
    a7d2:	cmp	r5, #0
    a7d4:	beq.n	a882 <__udivmoddi4+0x166>
    a7d6:	movs	r1, #0
    a7d8:	stmia.w	r5, {r0, r6}
    a7dc:	mov	r0, r1
    a7de:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    a7e2:	clz	r1, r3
    a7e6:	cmp	r1, #0
    a7e8:	bne.w	a90c <__udivmoddi4+0x1f0>
    a7ec:	cmp	r3, r6
    a7ee:	bcc.n	a7f6 <__udivmoddi4+0xda>
    a7f0:	cmp	r2, r0
    a7f2:	bhi.w	a9e6 <__udivmoddi4+0x2ca>
    a7f6:	subs	r4, r0, r2
    a7f8:	sbc.w	r6, r6, r3
    a7fc:	movs	r0, #1
    a7fe:	mov	ip, r6
    a800:	cmp	r5, #0
    a802:	beq.n	a886 <__udivmoddi4+0x16a>
    a804:	stmia.w	r5, {r4, ip}
    a808:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    a80c:	cbnz	r2, a814 <__udivmoddi4+0xf8>
    a80e:	movs	r7, #1
    a810:	udiv	r7, r7, r2
    a814:	clz	lr, r7
    a818:	cmp.w	lr, #0
    a81c:	bne.n	a88a <__udivmoddi4+0x16e>
    a81e:	subs	r3, r6, r7
    a820:	mov.w	r8, r7, lsr #16
    a824:	uxth.w	ip, r7
    a828:	movs	r1, #1
    a82a:	udiv	r0, r3, r8
    a82e:	lsrs	r2, r4, #16
    a830:	mls	r6, r8, r0, r3
    a834:	orr.w	r6, r2, r6, lsl #16
    a838:	mul.w	r3, ip, r0
    a83c:	cmp	r3, r6
    a83e:	bls.n	a850 <__udivmoddi4+0x134>
    a840:	adds	r6, r6, r7
    a842:	add.w	r2, r0, #4294967295
    a846:	bcs.n	a84e <__udivmoddi4+0x132>
    a848:	cmp	r3, r6
    a84a:	bhi.w	a9ea <__udivmoddi4+0x2ce>
    a84e:	mov	r0, r2
    a850:	subs	r6, r6, r3
    a852:	uxth	r2, r4
    a854:	udiv	r3, r6, r8
    a858:	mls	r6, r8, r3, r6
    a85c:	orr.w	r4, r2, r6, lsl #16
    a860:	mul.w	ip, ip, r3
    a864:	cmp	ip, r4
    a866:	bls.n	a878 <__udivmoddi4+0x15c>
    a868:	adds	r4, r4, r7
    a86a:	add.w	r2, r3, #4294967295
    a86e:	bcs.n	a876 <__udivmoddi4+0x15a>
    a870:	cmp	ip, r4
    a872:	bhi.w	a9e0 <__udivmoddi4+0x2c4>
    a876:	mov	r3, r2
    a878:	rsb	r4, ip, r4
    a87c:	orr.w	r0, r3, r0, lsl #16
    a880:	b.n	a7bc <__udivmoddi4+0xa0>
    a882:	mov	r1, r5
    a884:	mov	r0, r5
    a886:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    a88a:	rsb	r1, lr, #32
    a88e:	lsl.w	r3, r6, lr
    a892:	lsl.w	r7, r7, lr
    a896:	lsr.w	r9, r0, r1
    a89a:	mov.w	r8, r7, lsr #16
    a89e:	lsrs	r6, r1
    a8a0:	orr.w	r9, r9, r3
    a8a4:	udiv	sl, r6, r8
    a8a8:	mov.w	r4, r9, lsr #16
    a8ac:	mls	r6, r8, sl, r6
    a8b0:	uxth.w	ip, r7
    a8b4:	orr.w	r3, r4, r6, lsl #16
    a8b8:	mul.w	r2, sl, ip
    a8bc:	cmp	r2, r3
    a8be:	lsl.w	r4, r0, lr
    a8c2:	bls.n	a8da <__udivmoddi4+0x1be>
    a8c4:	adds	r3, r3, r7
    a8c6:	add.w	r1, sl, #4294967295
    a8ca:	bcs.w	a9dc <__udivmoddi4+0x2c0>
    a8ce:	cmp	r2, r3
    a8d0:	bls.w	a9dc <__udivmoddi4+0x2c0>
    a8d4:	sub.w	sl, sl, #2
    a8d8:	add	r3, r7
    a8da:	subs	r3, r3, r2
    a8dc:	uxth.w	r9, r9
    a8e0:	udiv	r1, r3, r8
    a8e4:	mls	r3, r8, r1, r3
    a8e8:	orr.w	r3, r9, r3, lsl #16
    a8ec:	mul.w	r6, r1, ip
    a8f0:	cmp	r6, r3
    a8f2:	bls.n	a904 <__udivmoddi4+0x1e8>
    a8f4:	adds	r3, r3, r7
    a8f6:	add.w	r2, r1, #4294967295
    a8fa:	bcs.n	a9d4 <__udivmoddi4+0x2b8>
    a8fc:	cmp	r6, r3
    a8fe:	bls.n	a9d4 <__udivmoddi4+0x2b8>
    a900:	subs	r1, #2
    a902:	add	r3, r7
    a904:	subs	r3, r3, r6
    a906:	orr.w	r1, r1, sl, lsl #16
    a90a:	b.n	a82a <__udivmoddi4+0x10e>
    a90c:	rsb	lr, r1, #32
    a910:	lsr.w	r4, r2, lr
    a914:	lsls	r3, r1
    a916:	orrs	r3, r4
    a918:	lsr.w	r7, r0, lr
    a91c:	lsl.w	r4, r6, r1
    a920:	mov.w	ip, r3, lsr #16
    a924:	lsr.w	r6, r6, lr
    a928:	orrs	r4, r7
    a92a:	udiv	r9, r6, ip
    a92e:	lsrs	r7, r4, #16
    a930:	mls	r6, ip, r9, r6
    a934:	uxth.w	r8, r3
    a938:	orr.w	r6, r7, r6, lsl #16
    a93c:	mul.w	r7, r9, r8
    a940:	cmp	r7, r6
    a942:	lsl.w	r2, r2, r1
    a946:	lsl.w	sl, r0, r1
    a94a:	bls.n	a95e <__udivmoddi4+0x242>
    a94c:	adds	r6, r6, r3
    a94e:	add.w	r0, r9, #4294967295
    a952:	bcs.n	a9d8 <__udivmoddi4+0x2bc>
    a954:	cmp	r7, r6
    a956:	bls.n	a9d8 <__udivmoddi4+0x2bc>
    a958:	sub.w	r9, r9, #2
    a95c:	add	r6, r3
    a95e:	subs	r6, r6, r7
    a960:	uxth	r0, r4
    a962:	udiv	r4, r6, ip
    a966:	mls	r6, ip, r4, r6
    a96a:	orr.w	r7, r0, r6, lsl #16
    a96e:	mul.w	r8, r4, r8
    a972:	cmp	r8, r7
    a974:	bls.n	a986 <__udivmoddi4+0x26a>
    a976:	adds	r7, r7, r3
    a978:	add.w	r0, r4, #4294967295
    a97c:	bcs.n	a9d0 <__udivmoddi4+0x2b4>
    a97e:	cmp	r8, r7
    a980:	bls.n	a9d0 <__udivmoddi4+0x2b4>
    a982:	subs	r4, #2
    a984:	add	r7, r3
    a986:	orr.w	r0, r4, r9, lsl #16
    a98a:	rsb	r7, r8, r7
    a98e:	umull	r8, r9, r0, r2
    a992:	cmp	r7, r9
    a994:	mov	r4, r8
    a996:	mov	r6, r9
    a998:	bcc.n	a9c4 <__udivmoddi4+0x2a8>
    a99a:	beq.n	a9f0 <__udivmoddi4+0x2d4>
    a99c:	cbz	r5, a9f8 <__udivmoddi4+0x2dc>
    a99e:	subs.w	r3, sl, r4
    a9a2:	sbc.w	r7, r7, r6
    a9a6:	lsl.w	lr, r7, lr
    a9aa:	lsrs	r3, r1
    a9ac:	lsrs	r7, r1
    a9ae:	orr.w	r3, lr, r3
    a9b2:	stmia.w	r5, {r3, r7}
    a9b6:	movs	r1, #0
    a9b8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    a9bc:	mov	r3, r2
    a9be:	b.n	a7b2 <__udivmoddi4+0x96>
    a9c0:	mov	r0, r2
    a9c2:	b.n	a786 <__udivmoddi4+0x6a>
    a9c4:	subs.w	r4, r8, r2
    a9c8:	sbc.w	r6, r9, r3
    a9cc:	subs	r0, #1
    a9ce:	b.n	a99c <__udivmoddi4+0x280>
    a9d0:	mov	r4, r0
    a9d2:	b.n	a986 <__udivmoddi4+0x26a>
    a9d4:	mov	r1, r2
    a9d6:	b.n	a904 <__udivmoddi4+0x1e8>
    a9d8:	mov	r9, r0
    a9da:	b.n	a95e <__udivmoddi4+0x242>
    a9dc:	mov	sl, r1
    a9de:	b.n	a8da <__udivmoddi4+0x1be>
    a9e0:	subs	r3, #2
    a9e2:	add	r4, r7
    a9e4:	b.n	a878 <__udivmoddi4+0x15c>
    a9e6:	mov	r0, r1
    a9e8:	b.n	a800 <__udivmoddi4+0xe4>
    a9ea:	subs	r0, #2
    a9ec:	add	r6, r7
    a9ee:	b.n	a850 <__udivmoddi4+0x134>
    a9f0:	cmp	sl, r8
    a9f2:	bcc.n	a9c4 <__udivmoddi4+0x2a8>
    a9f4:	mov	r6, r7
    a9f6:	b.n	a99c <__udivmoddi4+0x280>
    a9f8:	mov	r1, r5
    a9fa:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    a9fe:	nop

0000aa00 <__aeabi_idiv0>:
    aa00:	bx	lr
    aa02:	nop

0000aa04 <__cxa_atexit>:
    aa04:	mov	r3, r2
    aa06:	mov	r2, r1
    aa08:	mov	r1, r0
    aa0a:	movs	r0, #2
    aa0c:	b.w	ef28 <__register_exitproc>

0000aa10 <__errno>:
    aa10:	ldr	r3, [pc, #4]	; (aa18 <__errno+0x8>)
    aa12:	ldr	r0, [r3, #0]
    aa14:	bx	lr
    aa16:	nop
    aa18:	.word	0x1fff1840

0000aa1c <__libc_init_array>:
    aa1c:	push	{r4, r5, r6, lr}
    aa1e:	ldr	r6, [pc, #60]	; (aa5c <__libc_init_array+0x40>)
    aa20:	ldr	r5, [pc, #60]	; (aa60 <__libc_init_array+0x44>)
    aa22:	subs	r6, r6, r5
    aa24:	asrs	r6, r6, #2
    aa26:	it	ne
    aa28:	movne	r4, #0
    aa2a:	beq.n	aa38 <__libc_init_array+0x1c>
    aa2c:	adds	r4, #1
    aa2e:	ldr.w	r3, [r5], #4
    aa32:	blx	r3
    aa34:	cmp	r6, r4
    aa36:	bne.n	aa2c <__libc_init_array+0x10>
    aa38:	ldr	r6, [pc, #40]	; (aa64 <__libc_init_array+0x48>)
    aa3a:	ldr	r5, [pc, #44]	; (aa68 <__libc_init_array+0x4c>)
    aa3c:	subs	r6, r6, r5
    aa3e:	bl	12cbc <_init>
    aa42:	asrs	r6, r6, #2
    aa44:	it	ne
    aa46:	movne	r4, #0
    aa48:	beq.n	aa58 <__libc_init_array+0x3c>
    aa4a:	adds	r4, #1
    aa4c:	ldr.w	r3, [r5], #4
    aa50:	blx	r3
    aa52:	cmp	r6, r4
    aa54:	bne.n	aa4a <__libc_init_array+0x2e>
    aa56:	pop	{r4, r5, r6, pc}
    aa58:	pop	{r4, r5, r6, pc}
    aa5a:	nop
    aa5c:	.word	0x00012cc8
    aa60:	.word	0x00012cc8
    aa64:	.word	0x00012d1c
    aa68:	.word	0x00012cc8

0000aa6c <__get_current_locale>:
    aa6c:	ldr	r2, [pc, #12]	; (aa7c <__get_current_locale+0x10>)
    aa6e:	ldr	r3, [pc, #16]	; (aa80 <__get_current_locale+0x14>)
    aa70:	ldr	r2, [r2, #0]
    aa72:	ldr	r0, [r2, #52]	; 0x34
    aa74:	cmp	r0, #0
    aa76:	it	eq
    aa78:	moveq	r0, r3
    aa7a:	bx	lr
    aa7c:	.word	0x1fff1840
    aa80:	.word	0x1fff1844

0000aa84 <__locale_mb_cur_max>:
    aa84:	ldr	r3, [pc, #16]	; (aa98 <__locale_mb_cur_max+0x14>)
    aa86:	ldr	r2, [pc, #20]	; (aa9c <__locale_mb_cur_max+0x18>)
    aa88:	ldr	r3, [r3, #0]
    aa8a:	ldr	r3, [r3, #52]	; 0x34
    aa8c:	cmp	r3, #0
    aa8e:	it	eq
    aa90:	moveq	r3, r2
    aa92:	ldrb.w	r0, [r3, #296]	; 0x128
    aa96:	bx	lr
    aa98:	.word	0x1fff1840
    aa9c:	.word	0x1fff1844

0000aaa0 <__locale_ctype_ptr_l>:
    aaa0:	ldr.w	r0, [r0, #236]	; 0xec
    aaa4:	bx	lr
    aaa6:	nop

0000aaa8 <__locale_ctype_ptr>:
    aaa8:	push	{r3, lr}
    aaaa:	ldr	r3, [pc, #12]	; (aab8 <__locale_ctype_ptr+0x10>)
    aaac:	ldr	r0, [r3, #0]
    aaae:	bl	aa6c <__get_current_locale>
    aab2:	ldr.w	r0, [r0, #236]	; 0xec
    aab6:	pop	{r3, pc}
    aab8:	.word	0x1fff1840

0000aabc <malloc>:
    aabc:	ldr	r3, [pc, #8]	; (aac8 <malloc+0xc>)
    aabe:	mov	r1, r0
    aac0:	ldr	r0, [r3, #0]
    aac2:	b.w	aadc <_malloc_r>
    aac6:	nop
    aac8:	.word	0x1fff1840

0000aacc <free>:
    aacc:	ldr	r3, [pc, #8]	; (aad8 <free+0xc>)
    aace:	mov	r1, r0
    aad0:	ldr	r0, [r3, #0]
    aad2:	b.w	10010 <_free_r>
    aad6:	nop
    aad8:	.word	0x1fff1840

0000aadc <_malloc_r>:
    aadc:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    aae0:	add.w	r5, r1, #11
    aae4:	cmp	r5, #22
    aae6:	sub	sp, #12
    aae8:	mov	r6, r0
    aaea:	bls.w	ac2c <_malloc_r+0x150>
    aaee:	bics.w	r5, r5, #7
    aaf2:	bmi.w	ac74 <_malloc_r+0x198>
    aaf6:	cmp	r1, r5
    aaf8:	bhi.w	ac74 <_malloc_r+0x198>
    aafc:	bl	b24c <__malloc_lock>
    ab00:	cmp.w	r5, #504	; 0x1f8
    ab04:	bcc.w	b040 <_malloc_r+0x564>
    ab08:	lsrs	r3, r5, #9
    ab0a:	beq.w	ac82 <_malloc_r+0x1a6>
    ab0e:	cmp	r3, #4
    ab10:	bhi.w	ae1a <_malloc_r+0x33e>
    ab14:	lsrs	r0, r5, #6
    ab16:	add.w	lr, r0, #57	; 0x39
    ab1a:	mov.w	r3, lr, lsl #1
    ab1e:	adds	r0, #56	; 0x38
    ab20:	ldr	r7, [pc, #784]	; (ae34 <_malloc_r+0x358>)
    ab22:	add.w	r3, r7, r3, lsl #2
    ab26:	sub.w	r1, r3, #8
    ab2a:	ldr	r4, [r3, #4]
    ab2c:	cmp	r1, r4
    ab2e:	bne.n	ab40 <_malloc_r+0x64>
    ab30:	b.n	ac8c <_malloc_r+0x1b0>
    ab32:	cmp	r2, #0
    ab34:	bge.w	ac90 <_malloc_r+0x1b4>
    ab38:	ldr	r4, [r4, #12]
    ab3a:	cmp	r1, r4
    ab3c:	beq.w	ac8c <_malloc_r+0x1b0>
    ab40:	ldr	r3, [r4, #4]
    ab42:	bic.w	r3, r3, #3
    ab46:	subs	r2, r3, r5
    ab48:	cmp	r2, #15
    ab4a:	ble.n	ab32 <_malloc_r+0x56>
    ab4c:	ldr	r1, [pc, #740]	; (ae34 <_malloc_r+0x358>)
    ab4e:	ldr	r4, [r7, #16]
    ab50:	add.w	lr, r1, #8
    ab54:	cmp	r4, lr
    ab56:	beq.w	aec0 <_malloc_r+0x3e4>
    ab5a:	ldr	r3, [r4, #4]
    ab5c:	bic.w	r3, r3, #3
    ab60:	subs	r2, r3, r5
    ab62:	cmp	r2, #15
    ab64:	bgt.w	ae9a <_malloc_r+0x3be>
    ab68:	cmp	r2, #0
    ab6a:	str.w	lr, [r1, #20]
    ab6e:	str.w	lr, [r1, #16]
    ab72:	bge.w	acb2 <_malloc_r+0x1d6>
    ab76:	cmp.w	r3, #512	; 0x200
    ab7a:	bcs.w	ae4c <_malloc_r+0x370>
    ab7e:	lsrs	r3, r3, #3
    ab80:	add.w	ip, r3, #1
    ab84:	movs	r2, #1
    ab86:	asrs	r3, r3, #2
    ab88:	lsl.w	r3, r2, r3
    ab8c:	ldr	r2, [r1, #4]
    ab8e:	ldr.w	r8, [r1, ip, lsl #3]
    ab92:	str.w	r8, [r4, #8]
    ab96:	add.w	r9, r1, ip, lsl #3
    ab9a:	orrs	r2, r3
    ab9c:	sub.w	r3, r9, #8
    aba0:	str	r3, [r4, #12]
    aba2:	str	r2, [r1, #4]
    aba4:	str.w	r4, [r1, ip, lsl #3]
    aba8:	str.w	r4, [r8, #12]
    abac:	asrs	r3, r0, #2
    abae:	movs	r4, #1
    abb0:	lsls	r4, r3
    abb2:	cmp	r4, r2
    abb4:	bhi.w	accc <_malloc_r+0x1f0>
    abb8:	tst	r4, r2
    abba:	bne.n	abca <_malloc_r+0xee>
    abbc:	bic.w	r0, r0, #3
    abc0:	lsls	r4, r4, #1
    abc2:	tst	r4, r2
    abc4:	add.w	r0, r0, #4
    abc8:	beq.n	abc0 <_malloc_r+0xe4>
    abca:	add.w	r9, r7, r0, lsl #3
    abce:	mov	ip, r9
    abd0:	mov	r8, r0
    abd2:	ldr.w	r1, [ip, #12]
    abd6:	cmp	ip, r1
    abd8:	bne.n	abea <_malloc_r+0x10e>
    abda:	b.n	aec4 <_malloc_r+0x3e8>
    abdc:	cmp	r2, #0
    abde:	bge.w	aee4 <_malloc_r+0x408>
    abe2:	ldr	r1, [r1, #12]
    abe4:	cmp	ip, r1
    abe6:	beq.w	aec4 <_malloc_r+0x3e8>
    abea:	ldr	r3, [r1, #4]
    abec:	bic.w	r3, r3, #3
    abf0:	subs	r2, r3, r5
    abf2:	cmp	r2, #15
    abf4:	ble.n	abdc <_malloc_r+0x100>
    abf6:	mov	r4, r1
    abf8:	ldr.w	ip, [r1, #12]
    abfc:	ldr.w	r8, [r4, #8]!
    ac00:	adds	r3, r1, r5
    ac02:	orr.w	r5, r5, #1
    ac06:	str	r5, [r1, #4]
    ac08:	orr.w	r1, r2, #1
    ac0c:	str.w	ip, [r8, #12]
    ac10:	mov	r0, r6
    ac12:	str.w	r8, [ip, #8]
    ac16:	str	r3, [r7, #20]
    ac18:	str	r3, [r7, #16]
    ac1a:	str.w	lr, [r3, #12]
    ac1e:	str.w	lr, [r3, #8]
    ac22:	str	r1, [r3, #4]
    ac24:	str	r2, [r3, r2]
    ac26:	bl	b250 <__malloc_unlock>
    ac2a:	b.n	ac6c <_malloc_r+0x190>
    ac2c:	cmp	r1, #16
    ac2e:	bhi.n	ac74 <_malloc_r+0x198>
    ac30:	bl	b24c <__malloc_lock>
    ac34:	movs	r5, #16
    ac36:	movs	r3, #6
    ac38:	movs	r0, #2
    ac3a:	ldr	r7, [pc, #504]	; (ae34 <_malloc_r+0x358>)
    ac3c:	add.w	r3, r7, r3, lsl #2
    ac40:	sub.w	r2, r3, #8
    ac44:	ldr	r4, [r3, #4]
    ac46:	cmp	r4, r2
    ac48:	beq.w	aed6 <_malloc_r+0x3fa>
    ac4c:	ldr	r3, [r4, #4]
    ac4e:	ldr	r1, [r4, #12]
    ac50:	ldr	r5, [r4, #8]
    ac52:	bic.w	r3, r3, #3
    ac56:	add	r3, r4
    ac58:	mov	r0, r6
    ac5a:	ldr	r2, [r3, #4]
    ac5c:	str	r1, [r5, #12]
    ac5e:	orr.w	r2, r2, #1
    ac62:	str	r5, [r1, #8]
    ac64:	str	r2, [r3, #4]
    ac66:	bl	b250 <__malloc_unlock>
    ac6a:	adds	r4, #8
    ac6c:	mov	r0, r4
    ac6e:	add	sp, #12
    ac70:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ac74:	movs	r4, #0
    ac76:	movs	r3, #12
    ac78:	mov	r0, r4
    ac7a:	str	r3, [r6, #0]
    ac7c:	add	sp, #12
    ac7e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ac82:	movs	r3, #128	; 0x80
    ac84:	mov.w	lr, #64	; 0x40
    ac88:	movs	r0, #63	; 0x3f
    ac8a:	b.n	ab20 <_malloc_r+0x44>
    ac8c:	mov	r0, lr
    ac8e:	b.n	ab4c <_malloc_r+0x70>
    ac90:	add	r3, r4
    ac92:	ldr	r1, [r4, #12]
    ac94:	ldr	r2, [r3, #4]
    ac96:	ldr	r5, [r4, #8]
    ac98:	orr.w	r2, r2, #1
    ac9c:	str	r1, [r5, #12]
    ac9e:	mov	r0, r6
    aca0:	str	r5, [r1, #8]
    aca2:	str	r2, [r3, #4]
    aca4:	bl	b250 <__malloc_unlock>
    aca8:	adds	r4, #8
    acaa:	mov	r0, r4
    acac:	add	sp, #12
    acae:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    acb2:	add	r3, r4
    acb4:	mov	r0, r6
    acb6:	ldr	r2, [r3, #4]
    acb8:	orr.w	r2, r2, #1
    acbc:	str	r2, [r3, #4]
    acbe:	bl	b250 <__malloc_unlock>
    acc2:	adds	r4, #8
    acc4:	mov	r0, r4
    acc6:	add	sp, #12
    acc8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    accc:	ldr	r4, [r7, #8]
    acce:	ldr	r3, [r4, #4]
    acd0:	bic.w	r8, r3, #3
    acd4:	cmp	r8, r5
    acd6:	bcc.n	ace2 <_malloc_r+0x206>
    acd8:	rsb	r3, r5, r8
    acdc:	cmp	r3, #15
    acde:	bgt.w	adfa <_malloc_r+0x31e>
    ace2:	ldr	r3, [pc, #340]	; (ae38 <_malloc_r+0x35c>)
    ace4:	ldr.w	r9, [pc, #352]	; ae48 <_malloc_r+0x36c>
    ace8:	ldr	r2, [r3, #0]
    acea:	ldr.w	r3, [r9]
    acee:	adds	r3, #1
    acf0:	add	r2, r5
    acf2:	add.w	sl, r4, r8
    acf6:	beq.w	afba <_malloc_r+0x4de>
    acfa:	add.w	r2, r2, #4096	; 0x1000
    acfe:	adds	r2, #15
    ad00:	bic.w	r2, r2, #4080	; 0xff0
    ad04:	bic.w	r2, r2, #15
    ad08:	mov	r1, r2
    ad0a:	mov	r0, r6
    ad0c:	str	r2, [sp, #4]
    ad0e:	bl	b634 <_sbrk_r>
    ad12:	cmp.w	r0, #4294967295
    ad16:	mov	fp, r0
    ad18:	ldr	r2, [sp, #4]
    ad1a:	beq.w	afce <_malloc_r+0x4f2>
    ad1e:	cmp	sl, r0
    ad20:	bhi.w	af1c <_malloc_r+0x440>
    ad24:	ldr	r3, [pc, #276]	; (ae3c <_malloc_r+0x360>)
    ad26:	ldr	r1, [r3, #0]
    ad28:	cmp	sl, fp
    ad2a:	add	r1, r2
    ad2c:	str	r1, [r3, #0]
    ad2e:	beq.w	afd8 <_malloc_r+0x4fc>
    ad32:	ldr.w	r0, [r9]
    ad36:	ldr.w	lr, [pc, #272]	; ae48 <_malloc_r+0x36c>
    ad3a:	adds	r0, #1
    ad3c:	ittet	ne
    ad3e:	rsbne	sl, sl, fp
    ad42:	addne	r1, sl
    ad44:	streq.w	fp, [lr]
    ad48:	strne	r1, [r3, #0]
    ad4a:	ands.w	r1, fp, #7
    ad4e:	beq.w	af80 <_malloc_r+0x4a4>
    ad52:	rsb	r0, r1, #8
    ad56:	rsb	r1, r1, #4096	; 0x1000
    ad5a:	add	fp, r0
    ad5c:	adds	r1, #8
    ad5e:	add	r2, fp
    ad60:	ubfx	r2, r2, #0, #12
    ad64:	rsb	r9, r2, r1
    ad68:	mov	r1, r9
    ad6a:	mov	r0, r6
    ad6c:	str	r3, [sp, #4]
    ad6e:	bl	b634 <_sbrk_r>
    ad72:	adds	r3, r0, #1
    ad74:	ldr	r3, [sp, #4]
    ad76:	beq.w	aff8 <_malloc_r+0x51c>
    ad7a:	rsb	r2, fp, r0
    ad7e:	add	r2, r9
    ad80:	orr.w	r2, r2, #1
    ad84:	ldr	r1, [r3, #0]
    ad86:	str.w	fp, [r7, #8]
    ad8a:	add	r1, r9
    ad8c:	cmp	r4, r7
    ad8e:	str.w	r2, [fp, #4]
    ad92:	str	r1, [r3, #0]
    ad94:	ldr.w	r9, [pc, #164]	; ae3c <_malloc_r+0x360>
    ad98:	beq.n	adc8 <_malloc_r+0x2ec>
    ad9a:	cmp.w	r8, #15
    ad9e:	bls.w	af9c <_malloc_r+0x4c0>
    ada2:	ldr	r2, [r4, #4]
    ada4:	sub.w	r3, r8, #12
    ada8:	bic.w	r3, r3, #7
    adac:	adds	r0, r4, r3
    adae:	and.w	r2, r2, #1
    adb2:	mov.w	lr, #5
    adb6:	orrs	r2, r3
    adb8:	cmp	r3, #15
    adba:	str	r2, [r4, #4]
    adbc:	str.w	lr, [r0, #4]
    adc0:	str.w	lr, [r0, #8]
    adc4:	bhi.w	b000 <_malloc_r+0x524>
    adc8:	ldr	r3, [pc, #116]	; (ae40 <_malloc_r+0x364>)
    adca:	ldr	r4, [r7, #8]
    adcc:	ldr	r2, [r3, #0]
    adce:	cmp	r1, r2
    add0:	it	hi
    add2:	strhi	r1, [r3, #0]
    add4:	ldr	r3, [pc, #108]	; (ae44 <_malloc_r+0x368>)
    add6:	ldr	r2, [r3, #0]
    add8:	cmp	r1, r2
    adda:	ldr	r2, [r4, #4]
    addc:	it	hi
    adde:	strhi	r1, [r3, #0]
    ade0:	bic.w	r2, r2, #3
    ade4:	cmp	r5, r2
    ade6:	sub.w	r3, r2, r5
    adea:	bhi.n	adf0 <_malloc_r+0x314>
    adec:	cmp	r3, #15
    adee:	bgt.n	adfa <_malloc_r+0x31e>
    adf0:	mov	r0, r6
    adf2:	bl	b250 <__malloc_unlock>
    adf6:	movs	r4, #0
    adf8:	b.n	ac6c <_malloc_r+0x190>
    adfa:	adds	r2, r4, r5
    adfc:	orr.w	r3, r3, #1
    ae00:	orr.w	r5, r5, #1
    ae04:	str	r5, [r4, #4]
    ae06:	mov	r0, r6
    ae08:	str	r2, [r7, #8]
    ae0a:	str	r3, [r2, #4]
    ae0c:	bl	b250 <__malloc_unlock>
    ae10:	adds	r4, #8
    ae12:	mov	r0, r4
    ae14:	add	sp, #12
    ae16:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ae1a:	cmp	r3, #20
    ae1c:	bls.n	af02 <_malloc_r+0x426>
    ae1e:	cmp	r3, #84	; 0x54
    ae20:	bhi.w	af6c <_malloc_r+0x490>
    ae24:	lsrs	r0, r5, #12
    ae26:	add.w	lr, r0, #111	; 0x6f
    ae2a:	mov.w	r3, lr, lsl #1
    ae2e:	adds	r0, #110	; 0x6e
    ae30:	b.n	ab20 <_malloc_r+0x44>
    ae32:	nop
    ae34:	.word	0x1fff19b0
    ae38:	.word	0x1fff85ac
    ae3c:	.word	0x1fff85b0
    ae40:	.word	0x1fff85a8
    ae44:	.word	0x1fff85a4
    ae48:	.word	0x1fff1dbc
    ae4c:	lsrs	r2, r3, #9
    ae4e:	cmp	r2, #4
    ae50:	bls.n	af10 <_malloc_r+0x434>
    ae52:	cmp	r2, #20
    ae54:	bhi.w	afbe <_malloc_r+0x4e2>
    ae58:	add.w	r1, r2, #92	; 0x5c
    ae5c:	lsls	r1, r1, #1
    ae5e:	adds	r2, #91	; 0x5b
    ae60:	add.w	ip, r7, r1, lsl #2
    ae64:	ldr.w	r1, [r7, r1, lsl #2]
    ae68:	ldr.w	r8, [pc, #476]	; b048 <_malloc_r+0x56c>
    ae6c:	sub.w	ip, ip, #8
    ae70:	cmp	ip, r1
    ae72:	beq.w	af86 <_malloc_r+0x4aa>
    ae76:	ldr	r2, [r1, #4]
    ae78:	bic.w	r2, r2, #3
    ae7c:	cmp	r3, r2
    ae7e:	bcs.n	ae86 <_malloc_r+0x3aa>
    ae80:	ldr	r1, [r1, #8]
    ae82:	cmp	ip, r1
    ae84:	bne.n	ae76 <_malloc_r+0x39a>
    ae86:	ldr.w	ip, [r1, #12]
    ae8a:	ldr	r2, [r7, #4]
    ae8c:	str.w	ip, [r4, #12]
    ae90:	str	r1, [r4, #8]
    ae92:	str.w	r4, [ip, #8]
    ae96:	str	r4, [r1, #12]
    ae98:	b.n	abac <_malloc_r+0xd0>
    ae9a:	adds	r3, r4, r5
    ae9c:	orr.w	r7, r2, #1
    aea0:	orr.w	r5, r5, #1
    aea4:	str	r5, [r4, #4]
    aea6:	mov	r0, r6
    aea8:	str	r3, [r1, #20]
    aeaa:	str	r3, [r1, #16]
    aeac:	str.w	lr, [r3, #12]
    aeb0:	str.w	lr, [r3, #8]
    aeb4:	str	r7, [r3, #4]
    aeb6:	str	r2, [r3, r2]
    aeb8:	adds	r4, #8
    aeba:	bl	b250 <__malloc_unlock>
    aebe:	b.n	ac6c <_malloc_r+0x190>
    aec0:	ldr	r2, [r1, #4]
    aec2:	b.n	abac <_malloc_r+0xd0>
    aec4:	add.w	r8, r8, #1
    aec8:	tst.w	r8, #3
    aecc:	add.w	ip, ip, #8
    aed0:	bne.w	abd2 <_malloc_r+0xf6>
    aed4:	b.n	af38 <_malloc_r+0x45c>
    aed6:	ldr	r4, [r3, #12]
    aed8:	cmp	r3, r4
    aeda:	it	eq
    aedc:	addeq	r0, #2
    aede:	beq.w	ab4c <_malloc_r+0x70>
    aee2:	b.n	ac4c <_malloc_r+0x170>
    aee4:	add	r3, r1
    aee6:	mov	r4, r1
    aee8:	ldr	r2, [r3, #4]
    aeea:	ldr	r1, [r1, #12]
    aeec:	ldr.w	r5, [r4, #8]!
    aef0:	orr.w	r2, r2, #1
    aef4:	str	r2, [r3, #4]
    aef6:	mov	r0, r6
    aef8:	str	r1, [r5, #12]
    aefa:	str	r5, [r1, #8]
    aefc:	bl	b250 <__malloc_unlock>
    af00:	b.n	ac6c <_malloc_r+0x190>
    af02:	add.w	lr, r3, #92	; 0x5c
    af06:	add.w	r0, r3, #91	; 0x5b
    af0a:	mov.w	r3, lr, lsl #1
    af0e:	b.n	ab20 <_malloc_r+0x44>
    af10:	lsrs	r2, r3, #6
    af12:	add.w	r1, r2, #57	; 0x39
    af16:	lsls	r1, r1, #1
    af18:	adds	r2, #56	; 0x38
    af1a:	b.n	ae60 <_malloc_r+0x384>
    af1c:	cmp	r4, r7
    af1e:	ldr	r3, [pc, #296]	; (b048 <_malloc_r+0x56c>)
    af20:	beq.w	ad24 <_malloc_r+0x248>
    af24:	ldr	r4, [r3, #8]
    af26:	ldr	r2, [r4, #4]
    af28:	bic.w	r2, r2, #3
    af2c:	b.n	ade4 <_malloc_r+0x308>
    af2e:	ldr.w	r3, [r9], #-8
    af32:	cmp	r9, r3
    af34:	bne.w	b03c <_malloc_r+0x560>
    af38:	tst.w	r0, #3
    af3c:	add.w	r0, r0, #4294967295
    af40:	bne.n	af2e <_malloc_r+0x452>
    af42:	ldr	r3, [r7, #4]
    af44:	bic.w	r3, r3, r4
    af48:	str	r3, [r7, #4]
    af4a:	lsls	r4, r4, #1
    af4c:	cmp	r4, r3
    af4e:	bhi.w	accc <_malloc_r+0x1f0>
    af52:	cmp	r4, #0
    af54:	beq.w	accc <_malloc_r+0x1f0>
    af58:	tst	r4, r3
    af5a:	mov	r0, r8
    af5c:	bne.w	abca <_malloc_r+0xee>
    af60:	lsls	r4, r4, #1
    af62:	tst	r4, r3
    af64:	add.w	r0, r0, #4
    af68:	beq.n	af60 <_malloc_r+0x484>
    af6a:	b.n	abca <_malloc_r+0xee>
    af6c:	cmp.w	r3, #340	; 0x154
    af70:	bhi.n	afa4 <_malloc_r+0x4c8>
    af72:	lsrs	r0, r5, #15
    af74:	add.w	lr, r0, #120	; 0x78
    af78:	mov.w	r3, lr, lsl #1
    af7c:	adds	r0, #119	; 0x77
    af7e:	b.n	ab20 <_malloc_r+0x44>
    af80:	mov.w	r1, #4096	; 0x1000
    af84:	b.n	ad5e <_malloc_r+0x282>
    af86:	movs	r1, #1
    af88:	ldr.w	r3, [r8, #4]
    af8c:	asrs	r2, r2, #2
    af8e:	lsl.w	r2, r1, r2
    af92:	orrs	r2, r3
    af94:	str.w	r2, [r8, #4]
    af98:	mov	r1, ip
    af9a:	b.n	ae8c <_malloc_r+0x3b0>
    af9c:	movs	r3, #1
    af9e:	str.w	r3, [fp, #4]
    afa2:	b.n	adf0 <_malloc_r+0x314>
    afa4:	movw	r2, #1364	; 0x554
    afa8:	cmp	r3, r2
    afaa:	bhi.n	afee <_malloc_r+0x512>
    afac:	lsrs	r0, r5, #18
    afae:	add.w	lr, r0, #125	; 0x7d
    afb2:	mov.w	r3, lr, lsl #1
    afb6:	adds	r0, #124	; 0x7c
    afb8:	b.n	ab20 <_malloc_r+0x44>
    afba:	adds	r2, #16
    afbc:	b.n	ad08 <_malloc_r+0x22c>
    afbe:	cmp	r2, #84	; 0x54
    afc0:	bhi.n	b010 <_malloc_r+0x534>
    afc2:	lsrs	r2, r3, #12
    afc4:	add.w	r1, r2, #111	; 0x6f
    afc8:	lsls	r1, r1, #1
    afca:	adds	r2, #110	; 0x6e
    afcc:	b.n	ae60 <_malloc_r+0x384>
    afce:	ldr	r4, [r7, #8]
    afd0:	ldr	r2, [r4, #4]
    afd2:	bic.w	r2, r2, #3
    afd6:	b.n	ade4 <_malloc_r+0x308>
    afd8:	ubfx	r0, sl, #0, #12
    afdc:	cmp	r0, #0
    afde:	bne.w	ad32 <_malloc_r+0x256>
    afe2:	add	r2, r8
    afe4:	ldr	r3, [r7, #8]
    afe6:	orr.w	r2, r2, #1
    afea:	str	r2, [r3, #4]
    afec:	b.n	adc8 <_malloc_r+0x2ec>
    afee:	movs	r3, #254	; 0xfe
    aff0:	mov.w	lr, #127	; 0x7f
    aff4:	movs	r0, #126	; 0x7e
    aff6:	b.n	ab20 <_malloc_r+0x44>
    aff8:	movs	r2, #1
    affa:	mov.w	r9, #0
    affe:	b.n	ad84 <_malloc_r+0x2a8>
    b000:	add.w	r1, r4, #8
    b004:	mov	r0, r6
    b006:	bl	10010 <_free_r>
    b00a:	ldr.w	r1, [r9]
    b00e:	b.n	adc8 <_malloc_r+0x2ec>
    b010:	cmp.w	r2, #340	; 0x154
    b014:	bhi.n	b022 <_malloc_r+0x546>
    b016:	lsrs	r2, r3, #15
    b018:	add.w	r1, r2, #120	; 0x78
    b01c:	lsls	r1, r1, #1
    b01e:	adds	r2, #119	; 0x77
    b020:	b.n	ae60 <_malloc_r+0x384>
    b022:	movw	r1, #1364	; 0x554
    b026:	cmp	r2, r1
    b028:	bhi.n	b036 <_malloc_r+0x55a>
    b02a:	lsrs	r2, r3, #18
    b02c:	add.w	r1, r2, #125	; 0x7d
    b030:	lsls	r1, r1, #1
    b032:	adds	r2, #124	; 0x7c
    b034:	b.n	ae60 <_malloc_r+0x384>
    b036:	movs	r1, #254	; 0xfe
    b038:	movs	r2, #126	; 0x7e
    b03a:	b.n	ae60 <_malloc_r+0x384>
    b03c:	ldr	r3, [r7, #4]
    b03e:	b.n	af4a <_malloc_r+0x46e>
    b040:	lsrs	r0, r5, #3
    b042:	adds	r3, r0, #1
    b044:	lsls	r3, r3, #1
    b046:	b.n	ac3a <_malloc_r+0x15e>
    b048:	.word	0x1fff19b0

0000b04c <__ascii_mbtowc>:
    b04c:	sub	sp, #8
    b04e:	cbz	r1, b064 <__ascii_mbtowc+0x18>
    b050:	cbz	r2, b06a <__ascii_mbtowc+0x1e>
    b052:	cbz	r3, b070 <__ascii_mbtowc+0x24>
    b054:	ldrb	r3, [r2, #0]
    b056:	str	r3, [r1, #0]
    b058:	ldrb	r2, [r2, #0]
    b05a:	adds	r0, r2, #0
    b05c:	it	ne
    b05e:	movne	r0, #1
    b060:	add	sp, #8
    b062:	bx	lr
    b064:	add	r1, sp, #4
    b066:	cmp	r2, #0
    b068:	bne.n	b052 <__ascii_mbtowc+0x6>
    b06a:	mov	r0, r2
    b06c:	add	sp, #8
    b06e:	bx	lr
    b070:	mvn.w	r0, #1
    b074:	b.n	b060 <__ascii_mbtowc+0x14>
    b076:	nop
    b078:			; <UNDEFINED> instruction: 0xffffffff
    b07c:			; <UNDEFINED> instruction: 0xffffffff

0000b080 <memchr>:
    b080:	and.w	r1, r1, #255	; 0xff
    b084:	cmp	r2, #16
    b086:	blt.n	b0e0 <memchr+0x60>
    b088:	tst.w	r0, #7
    b08c:	beq.n	b0a0 <memchr+0x20>
    b08e:	ldrb.w	r3, [r0], #1
    b092:	subs	r2, #1
    b094:	cmp	r3, r1
    b096:	beq.n	b0f4 <memchr+0x74>
    b098:	tst.w	r0, #7
    b09c:	cbz	r2, b0f0 <memchr+0x70>
    b09e:	bne.n	b08e <memchr+0xe>
    b0a0:	push	{r4, r5, r6, r7}
    b0a2:	orr.w	r1, r1, r1, lsl #8
    b0a6:	orr.w	r1, r1, r1, lsl #16
    b0aa:	bic.w	r4, r2, #7
    b0ae:	mvns.w	r7, #0
    b0b2:	movs	r3, #0
    b0b4:	ldrd	r5, r6, [r0], #8
    b0b8:	subs	r4, #8
    b0ba:	eor.w	r5, r5, r1
    b0be:	eor.w	r6, r6, r1
    b0c2:	uadd8	r5, r5, r7
    b0c6:	sel	r5, r3, r7
    b0ca:	uadd8	r6, r6, r7
    b0ce:	sel	r6, r5, r7
    b0d2:	cbnz	r6, b0f8 <memchr+0x78>
    b0d4:	bne.n	b0b4 <memchr+0x34>
    b0d6:	pop	{r4, r5, r6, r7}
    b0d8:	and.w	r1, r1, #255	; 0xff
    b0dc:	and.w	r2, r2, #7
    b0e0:	cbz	r2, b0f0 <memchr+0x70>
    b0e2:	ldrb.w	r3, [r0], #1
    b0e6:	subs	r2, #1
    b0e8:	eor.w	r3, r3, r1
    b0ec:	cbz	r3, b0f4 <memchr+0x74>
    b0ee:	bne.n	b0e2 <memchr+0x62>
    b0f0:	movs	r0, #0
    b0f2:	bx	lr
    b0f4:	subs	r0, #1
    b0f6:	bx	lr
    b0f8:	cmp	r5, #0
    b0fa:	itte	eq
    b0fc:	moveq	r5, r6
    b0fe:	subeq	r0, #3
    b100:	subne	r0, #7
    b102:	tst.w	r5, #1
    b106:	bne.n	b118 <memchr+0x98>
    b108:	adds	r0, #1
    b10a:	tst.w	r5, #256	; 0x100
    b10e:	ittt	eq
    b110:	addeq	r0, #1
    b112:	tsteq.w	r5, #98304	; 0x18000
    b116:	addeq	r0, #1
    b118:	pop	{r4, r5, r6, r7}
    b11a:	subs	r0, #1
    b11c:	bx	lr
    b11e:	nop

0000b120 <memcmp>:
    b120:	cmp	r2, #3
    b122:	push	{r4, r5, r6}
    b124:	bls.n	b174 <memcmp+0x54>
    b126:	orr.w	r3, r0, r1
    b12a:	lsls	r3, r3, #30
    b12c:	beq.n	b152 <memcmp+0x32>
    b12e:	ldrb	r4, [r0, #0]
    b130:	ldrb	r5, [r1, #0]
    b132:	cmp	r4, r5
    b134:	bne.n	b17c <memcmp+0x5c>
    b136:	add	r2, r0
    b138:	adds	r3, r0, #1
    b13a:	b.n	b148 <memcmp+0x28>
    b13c:	ldrb.w	r4, [r3], #1
    b140:	ldrb.w	r5, [r1, #1]!
    b144:	cmp	r4, r5
    b146:	bne.n	b17c <memcmp+0x5c>
    b148:	cmp	r3, r2
    b14a:	bne.n	b13c <memcmp+0x1c>
    b14c:	movs	r0, #0
    b14e:	pop	{r4, r5, r6}
    b150:	bx	lr
    b152:	mov	r4, r1
    b154:	mov	r3, r0
    b156:	ldr	r6, [r3, #0]
    b158:	ldr	r5, [r4, #0]
    b15a:	cmp	r6, r5
    b15c:	mov	r0, r3
    b15e:	mov	r1, r4
    b160:	add.w	r3, r3, #4
    b164:	add.w	r4, r4, #4
    b168:	bne.n	b12e <memcmp+0xe>
    b16a:	subs	r2, #4
    b16c:	cmp	r2, #3
    b16e:	mov	r0, r3
    b170:	mov	r1, r4
    b172:	bhi.n	b156 <memcmp+0x36>
    b174:	cmp	r2, #0
    b176:	bne.n	b12e <memcmp+0xe>
    b178:	mov	r0, r2
    b17a:	b.n	b14e <memcmp+0x2e>
    b17c:	subs	r0, r4, r5
    b17e:	pop	{r4, r5, r6}
    b180:	bx	lr
    b182:	nop

0000b184 <memmove>:
    b184:	cmp	r0, r1
    b186:	push	{r4, r5, r6, r7, lr}
    b188:	bls.n	b1a6 <memmove+0x22>
    b18a:	adds	r3, r1, r2
    b18c:	cmp	r0, r3
    b18e:	bcs.n	b1a6 <memmove+0x22>
    b190:	adds	r1, r0, r2
    b192:	cmp	r2, #0
    b194:	beq.n	b23a <memmove+0xb6>
    b196:	subs	r2, r3, r2
    b198:	ldrb.w	r4, [r3, #-1]!
    b19c:	strb.w	r4, [r1, #-1]!
    b1a0:	cmp	r3, r2
    b1a2:	bne.n	b198 <memmove+0x14>
    b1a4:	pop	{r4, r5, r6, r7, pc}
    b1a6:	cmp	r2, #15
    b1a8:	bls.n	b23c <memmove+0xb8>
    b1aa:	orr.w	r3, r1, r0
    b1ae:	lsls	r3, r3, #30
    b1b0:	bne.n	b240 <memmove+0xbc>
    b1b2:	add.w	r4, r0, #16
    b1b6:	add.w	r3, r1, #16
    b1ba:	mov	r5, r2
    b1bc:	ldr.w	r6, [r3, #-16]
    b1c0:	str.w	r6, [r4, #-16]
    b1c4:	ldr.w	r6, [r3, #-12]
    b1c8:	str.w	r6, [r4, #-12]
    b1cc:	ldr.w	r6, [r3, #-8]
    b1d0:	str.w	r6, [r4, #-8]
    b1d4:	subs	r5, #16
    b1d6:	ldr.w	r6, [r3, #-4]
    b1da:	str.w	r6, [r4, #-4]
    b1de:	cmp	r5, #15
    b1e0:	add.w	r3, r3, #16
    b1e4:	add.w	r4, r4, #16
    b1e8:	bhi.n	b1bc <memmove+0x38>
    b1ea:	sub.w	r3, r2, #16
    b1ee:	bic.w	r3, r3, #15
    b1f2:	and.w	lr, r2, #15
    b1f6:	adds	r3, #16
    b1f8:	cmp.w	lr, #3
    b1fc:	add	r1, r3
    b1fe:	add	r3, r0
    b200:	bls.n	b246 <memmove+0xc2>
    b202:	subs	r6, r3, #4
    b204:	mov	r5, r1
    b206:	mov	r4, lr
    b208:	subs	r4, #4
    b20a:	ldr.w	r7, [r5], #4
    b20e:	str.w	r7, [r6, #4]!
    b212:	cmp	r4, #3
    b214:	bhi.n	b208 <memmove+0x84>
    b216:	sub.w	r4, lr, #4
    b21a:	bic.w	r4, r4, #3
    b21e:	adds	r4, #4
    b220:	add	r3, r4
    b222:	add	r1, r4
    b224:	and.w	r2, r2, #3
    b228:	cbz	r2, b244 <memmove+0xc0>
    b22a:	subs	r3, #1
    b22c:	add	r2, r1
    b22e:	ldrb.w	r4, [r1], #1
    b232:	strb.w	r4, [r3, #1]!
    b236:	cmp	r2, r1
    b238:	bne.n	b22e <memmove+0xaa>
    b23a:	pop	{r4, r5, r6, r7, pc}
    b23c:	mov	r3, r0
    b23e:	b.n	b228 <memmove+0xa4>
    b240:	mov	r3, r0
    b242:	b.n	b22a <memmove+0xa6>
    b244:	pop	{r4, r5, r6, r7, pc}
    b246:	mov	r2, lr
    b248:	b.n	b228 <memmove+0xa4>
    b24a:	nop

0000b24c <__malloc_lock>:
    b24c:	bx	lr
    b24e:	nop

0000b250 <__malloc_unlock>:
    b250:	bx	lr
    b252:	nop

0000b254 <_realloc_r>:
    b254:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b258:	mov	r7, r2
    b25a:	sub	sp, #12
    b25c:	cmp	r1, #0
    b25e:	beq.w	b3e4 <_realloc_r+0x190>
    b262:	mov	r6, r1
    b264:	mov	r9, r0
    b266:	add.w	r5, r7, #11
    b26a:	bl	b24c <__malloc_lock>
    b26e:	ldr.w	lr, [r6, #-4]
    b272:	cmp	r5, #22
    b274:	bic.w	r4, lr, #3
    b278:	sub.w	r8, r6, #8
    b27c:	bhi.n	b300 <_realloc_r+0xac>
    b27e:	movs	r2, #16
    b280:	mov	r5, r2
    b282:	cmp	r7, r5
    b284:	bhi.n	b30a <_realloc_r+0xb6>
    b286:	cmp	r4, r2
    b288:	bge.n	b376 <_realloc_r+0x122>
    b28a:	ldr	r3, [pc, #804]	; (b5b0 <_realloc_r+0x35c>)
    b28c:	ldr	r1, [r3, #8]
    b28e:	add.w	r0, r8, r4
    b292:	cmp	r0, r1
    b294:	ldr	r1, [r0, #4]
    b296:	beq.w	b44c <_realloc_r+0x1f8>
    b29a:	bic.w	r3, r1, #1
    b29e:	add	r3, r0
    b2a0:	ldr	r3, [r3, #4]
    b2a2:	lsls	r3, r3, #31
    b2a4:	bpl.n	b3a2 <_realloc_r+0x14e>
    b2a6:	tst.w	lr, #1
    b2aa:	beq.n	b318 <_realloc_r+0xc4>
    b2ac:	mov	r1, r7
    b2ae:	mov	r0, r9
    b2b0:	bl	aadc <_malloc_r>
    b2b4:	mov	r7, r0
    b2b6:	cbz	r0, b2f2 <_realloc_r+0x9e>
    b2b8:	ldr.w	r3, [r6, #-4]
    b2bc:	bic.w	r3, r3, #1
    b2c0:	add	r3, r8
    b2c2:	sub.w	r2, r0, #8
    b2c6:	cmp	r2, r3
    b2c8:	beq.w	b554 <_realloc_r+0x300>
    b2cc:	subs	r2, r4, #4
    b2ce:	cmp	r2, #36	; 0x24
    b2d0:	bhi.w	b536 <_realloc_r+0x2e2>
    b2d4:	cmp	r2, #19
    b2d6:	bhi.w	b4e2 <_realloc_r+0x28e>
    b2da:	mov	r3, r0
    b2dc:	mov	r2, r6
    b2de:	ldr	r1, [r2, #0]
    b2e0:	str	r1, [r3, #0]
    b2e2:	ldr	r1, [r2, #4]
    b2e4:	str	r1, [r3, #4]
    b2e6:	ldr	r2, [r2, #8]
    b2e8:	str	r2, [r3, #8]
    b2ea:	mov	r1, r6
    b2ec:	mov	r0, r9
    b2ee:	bl	10010 <_free_r>
    b2f2:	mov	r0, r9
    b2f4:	bl	b250 <__malloc_unlock>
    b2f8:	mov	r0, r7
    b2fa:	add	sp, #12
    b2fc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b300:	bic.w	r5, r5, #7
    b304:	cmp	r5, #0
    b306:	mov	r2, r5
    b308:	bge.n	b282 <_realloc_r+0x2e>
    b30a:	movs	r3, #12
    b30c:	movs	r0, #0
    b30e:	str.w	r3, [r9]
    b312:	add	sp, #12
    b314:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b318:	ldr.w	r3, [r6, #-8]
    b31c:	rsb	sl, r3, r8
    b320:	ldr.w	r3, [sl, #4]
    b324:	bic.w	ip, r3, #3
    b328:	add.w	r3, r4, ip
    b32c:	cmp	r3, r2
    b32e:	blt.n	b2ac <_realloc_r+0x58>
    b330:	mov	r7, sl
    b332:	ldr.w	r1, [sl, #12]
    b336:	ldr.w	r0, [r7, #8]!
    b33a:	subs	r2, r4, #4
    b33c:	cmp	r2, #36	; 0x24
    b33e:	str	r1, [r0, #12]
    b340:	str	r0, [r1, #8]
    b342:	bhi.w	b574 <_realloc_r+0x320>
    b346:	cmp	r2, #19
    b348:	bls.w	b570 <_realloc_r+0x31c>
    b34c:	ldr	r1, [r6, #0]
    b34e:	str.w	r1, [sl, #8]
    b352:	ldr	r1, [r6, #4]
    b354:	str.w	r1, [sl, #12]
    b358:	cmp	r2, #27
    b35a:	bhi.w	b5b4 <_realloc_r+0x360>
    b35e:	adds	r6, #8
    b360:	add.w	r2, sl, #16
    b364:	ldr	r1, [r6, #0]
    b366:	str	r1, [r2, #0]
    b368:	ldr	r1, [r6, #4]
    b36a:	str	r1, [r2, #4]
    b36c:	ldr	r1, [r6, #8]
    b36e:	str	r1, [r2, #8]
    b370:	mov	r6, r7
    b372:	mov	r4, r3
    b374:	mov	r8, sl
    b376:	subs	r3, r4, r5
    b378:	cmp	r3, #15
    b37a:	bhi.n	b3b8 <_realloc_r+0x164>
    b37c:	ldr.w	r3, [r8, #4]
    b380:	and.w	r3, r3, #1
    b384:	orrs	r3, r4
    b386:	add	r4, r8
    b388:	str.w	r3, [r8, #4]
    b38c:	ldr	r3, [r4, #4]
    b38e:	orr.w	r3, r3, #1
    b392:	str	r3, [r4, #4]
    b394:	mov	r0, r9
    b396:	bl	b250 <__malloc_unlock>
    b39a:	mov	r0, r6
    b39c:	add	sp, #12
    b39e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b3a2:	bic.w	r1, r1, #3
    b3a6:	add	r1, r4
    b3a8:	cmp	r1, r2
    b3aa:	blt.n	b3f0 <_realloc_r+0x19c>
    b3ac:	ldr	r3, [r0, #12]
    b3ae:	ldr	r2, [r0, #8]
    b3b0:	mov	r4, r1
    b3b2:	str	r3, [r2, #12]
    b3b4:	str	r2, [r3, #8]
    b3b6:	b.n	b376 <_realloc_r+0x122>
    b3b8:	ldr.w	r2, [r8, #4]
    b3bc:	add.w	r1, r8, r5
    b3c0:	and.w	r2, r2, #1
    b3c4:	orrs	r5, r2
    b3c6:	orr.w	r2, r3, #1
    b3ca:	add	r3, r1
    b3cc:	str.w	r5, [r8, #4]
    b3d0:	str	r2, [r1, #4]
    b3d2:	ldr	r2, [r3, #4]
    b3d4:	orr.w	r2, r2, #1
    b3d8:	adds	r1, #8
    b3da:	str	r2, [r3, #4]
    b3dc:	mov	r0, r9
    b3de:	bl	10010 <_free_r>
    b3e2:	b.n	b394 <_realloc_r+0x140>
    b3e4:	mov	r1, r2
    b3e6:	add	sp, #12
    b3e8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b3ec:	b.w	aadc <_malloc_r>
    b3f0:	tst.w	lr, #1
    b3f4:	bne.w	b2ac <_realloc_r+0x58>
    b3f8:	ldr.w	r3, [r6, #-8]
    b3fc:	rsb	sl, r3, r8
    b400:	ldr.w	r3, [sl, #4]
    b404:	bic.w	ip, r3, #3
    b408:	add.w	lr, r1, ip
    b40c:	cmp	lr, r2
    b40e:	blt.n	b328 <_realloc_r+0xd4>
    b410:	ldr	r3, [r0, #12]
    b412:	ldr	r2, [r0, #8]
    b414:	mov	r7, sl
    b416:	str	r3, [r2, #12]
    b418:	str	r2, [r3, #8]
    b41a:	ldr.w	r1, [r7, #8]!
    b41e:	ldr.w	r3, [sl, #12]
    b422:	str	r3, [r1, #12]
    b424:	subs	r2, r4, #4
    b426:	cmp	r2, #36	; 0x24
    b428:	str	r1, [r3, #8]
    b42a:	bhi.w	b560 <_realloc_r+0x30c>
    b42e:	cmp	r2, #19
    b430:	bls.n	b4f8 <_realloc_r+0x2a4>
    b432:	ldr	r3, [r6, #0]
    b434:	str.w	r3, [sl, #8]
    b438:	ldr	r3, [r6, #4]
    b43a:	str.w	r3, [sl, #12]
    b43e:	cmp	r2, #27
    b440:	bhi.w	b584 <_realloc_r+0x330>
    b444:	adds	r6, #8
    b446:	add.w	r3, sl, #16
    b44a:	b.n	b4fa <_realloc_r+0x2a6>
    b44c:	bic.w	fp, r1, #3
    b450:	add	fp, r4
    b452:	add.w	r0, r5, #16
    b456:	cmp	fp, r0
    b458:	bge.n	b50e <_realloc_r+0x2ba>
    b45a:	tst.w	lr, #1
    b45e:	bne.w	b2ac <_realloc_r+0x58>
    b462:	ldr.w	r1, [r6, #-8]
    b466:	rsb	sl, r1, r8
    b46a:	ldr.w	r1, [sl, #4]
    b46e:	bic.w	ip, r1, #3
    b472:	add	fp, ip
    b474:	cmp	r0, fp
    b476:	bgt.w	b328 <_realloc_r+0xd4>
    b47a:	mov	r7, sl
    b47c:	ldr.w	r1, [sl, #12]
    b480:	ldr.w	r0, [r7, #8]!
    b484:	subs	r2, r4, #4
    b486:	cmp	r2, #36	; 0x24
    b488:	str	r1, [r0, #12]
    b48a:	str	r0, [r1, #8]
    b48c:	bhi.w	b5f8 <_realloc_r+0x3a4>
    b490:	cmp	r2, #19
    b492:	bls.w	b5e0 <_realloc_r+0x38c>
    b496:	ldr	r1, [r6, #0]
    b498:	str.w	r1, [sl, #8]
    b49c:	ldr	r1, [r6, #4]
    b49e:	str.w	r1, [sl, #12]
    b4a2:	cmp	r2, #27
    b4a4:	bhi.w	b606 <_realloc_r+0x3b2>
    b4a8:	adds	r6, #8
    b4aa:	add.w	r2, sl, #16
    b4ae:	ldr	r1, [r6, #0]
    b4b0:	str	r1, [r2, #0]
    b4b2:	ldr	r1, [r6, #4]
    b4b4:	str	r1, [r2, #4]
    b4b6:	ldr	r1, [r6, #8]
    b4b8:	str	r1, [r2, #8]
    b4ba:	add.w	r1, sl, r5
    b4be:	rsb	r2, r5, fp
    b4c2:	orr.w	r2, r2, #1
    b4c6:	str	r1, [r3, #8]
    b4c8:	str	r2, [r1, #4]
    b4ca:	ldr.w	r3, [sl, #4]
    b4ce:	and.w	r3, r3, #1
    b4d2:	orrs	r5, r3
    b4d4:	mov	r0, r9
    b4d6:	str.w	r5, [sl, #4]
    b4da:	bl	b250 <__malloc_unlock>
    b4de:	mov	r0, r7
    b4e0:	b.n	b39c <_realloc_r+0x148>
    b4e2:	ldr	r3, [r6, #0]
    b4e4:	str	r3, [r0, #0]
    b4e6:	ldr	r3, [r6, #4]
    b4e8:	str	r3, [r0, #4]
    b4ea:	cmp	r2, #27
    b4ec:	bhi.n	b53e <_realloc_r+0x2ea>
    b4ee:	add.w	r3, r0, #8
    b4f2:	add.w	r2, r6, #8
    b4f6:	b.n	b2de <_realloc_r+0x8a>
    b4f8:	mov	r3, r7
    b4fa:	ldr	r2, [r6, #0]
    b4fc:	str	r2, [r3, #0]
    b4fe:	ldr	r2, [r6, #4]
    b500:	str	r2, [r3, #4]
    b502:	ldr	r2, [r6, #8]
    b504:	str	r2, [r3, #8]
    b506:	mov	r6, r7
    b508:	mov	r4, lr
    b50a:	mov	r8, sl
    b50c:	b.n	b376 <_realloc_r+0x122>
    b50e:	add.w	r1, r8, r5
    b512:	rsb	fp, r5, fp
    b516:	orr.w	r2, fp, #1
    b51a:	str	r1, [r3, #8]
    b51c:	str	r2, [r1, #4]
    b51e:	ldr.w	r3, [r6, #-4]
    b522:	and.w	r3, r3, #1
    b526:	orrs	r5, r3
    b528:	mov	r0, r9
    b52a:	str.w	r5, [r6, #-4]
    b52e:	bl	b250 <__malloc_unlock>
    b532:	mov	r0, r6
    b534:	b.n	b39c <_realloc_r+0x148>
    b536:	mov	r1, r6
    b538:	bl	b184 <memmove>
    b53c:	b.n	b2ea <_realloc_r+0x96>
    b53e:	ldr	r3, [r6, #8]
    b540:	str	r3, [r0, #8]
    b542:	ldr	r3, [r6, #12]
    b544:	str	r3, [r0, #12]
    b546:	cmp	r2, #36	; 0x24
    b548:	beq.n	b59c <_realloc_r+0x348>
    b54a:	add.w	r3, r0, #16
    b54e:	add.w	r2, r6, #16
    b552:	b.n	b2de <_realloc_r+0x8a>
    b554:	ldr.w	r3, [r0, #-4]
    b558:	bic.w	r3, r3, #3
    b55c:	add	r4, r3
    b55e:	b.n	b376 <_realloc_r+0x122>
    b560:	mov	r1, r6
    b562:	mov	r0, r7
    b564:	mov	r4, lr
    b566:	mov	r8, sl
    b568:	bl	b184 <memmove>
    b56c:	mov	r6, r7
    b56e:	b.n	b376 <_realloc_r+0x122>
    b570:	mov	r2, r7
    b572:	b.n	b364 <_realloc_r+0x110>
    b574:	mov	r1, r6
    b576:	mov	r0, r7
    b578:	mov	r4, r3
    b57a:	mov	r8, sl
    b57c:	bl	b184 <memmove>
    b580:	mov	r6, r7
    b582:	b.n	b376 <_realloc_r+0x122>
    b584:	ldr	r3, [r6, #8]
    b586:	str.w	r3, [sl, #16]
    b58a:	ldr	r3, [r6, #12]
    b58c:	str.w	r3, [sl, #20]
    b590:	cmp	r2, #36	; 0x24
    b592:	beq.n	b5cc <_realloc_r+0x378>
    b594:	adds	r6, #16
    b596:	add.w	r3, sl, #24
    b59a:	b.n	b4fa <_realloc_r+0x2a6>
    b59c:	ldr	r3, [r6, #16]
    b59e:	str	r3, [r0, #16]
    b5a0:	ldr	r3, [r6, #20]
    b5a2:	str	r3, [r0, #20]
    b5a4:	add.w	r2, r6, #24
    b5a8:	add.w	r3, r0, #24
    b5ac:	b.n	b2de <_realloc_r+0x8a>
    b5ae:	nop
    b5b0:	.word	0x1fff19b0
    b5b4:	ldr	r1, [r6, #8]
    b5b6:	str.w	r1, [sl, #16]
    b5ba:	ldr	r1, [r6, #12]
    b5bc:	str.w	r1, [sl, #20]
    b5c0:	cmp	r2, #36	; 0x24
    b5c2:	beq.n	b5e4 <_realloc_r+0x390>
    b5c4:	adds	r6, #16
    b5c6:	add.w	r2, sl, #24
    b5ca:	b.n	b364 <_realloc_r+0x110>
    b5cc:	ldr	r3, [r6, #16]
    b5ce:	str.w	r3, [sl, #24]
    b5d2:	ldr	r3, [r6, #20]
    b5d4:	str.w	r3, [sl, #28]
    b5d8:	adds	r6, #24
    b5da:	add.w	r3, sl, #32
    b5de:	b.n	b4fa <_realloc_r+0x2a6>
    b5e0:	mov	r2, r7
    b5e2:	b.n	b4ae <_realloc_r+0x25a>
    b5e4:	ldr	r2, [r6, #16]
    b5e6:	str.w	r2, [sl, #24]
    b5ea:	ldr	r2, [r6, #20]
    b5ec:	str.w	r2, [sl, #28]
    b5f0:	adds	r6, #24
    b5f2:	add.w	r2, sl, #32
    b5f6:	b.n	b364 <_realloc_r+0x110>
    b5f8:	mov	r1, r6
    b5fa:	mov	r0, r7
    b5fc:	str	r3, [sp, #4]
    b5fe:	bl	b184 <memmove>
    b602:	ldr	r3, [sp, #4]
    b604:	b.n	b4ba <_realloc_r+0x266>
    b606:	ldr	r1, [r6, #8]
    b608:	str.w	r1, [sl, #16]
    b60c:	ldr	r1, [r6, #12]
    b60e:	str.w	r1, [sl, #20]
    b612:	cmp	r2, #36	; 0x24
    b614:	beq.n	b61e <_realloc_r+0x3ca>
    b616:	adds	r6, #16
    b618:	add.w	r2, sl, #24
    b61c:	b.n	b4ae <_realloc_r+0x25a>
    b61e:	ldr	r2, [r6, #16]
    b620:	str.w	r2, [sl, #24]
    b624:	ldr	r2, [r6, #20]
    b626:	str.w	r2, [sl, #28]
    b62a:	adds	r6, #24
    b62c:	add.w	r2, sl, #32
    b630:	b.n	b4ae <_realloc_r+0x25a>
    b632:	nop

0000b634 <_sbrk_r>:
    b634:	push	{r3, r4, r5, lr}
    b636:	ldr	r4, [pc, #28]	; (b654 <_sbrk_r+0x20>)
    b638:	movs	r3, #0
    b63a:	mov	r5, r0
    b63c:	mov	r0, r1
    b63e:	str	r3, [r4, #0]
    b640:	bl	8cc4 <_sbrk>
    b644:	adds	r3, r0, #1
    b646:	beq.n	b64a <_sbrk_r+0x16>
    b648:	pop	{r3, r4, r5, pc}
    b64a:	ldr	r3, [r4, #0]
    b64c:	cmp	r3, #0
    b64e:	beq.n	b648 <_sbrk_r+0x14>
    b650:	str	r3, [r5, #0]
    b652:	pop	{r3, r4, r5, pc}
    b654:	.word	0x1fff85ec

0000b658 <sprintf>:
    b658:	push	{r1, r2, r3}
    b65a:	push	{r4, r5, r6, r7, lr}
    b65c:	sub	sp, #112	; 0x70
    b65e:	add	r3, sp, #132	; 0x84
    b660:	ldr	r1, [pc, #60]	; (b6a0 <sprintf+0x48>)
    b662:	ldr.w	r2, [r3], #4
    b666:	str	r3, [sp, #4]
    b668:	mov	r5, r0
    b66a:	mvn.w	r4, #2147483648	; 0x80000000
    b66e:	ldr	r0, [r1, #0]
    b670:	str	r5, [sp, #8]
    b672:	mov.w	r7, #520	; 0x208
    b676:	movw	r6, #65535	; 0xffff
    b67a:	add	r1, sp, #8
    b67c:	str	r5, [sp, #24]
    b67e:	strh.w	r7, [sp, #20]
    b682:	str	r4, [sp, #16]
    b684:	str	r4, [sp, #28]
    b686:	strh.w	r6, [sp, #22]
    b68a:	bl	c910 <_svfprintf_r>
    b68e:	ldr	r3, [sp, #8]
    b690:	movs	r2, #0
    b692:	strb	r2, [r3, #0]
    b694:	add	sp, #112	; 0x70
    b696:	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    b69a:	add	sp, #12
    b69c:	bx	lr
    b69e:	nop
    b6a0:	.word	0x1fff1840

0000b6a4 <sscanf>:
    b6a4:	push	{r1, r2, r3}
    b6a6:	push	{r4, r5, r6, r7, lr}
    b6a8:	sub	sp, #112	; 0x70
    b6aa:	add	r4, sp, #132	; 0x84
    b6ac:	mov.w	r2, #516	; 0x204
    b6b0:	ldr.w	r6, [r4], #4
    b6b4:	strh.w	r2, [sp, #20]
    b6b8:	str	r0, [sp, #8]
    b6ba:	str	r0, [sp, #24]
    b6bc:	bl	b700 <strlen>
    b6c0:	ldr	r3, [pc, #48]	; (b6f4 <sscanf+0x50>)
    b6c2:	str	r4, [sp, #4]
    b6c4:	mov	r5, r0
    b6c6:	mov	r2, r6
    b6c8:	ldr	r7, [pc, #44]	; (b6f8 <sscanf+0x54>)
    b6ca:	ldr	r0, [r3, #0]
    b6cc:	str	r5, [sp, #12]
    b6ce:	mov	r3, r4
    b6d0:	movw	r6, #65535	; 0xffff
    b6d4:	movs	r4, #0
    b6d6:	add	r1, sp, #8
    b6d8:	str	r5, [sp, #28]
    b6da:	str	r7, [sp, #40]	; 0x28
    b6dc:	str	r4, [sp, #56]	; 0x38
    b6de:	str	r4, [sp, #76]	; 0x4c
    b6e0:	strh.w	r6, [sp, #22]
    b6e4:	bl	dff4 <__ssvfscanf_r>
    b6e8:	add	sp, #112	; 0x70
    b6ea:	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    b6ee:	add	sp, #12
    b6f0:	bx	lr
    b6f2:	nop
    b6f4:	.word	0x1fff1840
    b6f8:	.word	0x0000b6fd

0000b6fc <__seofread>:
    b6fc:	movs	r0, #0
    b6fe:	bx	lr

0000b700 <strlen>:
    b700:	pld	[r0]
    b704:	strd	r4, r5, [sp, #-8]!
    b708:	bic.w	r1, r0, #7
    b70c:	mvn.w	ip, #0
    b710:	ands.w	r4, r0, #7
    b714:	pld	[r1, #32]
    b718:	bne.w	b7ae <strlen+0xae>
    b71c:	mov.w	r4, #0
    b720:	mvn.w	r0, #7
    b724:	ldrd	r2, r3, [r1]
    b728:	pld	[r1, #64]	; 0x40
    b72c:	add.w	r0, r0, #8
    b730:	uadd8	r2, r2, ip
    b734:	sel	r2, r4, ip
    b738:	uadd8	r3, r3, ip
    b73c:	sel	r3, r2, ip
    b740:	cbnz	r3, b796 <strlen+0x96>
    b742:	ldrd	r2, r3, [r1, #8]
    b746:	uadd8	r2, r2, ip
    b74a:	add.w	r0, r0, #8
    b74e:	sel	r2, r4, ip
    b752:	uadd8	r3, r3, ip
    b756:	sel	r3, r2, ip
    b75a:	cbnz	r3, b796 <strlen+0x96>
    b75c:	ldrd	r2, r3, [r1, #16]
    b760:	uadd8	r2, r2, ip
    b764:	add.w	r0, r0, #8
    b768:	sel	r2, r4, ip
    b76c:	uadd8	r3, r3, ip
    b770:	sel	r3, r2, ip
    b774:	cbnz	r3, b796 <strlen+0x96>
    b776:	ldrd	r2, r3, [r1, #24]
    b77a:	add.w	r1, r1, #32
    b77e:	uadd8	r2, r2, ip
    b782:	add.w	r0, r0, #8
    b786:	sel	r2, r4, ip
    b78a:	uadd8	r3, r3, ip
    b78e:	sel	r3, r2, ip
    b792:	cmp	r3, #0
    b794:	beq.n	b724 <strlen+0x24>
    b796:	cmp	r2, #0
    b798:	itt	eq
    b79a:	addeq	r0, #4
    b79c:	moveq	r2, r3
    b79e:	rev	r2, r2
    b7a0:	clz	r2, r2
    b7a4:	ldrd	r4, r5, [sp], #8
    b7a8:	add.w	r0, r0, r2, lsr #3
    b7ac:	bx	lr
    b7ae:	ldrd	r2, r3, [r1]
    b7b2:	and.w	r5, r4, #3
    b7b6:	rsb	r0, r4, #0
    b7ba:	mov.w	r5, r5, lsl #3
    b7be:	tst.w	r4, #4
    b7c2:	pld	[r1, #64]	; 0x40
    b7c6:	lsl.w	r5, ip, r5
    b7ca:	orn	r2, r2, r5
    b7ce:	itt	ne
    b7d0:	ornne	r3, r3, r5
    b7d4:	movne	r2, ip
    b7d6:	mov.w	r4, #0
    b7da:	b.n	b730 <strlen+0x30>

0000b7dc <strncmp>:
    b7dc:	cmp	r2, #0
    b7de:	beq.n	b864 <strncmp+0x88>
    b7e0:	orr.w	r3, r0, r1
    b7e4:	ands.w	r3, r3, #3
    b7e8:	push	{r4, r5, r6, r7}
    b7ea:	bne.n	b838 <strncmp+0x5c>
    b7ec:	cmp	r2, #3
    b7ee:	bls.n	b838 <strncmp+0x5c>
    b7f0:	ldr	r4, [r0, #0]
    b7f2:	ldr	r5, [r1, #0]
    b7f4:	cmp	r4, r5
    b7f6:	bne.n	b838 <strncmp+0x5c>
    b7f8:	subs	r2, #4
    b7fa:	beq.n	b868 <strncmp+0x8c>
    b7fc:	sub.w	r5, r4, #16843009	; 0x1010101
    b800:	bic.w	r4, r5, r4
    b804:	tst.w	r4, #2155905152	; 0x80808080
    b808:	bne.n	b86e <strncmp+0x92>
    b80a:	adds	r7, r0, #4
    b80c:	adds	r5, r1, #4
    b80e:	b.n	b82c <strncmp+0x50>
    b810:	ldr.w	r3, [r7], #4
    b814:	ldr	r6, [r1, #0]
    b816:	sub.w	r4, r3, #16843009	; 0x1010101
    b81a:	cmp	r3, r6
    b81c:	bic.w	r4, r4, r3
    b820:	bne.n	b838 <strncmp+0x5c>
    b822:	subs	r2, #4
    b824:	beq.n	b868 <strncmp+0x8c>
    b826:	tst.w	r4, #2155905152	; 0x80808080
    b82a:	bne.n	b874 <strncmp+0x98>
    b82c:	cmp	r2, #3
    b82e:	mov	r1, r5
    b830:	mov	r0, r7
    b832:	add.w	r5, r5, #4
    b836:	bhi.n	b810 <strncmp+0x34>
    b838:	ldrb	r3, [r0, #0]
    b83a:	ldrb	r4, [r1, #0]
    b83c:	cmp	r4, r3
    b83e:	add.w	r2, r2, #4294967295
    b842:	bne.n	b85e <strncmp+0x82>
    b844:	cbz	r2, b868 <strncmp+0x8c>
    b846:	cbnz	r4, b84e <strncmp+0x72>
    b848:	b.n	b878 <strncmp+0x9c>
    b84a:	cbz	r2, b868 <strncmp+0x8c>
    b84c:	cbz	r3, b86e <strncmp+0x92>
    b84e:	ldrb.w	r3, [r0, #1]!
    b852:	ldrb.w	r4, [r1, #1]!
    b856:	cmp	r3, r4
    b858:	add.w	r2, r2, #4294967295
    b85c:	beq.n	b84a <strncmp+0x6e>
    b85e:	subs	r0, r3, r4
    b860:	pop	{r4, r5, r6, r7}
    b862:	bx	lr
    b864:	mov	r0, r2
    b866:	bx	lr
    b868:	mov	r0, r2
    b86a:	pop	{r4, r5, r6, r7}
    b86c:	bx	lr
    b86e:	mov	r0, r3
    b870:	pop	{r4, r5, r6, r7}
    b872:	bx	lr
    b874:	movs	r0, #0
    b876:	b.n	b860 <strncmp+0x84>
    b878:	mov	r0, r4
    b87a:	b.n	b860 <strncmp+0x84>

0000b87c <sulp>:
    b87c:	push	{r4, r5, r6, lr}
    b87e:	mov	r4, r0
    b880:	mov	r5, r1
    b882:	vmov	d0, r4, r5
    b886:	mov	r6, r2
    b888:	bl	10fe0 <__ulp>
    b88c:	vmov	r0, r1, d0
    b890:	cbz	r6, b8b2 <sulp+0x36>
    b892:	ubfx	r3, r5, #20, #11
    b896:	rsb	r3, r3, #107	; 0x6b
    b89a:	cmp	r3, #0
    b89c:	ble.n	b8b2 <sulp+0x36>
    b89e:	lsls	r3, r3, #20
    b8a0:	add.w	r5, r3, #1069547520	; 0x3fc00000
    b8a4:	movs	r4, #0
    b8a6:	add.w	r5, r5, #3145728	; 0x300000
    b8aa:	mov	r2, r4
    b8ac:	mov	r3, r5
    b8ae:	bl	a05c <__aeabi_dmul>
    b8b2:	pop	{r4, r5, r6, pc}
    b8b4:			; <UNDEFINED> instruction: 0xffffffff

0000b8b8 <_strtod_l>:
    b8b8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b8bc:	mov	r5, r3
    b8be:	sub	sp, #132	; 0x84
    b8c0:	movs	r3, #0
    b8c2:	mov	fp, r0
    b8c4:	mov	r0, r5
    b8c6:	mov	r6, r1
    b8c8:	str	r2, [sp, #24]
    b8ca:	str	r3, [sp, #112]	; 0x70
    b8cc:	bl	10964 <__localeconv_l>
    b8d0:	movs	r4, #0
    b8d2:	movs	r3, #0
    b8d4:	mov	sl, r0
    b8d6:	ldr	r0, [r0, #0]
    b8d8:	strd	r3, r4, [sp, #16]
    b8dc:	bl	b700 <strlen>
    b8e0:	str	r6, [sp, #108]	; 0x6c
    b8e2:	mov	r9, r0
    b8e4:	mov	r2, r6
    b8e6:	mov	r4, r2
    b8e8:	ldrb.w	r7, [r2], #1
    b8ec:	cmp	r7, #45	; 0x2d
    b8ee:	bhi.w	ba50 <_strtod_l+0x198>
    b8f2:	tbb	[pc, r7]
    b8f6:	.short	0xad17
    b8f8:	.word	0xadadadad
    b8fc:	.word	0x81adadad
    b900:	.word	0x81818181
    b904:	.word	0xadadadad
    b908:	.word	0xadadadad
    b90c:	.word	0xadadadad
    b910:	.word	0xadadadad
    b914:	.word	0xad81adad
    b918:	.word	0xadadadad
    b91c:	.word	0xadadadad
    b920:	.word	0x7ead2bad
    b924:	ldr	r3, [sp, #24]
    b926:	mov.w	r8, #0
    b92a:	mov.w	r9, #0
    b92e:	cbz	r3, b942 <_strtod_l+0x8a>
    b930:	movs	r3, #0
    b932:	str	r3, [sp, #28]
    b934:	ldr	r3, [sp, #24]
    b936:	str	r6, [r3, #0]
    b938:	ldr	r3, [sp, #28]
    b93a:	cbz	r3, b942 <_strtod_l+0x8a>
    b93c:	add.w	r3, r9, #2147483648	; 0x80000000
    b940:	mov	r9, r3
    b942:	vmov	d0, r8, r9
    b946:	add	sp, #132	; 0x84
    b948:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b94c:	movs	r3, #0
    b94e:	str	r3, [sp, #28]
    b950:	adds	r2, r4, #1
    b952:	str	r2, [sp, #108]	; 0x6c
    b954:	ldrb	r7, [r4, #1]
    b956:	cmp	r7, #0
    b958:	beq.n	b924 <_strtod_l+0x6c>
    b95a:	cmp	r7, #48	; 0x30
    b95c:	mov	r4, r2
    b95e:	beq.n	ba58 <_strtod_l+0x1a0>
    b960:	movs	r3, #0
    b962:	str	r4, [sp, #32]
    b964:	str	r3, [sp, #40]	; 0x28
    b966:	sub.w	r3, r7, #48	; 0x30
    b96a:	cmp	r3, #9
    b96c:	bhi.w	c17e <_strtod_l+0x8c6>
    b970:	mov.w	r8, #0
    b974:	mov	r0, r4
    b976:	mov	r5, r8
    b978:	mov	r4, r8
    b97a:	cmp	r4, #8
    b97c:	it	gt
    b97e:	addgt.w	r8, r8, r8, lsl #2
    b982:	add.w	r3, r5, r5, lsl #2
    b986:	add.w	r0, r0, #1
    b98a:	add.w	r3, r7, r3, lsl #1
    b98e:	str	r0, [sp, #108]	; 0x6c
    b990:	itt	gt
    b992:	addgt.w	r7, r7, r8, lsl #1
    b996:	subgt.w	r8, r7, #48	; 0x30
    b99a:	ldrb	r7, [r0, #0]
    b99c:	it	le
    b99e:	suble.w	r5, r3, #48	; 0x30
    b9a2:	sub.w	r3, r7, #48	; 0x30
    b9a6:	cmp	r3, #9
    b9a8:	add.w	r4, r4, #1
    b9ac:	bls.n	b97a <_strtod_l+0xc2>
    b9ae:	ldr.w	r1, [sl]
    b9b2:	mov	r2, r9
    b9b4:	bl	b7dc <strncmp>
    b9b8:	cbz	r0, b9fc <_strtod_l+0x144>
    b9ba:	movs	r0, #0
    b9bc:	mov	r3, r7
    b9be:	mov	r9, r0
    b9c0:	mov	r7, r0
    b9c2:	mov	sl, r4
    b9c4:	cmp	r3, #101	; 0x65
    b9c6:	beq.w	bb2e <_strtod_l+0x276>
    b9ca:	cmp	r3, #69	; 0x45
    b9cc:	beq.w	bb2e <_strtod_l+0x276>
    b9d0:	movs	r2, #0
    b9d2:	cmp	r4, #0
    b9d4:	bne.n	ba7c <_strtod_l+0x1c4>
    b9d6:	cbnz	r0, b9e0 <_strtod_l+0x128>
    b9d8:	ldr	r2, [sp, #40]	; 0x28
    b9da:	cmp	r2, #0
    b9dc:	beq.w	bf82 <_strtod_l+0x6ca>
    b9e0:	mov.w	r8, #0
    b9e4:	mov.w	r9, #0
    b9e8:	ldr	r3, [sp, #24]
    b9ea:	cmp	r3, #0
    b9ec:	beq.n	b938 <_strtod_l+0x80>
    b9ee:	ldr	r6, [sp, #108]	; 0x6c
    b9f0:	b.n	b934 <_strtod_l+0x7c>
    b9f2:	movs	r3, #1
    b9f4:	str	r3, [sp, #28]
    b9f6:	b.n	b950 <_strtod_l+0x98>
    b9f8:	str	r2, [sp, #108]	; 0x6c
    b9fa:	b.n	b8e6 <_strtod_l+0x2e>
    b9fc:	ldr	r3, [sp, #108]	; 0x6c
    b9fe:	add.w	r2, r3, r9
    ba02:	str	r2, [sp, #108]	; 0x6c
    ba04:	ldrb.w	r3, [r3, r9]
    ba08:	mov	r7, r0
    ba0a:	mov	sl, r4
    ba0c:	sub.w	r2, r3, #48	; 0x30
    ba10:	cmp	r2, #9
    ba12:	bhi.w	bf08 <_strtod_l+0x650>
    ba16:	adds	r1, r0, #1
    ba18:	mov	r3, r2
    ba1a:	cmp	r2, #0
    ba1c:	beq.w	c75e <_strtod_l+0xea6>
    ba20:	cmp	r1, #1
    ba22:	add	r7, r1
    ba24:	it	ne
    ba26:	addne	r0, r0, r4
    ba28:	bne.n	ba36 <_strtod_l+0x17e>
    ba2a:	b.w	c756 <_strtod_l+0xe9e>
    ba2e:	lsls	r5, r1, #1
    ba30:	cmp	r4, r0
    ba32:	beq.w	c3ac <_strtod_l+0xaf4>
    ba36:	adds	r4, #1
    ba38:	subs	r1, r4, #1
    ba3a:	cmp	r1, #8
    ba3c:	add.w	r1, r5, r5, lsl #2
    ba40:	ble.n	ba2e <_strtod_l+0x176>
    ba42:	cmp	r4, #16
    ba44:	itt	le
    ba46:	addle.w	r8, r8, r8, lsl #2
    ba4a:	movle.w	r8, r8, lsl #1
    ba4e:	b.n	ba30 <_strtod_l+0x178>
    ba50:	movs	r3, #0
    ba52:	cmp	r7, #48	; 0x30
    ba54:	str	r3, [sp, #28]
    ba56:	bne.n	b960 <_strtod_l+0xa8>
    ba58:	ldrb	r3, [r4, #1]
    ba5a:	cmp	r3, #88	; 0x58
    ba5c:	beq.w	c146 <_strtod_l+0x88e>
    ba60:	cmp	r3, #120	; 0x78
    ba62:	beq.w	c146 <_strtod_l+0x88e>
    ba66:	adds	r4, #1
    ba68:	str	r4, [sp, #108]	; 0x6c
    ba6a:	ldrb	r7, [r4, #0]
    ba6c:	cmp	r7, #48	; 0x30
    ba6e:	beq.n	ba66 <_strtod_l+0x1ae>
    ba70:	cmp	r7, #0
    ba72:	beq.n	b9e0 <_strtod_l+0x128>
    ba74:	movs	r3, #1
    ba76:	str	r4, [sp, #32]
    ba78:	str	r3, [sp, #40]	; 0x28
    ba7a:	b.n	b966 <_strtod_l+0xae>
    ba7c:	cmp	r4, #16
    ba7e:	sub.w	r3, r2, r7
    ba82:	mov	r0, r5
    ba84:	mov	r9, r4
    ba86:	str	r3, [sp, #44]	; 0x2c
    ba88:	it	ge
    ba8a:	movge.w	r9, #16
    ba8e:	bl	9f70 <__aeabi_ui2d>
    ba92:	cmp.w	sl, #0
    ba96:	it	eq
    ba98:	moveq	sl, r4
    ba9a:	cmp.w	r9, #9
    ba9e:	strd	r0, r1, [sp, #16]
    baa2:	ble.n	bacc <_strtod_l+0x214>
    baa4:	ldr	r3, [pc, #292]	; (bbcc <_strtod_l+0x314>)
    baa6:	add.w	r3, r3, r9, lsl #3
    baaa:	ldrd	r2, r3, [r3, #-72]	; 0x48
    baae:	bl	a05c <__aeabi_dmul>
    bab2:	mov	r6, r0
    bab4:	mov	r0, r8
    bab6:	mov	r7, r1
    bab8:	bl	9f70 <__aeabi_ui2d>
    babc:	mov	r2, r0
    babe:	mov	r3, r1
    bac0:	mov	r0, r6
    bac2:	mov	r1, r7
    bac4:	bl	9cf8 <__adddf3>
    bac8:	strd	r0, r1, [sp, #16]
    bacc:	cmp	r4, #15
    bace:	bgt.w	bbdc <_strtod_l+0x324>
    bad2:	ldr	r3, [sp, #44]	; 0x2c
    bad4:	cmp	r3, #0
    bad6:	beq.n	bb28 <_strtod_l+0x270>
    bad8:	ble.w	c514 <_strtod_l+0xc5c>
    badc:	ldr	r3, [sp, #44]	; 0x2c
    bade:	cmp	r3, #22
    bae0:	bgt.w	c3e0 <_strtod_l+0xb28>
    bae4:	ldr	r7, [pc, #228]	; (bbcc <_strtod_l+0x314>)
    bae6:	add.w	r7, r7, r3, lsl #3
    baea:	ldrd	r0, r1, [r7]
    baee:	ldrd	r2, r3, [sp, #16]
    baf2:	bl	a05c <__aeabi_dmul>
    baf6:	mov	r8, r0
    baf8:	mov	r9, r1
    bafa:	b.n	b9e8 <_strtod_l+0x130>
    bafc:	add	r0, sp, #108	; 0x6c
    bafe:	ldr	r1, [pc, #208]	; (bbd0 <_strtod_l+0x318>)
    bb00:	bl	10798 <__match>
    bb04:	cmp	r0, #0
    bb06:	beq.w	b924 <_strtod_l+0x6c>
    bb0a:	ldr	r3, [sp, #108]	; 0x6c
    bb0c:	ldr	r1, [pc, #196]	; (bbd4 <_strtod_l+0x31c>)
    bb0e:	subs	r3, #1
    bb10:	add	r0, sp, #108	; 0x6c
    bb12:	str	r3, [sp, #108]	; 0x6c
    bb14:	bl	10798 <__match>
    bb18:	cbnz	r0, bb20 <_strtod_l+0x268>
    bb1a:	ldr	r3, [sp, #108]	; 0x6c
    bb1c:	adds	r3, #1
    bb1e:	str	r3, [sp, #108]	; 0x6c
    bb20:	ldr	r3, [pc, #180]	; (bbd8 <_strtod_l+0x320>)
    bb22:	str	r3, [sp, #20]
    bb24:	movs	r3, #0
    bb26:	str	r3, [sp, #16]
    bb28:	ldrd	r8, r9, [sp, #16]
    bb2c:	b.n	b9e8 <_strtod_l+0x130>
    bb2e:	cmp	r4, #0
    bb30:	beq.w	bec8 <_strtod_l+0x610>
    bb34:	ldr	r6, [sp, #108]	; 0x6c
    bb36:	adds	r3, r6, #1
    bb38:	str	r3, [sp, #108]	; 0x6c
    bb3a:	ldrb	r3, [r6, #1]
    bb3c:	cmp	r3, #43	; 0x2b
    bb3e:	beq.w	c0fc <_strtod_l+0x844>
    bb42:	cmp	r3, #45	; 0x2d
    bb44:	beq.w	bf72 <_strtod_l+0x6ba>
    bb48:	mov.w	ip, #0
    bb4c:	sub.w	r2, r3, #48	; 0x30
    bb50:	cmp	r2, #9
    bb52:	bhi.w	c0f6 <_strtod_l+0x83e>
    bb56:	cmp	r3, #48	; 0x30
    bb58:	bne.n	bb66 <_strtod_l+0x2ae>
    bb5a:	ldr	r2, [sp, #108]	; 0x6c
    bb5c:	adds	r2, #1
    bb5e:	str	r2, [sp, #108]	; 0x6c
    bb60:	ldrb	r3, [r2, #0]
    bb62:	cmp	r3, #48	; 0x30
    bb64:	beq.n	bb5c <_strtod_l+0x2a4>
    bb66:	sub.w	r2, r3, #49	; 0x31
    bb6a:	cmp	r2, #8
    bb6c:	bhi.w	b9d0 <_strtod_l+0x118>
    bb70:	ldr	r2, [sp, #108]	; 0x6c
    bb72:	str	r2, [sp, #48]	; 0x30
    bb74:	adds	r1, r2, #1
    bb76:	subs	r3, #48	; 0x30
    bb78:	str	r1, [sp, #108]	; 0x6c
    bb7a:	str	r3, [sp, #44]	; 0x2c
    bb7c:	ldrb	r3, [r2, #1]
    bb7e:	sub.w	lr, r3, #48	; 0x30
    bb82:	cmp.w	lr, #9
    bb86:	bhi.n	bba8 <_strtod_l+0x2f0>
    bb88:	ldr	r2, [sp, #44]	; 0x2c
    bb8a:	adds	r1, #1
    bb8c:	str	r1, [sp, #108]	; 0x6c
    bb8e:	add.w	r2, r2, r2, lsl #2
    bb92:	add.w	r2, r3, r2, lsl #1
    bb96:	ldrb	r3, [r1, #0]
    bb98:	sub.w	lr, r3, #48	; 0x30
    bb9c:	cmp.w	lr, #9
    bba0:	sub.w	r2, r2, #48	; 0x30
    bba4:	bls.n	bb8a <_strtod_l+0x2d2>
    bba6:	str	r2, [sp, #44]	; 0x2c
    bba8:	ldr	r2, [sp, #48]	; 0x30
    bbaa:	subs	r1, r1, r2
    bbac:	cmp	r1, #8
    bbae:	bgt.w	c3ce <_strtod_l+0xb16>
    bbb2:	ldr	r2, [sp, #44]	; 0x2c
    bbb4:	movw	r1, #19999	; 0x4e1f
    bbb8:	cmp	r2, r1
    bbba:	it	ge
    bbbc:	movge	r2, r1
    bbbe:	cmp.w	ip, #0
    bbc2:	beq.w	b9d2 <_strtod_l+0x11a>
    bbc6:	negs	r2, r2
    bbc8:	b.n	b9d2 <_strtod_l+0x11a>
    bbca:	nop
    bbcc:	.word	0x00012bc0
    bbd0:	.word	0x000128cc
    bbd4:	.word	0x000128d0
    bbd8:	.word	0x7ff00000
    bbdc:	ldr	r3, [sp, #44]	; 0x2c
    bbde:	rsb	r9, r9, r4
    bbe2:	add	r9, r3
    bbe4:	cmp.w	r9, #0
    bbe8:	ble.w	c2fa <_strtod_l+0xa42>
    bbec:	ands.w	r1, r9, #15
    bbf0:	beq.n	bc08 <_strtod_l+0x350>
    bbf2:	ldr	r3, [pc, #756]	; (bee8 <_strtod_l+0x630>)
    bbf4:	add.w	r1, r3, r1, lsl #3
    bbf8:	ldrd	r0, r1, [r1]
    bbfc:	ldrd	r2, r3, [sp, #16]
    bc00:	bl	a05c <__aeabi_dmul>
    bc04:	strd	r0, r1, [sp, #16]
    bc08:	bics.w	r6, r9, #15
    bc0c:	bne.w	c030 <_strtod_l+0x778>
    bc10:	movs	r3, #0
    bc12:	str	r3, [sp, #40]	; 0x28
    bc14:	str	r5, [sp, #0]
    bc16:	mov	r3, r4
    bc18:	mov	r2, sl
    bc1a:	ldr	r1, [sp, #32]
    bc1c:	mov	r0, fp
    bc1e:	bl	10ac0 <__s2b>
    bc22:	str	r0, [sp, #72]	; 0x48
    bc24:	cmp	r0, #0
    bc26:	beq.w	c276 <_strtod_l+0x9be>
    bc2a:	ldr	r2, [sp, #44]	; 0x2c
    bc2c:	movs	r7, #0
    bc2e:	cmp	r2, #0
    bc30:	rsb	r3, r2, #0
    bc34:	it	ge
    bc36:	movge	r3, r7
    bc38:	str	r3, [sp, #48]	; 0x30
    bc3a:	bic.w	r3, r2, r2, asr #31
    bc3e:	str	r3, [sp, #44]	; 0x2c
    bc40:	mov	sl, r7
    bc42:	ldr	r4, [sp, #72]	; 0x48
    bc44:	mov	r0, fp
    bc46:	ldr	r1, [r4, #4]
    bc48:	bl	109e0 <_Balloc>
    bc4c:	mov	r6, r0
    bc4e:	cmp	r0, #0
    bc50:	beq.w	c108 <_strtod_l+0x850>
    bc54:	ldr	r2, [r4, #16]
    bc56:	vldr	d7, [sp, #16]
    bc5a:	adds	r2, #2
    bc5c:	lsls	r2, r2, #2
    bc5e:	add.w	r1, r4, #12
    bc62:	adds	r0, #12
    bc64:	vstr	d7, [sp, #32]
    bc68:	bl	8720 <memcpy>
    bc6c:	vldr	d0, [sp, #32]
    bc70:	add	r2, sp, #120	; 0x78
    bc72:	add	r1, sp, #116	; 0x74
    bc74:	mov	r0, fp
    bc76:	bl	11104 <__d2b>
    bc7a:	str	r0, [sp, #112]	; 0x70
    bc7c:	cmp	r0, #0
    bc7e:	beq.w	c10a <_strtod_l+0x852>
    bc82:	movs	r1, #1
    bc84:	mov	r0, fp
    bc86:	bl	10bf4 <__i2b>
    bc8a:	mov	sl, r0
    bc8c:	cmp	r0, #0
    bc8e:	beq.w	c108 <_strtod_l+0x850>
    bc92:	ldr	r2, [sp, #116]	; 0x74
    bc94:	cmp	r2, #0
    bc96:	blt.w	bf00 <_strtod_l+0x648>
    bc9a:	ldr	r3, [sp, #48]	; 0x30
    bc9c:	ldr	r4, [sp, #44]	; 0x2c
    bc9e:	adds	r5, r3, r2
    bca0:	ldr	r0, [sp, #40]	; 0x28
    bca2:	ldr	r3, [sp, #120]	; 0x78
    bca4:	ldr	r1, [pc, #580]	; (beec <_strtod_l+0x634>)
    bca6:	subs	r2, r2, r0
    bca8:	add	r2, r3
    bcaa:	subs	r2, #1
    bcac:	cmp	r2, r1
    bcae:	rsb	r3, r3, #54	; 0x36
    bcb2:	bge.w	be92 <_strtod_l+0x5da>
    bcb6:	subs	r1, r1, r2
    bcb8:	cmp	r1, #31
    bcba:	sub.w	r3, r3, r1
    bcbe:	bgt.w	bf0e <_strtod_l+0x656>
    bcc2:	movs	r2, #1
    bcc4:	lsls	r2, r1
    bcc6:	str	r2, [sp, #56]	; 0x38
    bcc8:	movs	r2, #0
    bcca:	str	r2, [sp, #76]	; 0x4c
    bccc:	add.w	r9, r5, r3
    bcd0:	add	r4, r3
    bcd2:	ldr	r3, [sp, #40]	; 0x28
    bcd4:	cmp	r5, r9
    bcd6:	mov	r2, r5
    bcd8:	add	r4, r3
    bcda:	it	ge
    bcdc:	movge	r2, r9
    bcde:	cmp	r2, r4
    bce0:	it	ge
    bce2:	movge	r2, r4
    bce4:	cmp	r2, #0
    bce6:	ble.n	bcf0 <_strtod_l+0x438>
    bce8:	rsb	r9, r2, r9
    bcec:	subs	r4, r4, r2
    bcee:	subs	r5, r5, r2
    bcf0:	ldr	r3, [sp, #48]	; 0x30
    bcf2:	cbz	r3, bd24 <_strtod_l+0x46c>
    bcf4:	mov	r1, sl
    bcf6:	mov	r2, r3
    bcf8:	mov	r0, fp
    bcfa:	bl	10d38 <__pow5mult>
    bcfe:	mov	sl, r0
    bd00:	cmp	r0, #0
    bd02:	beq.w	c108 <_strtod_l+0x850>
    bd06:	mov	r1, r0
    bd08:	ldr	r2, [sp, #112]	; 0x70
    bd0a:	mov	r0, fp
    bd0c:	bl	10c08 <__multiply>
    bd10:	cmp	r0, #0
    bd12:	beq.w	c108 <_strtod_l+0x850>
    bd16:	str	r0, [sp, #52]	; 0x34
    bd18:	ldr	r1, [sp, #112]	; 0x70
    bd1a:	mov	r0, fp
    bd1c:	bl	10a2c <_Bfree>
    bd20:	ldr	r2, [sp, #52]	; 0x34
    bd22:	str	r2, [sp, #112]	; 0x70
    bd24:	cmp.w	r9, #0
    bd28:	ble.n	bd3c <_strtod_l+0x484>
    bd2a:	mov	r2, r9
    bd2c:	ldr	r1, [sp, #112]	; 0x70
    bd2e:	mov	r0, fp
    bd30:	bl	10dd8 <__lshift>
    bd34:	str	r0, [sp, #112]	; 0x70
    bd36:	cmp	r0, #0
    bd38:	beq.w	c10a <_strtod_l+0x852>
    bd3c:	ldr	r3, [sp, #44]	; 0x2c
    bd3e:	cbz	r3, bd52 <_strtod_l+0x49a>
    bd40:	mov	r1, r6
    bd42:	ldr	r2, [sp, #44]	; 0x2c
    bd44:	mov	r0, fp
    bd46:	bl	10d38 <__pow5mult>
    bd4a:	mov	r6, r0
    bd4c:	cmp	r0, #0
    bd4e:	beq.w	c108 <_strtod_l+0x850>
    bd52:	cmp	r4, #0
    bd54:	ble.n	bd68 <_strtod_l+0x4b0>
    bd56:	mov	r1, r6
    bd58:	mov	r2, r4
    bd5a:	mov	r0, fp
    bd5c:	bl	10dd8 <__lshift>
    bd60:	mov	r6, r0
    bd62:	cmp	r0, #0
    bd64:	beq.w	c108 <_strtod_l+0x850>
    bd68:	cmp	r5, #0
    bd6a:	ble.n	bd7e <_strtod_l+0x4c6>
    bd6c:	mov	r1, sl
    bd6e:	mov	r2, r5
    bd70:	mov	r0, fp
    bd72:	bl	10dd8 <__lshift>
    bd76:	mov	sl, r0
    bd78:	cmp	r0, #0
    bd7a:	beq.w	c108 <_strtod_l+0x850>
    bd7e:	mov	r2, r6
    bd80:	ldr	r1, [sp, #112]	; 0x70
    bd82:	mov	r0, fp
    bd84:	bl	10ecc <__mdiff>
    bd88:	mov	r7, r0
    bd8a:	cmp	r0, #0
    bd8c:	beq.w	c108 <_strtod_l+0x850>
    bd90:	movs	r3, #0
    bd92:	ldr	r2, [r0, #12]
    bd94:	str	r3, [r0, #12]
    bd96:	mov	r1, sl
    bd98:	str	r2, [sp, #52]	; 0x34
    bd9a:	bl	10e88 <__mcmp>
    bd9e:	cmp	r0, #0
    bda0:	blt.w	c5be <_strtod_l+0xd06>
    bda4:	beq.w	c538 <_strtod_l+0xc80>
    bda8:	mov	r1, sl
    bdaa:	mov	r0, r7
    bdac:	bl	111c0 <__ratio>
    bdb0:	vmov	r4, r5, d0
    bdb4:	movs	r2, #0
    bdb6:	mov.w	r3, #1073741824	; 0x40000000
    bdba:	vmov	r0, s0
    bdbe:	mov	r1, r5
    bdc0:	bl	a554 <__aeabi_dcmple>
    bdc4:	cmp	r0, #0
    bdc6:	beq.n	be9c <_strtod_l+0x5e4>
    bdc8:	ldr	r3, [sp, #52]	; 0x34
    bdca:	cmp	r3, #0
    bdcc:	beq.w	bf1e <_strtod_l+0x666>
    bdd0:	vldr	d7, [pc, #260]	; bed8 <_strtod_l+0x620>
    bdd4:	ldr	r3, [sp, #20]
    bdd6:	ldr	r5, [pc, #280]	; (bef0 <_strtod_l+0x638>)
    bdd8:	vstr	d7, [sp, #56]	; 0x38
    bddc:	movs	r4, #0
    bdde:	mov	r8, r3
    bde0:	ldr.w	r9, [pc, #276]	; bef8 <_strtod_l+0x640>
    bde4:	ldr	r3, [pc, #268]	; (bef4 <_strtod_l+0x63c>)
    bde6:	and.w	r9, r8, r9
    bdea:	cmp	r9, r3
    bdec:	beq.w	c21c <_strtod_l+0x964>
    bdf0:	ldr	r3, [sp, #40]	; 0x28
    bdf2:	cbz	r3, be40 <_strtod_l+0x588>
    bdf4:	cmp.w	r9, #111149056	; 0x6a00000
    bdf8:	bhi.n	be40 <_strtod_l+0x588>
    bdfa:	add	r3, pc, #228	; (adr r3, bee0 <_strtod_l+0x628>)
    bdfc:	ldrd	r2, r3, [r3]
    be00:	ldrd	r0, r1, [sp, #56]	; 0x38
    be04:	bl	a554 <__aeabi_dcmple>
    be08:	cbz	r0, be38 <_strtod_l+0x580>
    be0a:	ldrd	r0, r1, [sp, #56]	; 0x38
    be0e:	bl	a60c <__aeabi_d2uiz>
    be12:	cmp	r0, #0
    be14:	beq.w	c498 <_strtod_l+0xbe0>
    be18:	bl	9f70 <__aeabi_ui2d>
    be1c:	strd	r0, r1, [sp, #56]	; 0x38
    be20:	ldr	r3, [sp, #52]	; 0x34
    be22:	cmp	r3, #0
    be24:	bne.w	c48e <_strtod_l+0xbd6>
    be28:	ldrd	r1, r2, [sp, #56]	; 0x38
    be2c:	add.w	r3, r2, #2147483648	; 0x80000000
    be30:	str	r1, [sp, #80]	; 0x50
    be32:	str	r3, [sp, #84]	; 0x54
    be34:	ldrd	r4, r5, [sp, #80]	; 0x50
    be38:	add.w	r3, r5, #112197632	; 0x6b00000
    be3c:	rsb	r5, r9, r3
    be40:	vldr	d0, [sp, #32]
    be44:	bl	10fe0 <__ulp>
    be48:	mov	r0, r4
    be4a:	vmov	r2, r3, d0
    be4e:	mov	r1, r5
    be50:	bl	a05c <__aeabi_dmul>
    be54:	ldrd	r2, r3, [sp, #32]
    be58:	bl	9cf8 <__adddf3>
    be5c:	strd	r0, r1, [sp, #16]
    be60:	mov	r4, r1
    be62:	ldr	r3, [sp, #40]	; 0x28
    be64:	cbnz	r3, be70 <_strtod_l+0x5b8>
    be66:	ldr	r3, [pc, #144]	; (bef8 <_strtod_l+0x640>)
    be68:	ands	r3, r4
    be6a:	cmp	r9, r3
    be6c:	beq.w	c28c <_strtod_l+0x9d4>
    be70:	ldr	r1, [sp, #112]	; 0x70
    be72:	mov	r0, fp
    be74:	bl	10a2c <_Bfree>
    be78:	mov	r1, r6
    be7a:	mov	r0, fp
    be7c:	bl	10a2c <_Bfree>
    be80:	mov	r1, sl
    be82:	mov	r0, fp
    be84:	bl	10a2c <_Bfree>
    be88:	mov	r1, r7
    be8a:	mov	r0, fp
    be8c:	bl	10a2c <_Bfree>
    be90:	b.n	bc42 <_strtod_l+0x38a>
    be92:	movs	r2, #0
    be94:	str	r2, [sp, #76]	; 0x4c
    be96:	movs	r2, #1
    be98:	str	r2, [sp, #56]	; 0x38
    be9a:	b.n	bccc <_strtod_l+0x414>
    be9c:	ldr	r3, [pc, #92]	; (befc <_strtod_l+0x644>)
    be9e:	mov	r0, r4
    bea0:	mov	r1, r5
    bea2:	movs	r2, #0
    bea4:	bl	a05c <__aeabi_dmul>
    bea8:	ldr	r3, [sp, #52]	; 0x34
    beaa:	strd	r0, r1, [sp, #56]	; 0x38
    beae:	cmp	r3, #0
    beb0:	bne.n	bf68 <_strtod_l+0x6b0>
    beb2:	add.w	r3, r1, #2147483648	; 0x80000000
    beb6:	str	r0, [sp, #64]	; 0x40
    beb8:	str	r3, [sp, #68]	; 0x44
    beba:	ldr	r3, [sp, #20]
    bebc:	ldrd	r4, r5, [sp, #64]	; 0x40
    bec0:	mov	r8, r3
    bec2:	b.n	bde0 <_strtod_l+0x528>
    bec4:	mov.w	r9, #1
    bec8:	cmp	r0, #0
    beca:	bne.n	bf7e <_strtod_l+0x6c6>
    becc:	ldr	r3, [sp, #40]	; 0x28
    bece:	cmp	r3, #0
    bed0:	beq.w	b924 <_strtod_l+0x6c>
    bed4:	mov	r4, r0
    bed6:	b.n	bb34 <_strtod_l+0x27c>
    bed8:	.word	0x00000000
    bedc:	.word	0x3ff00000
    bee0:	.word	0xffc00000
    bee4:	.word	0x41dfffff
    bee8:	.word	0x00012bc0
    beec:	.word	0xfffffc02
    bef0:	.word	0x3ff00000
    bef4:	.word	0x7fe00000
    bef8:	.word	0x7ff00000
    befc:	.word	0x3fe00000
    bf00:	ldr	r3, [sp, #44]	; 0x2c
    bf02:	ldr	r5, [sp, #48]	; 0x30
    bf04:	subs	r4, r3, r2
    bf06:	b.n	bca0 <_strtod_l+0x3e8>
    bf08:	mov.w	r9, #1
    bf0c:	b.n	b9c4 <_strtod_l+0x10c>
    bf0e:	ldr	r1, [pc, #736]	; (c1f0 <_strtod_l+0x938>)
    bf10:	subs	r1, r1, r2
    bf12:	movs	r2, #1
    bf14:	lsl.w	r1, r2, r1
    bf18:	str	r1, [sp, #76]	; 0x4c
    bf1a:	str	r2, [sp, #56]	; 0x38
    bf1c:	b.n	bccc <_strtod_l+0x414>
    bf1e:	ldrd	r1, r2, [sp, #16]
    bf22:	cmp	r1, #0
    bf24:	bne.w	c0ba <_strtod_l+0x802>
    bf28:	ubfx	r3, r2, #0, #20
    bf2c:	mov	r8, r2
    bf2e:	cmp	r3, #0
    bf30:	bne.w	c0c6 <_strtod_l+0x80e>
    bf34:	movs	r2, #0
    bf36:	ldr	r3, [pc, #700]	; (c1f4 <_strtod_l+0x93c>)
    bf38:	mov	r0, r4
    bf3a:	mov	r1, r5
    bf3c:	bl	a540 <__aeabi_dcmplt>
    bf40:	cmp	r0, #0
    bf42:	bne.w	c642 <_strtod_l+0xd8a>
    bf46:	movs	r2, #0
    bf48:	ldr	r3, [pc, #684]	; (c1f8 <_strtod_l+0x940>)
    bf4a:	mov	r0, r4
    bf4c:	mov	r1, r5
    bf4e:	bl	a05c <__aeabi_dmul>
    bf52:	mov	r2, r1
    bf54:	mov	r1, r0
    bf56:	strd	r1, r2, [sp, #56]	; 0x38
    bf5a:	add.w	r3, r2, #2147483648	; 0x80000000
    bf5e:	str	r0, [sp, #96]	; 0x60
    bf60:	str	r3, [sp, #100]	; 0x64
    bf62:	ldrd	r4, r5, [sp, #96]	; 0x60
    bf66:	b.n	bde0 <_strtod_l+0x528>
    bf68:	vldr	d7, [sp, #56]	; 0x38
    bf6c:	vstr	d7, [sp, #64]	; 0x40
    bf70:	b.n	beba <_strtod_l+0x602>
    bf72:	mov.w	ip, #1
    bf76:	adds	r3, r6, #2
    bf78:	str	r3, [sp, #108]	; 0x6c
    bf7a:	ldrb	r3, [r6, #2]
    bf7c:	b.n	bb4c <_strtod_l+0x294>
    bf7e:	movs	r4, #0
    bf80:	b.n	bb34 <_strtod_l+0x27c>
    bf82:	cmp.w	r9, #0
    bf86:	bne.w	b924 <_strtod_l+0x6c>
    bf8a:	subs	r3, #73	; 0x49
    bf8c:	cmp	r3, #37	; 0x25
    bf8e:	bhi.w	b924 <_strtod_l+0x6c>
    bf92:	add	r2, pc, #4	; (adr r2, bf98 <_strtod_l+0x6e0>)
    bf94:	ldr.w	pc, [r2, r3, lsl #2]
    bf98:	.word	0x0000bafd
    bf9c:	.word	0x0000b925
    bfa0:	.word	0x0000b925
    bfa4:	.word	0x0000b925
    bfa8:	.word	0x0000b925
    bfac:	.word	0x0000c0d5
    bfb0:	.word	0x0000b925
    bfb4:	.word	0x0000b925
    bfb8:	.word	0x0000b925
    bfbc:	.word	0x0000b925
    bfc0:	.word	0x0000b925
    bfc4:	.word	0x0000b925
    bfc8:	.word	0x0000b925
    bfcc:	.word	0x0000b925
    bfd0:	.word	0x0000b925
    bfd4:	.word	0x0000b925
    bfd8:	.word	0x0000b925
    bfdc:	.word	0x0000b925
    bfe0:	.word	0x0000b925
    bfe4:	.word	0x0000b925
    bfe8:	.word	0x0000b925
    bfec:	.word	0x0000b925
    bff0:	.word	0x0000b925
    bff4:	.word	0x0000b925
    bff8:	.word	0x0000b925
    bffc:	.word	0x0000b925
    c000:	.word	0x0000b925
    c004:	.word	0x0000b925
    c008:	.word	0x0000b925
    c00c:	.word	0x0000b925
    c010:	.word	0x0000b925
    c014:	.word	0x0000b925
    c018:	.word	0x0000bafd
    c01c:	.word	0x0000b925
    c020:	.word	0x0000b925
    c024:	.word	0x0000b925
    c028:	.word	0x0000b925
    c02c:	.word	0x0000c0d5
    c030:	cmp.w	r6, #308	; 0x134
    c034:	bgt.w	c276 <_strtod_l+0x9be>
    c038:	asrs	r6, r6, #4
    c03a:	cmp	r6, #1
    c03c:	ldr.w	r9, [pc, #472]	; c218 <_strtod_l+0x960>
    c040:	ble.w	c676 <_strtod_l+0xdbe>
    c044:	ldrd	r0, r1, [sp, #16]
    c048:	movs	r3, #0
    c04a:	mov	r7, r9
    c04c:	mov	r8, r3
    c04e:	tst.w	r6, #1
    c052:	add.w	r8, r8, #1
    c056:	mov.w	r6, r6, asr #1
    c05a:	beq.n	c066 <_strtod_l+0x7ae>
    c05c:	ldrd	r2, r3, [r7]
    c060:	bl	a05c <__aeabi_dmul>
    c064:	movs	r3, #1
    c066:	cmp	r6, #1
    c068:	add.w	r7, r7, #8
    c06c:	bne.n	c04e <_strtod_l+0x796>
    c06e:	cmp	r3, #0
    c070:	bne.w	c73a <_strtod_l+0xe82>
    c074:	ldr	r3, [sp, #20]
    c076:	sub.w	r3, r3, #55574528	; 0x3500000
    c07a:	str	r3, [sp, #20]
    c07c:	add.w	r8, r9, r8, lsl #3
    c080:	ldrd	r2, r3, [sp, #16]
    c084:	ldrd	r0, r1, [r8]
    c088:	bl	a05c <__aeabi_dmul>
    c08c:	bic.w	r3, r1, #2147483648	; 0x80000000
    c090:	lsrs	r3, r3, #20
    c092:	ldr	r2, [pc, #360]	; (c1fc <_strtod_l+0x944>)
    c094:	lsls	r3, r3, #20
    c096:	cmp	r3, r2
    c098:	strd	r0, r1, [sp, #16]
    c09c:	bhi.w	c276 <_strtod_l+0x9be>
    c0a0:	sub.w	r2, r2, #1048576	; 0x100000
    c0a4:	cmp	r3, r2
    c0a6:	bls.w	c638 <_strtod_l+0xd80>
    c0aa:	ldr	r3, [pc, #340]	; (c200 <_strtod_l+0x948>)
    c0ac:	str	r3, [sp, #20]
    c0ae:	movs	r3, #0
    c0b0:	str	r3, [sp, #40]	; 0x28
    c0b2:	mov.w	r3, #4294967295
    c0b6:	str	r3, [sp, #16]
    c0b8:	b.n	bc14 <_strtod_l+0x35c>
    c0ba:	ldrd	r1, r2, [sp, #16]
    c0be:	cmp	r1, #1
    c0c0:	beq.w	c4a2 <_strtod_l+0xbea>
    c0c4:	mov	r8, r2
    c0c6:	vldr	d7, [pc, #288]	; c1e8 <_strtod_l+0x930>
    c0ca:	movs	r4, #0
    c0cc:	ldr	r5, [pc, #308]	; (c204 <_strtod_l+0x94c>)
    c0ce:	vstr	d7, [sp, #56]	; 0x38
    c0d2:	b.n	bde0 <_strtod_l+0x528>
    c0d4:	add	r0, sp, #108	; 0x6c
    c0d6:	ldr	r1, [pc, #304]	; (c208 <_strtod_l+0x950>)
    c0d8:	bl	10798 <__match>
    c0dc:	cmp	r0, #0
    c0de:	beq.w	b924 <_strtod_l+0x6c>
    c0e2:	ldr	r3, [sp, #108]	; 0x6c
    c0e4:	ldrb	r3, [r3, #0]
    c0e6:	cmp	r3, #40	; 0x28
    c0e8:	beq.w	c6f0 <_strtod_l+0xe38>
    c0ec:	ldr	r3, [pc, #284]	; (c20c <_strtod_l+0x954>)
    c0ee:	str	r3, [sp, #20]
    c0f0:	movs	r3, #0
    c0f2:	str	r3, [sp, #16]
    c0f4:	b.n	bb28 <_strtod_l+0x270>
    c0f6:	str	r6, [sp, #108]	; 0x6c
    c0f8:	movs	r2, #0
    c0fa:	b.n	b9d2 <_strtod_l+0x11a>
    c0fc:	mov.w	ip, #0
    c100:	b.n	bf76 <_strtod_l+0x6be>
    c102:	adds	r3, #1
    c104:	bne.w	c6d6 <_strtod_l+0xe1e>
    c108:	ldr	r0, [sp, #112]	; 0x70
    c10a:	ldr	r3, [pc, #260]	; (c210 <_strtod_l+0x958>)
    c10c:	str	r3, [sp, #20]
    c10e:	movs	r2, #0
    c110:	str	r2, [sp, #16]
    c112:	ldrd	r8, r9, [sp, #16]
    c116:	movs	r3, #34	; 0x22
    c118:	str.w	r3, [fp]
    c11c:	mov	r1, r0
    c11e:	mov	r0, fp
    c120:	bl	10a2c <_Bfree>
    c124:	mov	r1, r6
    c126:	mov	r0, fp
    c128:	bl	10a2c <_Bfree>
    c12c:	mov	r1, sl
    c12e:	mov	r0, fp
    c130:	bl	10a2c <_Bfree>
    c134:	ldr	r1, [sp, #72]	; 0x48
    c136:	mov	r0, fp
    c138:	bl	10a2c <_Bfree>
    c13c:	mov	r1, r7
    c13e:	mov	r0, fp
    c140:	bl	10a2c <_Bfree>
    c144:	b.n	b9e8 <_strtod_l+0x130>
    c146:	ldr	r2, [sp, #28]
    c148:	str	r5, [sp, #8]
    c14a:	add	r3, sp, #112	; 0x70
    c14c:	str	r2, [sp, #4]
    c14e:	str	r3, [sp, #0]
    c150:	ldr	r2, [pc, #192]	; (c214 <_strtod_l+0x95c>)
    c152:	add	r3, sp, #116	; 0x74
    c154:	add	r1, sp, #108	; 0x6c
    c156:	mov	r0, fp
    c158:	bl	10288 <__gethex>
    c15c:	ands.w	r6, r0, #7
    c160:	mov	r5, r0
    c162:	beq.w	b9e0 <_strtod_l+0x128>
    c166:	cmp	r6, #6
    c168:	bne.w	c418 <_strtod_l+0xb60>
    c16c:	adds	r4, #1
    c16e:	movs	r3, #0
    c170:	str	r4, [sp, #108]	; 0x6c
    c172:	mov.w	r8, #0
    c176:	mov.w	r9, #0
    c17a:	str	r3, [sp, #28]
    c17c:	b.n	b9e8 <_strtod_l+0x130>
    c17e:	ldr.w	r1, [sl]
    c182:	mov	r0, r4
    c184:	mov	r2, r9
    c186:	bl	b7dc <strncmp>
    c18a:	cbz	r0, c1a0 <_strtod_l+0x8e8>
    c18c:	mov.w	sl, #0
    c190:	mov	r3, r7
    c192:	mov	r8, sl
    c194:	mov	r5, sl
    c196:	mov	r0, sl
    c198:	mov	r7, sl
    c19a:	mov	r4, sl
    c19c:	mov	r9, sl
    c19e:	b.n	b9c4 <_strtod_l+0x10c>
    c1a0:	ldr	r3, [sp, #108]	; 0x6c
    c1a2:	add.w	r2, r3, r9
    c1a6:	str	r2, [sp, #108]	; 0x6c
    c1a8:	ldrb.w	r3, [r3, r9]
    c1ac:	cmp	r3, #48	; 0x30
    c1ae:	bne.n	c1be <_strtod_l+0x906>
    c1b0:	adds	r2, #1
    c1b2:	str	r2, [sp, #108]	; 0x6c
    c1b4:	ldrb	r3, [r2, #0]
    c1b6:	cmp	r3, #48	; 0x30
    c1b8:	add.w	r0, r0, #1
    c1bc:	beq.n	c1b0 <_strtod_l+0x8f8>
    c1be:	sub.w	r2, r3, #49	; 0x31
    c1c2:	cmp	r2, #8
    c1c4:	bls.w	c4c0 <_strtod_l+0xc08>
    c1c8:	mov.w	sl, #0
    c1cc:	cmp	r3, #101	; 0x65
    c1ce:	mov	r8, sl
    c1d0:	mov	r5, sl
    c1d2:	mov	r7, sl
    c1d4:	beq.w	bec4 <_strtod_l+0x60c>
    c1d8:	mov	r4, sl
    c1da:	mov.w	r9, #1
    c1de:	b.w	b9ca <_strtod_l+0x112>
    c1e2:	nop
    c1e4:	nop.w
    c1e8:	.word	0x00000000
    c1ec:	.word	0x3ff00000
    c1f0:	.word	0xfffffbe2
    c1f4:	.word	0x3ff00000
    c1f8:	.word	0x3fe00000
    c1fc:	.word	0x7ca00000
    c200:	.word	0x7fefffff
    c204:	.word	0xbff00000
    c208:	.word	0x000128d8
    c20c:	.word	0xfff80000
    c210:	.word	0x7ff00000
    c214:	.word	0x000128b8
    c218:	.word	0x00012c88
    c21c:	sub.w	r3, r8, #55574528	; 0x3500000
    c220:	str	r3, [sp, #20]
    c222:	vldr	d7, [sp, #16]
    c226:	vmov.f32	s0, s14
    c22a:	vmov.f32	s1, s15
    c22e:	bl	10fe0 <__ulp>
    c232:	mov	r0, r4
    c234:	vmov	r2, r3, d0
    c238:	mov	r1, r5
    c23a:	bl	a05c <__aeabi_dmul>
    c23e:	ldrd	r2, r3, [sp, #16]
    c242:	bl	9cf8 <__adddf3>
    c246:	bic.w	r3, r1, #2147483648	; 0x80000000
    c24a:	strd	r0, r1, [sp, #16]
    c24e:	lsrs	r3, r3, #20
    c250:	ldr	r2, [pc, #684]	; (c500 <_strtod_l+0xc48>)
    c252:	ldrd	r0, r1, [sp, #32]
    c256:	lsls	r3, r3, #20
    c258:	cmp	r3, r2
    c25a:	strd	r0, r1, [sp, #88]	; 0x58
    c25e:	bls.w	c3d6 <_strtod_l+0xb1e>
    c262:	ldr	r3, [pc, #672]	; (c504 <_strtod_l+0xc4c>)
    c264:	cmp	r1, r3
    c266:	beq.w	c62e <_strtod_l+0xd76>
    c26a:	ldr	r3, [pc, #664]	; (c504 <_strtod_l+0xc4c>)
    c26c:	str	r3, [sp, #20]
    c26e:	mov.w	r3, #4294967295
    c272:	str	r3, [sp, #16]
    c274:	b.n	be70 <_strtod_l+0x5b8>
    c276:	ldr	r3, [pc, #656]	; (c508 <_strtod_l+0xc50>)
    c278:	str	r3, [sp, #20]
    c27a:	movs	r2, #0
    c27c:	movs	r3, #34	; 0x22
    c27e:	str	r2, [sp, #16]
    c280:	ldrd	r8, r9, [sp, #16]
    c284:	str.w	r3, [fp]
    c288:	b.w	b9e8 <_strtod_l+0x130>
    c28c:	ldrd	r8, r9, [sp, #56]	; 0x38
    c290:	mov	r1, r9
    c292:	mov	r0, r8
    c294:	bl	a5bc <__aeabi_d2iz>
    c298:	bl	9f90 <__aeabi_i2d>
    c29c:	mov	r3, r1
    c29e:	mov	r2, r0
    c2a0:	mov	r1, r9
    c2a2:	mov	r0, r8
    c2a4:	bl	9cf4 <__aeabi_dsub>
    c2a8:	ldr	r3, [sp, #52]	; 0x34
    c2aa:	mov	r8, r0
    c2ac:	mov	r9, r1
    c2ae:	cbnz	r3, c2d2 <_strtod_l+0xa1a>
    c2b0:	ldr	r3, [sp, #16]
    c2b2:	cbnz	r3, c2d2 <_strtod_l+0xa1a>
    c2b4:	ubfx	r4, r4, #0, #20
    c2b8:	cbnz	r4, c2d2 <_strtod_l+0xa1a>
    c2ba:	add	r3, pc, #548	; (adr r3, c4e0 <_strtod_l+0xc28>)
    c2bc:	ldrd	r2, r3, [r3]
    c2c0:	bl	a540 <__aeabi_dcmplt>
    c2c4:	cmp	r0, #0
    c2c6:	beq.w	be70 <_strtod_l+0x5b8>
    c2ca:	ldrd	r8, r9, [sp, #16]
    c2ce:	ldr	r0, [sp, #112]	; 0x70
    c2d0:	b.n	c11c <_strtod_l+0x864>
    c2d2:	add	r3, pc, #532	; (adr r3, c4e8 <_strtod_l+0xc30>)
    c2d4:	ldrd	r2, r3, [r3]
    c2d8:	mov	r0, r8
    c2da:	mov	r1, r9
    c2dc:	bl	a540 <__aeabi_dcmplt>
    c2e0:	cmp	r0, #0
    c2e2:	bne.n	c2ca <_strtod_l+0xa12>
    c2e4:	mov	r0, r8
    c2e6:	mov	r1, r9
    c2e8:	add	r3, pc, #516	; (adr r3, c4f0 <_strtod_l+0xc38>)
    c2ea:	ldrd	r2, r3, [r3]
    c2ee:	bl	a57c <__aeabi_dcmpgt>
    c2f2:	cmp	r0, #0
    c2f4:	beq.w	be70 <_strtod_l+0x5b8>
    c2f8:	b.n	c2ca <_strtod_l+0xa12>
    c2fa:	beq.w	bc10 <_strtod_l+0x358>
    c2fe:	rsb	r6, r9, #0
    c302:	ands.w	r2, r6, #15
    c306:	beq.n	c31e <_strtod_l+0xa66>
    c308:	ldr	r3, [pc, #512]	; (c50c <_strtod_l+0xc54>)
    c30a:	add.w	r3, r3, r2, lsl #3
    c30e:	ldrd	r0, r1, [sp, #16]
    c312:	ldrd	r2, r3, [r3]
    c316:	bl	a2b0 <__aeabi_ddiv>
    c31a:	strd	r0, r1, [sp, #16]
    c31e:	asrs	r6, r6, #4
    c320:	beq.w	bc10 <_strtod_l+0x358>
    c324:	cmp	r6, #31
    c326:	bgt.n	c39a <_strtod_l+0xae2>
    c328:	ands.w	r3, r6, #16
    c32c:	beq.w	c6a0 <_strtod_l+0xde8>
    c330:	movs	r3, #106	; 0x6a
    c332:	cmp	r6, #0
    c334:	str	r3, [sp, #40]	; 0x28
    c336:	ble.n	c360 <_strtod_l+0xaa8>
    c338:	ldrd	r0, r1, [sp, #16]
    c33c:	ldr	r7, [pc, #464]	; (c510 <_strtod_l+0xc58>)
    c33e:	movs	r3, #0
    c340:	lsls	r2, r6, #31
    c342:	bpl.n	c34e <_strtod_l+0xa96>
    c344:	ldrd	r2, r3, [r7]
    c348:	bl	a05c <__aeabi_dmul>
    c34c:	movs	r3, #1
    c34e:	asrs	r6, r6, #1
    c350:	add.w	r7, r7, #8
    c354:	bne.n	c340 <_strtod_l+0xa88>
    c356:	cmp	r3, #0
    c358:	bne.w	c740 <_strtod_l+0xe88>
    c35c:	ldr	r3, [sp, #40]	; 0x28
    c35e:	cbz	r3, c388 <_strtod_l+0xad0>
    c360:	ldrd	r1, r2, [sp, #16]
    c364:	ubfx	r3, r2, #20, #11
    c368:	rsb	r3, r3, #107	; 0x6b
    c36c:	cmp	r3, #0
    c36e:	mov	r1, r2
    c370:	ble.n	c388 <_strtod_l+0xad0>
    c372:	cmp	r3, #31
    c374:	ble.w	c72a <_strtod_l+0xe72>
    c378:	movs	r2, #0
    c37a:	cmp	r3, #52	; 0x34
    c37c:	str	r2, [sp, #16]
    c37e:	ble.w	c746 <_strtod_l+0xe8e>
    c382:	mov.w	r3, #57671680	; 0x3700000
    c386:	str	r3, [sp, #20]
    c388:	movs	r2, #0
    c38a:	movs	r3, #0
    c38c:	ldrd	r0, r1, [sp, #16]
    c390:	bl	a52c <__aeabi_dcmpeq>
    c394:	cmp	r0, #0
    c396:	beq.w	bc14 <_strtod_l+0x35c>
    c39a:	movs	r3, #34	; 0x22
    c39c:	str.w	r3, [fp]
    c3a0:	mov.w	r8, #0
    c3a4:	mov.w	r9, #0
    c3a8:	b.w	b9e8 <_strtod_l+0x130>
    c3ac:	ldr	r1, [sp, #108]	; 0x6c
    c3ae:	adds	r4, #1
    c3b0:	cmp	r0, #8
    c3b2:	ble.w	c4d2 <_strtod_l+0xc1a>
    c3b6:	cmp	r4, #16
    c3b8:	itt	le
    c3ba:	addle.w	r8, r8, r8, lsl #2
    c3be:	addle.w	r8, r2, r8, lsl #1
    c3c2:	movs	r0, #0
    c3c4:	adds	r3, r1, #1
    c3c6:	str	r3, [sp, #108]	; 0x6c
    c3c8:	ldrb	r3, [r1, #1]
    c3ca:	b.w	ba0c <_strtod_l+0x154>
    c3ce:	movw	r2, #19999	; 0x4e1f
    c3d2:	b.w	bbbe <_strtod_l+0x306>
    c3d6:	ldr	r3, [sp, #20]
    c3d8:	add.w	r4, r3, #55574528	; 0x3500000
    c3dc:	str	r4, [sp, #20]
    c3de:	b.n	be62 <_strtod_l+0x5aa>
    c3e0:	ldr	r6, [sp, #44]	; 0x2c
    c3e2:	rsb	r3, r4, #37	; 0x25
    c3e6:	cmp	r6, r3
    c3e8:	bgt.w	bbdc <_strtod_l+0x324>
    c3ec:	ldr	r5, [pc, #284]	; (c50c <_strtod_l+0xc54>)
    c3ee:	rsb	r4, r4, #15
    c3f2:	add.w	r1, r5, r4, lsl #3
    c3f6:	subs	r4, r6, r4
    c3f8:	ldrd	r2, r3, [sp, #16]
    c3fc:	ldrd	r0, r1, [r1]
    c400:	add.w	r5, r5, r4, lsl #3
    c404:	bl	a05c <__aeabi_dmul>
    c408:	ldrd	r2, r3, [r5]
    c40c:	bl	a05c <__aeabi_dmul>
    c410:	mov	r8, r0
    c412:	mov	r9, r1
    c414:	b.w	b9e8 <_strtod_l+0x130>
    c418:	ldr	r2, [sp, #112]	; 0x70
    c41a:	cbz	r2, c42c <_strtod_l+0xb74>
    c41c:	movs	r1, #53	; 0x35
    c41e:	add	r0, sp, #120	; 0x78
    c420:	bl	11220 <__copybits>
    c424:	mov	r0, fp
    c426:	ldr	r1, [sp, #112]	; 0x70
    c428:	bl	10a2c <_Bfree>
    c42c:	cmp	r6, #6
    c42e:	bhi.n	c448 <_strtod_l+0xb90>
    c430:	tbb	[pc, r6]
    c434:	.word	0x1318211d
    c438:	.short	0x2104
    c43a:	.byte	0x1d
    c43b:	.byte	0x00
    c43c:	mvn.w	r3, #2147483648	; 0x80000000
    c440:	str	r3, [sp, #20]
    c442:	mov.w	r3, #4294967295
    c446:	str	r3, [sp, #16]
    c448:	lsls	r1, r5, #28
    c44a:	bpl.w	bb28 <_strtod_l+0x270>
    c44e:	ldr	r3, [sp, #20]
    c450:	orr.w	r3, r3, #2147483648	; 0x80000000
    c454:	str	r3, [sp, #20]
    c456:	b.w	bb28 <_strtod_l+0x270>
    c45a:	ldr	r3, [pc, #172]	; (c508 <_strtod_l+0xc50>)
    c45c:	str	r3, [sp, #20]
    c45e:	movs	r3, #0
    c460:	str	r3, [sp, #16]
    c462:	b.n	c448 <_strtod_l+0xb90>
    c464:	ldr	r3, [sp, #120]	; 0x78
    c466:	str	r3, [sp, #16]
    c468:	ldr	r3, [sp, #124]	; 0x7c
    c46a:	str	r3, [sp, #20]
    c46c:	b.n	c448 <_strtod_l+0xb90>
    c46e:	movs	r3, #0
    c470:	str	r3, [sp, #20]
    c472:	str	r3, [sp, #16]
    c474:	b.n	c448 <_strtod_l+0xb90>
    c476:	ldr	r2, [sp, #116]	; 0x74
    c478:	ldr	r3, [sp, #124]	; 0x7c
    c47a:	ldr	r1, [sp, #120]	; 0x78
    c47c:	str	r1, [sp, #16]
    c47e:	addw	r2, r2, #1075	; 0x433
    c482:	bic.w	r3, r3, #1048576	; 0x100000
    c486:	orr.w	r3, r3, r2, lsl #20
    c48a:	str	r3, [sp, #20]
    c48c:	b.n	c448 <_strtod_l+0xb90>
    c48e:	vldr	d7, [sp, #56]	; 0x38
    c492:	vstr	d7, [sp, #80]	; 0x50
    c496:	b.n	be34 <_strtod_l+0x57c>
    c498:	vldr	d7, [pc, #92]	; c4f8 <_strtod_l+0xc40>
    c49c:	vstr	d7, [sp, #56]	; 0x38
    c4a0:	b.n	be20 <_strtod_l+0x568>
    c4a2:	ldrd	r1, r2, [sp, #16]
    c4a6:	mov	r8, r2
    c4a8:	cmp	r2, #0
    c4aa:	bne.w	c0c6 <_strtod_l+0x80e>
    c4ae:	movs	r3, #34	; 0x22
    c4b0:	str.w	r3, [fp]
    c4b4:	ldr	r0, [sp, #112]	; 0x70
    c4b6:	mov.w	r8, #0
    c4ba:	mov.w	r9, #0
    c4be:	b.n	c11c <_strtod_l+0x864>
    c4c0:	ldr	r2, [sp, #108]	; 0x6c
    c4c2:	str	r2, [sp, #32]
    c4c4:	movs	r5, #0
    c4c6:	subs	r3, #48	; 0x30
    c4c8:	adds	r7, r0, #1
    c4ca:	mov	r1, r2
    c4cc:	mov	sl, r5
    c4ce:	mov	r8, r5
    c4d0:	movs	r4, #1
    c4d2:	add.w	r5, r5, r5, lsl #2
    c4d6:	add.w	r5, r3, r5, lsl #1
    c4da:	movs	r0, #0
    c4dc:	b.n	c3c4 <_strtod_l+0xb0c>
    c4de:	nop
    c4e0:	.word	0x94a03595
    c4e4:	.word	0x3fcfffff
    c4e8:	.word	0x94a03595
    c4ec:	.word	0x3fdfffff
    c4f0:	.word	0x35afe535
    c4f4:	.word	0x3fe00000
    c4f8:	.word	0x00000000
    c4fc:	.word	0x3ff00000
    c500:	.word	0x7c9fffff
    c504:	.word	0x7fefffff
    c508:	.word	0x7ff00000
    c50c:	.word	0x00012bc0
    c510:	.word	0x000128f0
    c514:	ldr	r1, [sp, #44]	; 0x2c
    c516:	cmn.w	r1, #22
    c51a:	blt.w	bbdc <_strtod_l+0x324>
    c51e:	ldr	r2, [pc, #600]	; (c778 <_strtod_l+0xec0>)
    c520:	sub.w	r2, r2, r1, lsl #3
    c524:	ldrd	r2, r3, [r2]
    c528:	ldrd	r0, r1, [sp, #16]
    c52c:	bl	a2b0 <__aeabi_ddiv>
    c530:	mov	r8, r0
    c532:	mov	r9, r1
    c534:	b.w	b9e8 <_strtod_l+0x130>
    c538:	ldr	r3, [sp, #52]	; 0x34
    c53a:	ldrd	r8, r9, [sp, #32]
    c53e:	cmp	r3, #0
    c540:	beq.w	c654 <_strtod_l+0xd9c>
    c544:	ldrd	r4, r5, [sp, #16]
    c548:	ldr	r3, [pc, #560]	; (c77c <_strtod_l+0xec4>)
    c54a:	ubfx	r1, r5, #0, #20
    c54e:	cmp	r1, r3
    c550:	mov	r2, r5
    c552:	beq.w	c6aa <_strtod_l+0xdf2>
    c556:	ldr	r3, [sp, #76]	; 0x4c
    c558:	cmp	r3, #0
    c55a:	beq.w	c66c <_strtod_l+0xdb4>
    c55e:	ldr	r2, [sp, #20]
    c560:	tst	r3, r2
    c562:	beq.n	c586 <_strtod_l+0xcce>
    c564:	ldr	r3, [sp, #52]	; 0x34
    c566:	ldr	r2, [sp, #40]	; 0x28
    c568:	ldrd	r0, r1, [sp, #16]
    c56c:	cmp	r3, #0
    c56e:	beq.w	c67c <_strtod_l+0xdc4>
    c572:	bl	b87c <sulp>
    c576:	mov	r2, r0
    c578:	mov	r3, r1
    c57a:	mov	r0, r8
    c57c:	mov	r1, r9
    c57e:	bl	9cf8 <__adddf3>
    c582:	mov	r8, r0
    c584:	mov	r9, r1
    c586:	ldr	r3, [sp, #40]	; 0x28
    c588:	cbz	r3, c5ba <_strtod_l+0xd02>
    c58a:	ldr	r3, [pc, #500]	; (c780 <_strtod_l+0xec8>)
    c58c:	str	r3, [sp, #92]	; 0x5c
    c58e:	movs	r3, #0
    c590:	str	r3, [sp, #88]	; 0x58
    c592:	ldrd	r2, r3, [sp, #88]	; 0x58
    c596:	mov	r0, r8
    c598:	mov	r1, r9
    c59a:	bl	a05c <__aeabi_dmul>
    c59e:	mov	r3, r0
    c5a0:	mov	r4, r1
    c5a2:	mov	r8, r0
    c5a4:	mov	r9, r1
    c5a6:	strd	r3, r4, [sp, #16]
    c5aa:	cbnz	r1, c5ba <_strtod_l+0xd02>
    c5ac:	ldr	r3, [sp, #16]
    c5ae:	cbnz	r3, c5ba <_strtod_l+0xd02>
    c5b0:	movs	r3, #34	; 0x22
    c5b2:	ldr	r0, [sp, #112]	; 0x70
    c5b4:	str.w	r3, [fp]
    c5b8:	b.n	c11c <_strtod_l+0x864>
    c5ba:	ldr	r0, [sp, #112]	; 0x70
    c5bc:	b.n	c11c <_strtod_l+0x864>
    c5be:	ldr	r3, [sp, #52]	; 0x34
    c5c0:	ldrd	r8, r9, [sp, #32]
    c5c4:	cmp	r3, #0
    c5c6:	bne.n	c586 <_strtod_l+0xcce>
    c5c8:	ldrd	r1, r2, [sp, #16]
    c5cc:	cmp	r1, #0
    c5ce:	bne.n	c586 <_strtod_l+0xcce>
    c5d0:	ubfx	r3, r2, #0, #20
    c5d4:	mov	r4, r2
    c5d6:	cmp	r3, #0
    c5d8:	bne.n	c586 <_strtod_l+0xcce>
    c5da:	bic.w	r3, r2, #2147483648	; 0x80000000
    c5de:	lsrs	r3, r3, #20
    c5e0:	lsls	r3, r3, #20
    c5e2:	cmp.w	r3, #112197632	; 0x6b00000
    c5e6:	bls.n	c586 <_strtod_l+0xcce>
    c5e8:	ldr	r3, [r7, #20]
    c5ea:	cbnz	r3, c5f2 <_strtod_l+0xd3a>
    c5ec:	ldr	r3, [r7, #16]
    c5ee:	cmp	r3, #1
    c5f0:	ble.n	c586 <_strtod_l+0xcce>
    c5f2:	mov	r1, r7
    c5f4:	movs	r2, #1
    c5f6:	mov	r0, fp
    c5f8:	bl	10dd8 <__lshift>
    c5fc:	mov	r1, sl
    c5fe:	mov	r7, r0
    c600:	bl	10e88 <__mcmp>
    c604:	cmp	r0, #0
    c606:	ble.n	c586 <_strtod_l+0xcce>
    c608:	ldr	r3, [sp, #40]	; 0x28
    c60a:	cmp	r3, #0
    c60c:	bne.w	c714 <_strtod_l+0xe5c>
    c610:	ldr	r3, [pc, #368]	; (c784 <_strtod_l+0xecc>)
    c612:	ands	r3, r4
    c614:	sub.w	r3, r3, #1048576	; 0x100000
    c618:	mvn.w	r3, r3, lsr #20
    c61c:	mvn.w	r3, r3, lsl #20
    c620:	str	r3, [sp, #20]
    c622:	mov.w	r3, #4294967295
    c626:	str	r3, [sp, #16]
    c628:	ldrd	r8, r9, [sp, #16]
    c62c:	b.n	c586 <_strtod_l+0xcce>
    c62e:	ldr	r3, [sp, #88]	; 0x58
    c630:	adds	r3, #1
    c632:	bne.w	c26a <_strtod_l+0x9b2>
    c636:	b.n	c108 <_strtod_l+0x850>
    c638:	add.w	r3, r1, #55574528	; 0x3500000
    c63c:	str	r3, [sp, #20]
    c63e:	b.w	bc10 <_strtod_l+0x358>
    c642:	vldr	d7, [pc, #292]	; c768 <_strtod_l+0xeb0>
    c646:	vstr	d7, [sp, #96]	; 0x60
    c64a:	vldr	d7, [pc, #292]	; c770 <_strtod_l+0xeb8>
    c64e:	vstr	d7, [sp, #56]	; 0x38
    c652:	b.n	bf62 <_strtod_l+0x6aa>
    c654:	ldrd	r1, r2, [sp, #16]
    c658:	ubfx	r3, r2, #0, #20
    c65c:	mov	r4, r2
    c65e:	cmp	r3, #0
    c660:	bne.w	c556 <_strtod_l+0xc9e>
    c664:	cmp	r1, #0
    c666:	bne.w	c556 <_strtod_l+0xc9e>
    c66a:	b.n	c608 <_strtod_l+0xd50>
    c66c:	ldr	r3, [sp, #56]	; 0x38
    c66e:	ldr	r2, [sp, #16]
    c670:	tst	r3, r2
    c672:	beq.n	c586 <_strtod_l+0xcce>
    c674:	b.n	c564 <_strtod_l+0xcac>
    c676:	mov.w	r8, #0
    c67a:	b.n	c074 <_strtod_l+0x7bc>
    c67c:	bl	b87c <sulp>
    c680:	mov	r2, r0
    c682:	mov	r3, r1
    c684:	mov	r0, r8
    c686:	mov	r1, r9
    c688:	bl	9cf4 <__aeabi_dsub>
    c68c:	movs	r2, #0
    c68e:	movs	r3, #0
    c690:	mov	r8, r0
    c692:	mov	r9, r1
    c694:	bl	a52c <__aeabi_dcmpeq>
    c698:	cmp	r0, #0
    c69a:	bne.w	c4ae <_strtod_l+0xbf6>
    c69e:	b.n	c586 <_strtod_l+0xcce>
    c6a0:	cmp	r6, #0
    c6a2:	str	r3, [sp, #40]	; 0x28
    c6a4:	bgt.w	c338 <_strtod_l+0xa80>
    c6a8:	b.n	c388 <_strtod_l+0xad0>
    c6aa:	ldr	r3, [sp, #40]	; 0x28
    c6ac:	ldr	r1, [sp, #16]
    c6ae:	cbz	r3, c6ea <_strtod_l+0xe32>
    c6b0:	ldr	r3, [pc, #208]	; (c784 <_strtod_l+0xecc>)
    c6b2:	ands	r3, r5
    c6b4:	cmp.w	r3, #111149056	; 0x6a00000
    c6b8:	bhi.n	c6ea <_strtod_l+0xe32>
    c6ba:	lsrs	r3, r3, #20
    c6bc:	rsb	r3, r3, #107	; 0x6b
    c6c0:	mov.w	r0, #4294967295
    c6c4:	lsl.w	r3, r0, r3
    c6c8:	cmp	r3, r1
    c6ca:	bne.w	c556 <_strtod_l+0xc9e>
    c6ce:	ldr	r1, [pc, #184]	; (c788 <_strtod_l+0xed0>)
    c6d0:	cmp	r2, r1
    c6d2:	beq.w	c102 <_strtod_l+0x84a>
    c6d6:	ldr	r3, [pc, #172]	; (c784 <_strtod_l+0xecc>)
    c6d8:	ands	r3, r2
    c6da:	add.w	r3, r3, #1048576	; 0x100000
    c6de:	str	r3, [sp, #20]
    c6e0:	movs	r3, #0
    c6e2:	str	r3, [sp, #16]
    c6e4:	ldrd	r8, r9, [sp, #16]
    c6e8:	b.n	c586 <_strtod_l+0xcce>
    c6ea:	mov.w	r3, #4294967295
    c6ee:	b.n	c6c8 <_strtod_l+0xe10>
    c6f0:	add	r0, sp, #108	; 0x6c
    c6f2:	add	r2, sp, #120	; 0x78
    c6f4:	ldr	r1, [pc, #148]	; (c78c <_strtod_l+0xed4>)
    c6f6:	bl	107c8 <__hexnan>
    c6fa:	cmp	r0, #5
    c6fc:	bne.w	c0ec <_strtod_l+0x834>
    c700:	ldr	r3, [sp, #124]	; 0x7c
    c702:	orr.w	r3, r3, #2139095040	; 0x7f800000
    c706:	orr.w	r3, r3, #7340032	; 0x700000
    c70a:	str	r3, [sp, #20]
    c70c:	ldr	r3, [sp, #120]	; 0x78
    c70e:	str	r3, [sp, #16]
    c710:	b.w	bb28 <_strtod_l+0x270>
    c714:	ldr	r3, [pc, #108]	; (c784 <_strtod_l+0xecc>)
    c716:	ands	r3, r4
    c718:	cmp.w	r3, #112197632	; 0x6b00000
    c71c:	bgt.w	c614 <_strtod_l+0xd5c>
    c720:	cmp.w	r3, #57671680	; 0x3700000
    c724:	bgt.w	c58a <_strtod_l+0xcd2>
    c728:	b.n	c4ae <_strtod_l+0xbf6>
    c72a:	mov.w	r2, #4294967295
    c72e:	lsl.w	r3, r2, r3
    c732:	ldr	r2, [sp, #16]
    c734:	ands	r2, r3
    c736:	str	r2, [sp, #16]
    c738:	b.n	c388 <_strtod_l+0xad0>
    c73a:	strd	r0, r1, [sp, #16]
    c73e:	b.n	c074 <_strtod_l+0x7bc>
    c740:	strd	r0, r1, [sp, #16]
    c744:	b.n	c35c <_strtod_l+0xaa4>
    c746:	subs	r3, #32
    c748:	mov.w	r2, #4294967295
    c74c:	lsl.w	r3, r2, r3
    c750:	ands	r3, r1
    c752:	str	r3, [sp, #20]
    c754:	b.n	c388 <_strtod_l+0xad0>
    c756:	mov	r0, r4
    c758:	ldr	r1, [sp, #108]	; 0x6c
    c75a:	adds	r4, #1
    c75c:	b.n	c3b0 <_strtod_l+0xaf8>
    c75e:	mov	r0, r1
    c760:	ldr	r1, [sp, #108]	; 0x6c
    c762:	b.n	c3c4 <_strtod_l+0xb0c>
    c764:	nop.w
    c768:	.word	0x00000000
    c76c:	.word	0xbfe00000
    c770:	.word	0x00000000
    c774:	.word	0x3fe00000
    c778:	.word	0x00012bc0
    c77c:	.word	0x000fffff
    c780:	.word	0x39500000
    c784:	.word	0x7ff00000
    c788:	.word	0x7fefffff
    c78c:	.word	0x000128dc

0000c790 <_strtod_r>:
    c790:	ldr	r3, [pc, #20]	; (c7a8 <_strtod_r+0x18>)
    c792:	ldr	r3, [r3, #0]
    c794:	push	{r4}
    c796:	ldr	r3, [r3, #52]	; 0x34
    c798:	ldr	r4, [pc, #16]	; (c7ac <_strtod_r+0x1c>)
    c79a:	cmp	r3, #0
    c79c:	it	eq
    c79e:	moveq	r3, r4
    c7a0:	ldr.w	r4, [sp], #4
    c7a4:	b.w	b8b8 <_strtod_l>
    c7a8:	.word	0x1fff1840
    c7ac:	.word	0x1fff1844

0000c7b0 <_strtol_l.isra.0>:
    c7b0:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c7b4:	ldr.w	r9, [sp, #40]	; 0x28
    c7b8:	mov	r7, r1
    c7ba:	mov	r8, r0
    c7bc:	mov	r6, r2
    c7be:	mov	r5, r3
    c7c0:	mov	fp, r1
    c7c2:	b.n	c7c6 <_strtol_l.isra.0+0x16>
    c7c4:	mov	fp, r4
    c7c6:	mov	r4, fp
    c7c8:	mov	r0, r9
    c7ca:	ldrb.w	sl, [r4], #1
    c7ce:	bl	aaa0 <__locale_ctype_ptr_l>
    c7d2:	add	r0, sl
    c7d4:	ldrb	r1, [r0, #1]
    c7d6:	and.w	r1, r1, #8
    c7da:	and.w	ip, r1, #255	; 0xff
    c7de:	cmp	r1, #0
    c7e0:	bne.n	c7c4 <_strtol_l.isra.0+0x14>
    c7e2:	mov	r2, sl
    c7e4:	cmp	r2, #45	; 0x2d
    c7e6:	beq.n	c8ac <_strtol_l.isra.0+0xfc>
    c7e8:	cmp	r2, #43	; 0x2b
    c7ea:	itt	eq
    c7ec:	ldrbeq.w	r2, [fp, #1]
    c7f0:	addeq.w	r4, fp, #2
    c7f4:	cmp	r5, #0
    c7f6:	beq.n	c880 <_strtol_l.isra.0+0xd0>
    c7f8:	cmp	r5, #16
    c7fa:	beq.n	c8c8 <_strtol_l.isra.0+0x118>
    c7fc:	mov	r9, r5
    c7fe:	cmp.w	ip, #0
    c802:	ite	eq
    c804:	mvneq.w	sl, #2147483648	; 0x80000000
    c808:	movne.w	sl, #2147483648	; 0x80000000
    c80c:	movs	r1, #0
    c80e:	udiv	lr, sl, r9
    c812:	mov	r0, r1
    c814:	mls	sl, r9, lr, sl
    c818:	b.n	c826 <_strtol_l.isra.0+0x76>
    c81a:	beq.n	c870 <_strtol_l.isra.0+0xc0>
    c81c:	mla	r0, r9, r0, r3
    c820:	movs	r1, #1
    c822:	ldrb.w	r2, [r4], #1
    c826:	sub.w	r3, r2, #48	; 0x30
    c82a:	cmp	r3, #9
    c82c:	bls.n	c83a <_strtol_l.isra.0+0x8a>
    c82e:	sub.w	r3, r2, #65	; 0x41
    c832:	cmp	r3, #25
    c834:	bhi.n	c84c <_strtol_l.isra.0+0x9c>
    c836:	sub.w	r3, r2, #55	; 0x37
    c83a:	cmp	r5, r3
    c83c:	ble.n	c85c <_strtol_l.isra.0+0xac>
    c83e:	adds	r2, r1, #1
    c840:	beq.n	c822 <_strtol_l.isra.0+0x72>
    c842:	cmp	lr, r0
    c844:	bcs.n	c81a <_strtol_l.isra.0+0x6a>
    c846:	mov.w	r1, #4294967295
    c84a:	b.n	c822 <_strtol_l.isra.0+0x72>
    c84c:	sub.w	r3, r2, #97	; 0x61
    c850:	cmp	r3, #25
    c852:	bhi.n	c85c <_strtol_l.isra.0+0xac>
    c854:	sub.w	r3, r2, #87	; 0x57
    c858:	cmp	r5, r3
    c85a:	bgt.n	c83e <_strtol_l.isra.0+0x8e>
    c85c:	adds	r3, r1, #1
    c85e:	beq.n	c88c <_strtol_l.isra.0+0xdc>
    c860:	cmp.w	ip, #0
    c864:	bne.n	c888 <_strtol_l.isra.0+0xd8>
    c866:	cbz	r6, c87c <_strtol_l.isra.0+0xcc>
    c868:	cbnz	r1, c8a4 <_strtol_l.isra.0+0xf4>
    c86a:	str	r7, [r6, #0]
    c86c:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c870:	cmp	sl, r3
    c872:	bge.n	c81c <_strtol_l.isra.0+0x6c>
    c874:	mov	r0, lr
    c876:	mov.w	r1, #4294967295
    c87a:	b.n	c822 <_strtol_l.isra.0+0x72>
    c87c:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c880:	cmp	r2, #48	; 0x30
    c882:	beq.n	c8ba <_strtol_l.isra.0+0x10a>
    c884:	movs	r5, #10
    c886:	b.n	c7fc <_strtol_l.isra.0+0x4c>
    c888:	negs	r0, r0
    c88a:	b.n	c866 <_strtol_l.isra.0+0xb6>
    c88c:	cmp.w	ip, #0
    c890:	mov.w	r3, #34	; 0x22
    c894:	ite	eq
    c896:	mvneq.w	r0, #2147483648	; 0x80000000
    c89a:	movne.w	r0, #2147483648	; 0x80000000
    c89e:	str.w	r3, [r8]
    c8a2:	cbz	r6, c8e2 <_strtol_l.isra.0+0x132>
    c8a4:	subs	r7, r4, #1
    c8a6:	str	r7, [r6, #0]
    c8a8:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c8ac:	add.w	r4, fp, #2
    c8b0:	ldrb.w	r2, [fp, #1]
    c8b4:	mov.w	ip, #1
    c8b8:	b.n	c7f4 <_strtol_l.isra.0+0x44>
    c8ba:	ldrb	r3, [r4, #0]
    c8bc:	and.w	r3, r3, #223	; 0xdf
    c8c0:	cmp	r3, #88	; 0x58
    c8c2:	beq.n	c8d6 <_strtol_l.isra.0+0x126>
    c8c4:	movs	r5, #8
    c8c6:	b.n	c7fc <_strtol_l.isra.0+0x4c>
    c8c8:	cmp	r2, #48	; 0x30
    c8ca:	bne.n	c7fc <_strtol_l.isra.0+0x4c>
    c8cc:	ldrb	r3, [r4, #0]
    c8ce:	and.w	r3, r3, #223	; 0xdf
    c8d2:	cmp	r3, #88	; 0x58
    c8d4:	bne.n	c7fc <_strtol_l.isra.0+0x4c>
    c8d6:	mov.w	r9, #16
    c8da:	ldrb	r2, [r4, #1]
    c8dc:	mov	r5, r9
    c8de:	adds	r4, #2
    c8e0:	b.n	c7fe <_strtol_l.isra.0+0x4e>
    c8e2:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c8e6:	nop

0000c8e8 <_strtol_r>:
    c8e8:	push	{r4, r5, lr}
    c8ea:	ldr	r4, [pc, #24]	; (c904 <_strtol_r+0x1c>)
    c8ec:	ldr	r5, [pc, #24]	; (c908 <_strtol_r+0x20>)
    c8ee:	ldr	r4, [r4, #0]
    c8f0:	ldr	r4, [r4, #52]	; 0x34
    c8f2:	sub	sp, #12
    c8f4:	cmp	r4, #0
    c8f6:	it	eq
    c8f8:	moveq	r4, r5
    c8fa:	str	r4, [sp, #0]
    c8fc:	bl	c7b0 <_strtol_l.isra.0>
    c900:	add	sp, #12
    c902:	pop	{r4, r5, pc}
    c904:	.word	0x1fff1840
    c908:	.word	0x1fff1844
    c90c:	.word	0xffffffff

0000c910 <_svfprintf_r>:
    c910:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c914:	sub	sp, #260	; 0x104
    c916:	mov	r4, r1
    c918:	str	r1, [sp, #20]
    c91a:	mov	r5, r2
    c91c:	str	r3, [sp, #40]	; 0x28
    c91e:	str	r0, [sp, #24]
    c920:	bl	10968 <_localeconv_r>
    c924:	ldr	r3, [r0, #0]
    c926:	str	r3, [sp, #76]	; 0x4c
    c928:	mov	r0, r3
    c92a:	bl	b700 <strlen>
    c92e:	ldrh	r3, [r4, #12]
    c930:	str	r0, [sp, #72]	; 0x48
    c932:	lsls	r6, r3, #24
    c934:	bpl.n	c93e <_svfprintf_r+0x2e>
    c936:	ldr	r3, [r4, #16]
    c938:	cmp	r3, #0
    c93a:	beq.w	dba0 <_svfprintf_r+0x1290>
    c93e:	vldr	d7, [pc, #664]	; cbd8 <_svfprintf_r+0x2c8>
    c942:	movs	r3, #0
    c944:	vstr	d7, [sp, #64]	; 0x40
    c948:	str	r3, [sp, #56]	; 0x38
    c94a:	str	r3, [sp, #148]	; 0x94
    c94c:	str	r3, [sp, #144]	; 0x90
    c94e:	str	r3, [sp, #84]	; 0x54
    c950:	str	r3, [sp, #28]
    c952:	ldr.w	sl, [pc, #656]	; cbe4 <_svfprintf_r+0x2d4>
    c956:	add	r3, sp, #192	; 0xc0
    c958:	str	r3, [sp, #140]	; 0x8c
    c95a:	mov	r9, r3
    c95c:	mov	r8, r5
    c95e:	ldrb.w	r3, [r8]
    c962:	mov	r4, r8
    c964:	cbz	r3, c9a2 <_svfprintf_r+0x92>
    c966:	cmp	r3, #37	; 0x25
    c968:	bne.n	c970 <_svfprintf_r+0x60>
    c96a:	b.n	c9a2 <_svfprintf_r+0x92>
    c96c:	cmp	r3, #37	; 0x25
    c96e:	beq.n	c978 <_svfprintf_r+0x68>
    c970:	ldrb.w	r3, [r4, #1]!
    c974:	cmp	r3, #0
    c976:	bne.n	c96c <_svfprintf_r+0x5c>
    c978:	rsb	r5, r8, r4
    c97c:	cbz	r5, c9a2 <_svfprintf_r+0x92>
    c97e:	ldr	r3, [sp, #144]	; 0x90
    c980:	ldr	r2, [sp, #148]	; 0x94
    c982:	str.w	r8, [r9]
    c986:	adds	r3, #1
    c988:	add	r2, r5
    c98a:	cmp	r3, #7
    c98c:	str.w	r5, [r9, #4]
    c990:	str	r2, [sp, #148]	; 0x94
    c992:	str	r3, [sp, #144]	; 0x90
    c994:	bgt.w	cae4 <_svfprintf_r+0x1d4>
    c998:	add.w	r9, r9, #8
    c99c:	ldr	r3, [sp, #28]
    c99e:	add	r3, r5
    c9a0:	str	r3, [sp, #28]
    c9a2:	ldrb	r3, [r4, #0]
    c9a4:	cmp	r3, #0
    c9a6:	beq.w	caf6 <_svfprintf_r+0x1e6>
    c9aa:	movs	r3, #0
    c9ac:	mov	r2, r3
    c9ae:	strb.w	r3, [sp, #111]	; 0x6f
    c9b2:	mov	r1, r3
    c9b4:	str	r3, [sp, #32]
    c9b6:	str	r3, [sp, #12]
    c9b8:	mov.w	fp, #4294967295
    c9bc:	ldrb	r3, [r4, #1]
    c9be:	add.w	r8, r4, #1
    c9c2:	mov	r5, fp
    c9c4:	add.w	r8, r8, #1
    c9c8:	sub.w	r0, r3, #32
    c9cc:	cmp	r0, #88	; 0x58
    c9ce:	bhi.w	d23a <_svfprintf_r+0x92a>
    c9d2:	tbh	[pc, r0, lsl #1]
    c9d6:	.short	0x03a0
    c9d8:	.word	0x04320432
    c9dc:	.word	0x043203a8
    c9e0:	.word	0x04320432
    c9e4:	.word	0x04320432
    c9e8:	.word	0x03af0432
    c9ec:	.word	0x043203bd
    c9f0:	.word	0x00e2005d
    c9f4:	.word	0x01090432
    c9f8:	.word	0x01100110
    c9fc:	.word	0x01100110
    ca00:	.word	0x01100110
    ca04:	.word	0x01100110
    ca08:	.word	0x04320110
    ca0c:	.word	0x04320432
    ca10:	.word	0x04320432
    ca14:	.word	0x04320432
    ca18:	.word	0x04320432
    ca1c:	.word	0x01200432
    ca20:	.word	0x04320286
    ca24:	.word	0x04320286
    ca28:	.word	0x04320432
    ca2c:	.word	0x02d40432
    ca30:	.word	0x04320432
    ca34:	.word	0x043202e5
    ca38:	.word	0x04320432
    ca3c:	.word	0x04320432
    ca40:	.word	0x0432030f
    ca44:	.word	0x033d0432
    ca48:	.word	0x04320432
    ca4c:	.word	0x04320432
    ca50:	.word	0x04320432
    ca54:	.word	0x04320432
    ca58:	.word	0x04320432
    ca5c:	.word	0x0391037e
    ca60:	.word	0x02860286
    ca64:	.word	0x03990286
    ca68:	.word	0x04320391
    ca6c:	.word	0x04070432
    ca70:	.word	0x04120432
    ca74:	.word	0x006400a3
    ca78:	.word	0x043203c2
    ca7c:	.word	0x043203c9
    ca80:	.word	0x043203ea
    ca84:	.word	0x03f20432
    ca88:	ldr	r0, [sp, #32]
    ca8a:	str	r3, [sp, #40]	; 0x28
    ca8c:	negs	r0, r0
    ca8e:	str	r0, [sp, #32]
    ca90:	ldr	r3, [sp, #12]
    ca92:	orr.w	r3, r3, #4
    ca96:	str	r3, [sp, #12]
    ca98:	ldrb.w	r3, [r8]
    ca9c:	b.n	c9c4 <_svfprintf_r+0xb4>
    ca9e:	ldr	r0, [sp, #40]	; 0x28
    caa0:	mov	fp, r5
    caa2:	movs	r1, #0
    caa4:	ldr	r4, [r0, #0]
    caa6:	strb.w	r1, [sp, #111]	; 0x6f
    caaa:	adds	r7, r0, #4
    caac:	ldr	r0, [sp, #12]
    caae:	movs	r3, #48	; 0x30
    cab0:	movs	r2, #120	; 0x78
    cab2:	cmp	fp, r1
    cab4:	strb.w	r3, [sp, #112]	; 0x70
    cab8:	mov.w	r5, #0
    cabc:	strb.w	r2, [sp, #113]	; 0x71
    cac0:	orr.w	r3, r0, #2
    cac4:	blt.w	d274 <_svfprintf_r+0x964>
    cac8:	bic.w	r3, r0, #128	; 0x80
    cacc:	orr.w	r3, r3, #2
    cad0:	str	r3, [sp, #12]
    cad2:	orrs.w	r3, r4, r5
    cad6:	str	r7, [sp, #40]	; 0x28
    cad8:	beq.w	d220 <_svfprintf_r+0x910>
    cadc:	mov	r7, r1
    cade:	str	r2, [sp, #52]	; 0x34
    cae0:	ldr	r0, [pc, #252]	; (cbe0 <_svfprintf_r+0x2d0>)
    cae2:	b.n	d0b2 <_svfprintf_r+0x7a2>
    cae4:	add	r2, sp, #140	; 0x8c
    cae6:	ldr	r1, [sp, #20]
    cae8:	ldr	r0, [sp, #24]
    caea:	bl	118a8 <__ssprint_r>
    caee:	cbnz	r0, cb04 <_svfprintf_r+0x1f4>
    caf0:	add.w	r9, sp, #192	; 0xc0
    caf4:	b.n	c99c <_svfprintf_r+0x8c>
    caf6:	ldr	r3, [sp, #148]	; 0x94
    caf8:	cbz	r3, cb04 <_svfprintf_r+0x1f4>
    cafa:	ldr	r0, [sp, #24]
    cafc:	ldr	r1, [sp, #20]
    cafe:	add	r2, sp, #140	; 0x8c
    cb00:	bl	118a8 <__ssprint_r>
    cb04:	ldr	r3, [sp, #20]
    cb06:	ldrh	r3, [r3, #12]
    cb08:	tst.w	r3, #64	; 0x40
    cb0c:	ldr	r3, [sp, #28]
    cb0e:	it	ne
    cb10:	movne.w	r3, #4294967295
    cb14:	mov	r0, r3
    cb16:	add	sp, #260	; 0x104
    cb18:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    cb1c:	str	r3, [sp, #52]	; 0x34
    cb1e:	mov	fp, r5
    cb20:	cmp	r2, #0
    cb22:	bne.w	df8c <_svfprintf_r+0x167c>
    cb26:	ldr	r2, [sp, #12]
    cb28:	ands.w	r3, r2, #32
    cb2c:	beq.w	cfbc <_svfprintf_r+0x6ac>
    cb30:	ldr	r7, [sp, #40]	; 0x28
    cb32:	adds	r7, #7
    cb34:	bic.w	r3, r7, #7
    cb38:	movs	r7, #0
    cb3a:	add.w	r1, r3, #8
    cb3e:	cmp	fp, r7
    cb40:	str	r1, [sp, #40]	; 0x28
    cb42:	ldrd	r4, r5, [r3]
    cb46:	strb.w	r7, [sp, #111]	; 0x6f
    cb4a:	blt.w	da12 <_svfprintf_r+0x1102>
    cb4e:	bic.w	r3, r2, #128	; 0x80
    cb52:	str	r3, [sp, #12]
    cb54:	orrs.w	r3, r4, r5
    cb58:	beq.w	d264 <_svfprintf_r+0x954>
    cb5c:	add	r6, sp, #192	; 0xc0
    cb5e:	lsrs	r2, r4, #3
    cb60:	orr.w	r2, r2, r5, lsl #29
    cb64:	lsrs	r1, r5, #3
    cb66:	and.w	r3, r4, #7
    cb6a:	mov	r5, r1
    cb6c:	mov	r4, r2
    cb6e:	adds	r3, #48	; 0x30
    cb70:	orrs.w	r2, r4, r5
    cb74:	strb.w	r3, [r6, #-1]!
    cb78:	bne.n	cb5e <_svfprintf_r+0x24e>
    cb7a:	ldr	r2, [sp, #12]
    cb7c:	lsls	r1, r2, #31
    cb7e:	bpl.w	cca0 <_svfprintf_r+0x390>
    cb82:	cmp	r3, #48	; 0x30
    cb84:	beq.w	cca0 <_svfprintf_r+0x390>
    cb88:	movs	r2, #48	; 0x30
    cb8a:	subs	r3, r6, #1
    cb8c:	strb.w	r2, [r6, #-1]
    cb90:	add	r2, sp, #192	; 0xc0
    cb92:	subs	r2, r2, r3
    cb94:	str	r2, [sp, #36]	; 0x24
    cb96:	mov	r6, r3
    cb98:	b.n	cca6 <_svfprintf_r+0x396>
    cb9a:	ldrb.w	r3, [r8]
    cb9e:	cmp	r3, #42	; 0x2a
    cba0:	add.w	r4, r8, #1
    cba4:	beq.w	df70 <_svfprintf_r+0x1660>
    cba8:	sub.w	r0, r3, #48	; 0x30
    cbac:	cmp	r0, #9
    cbae:	it	ls
    cbb0:	movls	r5, #0
    cbb2:	bhi.w	dec2 <_svfprintf_r+0x15b2>
    cbb6:	ldrb.w	r3, [r4], #1
    cbba:	add.w	r5, r5, r5, lsl #2
    cbbe:	add.w	r5, r0, r5, lsl #1
    cbc2:	sub.w	r0, r3, #48	; 0x30
    cbc6:	cmp	r0, #9
    cbc8:	bls.n	cbb6 <_svfprintf_r+0x2a6>
    cbca:	orr.w	r5, r5, r5, asr #31
    cbce:	mov	r8, r4
    cbd0:	b.n	c9c8 <_svfprintf_r+0xb8>
    cbd2:	nop
    cbd4:	nop.w
	...
    cbe0:	.word	0x0001294c
    cbe4:	.word	0x00012918
    cbe8:	ldr	r3, [sp, #12]
    cbea:	orr.w	r3, r3, #128	; 0x80
    cbee:	str	r3, [sp, #12]
    cbf0:	ldrb.w	r3, [r8]
    cbf4:	b.n	c9c4 <_svfprintf_r+0xb4>
    cbf6:	sub.w	r0, r3, #48	; 0x30
    cbfa:	movs	r3, #0
    cbfc:	mov	r4, r3
    cbfe:	ldrb.w	r3, [r8], #1
    cc02:	add.w	r4, r4, r4, lsl #2
    cc06:	add.w	r4, r0, r4, lsl #1
    cc0a:	sub.w	r0, r3, #48	; 0x30
    cc0e:	cmp	r0, #9
    cc10:	bls.n	cbfe <_svfprintf_r+0x2ee>
    cc12:	str	r4, [sp, #32]
    cc14:	b.n	c9c8 <_svfprintf_r+0xb8>
    cc16:	str	r3, [sp, #52]	; 0x34
    cc18:	mov	fp, r5
    cc1a:	cmp	r2, #0
    cc1c:	bne.w	dfa8 <_svfprintf_r+0x1698>
    cc20:	ldr	r3, [sp, #12]
    cc22:	orr.w	r3, r3, #16
    cc26:	str	r3, [sp, #12]
    cc28:	ldr	r3, [sp, #12]
    cc2a:	lsls	r4, r3, #26
    cc2c:	bpl.w	d69e <_svfprintf_r+0xd8e>
    cc30:	ldr	r7, [sp, #40]	; 0x28
    cc32:	adds	r7, #7
    cc34:	bic.w	r7, r7, #7
    cc38:	ldrd	r2, r3, [r7]
    cc3c:	add.w	r1, r7, #8
    cc40:	str	r1, [sp, #40]	; 0x28
    cc42:	mov	r4, r2
    cc44:	mov	r5, r3
    cc46:	cmp	r2, #0
    cc48:	sbcs.w	r3, r3, #0
    cc4c:	blt.w	d714 <_svfprintf_r+0xe04>
    cc50:	cmp.w	fp, #0
    cc54:	ldrb.w	r7, [sp, #111]	; 0x6f
    cc58:	blt.w	d6da <_svfprintf_r+0xdca>
    cc5c:	ldr	r3, [sp, #12]
    cc5e:	bic.w	r3, r3, #128	; 0x80
    cc62:	str	r3, [sp, #12]
    cc64:	orrs.w	r3, r4, r5
    cc68:	beq.w	d03c <_svfprintf_r+0x72c>
    cc6c:	cmp	r5, #0
    cc6e:	it	eq
    cc70:	cmpeq	r4, #10
    cc72:	bcc.w	d046 <_svfprintf_r+0x736>
    cc76:	add	r6, sp, #192	; 0xc0
    cc78:	mov	r0, r4
    cc7a:	mov	r1, r5
    cc7c:	movs	r2, #10
    cc7e:	movs	r3, #0
    cc80:	bl	a6ec <__aeabi_uldivmod>
    cc84:	adds	r2, #48	; 0x30
    cc86:	strb.w	r2, [r6, #-1]!
    cc8a:	mov	r0, r4
    cc8c:	mov	r1, r5
    cc8e:	movs	r3, #0
    cc90:	movs	r2, #10
    cc92:	bl	a6ec <__aeabi_uldivmod>
    cc96:	mov	r4, r0
    cc98:	mov	r5, r1
    cc9a:	orrs.w	r3, r4, r5
    cc9e:	bne.n	cc78 <_svfprintf_r+0x368>
    cca0:	add	r3, sp, #192	; 0xc0
    cca2:	subs	r3, r3, r6
    cca4:	str	r3, [sp, #36]	; 0x24
    cca6:	ldr	r3, [sp, #36]	; 0x24
    cca8:	cmp	r3, fp
    ccaa:	it	lt
    ccac:	movlt	r3, fp
    ccae:	str	r3, [sp, #16]
    ccb0:	movs	r3, #0
    ccb2:	str	r3, [sp, #60]	; 0x3c
    ccb4:	cbz	r7, ccbc <_svfprintf_r+0x3ac>
    ccb6:	ldr	r3, [sp, #16]
    ccb8:	adds	r3, #1
    ccba:	str	r3, [sp, #16]
    ccbc:	ldr	r3, [sp, #12]
    ccbe:	ands.w	r3, r3, #2
    ccc2:	str	r3, [sp, #44]	; 0x2c
    ccc4:	beq.n	cccc <_svfprintf_r+0x3bc>
    ccc6:	ldr	r3, [sp, #16]
    ccc8:	adds	r3, #2
    ccca:	str	r3, [sp, #16]
    cccc:	ldr	r3, [sp, #12]
    ccce:	ands.w	r3, r3, #132	; 0x84
    ccd2:	str	r3, [sp, #48]	; 0x30
    ccd4:	bne.w	d28e <_svfprintf_r+0x97e>
    ccd8:	ldr	r3, [sp, #32]
    ccda:	ldr	r2, [sp, #16]
    ccdc:	subs	r5, r3, r2
    ccde:	cmp	r5, #0
    cce0:	ble.w	d28e <_svfprintf_r+0x97e>
    cce4:	cmp	r5, #16
    cce6:	ldr	r1, [sp, #148]	; 0x94
    cce8:	ldr	r2, [sp, #144]	; 0x90
    ccea:	ldr	r7, [pc, #672]	; (cf8c <_svfprintf_r+0x67c>)
    ccec:	ble.n	cd3e <_svfprintf_r+0x42e>
    ccee:	str	r6, [sp, #80]	; 0x50
    ccf0:	mov	r0, r9
    ccf2:	movs	r4, #16
    ccf4:	mov	r9, r7
    ccf6:	ldr	r6, [sp, #20]
    ccf8:	mov	r7, r5
    ccfa:	ldr	r5, [sp, #24]
    ccfc:	b.n	cd08 <_svfprintf_r+0x3f8>
    ccfe:	subs	r7, #16
    cd00:	cmp	r7, #16
    cd02:	add.w	r0, r0, #8
    cd06:	ble.n	cd36 <_svfprintf_r+0x426>
    cd08:	adds	r2, #1
    cd0a:	ldr	r3, [pc, #640]	; (cf8c <_svfprintf_r+0x67c>)
    cd0c:	str	r2, [sp, #144]	; 0x90
    cd0e:	adds	r1, #16
    cd10:	cmp	r2, #7
    cd12:	str	r1, [sp, #148]	; 0x94
    cd14:	stmia.w	r0, {r3, r4}
    cd18:	ble.n	ccfe <_svfprintf_r+0x3ee>
    cd1a:	add	r2, sp, #140	; 0x8c
    cd1c:	mov	r1, r6
    cd1e:	mov	r0, r5
    cd20:	bl	118a8 <__ssprint_r>
    cd24:	cmp	r0, #0
    cd26:	bne.w	cb04 <_svfprintf_r+0x1f4>
    cd2a:	subs	r7, #16
    cd2c:	cmp	r7, #16
    cd2e:	ldr	r1, [sp, #148]	; 0x94
    cd30:	ldr	r2, [sp, #144]	; 0x90
    cd32:	add	r0, sp, #192	; 0xc0
    cd34:	bgt.n	cd08 <_svfprintf_r+0x3f8>
    cd36:	ldr	r6, [sp, #80]	; 0x50
    cd38:	mov	r5, r7
    cd3a:	mov	r7, r9
    cd3c:	mov	r9, r0
    cd3e:	adds	r2, #1
    cd40:	adds	r4, r5, r1
    cd42:	cmp	r2, #7
    cd44:	str	r4, [sp, #148]	; 0x94
    cd46:	str	r2, [sp, #144]	; 0x90
    cd48:	str.w	r7, [r9]
    cd4c:	str.w	r5, [r9, #4]
    cd50:	bgt.w	d5ae <_svfprintf_r+0xc9e>
    cd54:	ldrb.w	r7, [sp, #111]	; 0x6f
    cd58:	add.w	r9, r9, #8
    cd5c:	cbz	r7, cd7c <_svfprintf_r+0x46c>
    cd5e:	ldr	r3, [sp, #144]	; 0x90
    cd60:	adds	r3, #1
    cd62:	adds	r4, #1
    cd64:	add.w	r1, sp, #111	; 0x6f
    cd68:	movs	r2, #1
    cd6a:	cmp	r3, #7
    cd6c:	str	r4, [sp, #148]	; 0x94
    cd6e:	str	r3, [sp, #144]	; 0x90
    cd70:	stmia.w	r9, {r1, r2}
    cd74:	bgt.w	d4c2 <_svfprintf_r+0xbb2>
    cd78:	add.w	r9, r9, #8
    cd7c:	ldr	r3, [sp, #44]	; 0x2c
    cd7e:	cbz	r3, cd9c <_svfprintf_r+0x48c>
    cd80:	ldr	r3, [sp, #144]	; 0x90
    cd82:	adds	r3, #1
    cd84:	adds	r4, #2
    cd86:	add	r1, sp, #112	; 0x70
    cd88:	movs	r2, #2
    cd8a:	cmp	r3, #7
    cd8c:	str	r4, [sp, #148]	; 0x94
    cd8e:	str	r3, [sp, #144]	; 0x90
    cd90:	stmia.w	r9, {r1, r2}
    cd94:	bgt.w	d4da <_svfprintf_r+0xbca>
    cd98:	add.w	r9, r9, #8
    cd9c:	ldr	r3, [sp, #48]	; 0x30
    cd9e:	cmp	r3, #128	; 0x80
    cda0:	beq.w	d366 <_svfprintf_r+0xa56>
    cda4:	ldr	r3, [sp, #36]	; 0x24
    cda6:	rsb	r7, r3, fp
    cdaa:	cmp	r7, #0
    cdac:	ble.n	ce16 <_svfprintf_r+0x506>
    cdae:	ldr	r2, [pc, #480]	; (cf90 <_svfprintf_r+0x680>)
    cdb0:	ldr	r3, [sp, #144]	; 0x90
    cdb2:	str	r2, [sp, #44]	; 0x2c
    cdb4:	cmp	r7, #16
    cdb6:	ble.n	cdfe <_svfprintf_r+0x4ee>
    cdb8:	mov	r2, r4
    cdba:	mov.w	fp, #16
    cdbe:	ldr	r5, [sp, #24]
    cdc0:	ldr	r4, [sp, #20]
    cdc2:	b.n	cdce <_svfprintf_r+0x4be>
    cdc4:	subs	r7, #16
    cdc6:	cmp	r7, #16
    cdc8:	add.w	r9, r9, #8
    cdcc:	ble.n	cdfc <_svfprintf_r+0x4ec>
    cdce:	adds	r3, #1
    cdd0:	adds	r2, #16
    cdd2:	cmp	r3, #7
    cdd4:	str	r2, [sp, #148]	; 0x94
    cdd6:	str	r3, [sp, #144]	; 0x90
    cdd8:	stmia.w	r9, {sl, fp}
    cddc:	ble.n	cdc4 <_svfprintf_r+0x4b4>
    cdde:	add	r2, sp, #140	; 0x8c
    cde0:	mov	r1, r4
    cde2:	mov	r0, r5
    cde4:	bl	118a8 <__ssprint_r>
    cde8:	cmp	r0, #0
    cdea:	bne.w	cb04 <_svfprintf_r+0x1f4>
    cdee:	subs	r7, #16
    cdf0:	cmp	r7, #16
    cdf2:	ldr	r2, [sp, #148]	; 0x94
    cdf4:	ldr	r3, [sp, #144]	; 0x90
    cdf6:	add.w	r9, sp, #192	; 0xc0
    cdfa:	bgt.n	cdce <_svfprintf_r+0x4be>
    cdfc:	mov	r4, r2
    cdfe:	adds	r3, #1
    ce00:	ldr	r2, [sp, #44]	; 0x2c
    ce02:	str	r3, [sp, #144]	; 0x90
    ce04:	add	r4, r7
    ce06:	cmp	r3, #7
    ce08:	str	r4, [sp, #148]	; 0x94
    ce0a:	stmia.w	r9, {r2, r7}
    ce0e:	bgt.w	d4aa <_svfprintf_r+0xb9a>
    ce12:	add.w	r9, r9, #8
    ce16:	ldr	r3, [sp, #12]
    ce18:	lsls	r2, r3, #23
    ce1a:	bmi.w	d292 <_svfprintf_r+0x982>
    ce1e:	ldr	r3, [sp, #144]	; 0x90
    ce20:	ldr	r1, [sp, #36]	; 0x24
    ce22:	str.w	r6, [r9]
    ce26:	adds	r3, #1
    ce28:	add	r4, r1
    ce2a:	cmp	r3, #7
    ce2c:	str	r4, [sp, #148]	; 0x94
    ce2e:	str.w	r1, [r9, #4]
    ce32:	str	r3, [sp, #144]	; 0x90
    ce34:	bgt.w	d47e <_svfprintf_r+0xb6e>
    ce38:	add.w	r9, r9, #8
    ce3c:	ldr	r3, [sp, #12]
    ce3e:	lsls	r1, r3, #29
    ce40:	bpl.n	cec2 <_svfprintf_r+0x5b2>
    ce42:	ldr	r3, [sp, #32]
    ce44:	ldr	r2, [sp, #16]
    ce46:	subs	r5, r3, r2
    ce48:	cmp	r5, #0
    ce4a:	ble.n	cec2 <_svfprintf_r+0x5b2>
    ce4c:	cmp	r5, #16
    ce4e:	ldr	r3, [sp, #144]	; 0x90
    ce50:	ldr	r7, [pc, #312]	; (cf8c <_svfprintf_r+0x67c>)
    ce52:	ble.n	ce9c <_svfprintf_r+0x58c>
    ce54:	mov	r2, r4
    ce56:	movs	r6, #16
    ce58:	ldr.w	fp, [sp, #24]
    ce5c:	ldr	r4, [sp, #20]
    ce5e:	b.n	ce6a <_svfprintf_r+0x55a>
    ce60:	subs	r5, #16
    ce62:	cmp	r5, #16
    ce64:	add.w	r9, r9, #8
    ce68:	ble.n	ce9a <_svfprintf_r+0x58a>
    ce6a:	adds	r3, #1
    ce6c:	ldr	r1, [pc, #284]	; (cf8c <_svfprintf_r+0x67c>)
    ce6e:	str	r3, [sp, #144]	; 0x90
    ce70:	adds	r2, #16
    ce72:	cmp	r3, #7
    ce74:	str	r2, [sp, #148]	; 0x94
    ce76:	stmia.w	r9, {r1, r6}
    ce7a:	ble.n	ce60 <_svfprintf_r+0x550>
    ce7c:	add	r2, sp, #140	; 0x8c
    ce7e:	mov	r1, r4
    ce80:	mov	r0, fp
    ce82:	bl	118a8 <__ssprint_r>
    ce86:	cmp	r0, #0
    ce88:	bne.w	cb04 <_svfprintf_r+0x1f4>
    ce8c:	subs	r5, #16
    ce8e:	cmp	r5, #16
    ce90:	ldr	r2, [sp, #148]	; 0x94
    ce92:	ldr	r3, [sp, #144]	; 0x90
    ce94:	add.w	r9, sp, #192	; 0xc0
    ce98:	bgt.n	ce6a <_svfprintf_r+0x55a>
    ce9a:	mov	r4, r2
    ce9c:	adds	r3, #1
    ce9e:	add	r4, r5
    cea0:	cmp	r3, #7
    cea2:	str	r4, [sp, #148]	; 0x94
    cea4:	str	r3, [sp, #144]	; 0x90
    cea6:	str.w	r7, [r9]
    ceaa:	str.w	r5, [r9, #4]
    ceae:	ble.n	cec2 <_svfprintf_r+0x5b2>
    ceb0:	add	r2, sp, #140	; 0x8c
    ceb2:	ldr	r1, [sp, #20]
    ceb4:	ldr	r0, [sp, #24]
    ceb6:	bl	118a8 <__ssprint_r>
    ceba:	cmp	r0, #0
    cebc:	bne.w	cb04 <_svfprintf_r+0x1f4>
    cec0:	ldr	r4, [sp, #148]	; 0x94
    cec2:	ldr	r3, [sp, #28]
    cec4:	ldr	r2, [sp, #32]
    cec6:	ldr	r1, [sp, #16]
    cec8:	cmp	r2, r1
    ceca:	ite	ge
    cecc:	addge	r3, r3, r2
    cece:	addlt	r3, r3, r1
    ced0:	str	r3, [sp, #28]
    ced2:	cmp	r4, #0
    ced4:	bne.w	d496 <_svfprintf_r+0xb86>
    ced8:	movs	r3, #0
    ceda:	str	r3, [sp, #144]	; 0x90
    cedc:	add.w	r9, sp, #192	; 0xc0
    cee0:	b.n	c95e <_svfprintf_r+0x4e>
    cee2:	str	r3, [sp, #52]	; 0x34
    cee4:	mov	fp, r5
    cee6:	cmp	r2, #0
    cee8:	bne.w	dfb0 <_svfprintf_r+0x16a0>
    ceec:	ldr	r3, [sp, #12]
    ceee:	ldr	r7, [sp, #40]	; 0x28
    cef0:	lsls	r2, r3, #28
    cef2:	add.w	r7, r7, #7
    cef6:	bpl.w	d9e2 <_svfprintf_r+0x10d2>
    cefa:	bic.w	r3, r7, #7
    cefe:	vldr	d7, [r3]
    cf02:	vstr	d7, [sp, #64]	; 0x40
    cf06:	add.w	r2, r3, #8
    cf0a:	str	r2, [sp, #40]	; 0x28
    cf0c:	ldrd	r1, r2, [sp, #64]	; 0x40
    cf10:	bic.w	r3, r2, #2147483648	; 0x80000000
    cf14:	str	r1, [sp, #88]	; 0x58
    cf16:	str	r3, [sp, #92]	; 0x5c
    cf18:	ldrd	r4, r5, [sp, #88]	; 0x58
    cf1c:	mov.w	r2, #4294967295
    cf20:	mov	r0, r4
    cf22:	mov	r1, r5
    cf24:	ldr	r3, [pc, #108]	; (cf94 <_svfprintf_r+0x684>)
    cf26:	bl	a590 <__aeabi_dcmpun>
    cf2a:	cmp	r0, #0
    cf2c:	bne.w	d8e4 <_svfprintf_r+0xfd4>
    cf30:	mov.w	r2, #4294967295
    cf34:	ldr	r3, [pc, #92]	; (cf94 <_svfprintf_r+0x684>)
    cf36:	mov	r0, r4
    cf38:	mov	r1, r5
    cf3a:	bl	a554 <__aeabi_dcmple>
    cf3e:	cmp	r0, #0
    cf40:	bne.w	d8e4 <_svfprintf_r+0xfd4>
    cf44:	movs	r2, #0
    cf46:	movs	r3, #0
    cf48:	ldrd	r0, r1, [sp, #64]	; 0x40
    cf4c:	bl	a540 <__aeabi_dcmplt>
    cf50:	cmp	r0, #0
    cf52:	bne.w	ddfa <_svfprintf_r+0x14ea>
    cf56:	ldrb.w	r7, [sp, #111]	; 0x6f
    cf5a:	ldr	r6, [pc, #60]	; (cf98 <_svfprintf_r+0x688>)
    cf5c:	ldr	r3, [pc, #60]	; (cf9c <_svfprintf_r+0x68c>)
    cf5e:	ldr	r1, [sp, #12]
    cf60:	bic.w	r1, r1, #128	; 0x80
    cf64:	str	r1, [sp, #12]
    cf66:	ldr	r1, [sp, #52]	; 0x34
    cf68:	movs	r2, #3
    cf6a:	mov.w	fp, #0
    cf6e:	str	r2, [sp, #16]
    cf70:	cmp	r1, #71	; 0x47
    cf72:	it	le
    cf74:	movle	r6, r3
    cf76:	str	r2, [sp, #36]	; 0x24
    cf78:	str.w	fp, [sp, #60]	; 0x3c
    cf7c:	b.n	ccb4 <_svfprintf_r+0x3a4>
    cf7e:	ldr	r3, [sp, #12]
    cf80:	orr.w	r3, r3, #8
    cf84:	str	r3, [sp, #12]
    cf86:	ldrb.w	r3, [r8]
    cf8a:	b.n	c9c4 <_svfprintf_r+0xb4>
    cf8c:	.word	0x0001296c
    cf90:	.word	0x00012918
    cf94:	.word	0x7fefffff
    cf98:	.word	0x0001292c
    cf9c:	.word	0x00012928
    cfa0:	str	r3, [sp, #52]	; 0x34
    cfa2:	mov	fp, r5
    cfa4:	cmp	r2, #0
    cfa6:	bne.w	dfc8 <_svfprintf_r+0x16b8>
    cfaa:	ldr	r3, [sp, #12]
    cfac:	orr.w	r3, r3, #16
    cfb0:	str	r3, [sp, #12]
    cfb2:	ldr	r2, [sp, #12]
    cfb4:	ands.w	r3, r2, #32
    cfb8:	bne.w	cb30 <_svfprintf_r+0x220>
    cfbc:	ldr	r1, [sp, #12]
    cfbe:	ands.w	r2, r1, #16
    cfc2:	beq.w	d87c <_svfprintf_r+0xf6c>
    cfc6:	ldr	r0, [sp, #40]	; 0x28
    cfc8:	strb.w	r3, [sp, #111]	; 0x6f
    cfcc:	cmp.w	fp, #0
    cfd0:	ldr	r4, [r0, #0]
    cfd2:	add.w	r7, r0, #4
    cfd6:	mov.w	r5, #0
    cfda:	blt.w	da10 <_svfprintf_r+0x1100>
    cfde:	mov	r2, r1
    cfe0:	bic.w	r2, r2, #128	; 0x80
    cfe4:	str	r2, [sp, #12]
    cfe6:	orrs.w	r2, r4, r5
    cfea:	str	r7, [sp, #40]	; 0x28
    cfec:	beq.w	d264 <_svfprintf_r+0x954>
    cff0:	mov	r7, r3
    cff2:	b.n	cb5c <_svfprintf_r+0x24c>
    cff4:	str	r3, [sp, #52]	; 0x34
    cff6:	mov	fp, r5
    cff8:	cmp	r2, #0
    cffa:	bne.w	dfc0 <_svfprintf_r+0x16b0>
    cffe:	ldr	r3, [sp, #12]
    d000:	orr.w	r3, r3, #16
    d004:	str	r3, [sp, #12]
    d006:	ldr	r2, [sp, #12]
    d008:	ands.w	r3, r2, #32
    d00c:	beq.w	d668 <_svfprintf_r+0xd58>
    d010:	ldr	r7, [sp, #40]	; 0x28
    d012:	adds	r7, #7
    d014:	bic.w	r3, r7, #7
    d018:	movs	r7, #0
    d01a:	add.w	r1, r3, #8
    d01e:	cmp	fp, r7
    d020:	str	r1, [sp, #40]	; 0x28
    d022:	ldrd	r4, r5, [r3]
    d026:	strb.w	r7, [sp, #111]	; 0x6f
    d02a:	blt.w	d6da <_svfprintf_r+0xdca>
    d02e:	bic.w	r3, r2, #128	; 0x80
    d032:	str	r3, [sp, #12]
    d034:	orrs.w	r3, r4, r5
    d038:	bne.w	cc6c <_svfprintf_r+0x35c>
    d03c:	cmp.w	fp, #0
    d040:	beq.w	d22e <_svfprintf_r+0x91e>
    d044:	movs	r4, #0
    d046:	add	r6, sp, #256	; 0x100
    d048:	adds	r4, #48	; 0x30
    d04a:	strb.w	r4, [r6, #-65]!
    d04e:	b.n	cca0 <_svfprintf_r+0x390>
    d050:	str	r3, [sp, #52]	; 0x34
    d052:	mov	fp, r5
    d054:	cmp	r2, #0
    d056:	bne.w	dfb8 <_svfprintf_r+0x16a8>
    d05a:	ldr	r3, [sp, #12]
    d05c:	ldr	r0, [pc, #700]	; (d31c <_svfprintf_r+0xa0c>)
    d05e:	lsls	r5, r3, #26
    d060:	bpl.w	d1ce <_svfprintf_r+0x8be>
    d064:	ldr	r7, [sp, #40]	; 0x28
    d066:	adds	r7, #7
    d068:	bic.w	r3, r7, #7
    d06c:	ldrd	r4, r5, [r3]
    d070:	add.w	r2, r3, #8
    d074:	str	r2, [sp, #40]	; 0x28
    d076:	ldr	r2, [sp, #12]
    d078:	ands.w	r7, r2, #1
    d07c:	beq.w	d4f2 <_svfprintf_r+0xbe2>
    d080:	orrs.w	r3, r4, r5
    d084:	beq.w	da8c <_svfprintf_r+0x117c>
    d088:	ldrb.w	r2, [sp, #52]	; 0x34
    d08c:	strb.w	r2, [sp, #113]	; 0x71
    d090:	movs	r7, #0
    d092:	ldr	r2, [sp, #12]
    d094:	strb.w	r7, [sp, #111]	; 0x6f
    d098:	movs	r3, #48	; 0x30
    d09a:	cmp	fp, r7
    d09c:	strb.w	r3, [sp, #112]	; 0x70
    d0a0:	orr.w	r3, r2, #2
    d0a4:	blt.w	de04 <_svfprintf_r+0x14f4>
    d0a8:	bic.w	r3, r2, #128	; 0x80
    d0ac:	orr.w	r3, r3, #2
    d0b0:	str	r3, [sp, #12]
    d0b2:	add	r6, sp, #192	; 0xc0
    d0b4:	lsrs	r3, r4, #4
    d0b6:	and.w	r1, r4, #15
    d0ba:	orr.w	r3, r3, r5, lsl #28
    d0be:	lsrs	r2, r5, #4
    d0c0:	mov	r4, r3
    d0c2:	mov	r5, r2
    d0c4:	ldrb	r3, [r0, r1]
    d0c6:	strb.w	r3, [r6, #-1]!
    d0ca:	orrs.w	r3, r4, r5
    d0ce:	bne.n	d0b4 <_svfprintf_r+0x7a4>
    d0d0:	b.n	cca0 <_svfprintf_r+0x390>
    d0d2:	ldr	r1, [sp, #40]	; 0x28
    d0d4:	str	r3, [sp, #52]	; 0x34
    d0d6:	ldr	r2, [r1, #0]
    d0d8:	strb.w	r2, [sp, #152]	; 0x98
    d0dc:	movs	r3, #0
    d0de:	mov	r2, r1
    d0e0:	mov	r7, r3
    d0e2:	strb.w	r3, [sp, #111]	; 0x6f
    d0e6:	adds	r2, #4
    d0e8:	movs	r3, #1
    d0ea:	str	r3, [sp, #16]
    d0ec:	mov	fp, r7
    d0ee:	str	r7, [sp, #60]	; 0x3c
    d0f0:	str	r2, [sp, #40]	; 0x28
    d0f2:	str	r3, [sp, #36]	; 0x24
    d0f4:	add	r6, sp, #152	; 0x98
    d0f6:	b.n	ccbc <_svfprintf_r+0x3ac>
    d0f8:	str	r3, [sp, #52]	; 0x34
    d0fa:	mov	fp, r5
    d0fc:	cmp	r2, #0
    d0fe:	beq.w	cc28 <_svfprintf_r+0x318>
    d102:	strb.w	r1, [sp, #111]	; 0x6f
    d106:	b.n	cc28 <_svfprintf_r+0x318>
    d108:	ldr	r3, [sp, #12]
    d10a:	orr.w	r3, r3, #64	; 0x40
    d10e:	str	r3, [sp, #12]
    d110:	ldrb.w	r3, [r8]
    d114:	b.n	c9c4 <_svfprintf_r+0xb4>
    d116:	ldrb.w	r3, [r8]
    d11a:	cmp	r1, #0
    d11c:	bne.w	c9c4 <_svfprintf_r+0xb4>
    d120:	movs	r2, #1
    d122:	movs	r1, #32
    d124:	b.n	c9c4 <_svfprintf_r+0xb4>
    d126:	ldr	r3, [sp, #12]
    d128:	orr.w	r3, r3, #1
    d12c:	str	r3, [sp, #12]
    d12e:	ldrb.w	r3, [r8]
    d132:	b.n	c9c4 <_svfprintf_r+0xb4>
    d134:	ldr	r4, [sp, #40]	; 0x28
    d136:	ldr	r3, [r4, #0]
    d138:	str	r3, [sp, #32]
    d13a:	mov	r0, r3
    d13c:	cmp	r0, #0
    d13e:	mov	r3, r4
    d140:	add.w	r3, r3, #4
    d144:	blt.w	ca88 <_svfprintf_r+0x178>
    d148:	str	r3, [sp, #40]	; 0x28
    d14a:	ldrb.w	r3, [r8]
    d14e:	b.n	c9c4 <_svfprintf_r+0xb4>
    d150:	ldrb.w	r3, [r8]
    d154:	movs	r2, #1
    d156:	movs	r1, #43	; 0x2b
    d158:	b.n	c9c4 <_svfprintf_r+0xb4>
    d15a:	ldr	r3, [sp, #12]
    d15c:	orr.w	r3, r3, #32
    d160:	str	r3, [sp, #12]
    d162:	ldrb.w	r3, [r8]
    d166:	b.n	c9c4 <_svfprintf_r+0xb4>
    d168:	ldr	r2, [sp, #40]	; 0x28
    d16a:	str	r3, [sp, #52]	; 0x34
    d16c:	ldr	r6, [r2, #0]
    d16e:	movs	r4, #0
    d170:	strb.w	r4, [sp, #111]	; 0x6f
    d174:	adds	r7, r2, #4
    d176:	cmp	r6, #0
    d178:	beq.w	ddb4 <_svfprintf_r+0x14a4>
    d17c:	cmp	r5, #0
    d17e:	blt.w	dc44 <_svfprintf_r+0x1334>
    d182:	mov	r2, r5
    d184:	mov	r1, r4
    d186:	mov	r0, r6
    d188:	bl	b080 <memchr>
    d18c:	cmp	r0, #0
    d18e:	beq.w	de58 <_svfprintf_r+0x1548>
    d192:	subs	r3, r0, r6
    d194:	str	r3, [sp, #36]	; 0x24
    d196:	mov	fp, r4
    d198:	bic.w	r3, r3, r3, asr #31
    d19c:	str	r7, [sp, #40]	; 0x28
    d19e:	str	r3, [sp, #16]
    d1a0:	str.w	fp, [sp, #60]	; 0x3c
    d1a4:	ldrb.w	r7, [sp, #111]	; 0x6f
    d1a8:	b.n	ccb4 <_svfprintf_r+0x3a4>
    d1aa:	str	r3, [sp, #52]	; 0x34
    d1ac:	mov	fp, r5
    d1ae:	cmp	r2, #0
    d1b0:	beq.w	d006 <_svfprintf_r+0x6f6>
    d1b4:	strb.w	r1, [sp, #111]	; 0x6f
    d1b8:	b.n	d006 <_svfprintf_r+0x6f6>
    d1ba:	str	r3, [sp, #52]	; 0x34
    d1bc:	mov	fp, r5
    d1be:	cmp	r2, #0
    d1c0:	bne.w	dfe0 <_svfprintf_r+0x16d0>
    d1c4:	ldr	r3, [sp, #12]
    d1c6:	ldr	r0, [pc, #344]	; (d320 <_svfprintf_r+0xa10>)
    d1c8:	lsls	r5, r3, #26
    d1ca:	bmi.w	d064 <_svfprintf_r+0x754>
    d1ce:	ldr	r3, [sp, #12]
    d1d0:	lsls	r4, r3, #27
    d1d2:	bpl.w	da52 <_svfprintf_r+0x1142>
    d1d6:	ldr	r2, [sp, #40]	; 0x28
    d1d8:	mov	r3, r2
    d1da:	adds	r3, #4
    d1dc:	ldr	r4, [r2, #0]
    d1de:	str	r3, [sp, #40]	; 0x28
    d1e0:	movs	r5, #0
    d1e2:	b.n	d076 <_svfprintf_r+0x766>
    d1e4:	ldrb.w	r3, [r8]
    d1e8:	cmp	r3, #108	; 0x6c
    d1ea:	beq.w	db72 <_svfprintf_r+0x1262>
    d1ee:	ldr	r0, [sp, #12]
    d1f0:	orr.w	r0, r0, #16
    d1f4:	str	r0, [sp, #12]
    d1f6:	b.w	c9c4 <_svfprintf_r+0xb4>
    d1fa:	cmp	r2, #0
    d1fc:	bne.w	dfd8 <_svfprintf_r+0x16c8>
    d200:	ldr	r3, [sp, #12]
    d202:	lsls	r3, r3, #26
    d204:	bpl.w	d8b6 <_svfprintf_r+0xfa6>
    d208:	ldr	r2, [sp, #40]	; 0x28
    d20a:	ldr	r1, [sp, #28]
    d20c:	ldr	r3, [r2, #0]
    d20e:	asrs	r5, r1, #31
    d210:	mov	r0, r1
    d212:	adds	r2, #4
    d214:	mov	r1, r5
    d216:	str	r2, [sp, #40]	; 0x28
    d218:	strd	r0, r1, [r3]
    d21c:	b.w	c95e <_svfprintf_r+0x4e>
    d220:	ldr	r0, [pc, #252]	; (d320 <_svfprintf_r+0xa10>)
    d222:	str	r2, [sp, #52]	; 0x34
    d224:	cmp.w	fp, #0
    d228:	bne.w	d514 <_svfprintf_r+0xc04>
    d22c:	mov	r7, fp
    d22e:	mov.w	fp, #0
    d232:	str.w	fp, [sp, #36]	; 0x24
    d236:	add	r6, sp, #192	; 0xc0
    d238:	b.n	cca6 <_svfprintf_r+0x396>
    d23a:	str	r3, [sp, #52]	; 0x34
    d23c:	cmp	r2, #0
    d23e:	bne.w	dfd0 <_svfprintf_r+0x16c0>
    d242:	ldr	r2, [sp, #52]	; 0x34
    d244:	cmp	r2, #0
    d246:	beq.w	caf6 <_svfprintf_r+0x1e6>
    d24a:	movs	r3, #0
    d24c:	movs	r1, #1
    d24e:	mov	r7, r3
    d250:	str	r1, [sp, #16]
    d252:	strb.w	r2, [sp, #152]	; 0x98
    d256:	strb.w	r3, [sp, #111]	; 0x6f
    d25a:	mov	fp, r3
    d25c:	str	r3, [sp, #60]	; 0x3c
    d25e:	str	r1, [sp, #36]	; 0x24
    d260:	add	r6, sp, #152	; 0x98
    d262:	b.n	ccbc <_svfprintf_r+0x3ac>
    d264:	cmp.w	fp, #0
    d268:	beq.w	de88 <_svfprintf_r+0x1578>
    d26c:	movs	r7, #0
    d26e:	movs	r4, #0
    d270:	movs	r5, #0
    d272:	b.n	cb5c <_svfprintf_r+0x24c>
    d274:	ldr	r0, [pc, #168]	; (d320 <_svfprintf_r+0xa10>)
    d276:	str	r3, [sp, #12]
    d278:	str	r2, [sp, #52]	; 0x34
    d27a:	orrs.w	r3, r4, r5
    d27e:	str	r7, [sp, #40]	; 0x28
    d280:	mov.w	r7, #0
    d284:	bne.w	d0b2 <_svfprintf_r+0x7a2>
    d288:	movs	r4, #0
    d28a:	movs	r5, #0
    d28c:	b.n	d0b2 <_svfprintf_r+0x7a2>
    d28e:	ldr	r4, [sp, #148]	; 0x94
    d290:	b.n	cd5c <_svfprintf_r+0x44c>
    d292:	ldr	r3, [sp, #52]	; 0x34
    d294:	cmp	r3, #101	; 0x65
    d296:	ble.w	d3ee <_svfprintf_r+0xade>
    d29a:	movs	r2, #0
    d29c:	movs	r3, #0
    d29e:	ldrd	r0, r1, [sp, #64]	; 0x40
    d2a2:	bl	a52c <__aeabi_dcmpeq>
    d2a6:	cmp	r0, #0
    d2a8:	beq.w	d518 <_svfprintf_r+0xc08>
    d2ac:	ldr	r3, [sp, #144]	; 0x90
    d2ae:	ldr	r2, [pc, #116]	; (d324 <_svfprintf_r+0xa14>)
    d2b0:	str.w	r2, [r9]
    d2b4:	adds	r3, #1
    d2b6:	adds	r4, #1
    d2b8:	movs	r2, #1
    d2ba:	cmp	r3, #7
    d2bc:	str	r4, [sp, #148]	; 0x94
    d2be:	str	r3, [sp, #144]	; 0x90
    d2c0:	str.w	r2, [r9, #4]
    d2c4:	bgt.w	daa4 <_svfprintf_r+0x1194>
    d2c8:	add.w	r9, r9, #8
    d2cc:	ldr	r3, [sp, #116]	; 0x74
    d2ce:	ldr	r2, [sp, #56]	; 0x38
    d2d0:	cmp	r3, r2
    d2d2:	blt.n	d2dc <_svfprintf_r+0x9cc>
    d2d4:	ldr	r3, [sp, #12]
    d2d6:	lsls	r3, r3, #31
    d2d8:	bpl.w	ce3c <_svfprintf_r+0x52c>
    d2dc:	ldr	r3, [sp, #144]	; 0x90
    d2de:	ldr	r1, [sp, #72]	; 0x48
    d2e0:	ldr	r2, [sp, #76]	; 0x4c
    d2e2:	str.w	r2, [r9]
    d2e6:	adds	r3, #1
    d2e8:	add	r4, r1
    d2ea:	cmp	r3, #7
    d2ec:	str	r4, [sp, #148]	; 0x94
    d2ee:	str.w	r1, [r9, #4]
    d2f2:	str	r3, [sp, #144]	; 0x90
    d2f4:	bgt.w	db86 <_svfprintf_r+0x1276>
    d2f8:	add.w	r9, r9, #8
    d2fc:	ldr	r3, [sp, #56]	; 0x38
    d2fe:	subs	r5, r3, #1
    d300:	cmp	r5, #0
    d302:	ble.w	ce3c <_svfprintf_r+0x52c>
    d306:	ldr	r2, [pc, #32]	; (d328 <_svfprintf_r+0xa18>)
    d308:	ldr	r3, [sp, #144]	; 0x90
    d30a:	str	r2, [sp, #44]	; 0x2c
    d30c:	cmp	r5, #16
    d30e:	ble.w	d6e4 <_svfprintf_r+0xdd4>
    d312:	movs	r6, #16
    d314:	ldr	r7, [sp, #24]
    d316:	ldr.w	fp, [sp, #20]
    d31a:	b.n	d338 <_svfprintf_r+0xa28>
    d31c:	.word	0x00012938
    d320:	.word	0x0001294c
    d324:	.word	0x00012968
    d328:	.word	0x00012918
    d32c:	add.w	r9, r9, #8
    d330:	subs	r5, #16
    d332:	cmp	r5, #16
    d334:	ble.w	d6e4 <_svfprintf_r+0xdd4>
    d338:	adds	r3, #1
    d33a:	adds	r4, #16
    d33c:	cmp	r3, #7
    d33e:	str	r4, [sp, #148]	; 0x94
    d340:	str	r3, [sp, #144]	; 0x90
    d342:	str.w	sl, [r9]
    d346:	str.w	r6, [r9, #4]
    d34a:	ble.n	d32c <_svfprintf_r+0xa1c>
    d34c:	add	r2, sp, #140	; 0x8c
    d34e:	mov	r1, fp
    d350:	mov	r0, r7
    d352:	bl	118a8 <__ssprint_r>
    d356:	cmp	r0, #0
    d358:	bne.w	cb04 <_svfprintf_r+0x1f4>
    d35c:	ldr	r4, [sp, #148]	; 0x94
    d35e:	ldr	r3, [sp, #144]	; 0x90
    d360:	add.w	r9, sp, #192	; 0xc0
    d364:	b.n	d330 <_svfprintf_r+0xa20>
    d366:	ldr	r3, [sp, #32]
    d368:	ldr	r2, [sp, #16]
    d36a:	subs	r7, r3, r2
    d36c:	cmp	r7, #0
    d36e:	ble.w	cda4 <_svfprintf_r+0x494>
    d372:	ldr	r2, [pc, #752]	; (d664 <_svfprintf_r+0xd54>)
    d374:	ldr	r3, [sp, #144]	; 0x90
    d376:	str	r2, [sp, #44]	; 0x2c
    d378:	cmp	r7, #16
    d37a:	ble.n	d3d4 <_svfprintf_r+0xac4>
    d37c:	mov	r2, r9
    d37e:	mov	r1, r4
    d380:	mov	r9, r7
    d382:	movs	r5, #16
    d384:	mov	r7, r6
    d386:	ldr	r4, [sp, #24]
    d388:	ldr	r6, [sp, #20]
    d38a:	b.n	d39a <_svfprintf_r+0xa8a>
    d38c:	sub.w	r9, r9, #16
    d390:	cmp.w	r9, #16
    d394:	add.w	r2, r2, #8
    d398:	ble.n	d3cc <_svfprintf_r+0xabc>
    d39a:	adds	r3, #1
    d39c:	adds	r1, #16
    d39e:	cmp	r3, #7
    d3a0:	str	r1, [sp, #148]	; 0x94
    d3a2:	str	r3, [sp, #144]	; 0x90
    d3a4:	str.w	sl, [r2]
    d3a8:	str	r5, [r2, #4]
    d3aa:	ble.n	d38c <_svfprintf_r+0xa7c>
    d3ac:	add	r2, sp, #140	; 0x8c
    d3ae:	mov	r1, r6
    d3b0:	mov	r0, r4
    d3b2:	bl	118a8 <__ssprint_r>
    d3b6:	cmp	r0, #0
    d3b8:	bne.w	cb04 <_svfprintf_r+0x1f4>
    d3bc:	sub.w	r9, r9, #16
    d3c0:	cmp.w	r9, #16
    d3c4:	ldr	r1, [sp, #148]	; 0x94
    d3c6:	ldr	r3, [sp, #144]	; 0x90
    d3c8:	add	r2, sp, #192	; 0xc0
    d3ca:	bgt.n	d39a <_svfprintf_r+0xa8a>
    d3cc:	mov	r6, r7
    d3ce:	mov	r4, r1
    d3d0:	mov	r7, r9
    d3d2:	mov	r9, r2
    d3d4:	adds	r3, #1
    d3d6:	ldr	r2, [sp, #44]	; 0x2c
    d3d8:	str	r3, [sp, #144]	; 0x90
    d3da:	add	r4, r7
    d3dc:	cmp	r3, #7
    d3de:	str	r4, [sp, #148]	; 0x94
    d3e0:	stmia.w	r9, {r2, r7}
    d3e4:	bgt.w	d862 <_svfprintf_r+0xf52>
    d3e8:	add.w	r9, r9, #8
    d3ec:	b.n	cda4 <_svfprintf_r+0x494>
    d3ee:	ldr	r3, [sp, #56]	; 0x38
    d3f0:	ldr	r5, [sp, #144]	; 0x90
    d3f2:	cmp	r3, #1
    d3f4:	ble.w	d80c <_svfprintf_r+0xefc>
    d3f8:	adds	r5, #1
    d3fa:	adds	r4, #1
    d3fc:	movs	r3, #1
    d3fe:	cmp	r5, #7
    d400:	str	r4, [sp, #148]	; 0x94
    d402:	str	r5, [sp, #144]	; 0x90
    d404:	str.w	r6, [r9]
    d408:	str.w	r3, [r9, #4]
    d40c:	bgt.w	d82e <_svfprintf_r+0xf1e>
    d410:	add.w	r9, r9, #8
    d414:	ldr	r2, [sp, #72]	; 0x48
    d416:	ldr	r3, [sp, #76]	; 0x4c
    d418:	str.w	r3, [r9]
    d41c:	adds	r5, #1
    d41e:	add	r4, r2
    d420:	cmp	r5, #7
    d422:	str	r4, [sp, #148]	; 0x94
    d424:	str	r5, [sp, #144]	; 0x90
    d426:	str.w	r2, [r9, #4]
    d42a:	bgt.w	d848 <_svfprintf_r+0xf38>
    d42e:	add.w	r9, r9, #8
    d432:	movs	r3, #0
    d434:	movs	r2, #0
    d436:	ldrd	r0, r1, [sp, #64]	; 0x40
    d43a:	bl	a52c <__aeabi_dcmpeq>
    d43e:	ldr	r3, [sp, #56]	; 0x38
    d440:	cmp	r0, #0
    d442:	bne.w	d5cc <_svfprintf_r+0xcbc>
    d446:	subs	r3, #1
    d448:	adds	r5, #1
    d44a:	adds	r6, #1
    d44c:	add	r4, r3
    d44e:	cmp	r5, #7
    d450:	str	r5, [sp, #144]	; 0x90
    d452:	str	r4, [sp, #148]	; 0x94
    d454:	str.w	r6, [r9]
    d458:	str.w	r3, [r9, #4]
    d45c:	bgt.w	d64a <_svfprintf_r+0xd3a>
    d460:	add.w	r9, r9, #8
    d464:	ldr	r2, [sp, #84]	; 0x54
    d466:	str.w	r2, [r9, #4]
    d46a:	adds	r5, #1
    d46c:	add	r4, r2
    d46e:	add	r3, sp, #124	; 0x7c
    d470:	cmp	r5, #7
    d472:	str	r4, [sp, #148]	; 0x94
    d474:	str	r5, [sp, #144]	; 0x90
    d476:	str.w	r3, [r9]
    d47a:	ble.w	ce38 <_svfprintf_r+0x528>
    d47e:	add	r2, sp, #140	; 0x8c
    d480:	ldr	r1, [sp, #20]
    d482:	ldr	r0, [sp, #24]
    d484:	bl	118a8 <__ssprint_r>
    d488:	cmp	r0, #0
    d48a:	bne.w	cb04 <_svfprintf_r+0x1f4>
    d48e:	ldr	r4, [sp, #148]	; 0x94
    d490:	add.w	r9, sp, #192	; 0xc0
    d494:	b.n	ce3c <_svfprintf_r+0x52c>
    d496:	add	r2, sp, #140	; 0x8c
    d498:	ldr	r1, [sp, #20]
    d49a:	ldr	r0, [sp, #24]
    d49c:	bl	118a8 <__ssprint_r>
    d4a0:	cmp	r0, #0
    d4a2:	beq.w	ced8 <_svfprintf_r+0x5c8>
    d4a6:	b.w	cb04 <_svfprintf_r+0x1f4>
    d4aa:	add	r2, sp, #140	; 0x8c
    d4ac:	ldr	r1, [sp, #20]
    d4ae:	ldr	r0, [sp, #24]
    d4b0:	bl	118a8 <__ssprint_r>
    d4b4:	cmp	r0, #0
    d4b6:	bne.w	cb04 <_svfprintf_r+0x1f4>
    d4ba:	ldr	r4, [sp, #148]	; 0x94
    d4bc:	add.w	r9, sp, #192	; 0xc0
    d4c0:	b.n	ce16 <_svfprintf_r+0x506>
    d4c2:	add	r2, sp, #140	; 0x8c
    d4c4:	ldr	r1, [sp, #20]
    d4c6:	ldr	r0, [sp, #24]
    d4c8:	bl	118a8 <__ssprint_r>
    d4cc:	cmp	r0, #0
    d4ce:	bne.w	cb04 <_svfprintf_r+0x1f4>
    d4d2:	ldr	r4, [sp, #148]	; 0x94
    d4d4:	add.w	r9, sp, #192	; 0xc0
    d4d8:	b.n	cd7c <_svfprintf_r+0x46c>
    d4da:	add	r2, sp, #140	; 0x8c
    d4dc:	ldr	r1, [sp, #20]
    d4de:	ldr	r0, [sp, #24]
    d4e0:	bl	118a8 <__ssprint_r>
    d4e4:	cmp	r0, #0
    d4e6:	bne.w	cb04 <_svfprintf_r+0x1f4>
    d4ea:	ldr	r4, [sp, #148]	; 0x94
    d4ec:	add.w	r9, sp, #192	; 0xc0
    d4f0:	b.n	cd9c <_svfprintf_r+0x48c>
    d4f2:	cmp.w	fp, #0
    d4f6:	strb.w	r7, [sp, #111]	; 0x6f
    d4fa:	blt.w	dabc <_svfprintf_r+0x11ac>
    d4fe:	bic.w	r3, r2, #128	; 0x80
    d502:	str	r3, [sp, #12]
    d504:	orrs.w	r3, r4, r5
    d508:	bne.w	d0b2 <_svfprintf_r+0x7a2>
    d50c:	cmp.w	fp, #0
    d510:	beq.w	d22c <_svfprintf_r+0x91c>
    d514:	movs	r7, #0
    d516:	b.n	d288 <_svfprintf_r+0x978>
    d518:	ldr	r5, [sp, #116]	; 0x74
    d51a:	cmp	r5, #0
    d51c:	ble.w	dac2 <_svfprintf_r+0x11b2>
    d520:	ldr	r3, [sp, #60]	; 0x3c
    d522:	ldr	r2, [sp, #56]	; 0x38
    d524:	cmp	r3, r2
    d526:	it	ge
    d528:	movge	r3, r2
    d52a:	cmp	r3, #0
    d52c:	mov	r5, r3
    d52e:	ble.n	d54c <_svfprintf_r+0xc3c>
    d530:	ldr	r3, [sp, #144]	; 0x90
    d532:	str.w	r6, [r9]
    d536:	adds	r3, #1
    d538:	add	r4, r5
    d53a:	cmp	r3, #7
    d53c:	str	r4, [sp, #148]	; 0x94
    d53e:	str.w	r5, [r9, #4]
    d542:	str	r3, [sp, #144]	; 0x90
    d544:	bgt.w	dc9a <_svfprintf_r+0x138a>
    d548:	add.w	r9, r9, #8
    d54c:	ldr	r3, [sp, #60]	; 0x3c
    d54e:	cmp	r5, #0
    d550:	it	ge
    d552:	subge	r3, r3, r5
    d554:	cmp	r3, #0
    d556:	mov	r5, r3
    d558:	ble.w	d74c <_svfprintf_r+0xe3c>
    d55c:	ldr	r2, [pc, #260]	; (d664 <_svfprintf_r+0xd54>)
    d55e:	ldr	r3, [sp, #144]	; 0x90
    d560:	str	r2, [sp, #44]	; 0x2c
    d562:	cmp	r5, #16
    d564:	ble.w	da6e <_svfprintf_r+0x115e>
    d568:	mov	r2, r4
    d56a:	movs	r7, #16
    d56c:	ldr.w	fp, [sp, #24]
    d570:	ldr	r4, [sp, #20]
    d572:	b.n	d580 <_svfprintf_r+0xc70>
    d574:	add.w	r9, r9, #8
    d578:	subs	r5, #16
    d57a:	cmp	r5, #16
    d57c:	ble.w	da6c <_svfprintf_r+0x115c>
    d580:	adds	r3, #1
    d582:	adds	r2, #16
    d584:	cmp	r3, #7
    d586:	str	r2, [sp, #148]	; 0x94
    d588:	str	r3, [sp, #144]	; 0x90
    d58a:	str.w	sl, [r9]
    d58e:	str.w	r7, [r9, #4]
    d592:	ble.n	d574 <_svfprintf_r+0xc64>
    d594:	add	r2, sp, #140	; 0x8c
    d596:	mov	r1, r4
    d598:	mov	r0, fp
    d59a:	bl	118a8 <__ssprint_r>
    d59e:	cmp	r0, #0
    d5a0:	bne.w	cb04 <_svfprintf_r+0x1f4>
    d5a4:	ldr	r2, [sp, #148]	; 0x94
    d5a6:	ldr	r3, [sp, #144]	; 0x90
    d5a8:	add.w	r9, sp, #192	; 0xc0
    d5ac:	b.n	d578 <_svfprintf_r+0xc68>
    d5ae:	add	r2, sp, #140	; 0x8c
    d5b0:	ldr	r1, [sp, #20]
    d5b2:	ldr	r0, [sp, #24]
    d5b4:	bl	118a8 <__ssprint_r>
    d5b8:	cmp	r0, #0
    d5ba:	bne.w	cb04 <_svfprintf_r+0x1f4>
    d5be:	ldrb.w	r7, [sp, #111]	; 0x6f
    d5c2:	ldr	r4, [sp, #148]	; 0x94
    d5c4:	add.w	r9, sp, #192	; 0xc0
    d5c8:	b.w	cd5c <_svfprintf_r+0x44c>
    d5cc:	subs	r6, r3, #1
    d5ce:	cmp	r6, #0
    d5d0:	ble.w	d464 <_svfprintf_r+0xb54>
    d5d4:	ldr	r3, [pc, #140]	; (d664 <_svfprintf_r+0xd54>)
    d5d6:	str	r3, [sp, #44]	; 0x2c
    d5d8:	cmp	r6, #16
    d5da:	ble.n	d636 <_svfprintf_r+0xd26>
    d5dc:	str.w	r8, [sp, #36]	; 0x24
    d5e0:	movs	r7, #16
    d5e2:	mov	r8, r6
    d5e4:	ldr.w	fp, [sp, #24]
    d5e8:	ldr	r6, [sp, #20]
    d5ea:	b.n	d5fa <_svfprintf_r+0xcea>
    d5ec:	sub.w	r8, r8, #16
    d5f0:	cmp.w	r8, #16
    d5f4:	add.w	r9, r9, #8
    d5f8:	ble.n	d630 <_svfprintf_r+0xd20>
    d5fa:	adds	r5, #1
    d5fc:	adds	r4, #16
    d5fe:	cmp	r5, #7
    d600:	str	r4, [sp, #148]	; 0x94
    d602:	str	r5, [sp, #144]	; 0x90
    d604:	str.w	sl, [r9]
    d608:	str.w	r7, [r9, #4]
    d60c:	ble.n	d5ec <_svfprintf_r+0xcdc>
    d60e:	add	r2, sp, #140	; 0x8c
    d610:	mov	r1, r6
    d612:	mov	r0, fp
    d614:	bl	118a8 <__ssprint_r>
    d618:	cmp	r0, #0
    d61a:	bne.w	cb04 <_svfprintf_r+0x1f4>
    d61e:	sub.w	r8, r8, #16
    d622:	cmp.w	r8, #16
    d626:	ldr	r4, [sp, #148]	; 0x94
    d628:	ldr	r5, [sp, #144]	; 0x90
    d62a:	add.w	r9, sp, #192	; 0xc0
    d62e:	bgt.n	d5fa <_svfprintf_r+0xcea>
    d630:	mov	r6, r8
    d632:	ldr.w	r8, [sp, #36]	; 0x24
    d636:	ldr	r3, [sp, #44]	; 0x2c
    d638:	adds	r5, #1
    d63a:	add	r4, r6
    d63c:	cmp	r5, #7
    d63e:	str	r4, [sp, #148]	; 0x94
    d640:	str	r5, [sp, #144]	; 0x90
    d642:	stmia.w	r9, {r3, r6}
    d646:	ble.w	d460 <_svfprintf_r+0xb50>
    d64a:	add	r2, sp, #140	; 0x8c
    d64c:	ldr	r1, [sp, #20]
    d64e:	ldr	r0, [sp, #24]
    d650:	bl	118a8 <__ssprint_r>
    d654:	cmp	r0, #0
    d656:	bne.w	cb04 <_svfprintf_r+0x1f4>
    d65a:	ldr	r4, [sp, #148]	; 0x94
    d65c:	ldr	r5, [sp, #144]	; 0x90
    d65e:	add.w	r9, sp, #192	; 0xc0
    d662:	b.n	d464 <_svfprintf_r+0xb54>
    d664:	.word	0x00012918
    d668:	ldr	r1, [sp, #12]
    d66a:	ands.w	r2, r1, #16
    d66e:	beq.w	da18 <_svfprintf_r+0x1108>
    d672:	ldr	r0, [sp, #40]	; 0x28
    d674:	strb.w	r3, [sp, #111]	; 0x6f
    d678:	cmp.w	fp, #0
    d67c:	ldr	r4, [r0, #0]
    d67e:	add.w	r7, r0, #4
    d682:	mov.w	r5, #0
    d686:	blt.n	d6d6 <_svfprintf_r+0xdc6>
    d688:	mov	r2, r1
    d68a:	bic.w	r2, r2, #128	; 0x80
    d68e:	str	r2, [sp, #12]
    d690:	orrs.w	r2, r4, r5
    d694:	str	r7, [sp, #40]	; 0x28
    d696:	mov	r7, r3
    d698:	bne.w	cc6c <_svfprintf_r+0x35c>
    d69c:	b.n	d03c <_svfprintf_r+0x72c>
    d69e:	ldr	r3, [sp, #12]
    d6a0:	lsls	r0, r3, #27
    d6a2:	bmi.n	d6fa <_svfprintf_r+0xdea>
    d6a4:	ldr	r3, [sp, #12]
    d6a6:	lsls	r1, r3, #25
    d6a8:	bpl.n	d6fa <_svfprintf_r+0xdea>
    d6aa:	ldr	r1, [sp, #40]	; 0x28
    d6ac:	ldrsh.w	r4, [r1]
    d6b0:	adds	r1, #4
    d6b2:	asrs	r5, r4, #31
    d6b4:	mov	r2, r4
    d6b6:	mov	r3, r5
    d6b8:	str	r1, [sp, #40]	; 0x28
    d6ba:	b.w	cc46 <_svfprintf_r+0x336>
    d6be:	ldr	r1, [sp, #40]	; 0x28
    d6c0:	strb.w	r3, [sp, #111]	; 0x6f
    d6c4:	cmp.w	fp, #0
    d6c8:	ldr	r4, [r1, #0]
    d6ca:	add.w	r7, r1, #4
    d6ce:	mov.w	r5, #0
    d6d2:	bge.w	db6e <_svfprintf_r+0x125e>
    d6d6:	str	r7, [sp, #40]	; 0x28
    d6d8:	mov	r7, r3
    d6da:	orrs.w	r3, r4, r5
    d6de:	bne.w	cc6c <_svfprintf_r+0x35c>
    d6e2:	b.n	d046 <_svfprintf_r+0x736>
    d6e4:	adds	r3, #1
    d6e6:	ldr	r2, [sp, #44]	; 0x2c
    d6e8:	str	r3, [sp, #144]	; 0x90
    d6ea:	add	r4, r5
    d6ec:	cmp	r3, #7
    d6ee:	str	r4, [sp, #148]	; 0x94
    d6f0:	stmia.w	r9, {r2, r5}
    d6f4:	ble.w	ce38 <_svfprintf_r+0x528>
    d6f8:	b.n	d47e <_svfprintf_r+0xb6e>
    d6fa:	ldr	r2, [sp, #40]	; 0x28
    d6fc:	ldr	r4, [r2, #0]
    d6fe:	mov	r3, r2
    d700:	adds	r3, #4
    d702:	asrs	r5, r4, #31
    d704:	mov	r2, r4
    d706:	str	r3, [sp, #40]	; 0x28
    d708:	cmp	r2, #0
    d70a:	mov	r3, r5
    d70c:	sbcs.w	r3, r3, #0
    d710:	bge.w	cc50 <_svfprintf_r+0x340>
    d714:	negs	r4, r4
    d716:	mov.w	r7, #45	; 0x2d
    d71a:	sbc.w	r5, r5, r5, lsl #1
    d71e:	cmp.w	fp, #0
    d722:	strb.w	r7, [sp, #111]	; 0x6f
    d726:	blt.w	cc6c <_svfprintf_r+0x35c>
    d72a:	ldr	r3, [sp, #12]
    d72c:	bic.w	r3, r3, #128	; 0x80
    d730:	str	r3, [sp, #12]
    d732:	b.w	cc6c <_svfprintf_r+0x35c>
    d736:	add	r2, sp, #140	; 0x8c
    d738:	ldr	r1, [sp, #20]
    d73a:	ldr	r0, [sp, #24]
    d73c:	bl	118a8 <__ssprint_r>
    d740:	cmp	r0, #0
    d742:	bne.w	cb04 <_svfprintf_r+0x1f4>
    d746:	ldr	r4, [sp, #148]	; 0x94
    d748:	add.w	r9, sp, #192	; 0xc0
    d74c:	ldr	r2, [sp, #60]	; 0x3c
    d74e:	ldr	r3, [sp, #116]	; 0x74
    d750:	add	r2, r6
    d752:	mov	r7, r2
    d754:	ldr	r2, [sp, #56]	; 0x38
    d756:	cmp	r3, r2
    d758:	blt.n	d7ea <_svfprintf_r+0xeda>
    d75a:	ldr	r2, [sp, #12]
    d75c:	lsls	r5, r2, #31
    d75e:	bmi.n	d7ea <_svfprintf_r+0xeda>
    d760:	ldr	r1, [sp, #56]	; 0x38
    d762:	add	r6, r1
    d764:	subs	r5, r6, r7
    d766:	subs	r3, r1, r3
    d768:	cmp	r5, r3
    d76a:	it	ge
    d76c:	movge	r5, r3
    d76e:	cmp	r5, #0
    d770:	mov	r6, r5
    d772:	ble.n	d790 <_svfprintf_r+0xe80>
    d774:	ldr	r2, [sp, #144]	; 0x90
    d776:	str.w	r7, [r9]
    d77a:	adds	r2, #1
    d77c:	add	r4, r5
    d77e:	cmp	r2, #7
    d780:	str	r4, [sp, #148]	; 0x94
    d782:	str.w	r5, [r9, #4]
    d786:	str	r2, [sp, #144]	; 0x90
    d788:	bgt.w	dd88 <_svfprintf_r+0x1478>
    d78c:	add.w	r9, r9, #8
    d790:	cmp	r6, #0
    d792:	ite	ge
    d794:	subge	r5, r3, r6
    d796:	movlt	r5, r3
    d798:	cmp	r5, #0
    d79a:	ble.w	ce3c <_svfprintf_r+0x52c>
    d79e:	ldr	r2, [pc, #744]	; (da88 <_svfprintf_r+0x1178>)
    d7a0:	ldr	r3, [sp, #144]	; 0x90
    d7a2:	str	r2, [sp, #44]	; 0x2c
    d7a4:	cmp	r5, #16
    d7a6:	ble.n	d6e4 <_svfprintf_r+0xdd4>
    d7a8:	movs	r6, #16
    d7aa:	ldr	r7, [sp, #24]
    d7ac:	ldr.w	fp, [sp, #20]
    d7b0:	b.n	d7bc <_svfprintf_r+0xeac>
    d7b2:	add.w	r9, r9, #8
    d7b6:	subs	r5, #16
    d7b8:	cmp	r5, #16
    d7ba:	ble.n	d6e4 <_svfprintf_r+0xdd4>
    d7bc:	adds	r3, #1
    d7be:	adds	r4, #16
    d7c0:	cmp	r3, #7
    d7c2:	str	r4, [sp, #148]	; 0x94
    d7c4:	str	r3, [sp, #144]	; 0x90
    d7c6:	str.w	sl, [r9]
    d7ca:	str.w	r6, [r9, #4]
    d7ce:	ble.n	d7b2 <_svfprintf_r+0xea2>
    d7d0:	add	r2, sp, #140	; 0x8c
    d7d2:	mov	r1, fp
    d7d4:	mov	r0, r7
    d7d6:	bl	118a8 <__ssprint_r>
    d7da:	cmp	r0, #0
    d7dc:	bne.w	cb04 <_svfprintf_r+0x1f4>
    d7e0:	ldr	r4, [sp, #148]	; 0x94
    d7e2:	ldr	r3, [sp, #144]	; 0x90
    d7e4:	add.w	r9, sp, #192	; 0xc0
    d7e8:	b.n	d7b6 <_svfprintf_r+0xea6>
    d7ea:	ldr	r2, [sp, #144]	; 0x90
    d7ec:	ldr	r0, [sp, #72]	; 0x48
    d7ee:	ldr	r1, [sp, #76]	; 0x4c
    d7f0:	str.w	r1, [r9]
    d7f4:	adds	r2, #1
    d7f6:	add	r4, r0
    d7f8:	cmp	r2, #7
    d7fa:	str	r4, [sp, #148]	; 0x94
    d7fc:	str.w	r0, [r9, #4]
    d800:	str	r2, [sp, #144]	; 0x90
    d802:	bgt.w	dd6e <_svfprintf_r+0x145e>
    d806:	add.w	r9, r9, #8
    d80a:	b.n	d760 <_svfprintf_r+0xe50>
    d80c:	ldr	r3, [sp, #12]
    d80e:	lsls	r0, r3, #31
    d810:	bmi.w	d3f8 <_svfprintf_r+0xae8>
    d814:	adds	r5, #1
    d816:	adds	r4, #1
    d818:	movs	r3, #1
    d81a:	cmp	r5, #7
    d81c:	str	r4, [sp, #148]	; 0x94
    d81e:	str	r5, [sp, #144]	; 0x90
    d820:	str.w	r6, [r9]
    d824:	str.w	r3, [r9, #4]
    d828:	ble.w	d460 <_svfprintf_r+0xb50>
    d82c:	b.n	d64a <_svfprintf_r+0xd3a>
    d82e:	add	r2, sp, #140	; 0x8c
    d830:	ldr	r1, [sp, #20]
    d832:	ldr	r0, [sp, #24]
    d834:	bl	118a8 <__ssprint_r>
    d838:	cmp	r0, #0
    d83a:	bne.w	cb04 <_svfprintf_r+0x1f4>
    d83e:	ldr	r4, [sp, #148]	; 0x94
    d840:	ldr	r5, [sp, #144]	; 0x90
    d842:	add.w	r9, sp, #192	; 0xc0
    d846:	b.n	d414 <_svfprintf_r+0xb04>
    d848:	add	r2, sp, #140	; 0x8c
    d84a:	ldr	r1, [sp, #20]
    d84c:	ldr	r0, [sp, #24]
    d84e:	bl	118a8 <__ssprint_r>
    d852:	cmp	r0, #0
    d854:	bne.w	cb04 <_svfprintf_r+0x1f4>
    d858:	ldr	r4, [sp, #148]	; 0x94
    d85a:	ldr	r5, [sp, #144]	; 0x90
    d85c:	add.w	r9, sp, #192	; 0xc0
    d860:	b.n	d432 <_svfprintf_r+0xb22>
    d862:	add	r2, sp, #140	; 0x8c
    d864:	ldr	r1, [sp, #20]
    d866:	ldr	r0, [sp, #24]
    d868:	bl	118a8 <__ssprint_r>
    d86c:	cmp	r0, #0
    d86e:	bne.w	cb04 <_svfprintf_r+0x1f4>
    d872:	ldr	r4, [sp, #148]	; 0x94
    d874:	add.w	r9, sp, #192	; 0xc0
    d878:	b.w	cda4 <_svfprintf_r+0x494>
    d87c:	ldr	r1, [sp, #12]
    d87e:	ands.w	r3, r1, #64	; 0x40
    d882:	beq.w	d9f8 <_svfprintf_r+0x10e8>
    d886:	ldr	r0, [sp, #40]	; 0x28
    d888:	strb.w	r2, [sp, #111]	; 0x6f
    d88c:	mov	r3, r0
    d88e:	cmp.w	fp, #0
    d892:	add.w	r3, r3, #4
    d896:	ldrh	r4, [r0, #0]
    d898:	mov.w	r5, #0
    d89c:	blt.w	dc20 <_svfprintf_r+0x1310>
    d8a0:	bic.w	r1, r1, #128	; 0x80
    d8a4:	str	r1, [sp, #12]
    d8a6:	orrs.w	r1, r4, r5
    d8aa:	str	r3, [sp, #40]	; 0x28
    d8ac:	beq.w	d264 <_svfprintf_r+0x954>
    d8b0:	mov	r7, r2
    d8b2:	b.w	cb5c <_svfprintf_r+0x24c>
    d8b6:	ldr	r3, [sp, #12]
    d8b8:	lsls	r7, r3, #27
    d8ba:	bmi.n	d8d4 <_svfprintf_r+0xfc4>
    d8bc:	ldr	r3, [sp, #12]
    d8be:	lsls	r6, r3, #25
    d8c0:	bpl.n	d8d4 <_svfprintf_r+0xfc4>
    d8c2:	ldr	r2, [sp, #40]	; 0x28
    d8c4:	ldr	r3, [r2, #0]
    d8c6:	adds	r2, #4
    d8c8:	str	r2, [sp, #40]	; 0x28
    d8ca:	ldrh.w	r2, [sp, #28]
    d8ce:	strh	r2, [r3, #0]
    d8d0:	b.w	c95e <_svfprintf_r+0x4e>
    d8d4:	ldr	r2, [sp, #40]	; 0x28
    d8d6:	ldr	r3, [r2, #0]
    d8d8:	adds	r2, #4
    d8da:	str	r2, [sp, #40]	; 0x28
    d8dc:	ldr	r2, [sp, #28]
    d8de:	str	r2, [r3, #0]
    d8e0:	b.w	c95e <_svfprintf_r+0x4e>
    d8e4:	ldrd	r0, r1, [sp, #64]	; 0x40
    d8e8:	mov	r2, r0
    d8ea:	mov	r3, r1
    d8ec:	bl	a590 <__aeabi_dcmpun>
    d8f0:	cmp	r0, #0
    d8f2:	bne.w	def0 <_svfprintf_r+0x15e0>
    d8f6:	ldr	r3, [sp, #52]	; 0x34
    d8f8:	cmp.w	fp, #4294967295
    d8fc:	bic.w	r7, r3, #32
    d900:	beq.w	ddd2 <_svfprintf_r+0x14c2>
    d904:	cmp	r7, #71	; 0x47
    d906:	beq.w	dc0e <_svfprintf_r+0x12fe>
    d90a:	ldr	r3, [sp, #68]	; 0x44
    d90c:	ldr	r2, [sp, #12]
    d90e:	cmp	r3, #0
    d910:	orr.w	r2, r2, #256	; 0x100
    d914:	str	r2, [sp, #44]	; 0x2c
    d916:	blt.w	de0a <_svfprintf_r+0x14fa>
    d91a:	vldr	d7, [sp, #64]	; 0x40
    d91e:	vstr	d7, [sp, #96]	; 0x60
    d922:	movs	r3, #0
    d924:	str	r3, [sp, #16]
    d926:	ldr	r3, [sp, #52]	; 0x34
    d928:	cmp	r3, #102	; 0x66
    d92a:	beq.w	ddd8 <_svfprintf_r+0x14c8>
    d92e:	cmp	r3, #70	; 0x46
    d930:	beq.w	dbbe <_svfprintf_r+0x12ae>
    d934:	cmp	r7, #69	; 0x45
    d936:	ite	eq
    d938:	addeq.w	r5, fp, #1
    d93c:	movne	r5, fp
    d93e:	add	r2, sp, #132	; 0x84
    d940:	add	r3, sp, #120	; 0x78
    d942:	str	r2, [sp, #4]
    d944:	str	r3, [sp, #0]
    d946:	mov	r2, r5
    d948:	add	r3, sp, #116	; 0x74
    d94a:	movs	r1, #2
    d94c:	vldr	d0, [sp, #96]	; 0x60
    d950:	ldr	r0, [sp, #24]
    d952:	bl	f118 <_dtoa_r>
    d956:	ldr	r3, [sp, #52]	; 0x34
    d958:	cmp	r3, #103	; 0x67
    d95a:	mov	r6, r0
    d95c:	bne.w	de36 <_svfprintf_r+0x1526>
    d960:	ldr	r3, [sp, #12]
    d962:	lsls	r2, r3, #31
    d964:	bpl.w	deda <_svfprintf_r+0x15ca>
    d968:	adds	r4, r6, r5
    d96a:	movs	r2, #0
    d96c:	movs	r3, #0
    d96e:	ldrd	r0, r1, [sp, #96]	; 0x60
    d972:	bl	a52c <__aeabi_dcmpeq>
    d976:	cmp	r0, #0
    d978:	bne.w	dc96 <_svfprintf_r+0x1386>
    d97c:	ldr	r3, [sp, #132]	; 0x84
    d97e:	cmp	r4, r3
    d980:	bls.n	d990 <_svfprintf_r+0x1080>
    d982:	movs	r1, #48	; 0x30
    d984:	adds	r2, r3, #1
    d986:	str	r2, [sp, #132]	; 0x84
    d988:	strb	r1, [r3, #0]
    d98a:	ldr	r3, [sp, #132]	; 0x84
    d98c:	cmp	r4, r3
    d98e:	bhi.n	d984 <_svfprintf_r+0x1074>
    d990:	subs	r3, r3, r6
    d992:	cmp	r7, #71	; 0x47
    d994:	str	r3, [sp, #56]	; 0x38
    d996:	beq.w	dc88 <_svfprintf_r+0x1378>
    d99a:	ldr	r3, [sp, #52]	; 0x34
    d99c:	cmp	r3, #101	; 0x65
    d99e:	ble.w	de54 <_svfprintf_r+0x1544>
    d9a2:	ldr	r3, [sp, #52]	; 0x34
    d9a4:	cmp	r3, #102	; 0x66
    d9a6:	ldr	r3, [sp, #116]	; 0x74
    d9a8:	str	r3, [sp, #60]	; 0x3c
    d9aa:	beq.w	de6e <_svfprintf_r+0x155e>
    d9ae:	ldr	r2, [sp, #60]	; 0x3c
    d9b0:	ldr	r1, [sp, #56]	; 0x38
    d9b2:	cmp	r2, r1
    d9b4:	blt.w	de1c <_svfprintf_r+0x150c>
    d9b8:	ldr	r3, [sp, #12]
    d9ba:	lsls	r1, r3, #31
    d9bc:	bmi.w	dede <_svfprintf_r+0x15ce>
    d9c0:	bic.w	r3, r2, r2, asr #31
    d9c4:	str	r2, [sp, #36]	; 0x24
    d9c6:	movs	r2, #103	; 0x67
    d9c8:	str	r2, [sp, #52]	; 0x34
    d9ca:	ldr	r2, [sp, #16]
    d9cc:	cmp	r2, #0
    d9ce:	bne.w	dc30 <_svfprintf_r+0x1320>
    d9d2:	str	r3, [sp, #16]
    d9d4:	ldr	r3, [sp, #44]	; 0x2c
    d9d6:	str	r3, [sp, #12]
    d9d8:	mov	fp, r2
    d9da:	ldrb.w	r7, [sp, #111]	; 0x6f
    d9de:	b.w	ccb4 <_svfprintf_r+0x3a4>
    d9e2:	bic.w	r7, r7, #7
    d9e6:	vldr	d7, [r7]
    d9ea:	add.w	r3, r7, #8
    d9ee:	vstr	d7, [sp, #64]	; 0x40
    d9f2:	str	r3, [sp, #40]	; 0x28
    d9f4:	b.w	cf0c <_svfprintf_r+0x5fc>
    d9f8:	ldr	r1, [sp, #40]	; 0x28
    d9fa:	strb.w	r3, [sp, #111]	; 0x6f
    d9fe:	cmp.w	fp, #0
    da02:	ldr	r4, [r1, #0]
    da04:	add.w	r7, r1, #4
    da08:	mov.w	r5, #0
    da0c:	bge.w	db68 <_svfprintf_r+0x1258>
    da10:	str	r7, [sp, #40]	; 0x28
    da12:	movs	r7, #0
    da14:	b.w	cb5c <_svfprintf_r+0x24c>
    da18:	ldr	r1, [sp, #12]
    da1a:	ands.w	r3, r1, #64	; 0x40
    da1e:	beq.w	d6be <_svfprintf_r+0xdae>
    da22:	ldr	r0, [sp, #40]	; 0x28
    da24:	strb.w	r2, [sp, #111]	; 0x6f
    da28:	mov	r3, r0
    da2a:	cmp.w	fp, #0
    da2e:	add.w	r3, r3, #4
    da32:	ldrh	r4, [r0, #0]
    da34:	mov.w	r5, #0
    da38:	blt.w	dc1a <_svfprintf_r+0x130a>
    da3c:	bic.w	r1, r1, #128	; 0x80
    da40:	str	r1, [sp, #12]
    da42:	orrs.w	r1, r4, r5
    da46:	str	r3, [sp, #40]	; 0x28
    da48:	mov	r7, r2
    da4a:	bne.w	cc6c <_svfprintf_r+0x35c>
    da4e:	b.w	d03c <_svfprintf_r+0x72c>
    da52:	ldr	r3, [sp, #12]
    da54:	ldr	r2, [sp, #40]	; 0x28
    da56:	tst.w	r3, #64	; 0x40
    da5a:	mov	r3, r2
    da5c:	beq.w	dc24 <_svfprintf_r+0x1314>
    da60:	adds	r3, #4
    da62:	ldrh	r4, [r2, #0]
    da64:	str	r3, [sp, #40]	; 0x28
    da66:	movs	r5, #0
    da68:	b.w	d076 <_svfprintf_r+0x766>
    da6c:	mov	r4, r2
    da6e:	adds	r3, #1
    da70:	ldr	r2, [sp, #44]	; 0x2c
    da72:	str	r3, [sp, #144]	; 0x90
    da74:	add	r4, r5
    da76:	cmp	r3, #7
    da78:	str	r4, [sp, #148]	; 0x94
    da7a:	stmia.w	r9, {r2, r5}
    da7e:	bgt.w	d736 <_svfprintf_r+0xe26>
    da82:	add.w	r9, r9, #8
    da86:	b.n	d74c <_svfprintf_r+0xe3c>
    da88:	.word	0x00012918
    da8c:	movs	r7, #0
    da8e:	cmp	fp, r7
    da90:	strb.w	r7, [sp, #111]	; 0x6f
    da94:	blt.w	d288 <_svfprintf_r+0x978>
    da98:	ldr	r3, [sp, #12]
    da9a:	bic.w	r3, r3, #128	; 0x80
    da9e:	str	r3, [sp, #12]
    daa0:	b.w	d224 <_svfprintf_r+0x914>
    daa4:	add	r2, sp, #140	; 0x8c
    daa6:	ldr	r1, [sp, #20]
    daa8:	ldr	r0, [sp, #24]
    daaa:	bl	118a8 <__ssprint_r>
    daae:	cmp	r0, #0
    dab0:	bne.w	cb04 <_svfprintf_r+0x1f4>
    dab4:	ldr	r4, [sp, #148]	; 0x94
    dab6:	add.w	r9, sp, #192	; 0xc0
    daba:	b.n	d2cc <_svfprintf_r+0x9bc>
    dabc:	ldr	r7, [sp, #40]	; 0x28
    dabe:	b.w	d27a <_svfprintf_r+0x96a>
    dac2:	ldr	r3, [sp, #144]	; 0x90
    dac4:	ldr	r2, [pc, #736]	; (dda8 <_svfprintf_r+0x1498>)
    dac6:	str.w	r2, [r9]
    daca:	adds	r3, #1
    dacc:	adds	r4, #1
    dace:	movs	r2, #1
    dad0:	cmp	r3, #7
    dad2:	str	r4, [sp, #148]	; 0x94
    dad4:	str	r3, [sp, #144]	; 0x90
    dad6:	str.w	r2, [r9, #4]
    dada:	bgt.w	dbf4 <_svfprintf_r+0x12e4>
    dade:	add.w	r9, r9, #8
    dae2:	cbnz	r5, daf0 <_svfprintf_r+0x11e0>
    dae4:	ldr	r3, [sp, #56]	; 0x38
    dae6:	cbnz	r3, daf0 <_svfprintf_r+0x11e0>
    dae8:	ldr	r3, [sp, #12]
    daea:	lsls	r7, r3, #31
    daec:	bpl.w	ce3c <_svfprintf_r+0x52c>
    daf0:	ldr	r3, [sp, #144]	; 0x90
    daf2:	ldr	r1, [sp, #72]	; 0x48
    daf4:	ldr	r2, [sp, #76]	; 0x4c
    daf6:	str.w	r2, [r9]
    dafa:	adds	r3, #1
    dafc:	add	r4, r1
    dafe:	cmp	r3, #7
    db00:	str	r4, [sp, #148]	; 0x94
    db02:	str.w	r1, [r9, #4]
    db06:	str	r3, [sp, #144]	; 0x90
    db08:	bgt.w	dea6 <_svfprintf_r+0x1596>
    db0c:	add.w	r9, r9, #8
    db10:	negs	r5, r5
    db12:	cmp	r5, #0
    db14:	ble.w	dc6c <_svfprintf_r+0x135c>
    db18:	ldr	r2, [pc, #656]	; (ddac <_svfprintf_r+0x149c>)
    db1a:	str	r2, [sp, #44]	; 0x2c
    db1c:	cmp	r5, #16
    db1e:	ble.w	dcb4 <_svfprintf_r+0x13a4>
    db22:	mov	r2, r4
    db24:	movs	r7, #16
    db26:	ldr.w	fp, [sp, #24]
    db2a:	ldr	r4, [sp, #20]
    db2c:	b.n	db3a <_svfprintf_r+0x122a>
    db2e:	add.w	r9, r9, #8
    db32:	subs	r5, #16
    db34:	cmp	r5, #16
    db36:	ble.w	dcb2 <_svfprintf_r+0x13a2>
    db3a:	adds	r3, #1
    db3c:	adds	r2, #16
    db3e:	cmp	r3, #7
    db40:	str	r2, [sp, #148]	; 0x94
    db42:	str	r3, [sp, #144]	; 0x90
    db44:	str.w	sl, [r9]
    db48:	str.w	r7, [r9, #4]
    db4c:	ble.n	db2e <_svfprintf_r+0x121e>
    db4e:	add	r2, sp, #140	; 0x8c
    db50:	mov	r1, r4
    db52:	mov	r0, fp
    db54:	bl	118a8 <__ssprint_r>
    db58:	cmp	r0, #0
    db5a:	bne.w	cb04 <_svfprintf_r+0x1f4>
    db5e:	ldr	r2, [sp, #148]	; 0x94
    db60:	ldr	r3, [sp, #144]	; 0x90
    db62:	add.w	r9, sp, #192	; 0xc0
    db66:	b.n	db32 <_svfprintf_r+0x1222>
    db68:	ldr	r2, [sp, #12]
    db6a:	b.w	cfe0 <_svfprintf_r+0x6d0>
    db6e:	ldr	r2, [sp, #12]
    db70:	b.n	d68a <_svfprintf_r+0xd7a>
    db72:	ldr	r3, [sp, #12]
    db74:	orr.w	r3, r3, #32
    db78:	str	r3, [sp, #12]
    db7a:	add.w	r8, r8, #1
    db7e:	ldrb.w	r3, [r8]
    db82:	b.w	c9c4 <_svfprintf_r+0xb4>
    db86:	add	r2, sp, #140	; 0x8c
    db88:	ldr	r1, [sp, #20]
    db8a:	ldr	r0, [sp, #24]
    db8c:	bl	118a8 <__ssprint_r>
    db90:	cmp	r0, #0
    db92:	bne.w	cb04 <_svfprintf_r+0x1f4>
    db96:	ldr	r4, [sp, #148]	; 0x94
    db98:	add.w	r9, sp, #192	; 0xc0
    db9c:	b.w	d2fc <_svfprintf_r+0x9ec>
    dba0:	movs	r1, #64	; 0x40
    dba2:	ldr	r0, [sp, #24]
    dba4:	bl	aadc <_malloc_r>
    dba8:	ldr	r2, [sp, #20]
    dbaa:	str	r0, [r2, #0]
    dbac:	str	r0, [r2, #16]
    dbae:	cmp	r0, #0
    dbb0:	beq.w	df9a <_svfprintf_r+0x168a>
    dbb4:	ldr	r2, [sp, #20]
    dbb6:	movs	r3, #64	; 0x40
    dbb8:	str	r3, [r2, #20]
    dbba:	b.w	c93e <_svfprintf_r+0x2e>
    dbbe:	add	r2, sp, #132	; 0x84
    dbc0:	add	r3, sp, #120	; 0x78
    dbc2:	str	r2, [sp, #4]
    dbc4:	str	r3, [sp, #0]
    dbc6:	mov	r2, fp
    dbc8:	add	r3, sp, #116	; 0x74
    dbca:	movs	r1, #3
    dbcc:	vldr	d0, [sp, #96]	; 0x60
    dbd0:	ldr	r0, [sp, #24]
    dbd2:	bl	f118 <_dtoa_r>
    dbd6:	mov	r5, fp
    dbd8:	mov	r6, r0
    dbda:	ldr	r3, [sp, #52]	; 0x34
    dbdc:	cmp	r3, #70	; 0x46
    dbde:	add.w	r4, r6, r5
    dbe2:	bne.w	d96a <_svfprintf_r+0x105a>
    dbe6:	ldrb	r3, [r6, #0]
    dbe8:	cmp	r3, #48	; 0x30
    dbea:	beq.w	defc <_svfprintf_r+0x15ec>
    dbee:	ldr	r5, [sp, #116]	; 0x74
    dbf0:	add	r4, r5
    dbf2:	b.n	d96a <_svfprintf_r+0x105a>
    dbf4:	add	r2, sp, #140	; 0x8c
    dbf6:	ldr	r1, [sp, #20]
    dbf8:	ldr	r0, [sp, #24]
    dbfa:	bl	118a8 <__ssprint_r>
    dbfe:	cmp	r0, #0
    dc00:	bne.w	cb04 <_svfprintf_r+0x1f4>
    dc04:	ldr	r5, [sp, #116]	; 0x74
    dc06:	ldr	r4, [sp, #148]	; 0x94
    dc08:	add.w	r9, sp, #192	; 0xc0
    dc0c:	b.n	dae2 <_svfprintf_r+0x11d2>
    dc0e:	cmp.w	fp, #0
    dc12:	it	eq
    dc14:	moveq.w	fp, #1
    dc18:	b.n	d90a <_svfprintf_r+0xffa>
    dc1a:	str	r3, [sp, #40]	; 0x28
    dc1c:	mov	r7, r2
    dc1e:	b.n	d6da <_svfprintf_r+0xdca>
    dc20:	str	r3, [sp, #40]	; 0x28
    dc22:	b.n	da12 <_svfprintf_r+0x1102>
    dc24:	adds	r3, #4
    dc26:	ldr	r4, [r2, #0]
    dc28:	str	r3, [sp, #40]	; 0x28
    dc2a:	movs	r5, #0
    dc2c:	b.w	d076 <_svfprintf_r+0x766>
    dc30:	movs	r7, #45	; 0x2d
    dc32:	str	r3, [sp, #16]
    dc34:	ldr	r3, [sp, #44]	; 0x2c
    dc36:	str	r3, [sp, #12]
    dc38:	strb.w	r7, [sp, #111]	; 0x6f
    dc3c:	mov.w	fp, #0
    dc40:	b.w	ccb6 <_svfprintf_r+0x3a6>
    dc44:	mov	r0, r6
    dc46:	bl	b700 <strlen>
    dc4a:	mov	fp, r4
    dc4c:	mov	r3, r0
    dc4e:	str	r0, [sp, #36]	; 0x24
    dc50:	b.w	d198 <_svfprintf_r+0x888>
    dc54:	add	r2, sp, #140	; 0x8c
    dc56:	ldr	r1, [sp, #20]
    dc58:	ldr	r0, [sp, #24]
    dc5a:	bl	118a8 <__ssprint_r>
    dc5e:	cmp	r0, #0
    dc60:	bne.w	cb04 <_svfprintf_r+0x1f4>
    dc64:	ldr	r4, [sp, #148]	; 0x94
    dc66:	ldr	r3, [sp, #144]	; 0x90
    dc68:	add.w	r9, sp, #192	; 0xc0
    dc6c:	ldr	r1, [sp, #56]	; 0x38
    dc6e:	str.w	r6, [r9]
    dc72:	adds	r3, #1
    dc74:	add	r4, r1
    dc76:	cmp	r3, #7
    dc78:	str	r4, [sp, #148]	; 0x94
    dc7a:	str	r3, [sp, #144]	; 0x90
    dc7c:	str.w	r1, [r9, #4]
    dc80:	ble.w	ce38 <_svfprintf_r+0x528>
    dc84:	b.w	d47e <_svfprintf_r+0xb6e>
    dc88:	ldr	r3, [sp, #116]	; 0x74
    dc8a:	adds	r5, r3, #3
    dc8c:	blt.n	dccc <_svfprintf_r+0x13bc>
    dc8e:	cmp	fp, r3
    dc90:	blt.n	dccc <_svfprintf_r+0x13bc>
    dc92:	str	r3, [sp, #60]	; 0x3c
    dc94:	b.n	d9ae <_svfprintf_r+0x109e>
    dc96:	mov	r3, r4
    dc98:	b.n	d990 <_svfprintf_r+0x1080>
    dc9a:	add	r2, sp, #140	; 0x8c
    dc9c:	ldr	r1, [sp, #20]
    dc9e:	ldr	r0, [sp, #24]
    dca0:	bl	118a8 <__ssprint_r>
    dca4:	cmp	r0, #0
    dca6:	bne.w	cb04 <_svfprintf_r+0x1f4>
    dcaa:	ldr	r4, [sp, #148]	; 0x94
    dcac:	add.w	r9, sp, #192	; 0xc0
    dcb0:	b.n	d54c <_svfprintf_r+0xc3c>
    dcb2:	mov	r4, r2
    dcb4:	adds	r3, #1
    dcb6:	ldr	r2, [sp, #44]	; 0x2c
    dcb8:	str	r3, [sp, #144]	; 0x90
    dcba:	add	r4, r5
    dcbc:	cmp	r3, #7
    dcbe:	str	r4, [sp, #148]	; 0x94
    dcc0:	stmia.w	r9, {r2, r5}
    dcc4:	bgt.n	dc54 <_svfprintf_r+0x1344>
    dcc6:	add.w	r9, r9, #8
    dcca:	b.n	dc6c <_svfprintf_r+0x135c>
    dccc:	ldr	r2, [sp, #52]	; 0x34
    dcce:	subs	r2, #2
    dcd0:	str	r2, [sp, #52]	; 0x34
    dcd2:	subs	r3, #1
    dcd4:	cmp	r3, #0
    dcd6:	ldrb.w	r2, [sp, #52]	; 0x34
    dcda:	str	r3, [sp, #116]	; 0x74
    dcdc:	it	lt
    dcde:	neglt	r3, r3
    dce0:	strb.w	r2, [sp, #124]	; 0x7c
    dce4:	ite	lt
    dce6:	movlt	r2, #45	; 0x2d
    dce8:	movge	r2, #43	; 0x2b
    dcea:	cmp	r3, #9
    dcec:	strb.w	r2, [sp, #125]	; 0x7d
    dcf0:	ble.w	deca <_svfprintf_r+0x15ba>
    dcf4:	add.w	r0, sp, #139	; 0x8b
    dcf8:	mov	r4, r0
    dcfa:	ldr	r2, [pc, #180]	; (ddb0 <_svfprintf_r+0x14a0>)
    dcfc:	smull	r2, r1, r2, r3
    dd00:	asrs	r2, r3, #31
    dd02:	rsb	r2, r2, r1, asr #2
    dd06:	add.w	r1, r2, r2, lsl #2
    dd0a:	sub.w	r3, r3, r1, lsl #1
    dd0e:	add.w	r1, r3, #48	; 0x30
    dd12:	cmp	r2, #9
    dd14:	mov	r3, r2
    dd16:	strb.w	r1, [r4, #-1]!
    dd1a:	bgt.n	dcfa <_svfprintf_r+0x13ea>
    dd1c:	mov	r1, r4
    dd1e:	adds	r3, #48	; 0x30
    dd20:	uxtb	r2, r3
    dd22:	strb.w	r2, [r1, #-1]!
    dd26:	cmp	r0, r1
    dd28:	bls.w	df94 <_svfprintf_r+0x1684>
    dd2c:	add.w	r1, sp, #126	; 0x7e
    dd30:	mov	r3, r4
    dd32:	b.n	dd38 <_svfprintf_r+0x1428>
    dd34:	ldrb.w	r2, [r3], #1
    dd38:	strb.w	r2, [r1], #1
    dd3c:	cmp	r0, r3
    dd3e:	bne.n	dd34 <_svfprintf_r+0x1424>
    dd40:	adds	r3, r0, #1
    dd42:	subs	r3, r3, r4
    dd44:	add.w	r2, sp, #126	; 0x7e
    dd48:	add	r3, r2
    dd4a:	add	r2, sp, #124	; 0x7c
    dd4c:	subs	r3, r3, r2
    dd4e:	ldr	r2, [sp, #56]	; 0x38
    dd50:	str	r3, [sp, #84]	; 0x54
    dd52:	cmp	r2, #1
    dd54:	add	r3, r2
    dd56:	str	r3, [sp, #36]	; 0x24
    dd58:	ble.w	df2a <_svfprintf_r+0x161a>
    dd5c:	ldr	r3, [sp, #36]	; 0x24
    dd5e:	ldr	r2, [sp, #72]	; 0x48
    dd60:	add	r3, r2
    dd62:	movs	r2, #0
    dd64:	str	r3, [sp, #36]	; 0x24
    dd66:	str	r2, [sp, #60]	; 0x3c
    dd68:	bic.w	r3, r3, r3, asr #31
    dd6c:	b.n	d9ca <_svfprintf_r+0x10ba>
    dd6e:	add	r2, sp, #140	; 0x8c
    dd70:	ldr	r1, [sp, #20]
    dd72:	ldr	r0, [sp, #24]
    dd74:	bl	118a8 <__ssprint_r>
    dd78:	cmp	r0, #0
    dd7a:	bne.w	cb04 <_svfprintf_r+0x1f4>
    dd7e:	ldr	r3, [sp, #116]	; 0x74
    dd80:	ldr	r4, [sp, #148]	; 0x94
    dd82:	add.w	r9, sp, #192	; 0xc0
    dd86:	b.n	d760 <_svfprintf_r+0xe50>
    dd88:	add	r2, sp, #140	; 0x8c
    dd8a:	ldr	r1, [sp, #20]
    dd8c:	ldr	r0, [sp, #24]
    dd8e:	bl	118a8 <__ssprint_r>
    dd92:	cmp	r0, #0
    dd94:	bne.w	cb04 <_svfprintf_r+0x1f4>
    dd98:	ldr	r3, [sp, #116]	; 0x74
    dd9a:	ldr	r2, [sp, #56]	; 0x38
    dd9c:	ldr	r4, [sp, #148]	; 0x94
    dd9e:	subs	r3, r2, r3
    dda0:	add.w	r9, sp, #192	; 0xc0
    dda4:	b.n	d790 <_svfprintf_r+0xe80>
    dda6:	nop
    dda8:	.word	0x00012968
    ddac:	.word	0x00012918
    ddb0:	.word	0x66666667
    ddb4:	cmp	r5, #6
    ddb6:	mov	r3, r5
    ddb8:	it	cs
    ddba:	movcs	r3, #6
    ddbc:	str	r3, [sp, #36]	; 0x24
    ddbe:	bic.w	r3, r3, r3, asr #31
    ddc2:	mov	fp, r6
    ddc4:	str	r7, [sp, #40]	; 0x28
    ddc6:	str	r6, [sp, #60]	; 0x3c
    ddc8:	mov	r7, r6
    ddca:	str	r3, [sp, #16]
    ddcc:	ldr	r6, [pc, #536]	; (dfe8 <_svfprintf_r+0x16d8>)
    ddce:	b.w	ccb4 <_svfprintf_r+0x3a4>
    ddd2:	mov.w	fp, #6
    ddd6:	b.n	d90a <_svfprintf_r+0xffa>
    ddd8:	add	r2, sp, #132	; 0x84
    ddda:	add	r3, sp, #120	; 0x78
    dddc:	str	r2, [sp, #4]
    ddde:	str	r3, [sp, #0]
    dde0:	mov	r2, fp
    dde2:	add	r3, sp, #116	; 0x74
    dde4:	movs	r1, #3
    dde6:	vldr	d0, [sp, #96]	; 0x60
    ddea:	ldr	r0, [sp, #24]
    ddec:	bl	f118 <_dtoa_r>
    ddf0:	mov	r5, fp
    ddf2:	mov	r6, r0
    ddf4:	add.w	r4, r0, fp
    ddf8:	b.n	dbe6 <_svfprintf_r+0x12d6>
    ddfa:	movs	r7, #45	; 0x2d
    ddfc:	strb.w	r7, [sp, #111]	; 0x6f
    de00:	b.w	cf5a <_svfprintf_r+0x64a>
    de04:	str	r3, [sp, #12]
    de06:	b.w	d0b2 <_svfprintf_r+0x7a2>
    de0a:	ldrd	r1, r2, [sp, #64]	; 0x40
    de0e:	add.w	r3, r2, #2147483648	; 0x80000000
    de12:	str	r3, [sp, #100]	; 0x64
    de14:	movs	r3, #45	; 0x2d
    de16:	str	r1, [sp, #96]	; 0x60
    de18:	str	r3, [sp, #16]
    de1a:	b.n	d926 <_svfprintf_r+0x1016>
    de1c:	ldr	r2, [sp, #72]	; 0x48
    de1e:	ldr	r3, [sp, #56]	; 0x38
    de20:	add	r3, r2
    de22:	ldr	r2, [sp, #60]	; 0x3c
    de24:	str	r3, [sp, #36]	; 0x24
    de26:	cmp	r2, #0
    de28:	ble.w	df3e <_svfprintf_r+0x162e>
    de2c:	movs	r2, #103	; 0x67
    de2e:	bic.w	r3, r3, r3, asr #31
    de32:	str	r2, [sp, #52]	; 0x34
    de34:	b.n	d9ca <_svfprintf_r+0x10ba>
    de36:	ldr	r3, [sp, #52]	; 0x34
    de38:	cmp	r3, #71	; 0x47
    de3a:	bne.w	d968 <_svfprintf_r+0x1058>
    de3e:	ldr	r3, [sp, #12]
    de40:	lsls	r3, r3, #31
    de42:	bmi.w	dbda <_svfprintf_r+0x12ca>
    de46:	ldr	r3, [sp, #132]	; 0x84
    de48:	cmp	r7, #71	; 0x47
    de4a:	sub.w	r3, r3, r6
    de4e:	str	r3, [sp, #56]	; 0x38
    de50:	beq.w	dc88 <_svfprintf_r+0x1378>
    de54:	ldr	r3, [sp, #116]	; 0x74
    de56:	b.n	dcd2 <_svfprintf_r+0x13c2>
    de58:	bic.w	r3, r5, r5, asr #31
    de5c:	str	r7, [sp, #40]	; 0x28
    de5e:	str	r3, [sp, #16]
    de60:	str	r5, [sp, #36]	; 0x24
    de62:	mov	fp, r0
    de64:	str	r0, [sp, #60]	; 0x3c
    de66:	ldrb.w	r7, [sp, #111]	; 0x6f
    de6a:	b.w	ccb4 <_svfprintf_r+0x3a4>
    de6e:	cmp	r3, #0
    de70:	ble.n	df4e <_svfprintf_r+0x163e>
    de72:	cmp.w	fp, #0
    de76:	bne.n	df18 <_svfprintf_r+0x1608>
    de78:	ldr	r2, [sp, #12]
    de7a:	lsls	r4, r2, #31
    de7c:	bmi.n	df18 <_svfprintf_r+0x1608>
    de7e:	mov	r2, r3
    de80:	str	r2, [sp, #36]	; 0x24
    de82:	bic.w	r3, r3, r3, asr #31
    de86:	b.n	d9ca <_svfprintf_r+0x10ba>
    de88:	ldr	r3, [sp, #12]
    de8a:	lsls	r3, r3, #31
    de8c:	mov	r7, fp
    de8e:	bpl.n	de9c <_svfprintf_r+0x158c>
    de90:	add	r6, sp, #256	; 0x100
    de92:	movs	r3, #48	; 0x30
    de94:	strb.w	r3, [r6, #-65]!
    de98:	b.w	cca0 <_svfprintf_r+0x390>
    de9c:	str.w	fp, [sp, #36]	; 0x24
    dea0:	add	r6, sp, #192	; 0xc0
    dea2:	b.w	cca6 <_svfprintf_r+0x396>
    dea6:	add	r2, sp, #140	; 0x8c
    dea8:	ldr	r1, [sp, #20]
    deaa:	ldr	r0, [sp, #24]
    deac:	bl	118a8 <__ssprint_r>
    deb0:	cmp	r0, #0
    deb2:	bne.w	cb04 <_svfprintf_r+0x1f4>
    deb6:	ldr	r5, [sp, #116]	; 0x74
    deb8:	ldr	r4, [sp, #148]	; 0x94
    deba:	ldr	r3, [sp, #144]	; 0x90
    debc:	add.w	r9, sp, #192	; 0xc0
    dec0:	b.n	db10 <_svfprintf_r+0x1200>
    dec2:	mov	r8, r4
    dec4:	movs	r5, #0
    dec6:	b.w	c9c8 <_svfprintf_r+0xb8>
    deca:	adds	r3, #48	; 0x30
    decc:	movs	r2, #48	; 0x30
    dece:	strb.w	r3, [sp, #127]	; 0x7f
    ded2:	strb.w	r2, [sp, #126]	; 0x7e
    ded6:	add	r3, sp, #128	; 0x80
    ded8:	b.n	dd4a <_svfprintf_r+0x143a>
    deda:	ldr	r3, [sp, #132]	; 0x84
    dedc:	b.n	d990 <_svfprintf_r+0x1080>
    dede:	ldr	r2, [sp, #72]	; 0x48
    dee0:	ldr	r3, [sp, #60]	; 0x3c
    dee2:	add	r3, r2
    dee4:	movs	r2, #103	; 0x67
    dee6:	str	r3, [sp, #36]	; 0x24
    dee8:	str	r2, [sp, #52]	; 0x34
    deea:	bic.w	r3, r3, r3, asr #31
    deee:	b.n	d9ca <_svfprintf_r+0x10ba>
    def0:	ldr	r6, [pc, #248]	; (dfec <_svfprintf_r+0x16dc>)
    def2:	ldr	r3, [pc, #252]	; (dff0 <_svfprintf_r+0x16e0>)
    def4:	ldrb.w	r7, [sp, #111]	; 0x6f
    def8:	b.w	cf5e <_svfprintf_r+0x64e>
    defc:	movs	r2, #0
    defe:	movs	r3, #0
    df00:	ldrd	r0, r1, [sp, #96]	; 0x60
    df04:	bl	a52c <__aeabi_dcmpeq>
    df08:	cmp	r0, #0
    df0a:	bne.w	dbee <_svfprintf_r+0x12de>
    df0e:	rsb	r5, r5, #1
    df12:	str	r5, [sp, #116]	; 0x74
    df14:	add	r4, r5
    df16:	b.n	d96a <_svfprintf_r+0x105a>
    df18:	ldr	r3, [sp, #60]	; 0x3c
    df1a:	ldr	r2, [sp, #72]	; 0x48
    df1c:	adds	r5, r3, r2
    df1e:	add.w	r3, r5, fp
    df22:	str	r3, [sp, #36]	; 0x24
    df24:	bic.w	r3, r3, r3, asr #31
    df28:	b.n	d9ca <_svfprintf_r+0x10ba>
    df2a:	ldr	r3, [sp, #12]
    df2c:	ands.w	r3, r3, #1
    df30:	bne.w	dd5c <_svfprintf_r+0x144c>
    df34:	str	r3, [sp, #60]	; 0x3c
    df36:	ldr	r3, [sp, #36]	; 0x24
    df38:	bic.w	r3, r3, r3, asr #31
    df3c:	b.n	d9ca <_svfprintf_r+0x10ba>
    df3e:	ldr	r3, [sp, #60]	; 0x3c
    df40:	ldr	r2, [sp, #36]	; 0x24
    df42:	rsb	r3, r3, #1
    df46:	add	r2, r3
    df48:	mov	r3, r2
    df4a:	str	r2, [sp, #36]	; 0x24
    df4c:	b.n	de2c <_svfprintf_r+0x151c>
    df4e:	cmp.w	fp, #0
    df52:	bne.n	df5a <_svfprintf_r+0x164a>
    df54:	ldr	r3, [sp, #12]
    df56:	lsls	r0, r3, #31
    df58:	bpl.n	df6a <_svfprintf_r+0x165a>
    df5a:	ldr	r3, [sp, #72]	; 0x48
    df5c:	adds	r5, r3, #1
    df5e:	add.w	r3, r5, fp
    df62:	str	r3, [sp, #36]	; 0x24
    df64:	bic.w	r3, r3, r3, asr #31
    df68:	b.n	d9ca <_svfprintf_r+0x10ba>
    df6a:	movs	r3, #1
    df6c:	str	r3, [sp, #36]	; 0x24
    df6e:	b.n	d9ca <_svfprintf_r+0x10ba>
    df70:	ldr	r0, [sp, #40]	; 0x28
    df72:	ldrb.w	r3, [r8, #1]
    df76:	ldr	r5, [r0, #0]
    df78:	adds	r0, #4
    df7a:	cmp	r5, #0
    df7c:	str	r0, [sp, #40]	; 0x28
    df7e:	mov	r8, r4
    df80:	bge.w	c9c4 <_svfprintf_r+0xb4>
    df84:	mov.w	r5, #4294967295
    df88:	b.w	c9c4 <_svfprintf_r+0xb4>
    df8c:	strb.w	r1, [sp, #111]	; 0x6f
    df90:	b.w	cb26 <_svfprintf_r+0x216>
    df94:	add.w	r3, sp, #126	; 0x7e
    df98:	b.n	dd4a <_svfprintf_r+0x143a>
    df9a:	ldr	r2, [sp, #24]
    df9c:	movs	r3, #12
    df9e:	str	r3, [r2, #0]
    dfa0:	mov.w	r0, #4294967295
    dfa4:	b.w	cb16 <_svfprintf_r+0x206>
    dfa8:	strb.w	r1, [sp, #111]	; 0x6f
    dfac:	b.w	cc20 <_svfprintf_r+0x310>
    dfb0:	strb.w	r1, [sp, #111]	; 0x6f
    dfb4:	b.w	ceec <_svfprintf_r+0x5dc>
    dfb8:	strb.w	r1, [sp, #111]	; 0x6f
    dfbc:	b.w	d05a <_svfprintf_r+0x74a>
    dfc0:	strb.w	r1, [sp, #111]	; 0x6f
    dfc4:	b.w	cffe <_svfprintf_r+0x6ee>
    dfc8:	strb.w	r1, [sp, #111]	; 0x6f
    dfcc:	b.w	cfaa <_svfprintf_r+0x69a>
    dfd0:	strb.w	r1, [sp, #111]	; 0x6f
    dfd4:	b.w	d242 <_svfprintf_r+0x932>
    dfd8:	strb.w	r1, [sp, #111]	; 0x6f
    dfdc:	b.w	d200 <_svfprintf_r+0x8f0>
    dfe0:	strb.w	r1, [sp, #111]	; 0x6f
    dfe4:	b.w	d1c4 <_svfprintf_r+0x8b4>
    dfe8:	.word	0x00012960
    dfec:	.word	0x00012934
    dff0:	.word	0x00012930

0000dff4 <__ssvfscanf_r>:
    dff4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    dff8:	mov	fp, r1
    dffa:	ldrsh.w	r1, [r1, #12]
    dffe:	sub.w	sp, sp, #692	; 0x2b4
    e002:	mov	sl, r0
    e004:	lsls	r0, r1, #18
    e006:	mov	r4, r2
    e008:	str	r3, [sp, #20]
    e00a:	bmi.n	e020 <__ssvfscanf_r+0x2c>
    e00c:	ldr.w	r3, [fp, #100]	; 0x64
    e010:	orr.w	r1, r1, #8192	; 0x2000
    e014:	bic.w	r3, r3, #8192	; 0x2000
    e018:	strh.w	r1, [fp, #12]
    e01c:	str.w	r3, [fp, #100]	; 0x64
    e020:	mov	r6, r4
    e022:	movs	r3, #0
    e024:	str	r3, [sp, #28]
    e026:	str	r3, [sp, #16]
    e028:	mov	r7, r3
    e02a:	str	r3, [sp, #24]
    e02c:	ldrb.w	r3, [r6], #1
    e030:	str	r3, [sp, #68]	; 0x44
    e032:	cbz	r3, e090 <__ssvfscanf_r+0x9c>
    e034:	bl	aaa8 <__locale_ctype_ptr>
    e038:	ldr	r2, [sp, #68]	; 0x44
    e03a:	add	r0, r2
    e03c:	ldrb	r3, [r0, #1]
    e03e:	and.w	r3, r3, #8
    e042:	and.w	r5, r3, #255	; 0xff
    e046:	cbz	r3, e09a <__ssvfscanf_r+0xa6>
    e048:	ldr.w	r3, [fp, #4]
    e04c:	b.n	e072 <__ssvfscanf_r+0x7e>
    e04e:	bl	aaa8 <__locale_ctype_ptr>
    e052:	ldr.w	r3, [fp]
    e056:	ldrb	r2, [r3, #0]
    e058:	add	r0, r2
    e05a:	adds	r3, #1
    e05c:	ldrb	r2, [r0, #1]
    e05e:	lsls	r1, r2, #28
    e060:	bpl.n	e082 <__ssvfscanf_r+0x8e>
    e062:	ldr.w	r2, [fp, #4]
    e066:	str.w	r3, [fp]
    e06a:	subs	r3, r2, #1
    e06c:	adds	r7, #1
    e06e:	str.w	r3, [fp, #4]
    e072:	cmp	r3, #0
    e074:	bgt.n	e04e <__ssvfscanf_r+0x5a>
    e076:	mov	r1, fp
    e078:	mov	r0, sl
    e07a:	bl	11a2c <__ssrefill_r>
    e07e:	cmp	r0, #0
    e080:	beq.n	e04e <__ssvfscanf_r+0x5a>
    e082:	mov	r4, r6
    e084:	mov	r6, r4
    e086:	ldrb.w	r3, [r6], #1
    e08a:	str	r3, [sp, #68]	; 0x44
    e08c:	cmp	r3, #0
    e08e:	bne.n	e034 <__ssvfscanf_r+0x40>
    e090:	ldr	r0, [sp, #24]
    e092:	add.w	sp, sp, #692	; 0x2b4
    e096:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    e09a:	cmp	r2, #37	; 0x25
    e09c:	bne.w	e1a8 <__ssvfscanf_r+0x1b4>
    e0a0:	ldrb.w	r8, [r4, #1]
    e0a4:	mov	r4, r5
    e0a6:	adds	r3, r6, #1
    e0a8:	cmp.w	r8, #120	; 0x78
    e0ac:	bhi.w	e536 <__ssvfscanf_r+0x542>
    e0b0:	tbh	[pc, r8, lsl #1]
    e0b4:	.word	0x02410092
    e0b8:	.word	0x02410241
    e0bc:	.word	0x02410241
    e0c0:	.word	0x02410241
    e0c4:	.word	0x02410241
    e0c8:	.word	0x02410241
    e0cc:	.word	0x02410241
    e0d0:	.word	0x02410241
    e0d4:	.word	0x02410241
    e0d8:	.word	0x02410241
    e0dc:	.word	0x02410241
    e0e0:	.word	0x02410241
    e0e4:	.word	0x02410241
    e0e8:	.word	0x02410241
    e0ec:	.word	0x02410241
    e0f0:	.word	0x02410241
    e0f4:	.word	0x02410241
    e0f8:	.word	0x02410241
    e0fc:	.word	0x00790241
    e100:	.word	0x02410241
    e104:	.word	0x02410241
    e108:	.word	0x024101d8
    e10c:	.word	0x02410241
    e110:	.word	0x02410241
    e114:	.word	0x01cf01cf
    e118:	.word	0x01cf01cf
    e11c:	.word	0x01cf01cf
    e120:	.word	0x01cf01cf
    e124:	.word	0x01cf01cf
    e128:	.word	0x02410241
    e12c:	.word	0x02410241
    e130:	.word	0x02410241
    e134:	.word	0x02410241
    e138:	.word	0x02410241
    e13c:	.word	0x01b901c1
    e140:	.word	0x01b90241
    e144:	.word	0x02410241
    e148:	.word	0x02410241
    e14c:	.word	0x024101b3
    e150:	.word	0x01a30241
    e154:	.word	0x02410241
    e158:	.word	0x02410241
    e15c:	.word	0x02410241
    e160:	.word	0x02410241
    e164:	.word	0x02410193
    e168:	.word	0x01510241
    e16c:	.word	0x02410241
    e170:	.word	0x02410241
    e174:	.word	0x02410241
    e178:	.word	0x01220241
    e17c:	.word	0x01b90188
    e180:	.word	0x01b901b9
    e184:	.word	0x0098011c
    e188:	.word	0x02410241
    e18c:	.word	0x024100d5
    e190:	.word	0x0101010d
    e194:	.word	0x024100f3
    e198:	.word	0x00eb0241
    e19c:	.word	0x00df0241
    e1a0:	.word	0x02410241
    e1a4:	.short	0x0193
    e1a6:	mov	r6, r3
    e1a8:	ldr.w	r3, [fp, #4]
    e1ac:	cmp	r3, #0
    e1ae:	ble.w	e658 <__ssvfscanf_r+0x664>
    e1b2:	ldr.w	r3, [fp]
    e1b6:	ldrb.w	r2, [r6, #-1]
    e1ba:	ldrb	r1, [r3, #0]
    e1bc:	cmp	r1, r2
    e1be:	bne.w	e090 <__ssvfscanf_r+0x9c>
    e1c2:	ldr.w	r2, [fp, #4]
    e1c6:	adds	r3, #1
    e1c8:	subs	r2, #1
    e1ca:	str.w	r3, [fp]
    e1ce:	adds	r7, #1
    e1d0:	str.w	r2, [fp, #4]
    e1d4:	mov	r4, r6
    e1d6:	b.n	e084 <__ssvfscanf_r+0x90>
    e1d8:	mov.w	r0, #4294967295
    e1dc:	add.w	sp, sp, #692	; 0x2b4
    e1e0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    e1e4:	str	r3, [sp, #12]
    e1e6:	ldr.w	r3, [fp, #4]
    e1ea:	cmp	r3, #0
    e1ec:	ble.w	e6b6 <__ssvfscanf_r+0x6c2>
    e1f0:	ldr	r3, [pc, #736]	; (e4d4 <__ssvfscanf_r+0x4e0>)
    e1f2:	str	r3, [sp, #28]
    e1f4:	movs	r3, #0
    e1f6:	str	r3, [sp, #16]
    e1f8:	movs	r6, #3
    e1fa:	b.n	e200 <__ssvfscanf_r+0x20c>
    e1fc:	str.w	lr, [fp]
    e200:	bl	aaa8 <__locale_ctype_ptr>
    e204:	ldr.w	r2, [fp]
    e208:	ldrb	r1, [r2, #0]
    e20a:	add	r0, r1
    e20c:	add.w	lr, r2, #1
    e210:	ldrb	r3, [r0, #1]
    e212:	and.w	r3, r3, #8
    e216:	and.w	r8, r3, #255	; 0xff
    e21a:	cmp	r3, #0
    e21c:	beq.w	e71e <__ssvfscanf_r+0x72a>
    e220:	ldr.w	r3, [fp, #4]
    e224:	subs	r3, #1
    e226:	cmp	r3, #0
    e228:	add.w	r7, r7, #1
    e22c:	str.w	r3, [fp, #4]
    e230:	bgt.n	e1fc <__ssvfscanf_r+0x208>
    e232:	mov	r1, fp
    e234:	mov	r0, sl
    e236:	bl	11a2c <__ssrefill_r>
    e23a:	cmp	r0, #0
    e23c:	beq.n	e200 <__ssvfscanf_r+0x20c>
    e23e:	ldr	r2, [sp, #24]
    e240:	cmp	r2, #0
    e242:	beq.n	e1d8 <__ssvfscanf_r+0x1e4>
    e244:	ldrh.w	r3, [fp, #12]
    e248:	tst.w	r3, #64	; 0x40
    e24c:	mov	r3, r2
    e24e:	it	ne
    e250:	movne.w	r3, #4294967295
    e254:	mov	r0, r3
    e256:	add.w	sp, sp, #692	; 0x2b4
    e25a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    e25e:	ldrb.w	r8, [r6, #1]
    e262:	cmp.w	r8, #108	; 0x6c
    e266:	beq.w	e66e <__ssvfscanf_r+0x67a>
    e26a:	orr.w	r5, r5, #1
    e26e:	mov	r6, r3
    e270:	b.n	e0a6 <__ssvfscanf_r+0xb2>
    e272:	str	r3, [sp, #12]
    e274:	ldr.w	r3, [fp, #4]
    e278:	cmp	r3, #0
    e27a:	ble.w	e70e <__ssvfscanf_r+0x71a>
    e27e:	ldr	r3, [pc, #600]	; (e4d8 <__ssvfscanf_r+0x4e4>)
    e280:	str	r3, [sp, #28]
    e282:	movs	r3, #10
    e284:	str	r3, [sp, #16]
    e286:	movs	r6, #3
    e288:	b.n	e200 <__ssvfscanf_r+0x20c>
    e28a:	str	r3, [sp, #12]
    e28c:	ldr.w	r3, [fp, #4]
    e290:	cmp	r3, #0
    e292:	ble.w	e6fe <__ssvfscanf_r+0x70a>
    e296:	movs	r6, #2
    e298:	b.n	e200 <__ssvfscanf_r+0x20c>
    e29a:	str	r3, [sp, #12]
    e29c:	ldr.w	r3, [fp, #4]
    e2a0:	cmp	r3, #0
    e2a2:	orr.w	r5, r5, #544	; 0x220
    e2a6:	ble.w	e3ea <__ssvfscanf_r+0x3f6>
    e2aa:	ldr	r3, [pc, #556]	; (e4d8 <__ssvfscanf_r+0x4e4>)
    e2ac:	str	r3, [sp, #28]
    e2ae:	movs	r3, #16
    e2b0:	str	r3, [sp, #16]
    e2b2:	movs	r6, #3
    e2b4:	b.n	e200 <__ssvfscanf_r+0x20c>
    e2b6:	str	r3, [sp, #12]
    e2b8:	ldr.w	r3, [fp, #4]
    e2bc:	cmp	r3, #0
    e2be:	ble.w	e40a <__ssvfscanf_r+0x416>
    e2c2:	ldr	r3, [pc, #532]	; (e4d8 <__ssvfscanf_r+0x4e4>)
    e2c4:	str	r3, [sp, #28]
    e2c6:	movs	r3, #8
    e2c8:	str	r3, [sp, #16]
    e2ca:	movs	r6, #3
    e2cc:	b.n	e200 <__ssvfscanf_r+0x20c>
    e2ce:	lsls	r2, r5, #27
    e2d0:	mov	r6, r3
    e2d2:	str	r3, [sp, #12]
    e2d4:	bmi.w	e4bc <__ssvfscanf_r+0x4c8>
    e2d8:	lsls	r3, r5, #29
    e2da:	bpl.w	e686 <__ssvfscanf_r+0x692>
    e2de:	ldr	r1, [sp, #20]
    e2e0:	ldr	r3, [r1, #0]
    e2e2:	strh	r7, [r3, #0]
    e2e4:	adds	r3, r1, #4
    e2e6:	str	r3, [sp, #20]
    e2e8:	mov	r4, r6
    e2ea:	b.n	e084 <__ssvfscanf_r+0x90>
    e2ec:	ldrb.w	r8, [r6, #1]
    e2f0:	orr.w	r5, r5, #4
    e2f4:	mov	r6, r3
    e2f6:	b.n	e0a6 <__ssvfscanf_r+0xb2>
    e2f8:	str	r3, [sp, #12]
    e2fa:	ldr.w	r3, [fp, #4]
    e2fe:	cmp	r3, #0
    e300:	ble.w	e6de <__ssvfscanf_r+0x6ea>
    e304:	cmp	r4, #0
    e306:	it	eq
    e308:	moveq	r4, #1
    e30a:	ands.w	r3, r5, #1
    e30e:	bne.w	e556 <__ssvfscanf_r+0x562>
    e312:	lsls	r2, r5, #27
    e314:	bpl.w	e62e <__ssvfscanf_r+0x63a>
    e318:	mov	r5, r3
    e31a:	b.n	e330 <__ssvfscanf_r+0x33c>
    e31c:	add	r3, r2
    e31e:	str.w	r3, [fp]
    e322:	add	r5, r2
    e324:	subs	r4, r4, r2
    e326:	bl	11a2c <__ssrefill_r>
    e32a:	cmp	r0, #0
    e32c:	bne.w	e626 <__ssvfscanf_r+0x632>
    e330:	ldr.w	r2, [fp, #4]
    e334:	ldr.w	r3, [fp]
    e338:	cmp	r2, r4
    e33a:	mov	r1, fp
    e33c:	mov	r0, sl
    e33e:	blt.n	e31c <__ssvfscanf_r+0x328>
    e340:	subs	r2, r2, r4
    e342:	add	r3, r4
    e344:	str.w	r2, [fp, #4]
    e348:	add	r5, r4
    e34a:	str.w	r3, [fp]
    e34e:	ldr	r6, [sp, #12]
    e350:	add	r7, r5
    e352:	mov	r4, r6
    e354:	b.n	e084 <__ssvfscanf_r+0x90>
    e356:	add.w	r9, sp, #80	; 0x50
    e35a:	mov	r1, r3
    e35c:	mov	r0, r9
    e35e:	bl	112c8 <__sccl>
    e362:	ldr.w	r3, [fp, #4]
    e366:	cmp	r3, #0
    e368:	mov	r6, r0
    e36a:	ble.w	e6ce <__ssvfscanf_r+0x6da>
    e36e:	cmp	r4, #0
    e370:	ldr.w	r2, [fp]
    e374:	it	eq
    e376:	moveq.w	r4, #4294967295
    e37a:	lsls	r3, r5, #27
    e37c:	ldrb	r1, [r2, #0]
    e37e:	bpl.w	e4c2 <__ssvfscanf_r+0x4ce>
    e382:	mov	r8, r4
    e384:	movs	r5, #0
    e386:	b.n	e38a <__ssvfscanf_r+0x396>
    e388:	ldrb	r1, [r2, #0]
    e38a:	ldrb.w	r3, [r9, r1]
    e38e:	adds	r2, #1
    e390:	cmp	r3, #0
    e392:	beq.w	e61c <__ssvfscanf_r+0x628>
    e396:	ldr.w	r3, [fp, #4]
    e39a:	str.w	r2, [fp]
    e39e:	adds	r5, #1
    e3a0:	subs	r3, #1
    e3a2:	cmp	r5, r4
    e3a4:	str.w	r3, [fp, #4]
    e3a8:	beq.w	e616 <__ssvfscanf_r+0x622>
    e3ac:	cmp	r3, #0
    e3ae:	bgt.n	e388 <__ssvfscanf_r+0x394>
    e3b0:	mov	r1, fp
    e3b2:	mov	r0, sl
    e3b4:	bl	11a2c <__ssrefill_r>
    e3b8:	cmp	r0, #0
    e3ba:	bne.w	e614 <__ssvfscanf_r+0x620>
    e3be:	ldr.w	r2, [fp]
    e3c2:	b.n	e388 <__ssvfscanf_r+0x394>
    e3c4:	str	r3, [sp, #12]
    e3c6:	ldr.w	r3, [fp, #4]
    e3ca:	cmp	r3, #0
    e3cc:	ble.n	e444 <__ssvfscanf_r+0x450>
    e3ce:	ldr	r3, [pc, #260]	; (e4d4 <__ssvfscanf_r+0x4e0>)
    e3d0:	str	r3, [sp, #28]
    e3d2:	movs	r3, #10
    e3d4:	str	r3, [sp, #16]
    e3d6:	movs	r6, #3
    e3d8:	b.n	e200 <__ssvfscanf_r+0x20c>
    e3da:	str	r3, [sp, #12]
    e3dc:	ldr.w	r3, [fp, #4]
    e3e0:	cmp	r3, #0
    e3e2:	orr.w	r5, r5, #512	; 0x200
    e3e6:	bgt.w	e2aa <__ssvfscanf_r+0x2b6>
    e3ea:	mov	r1, fp
    e3ec:	mov	r0, sl
    e3ee:	bl	11a2c <__ssrefill_r>
    e3f2:	cmp	r0, #0
    e3f4:	beq.w	e2aa <__ssvfscanf_r+0x2b6>
    e3f8:	b.n	e23e <__ssvfscanf_r+0x24a>
    e3fa:	str	r3, [sp, #12]
    e3fc:	ldr.w	r3, [fp, #4]
    e400:	cmp	r3, #0
    e402:	orr.w	r5, r5, #1
    e406:	bgt.w	e2c2 <__ssvfscanf_r+0x2ce>
    e40a:	mov	r1, fp
    e40c:	mov	r0, sl
    e40e:	bl	11a2c <__ssrefill_r>
    e412:	cmp	r0, #0
    e414:	beq.w	e2c2 <__ssvfscanf_r+0x2ce>
    e418:	b.n	e23e <__ssvfscanf_r+0x24a>
    e41a:	ldrb.w	r8, [r6, #1]
    e41e:	orr.w	r5, r5, #2
    e422:	mov	r6, r3
    e424:	b.n	e0a6 <__ssvfscanf_r+0xb2>
    e426:	str	r3, [sp, #12]
    e428:	ldr.w	r3, [fp, #4]
    e42c:	cmp	r3, #0
    e42e:	ble.w	e6ee <__ssvfscanf_r+0x6fa>
    e432:	movs	r6, #4
    e434:	b.n	e200 <__ssvfscanf_r+0x20c>
    e436:	str	r3, [sp, #12]
    e438:	ldr.w	r3, [fp, #4]
    e43c:	cmp	r3, #0
    e43e:	orr.w	r5, r5, #1
    e442:	bgt.n	e3ce <__ssvfscanf_r+0x3da>
    e444:	mov	r1, fp
    e446:	mov	r0, sl
    e448:	bl	11a2c <__ssrefill_r>
    e44c:	cmp	r0, #0
    e44e:	beq.n	e3ce <__ssvfscanf_r+0x3da>
    e450:	b.n	e23e <__ssvfscanf_r+0x24a>
    e452:	add.w	r4, r4, r4, lsl #2
    e456:	add.w	r4, r8, r4, lsl #1
    e45a:	subs	r4, #48	; 0x30
    e45c:	ldrb.w	r8, [r6, #1]
    e460:	mov	r6, r3
    e462:	b.n	e0a6 <__ssvfscanf_r+0xb2>
    e464:	ldrb.w	r8, [r6, #1]
    e468:	orr.w	r5, r5, #16
    e46c:	mov	r6, r3
    e46e:	b.n	e0a6 <__ssvfscanf_r+0xb2>
    e470:	add	r3, sp, #72	; 0x48
    e472:	mov	r1, r8
    e474:	mov	r0, r3
    e476:	movs	r2, #8
    e478:	str	r3, [sp, #32]
    e47a:	bl	88c8 <memset>
    e47e:	ands.w	r9, r5, #16
    e482:	bne.w	ed48 <__ssvfscanf_r+0xd54>
    e486:	ldr	r2, [sp, #20]
    e488:	mov	r3, r2
    e48a:	adds	r3, #4
    e48c:	ldr.w	r8, [r2]
    e490:	str	r3, [sp, #20]
    e492:	movs	r6, #0
    e494:	bl	aaa8 <__locale_ctype_ptr>
    e498:	ldr.w	r3, [fp]
    e49c:	ldrb	r3, [r3, #0]
    e49e:	add	r0, r3
    e4a0:	ldrb	r3, [r0, #1]
    e4a2:	lsls	r0, r3, #28
    e4a4:	bmi.n	e4ac <__ssvfscanf_r+0x4b8>
    e4a6:	cmp	r4, #0
    e4a8:	bne.w	ecac <__ssvfscanf_r+0xcb8>
    e4ac:	cmp.w	r9, #0
    e4b0:	bne.n	e4bc <__ssvfscanf_r+0x4c8>
    e4b2:	str.w	r9, [r8]
    e4b6:	ldr	r3, [sp, #24]
    e4b8:	adds	r3, #1
    e4ba:	str	r3, [sp, #24]
    e4bc:	ldr	r6, [sp, #12]
    e4be:	mov	r4, r6
    e4c0:	b.n	e084 <__ssvfscanf_r+0x90>
    e4c2:	ldr	r0, [sp, #20]
    e4c4:	ldr	r5, [r0, #0]
    e4c6:	mov	r3, r0
    e4c8:	adds	r3, #4
    e4ca:	add.w	r8, r5, r4
    e4ce:	str	r3, [sp, #12]
    e4d0:	mov	r4, r5
    e4d2:	b.n	e4e2 <__ssvfscanf_r+0x4ee>
    e4d4:	.word	0x0000c8e9
    e4d8:	.word	0x00011675
    e4dc:	ldr.w	r2, [fp]
    e4e0:	ldrb	r1, [r2, #0]
    e4e2:	ldrb.w	r3, [r9, r1]
    e4e6:	adds	r0, r2, #1
    e4e8:	cbz	r3, e51c <__ssvfscanf_r+0x528>
    e4ea:	ldr.w	r3, [fp, #4]
    e4ee:	str.w	r0, [fp]
    e4f2:	subs	r3, #1
    e4f4:	str.w	r3, [fp, #4]
    e4f8:	ldrb	r3, [r2, #0]
    e4fa:	strb.w	r3, [r4], #1
    e4fe:	cmp	r8, r4
    e500:	beq.n	e51c <__ssvfscanf_r+0x528>
    e502:	ldr.w	r3, [fp, #4]
    e506:	cmp	r3, #0
    e508:	bgt.n	e4dc <__ssvfscanf_r+0x4e8>
    e50a:	mov	r1, fp
    e50c:	mov	r0, sl
    e50e:	bl	11a2c <__ssrefill_r>
    e512:	cmp	r0, #0
    e514:	beq.n	e4dc <__ssvfscanf_r+0x4e8>
    e516:	cmp	r5, r4
    e518:	beq.w	e23e <__ssvfscanf_r+0x24a>
    e51c:	subs	r5, r4, r5
    e51e:	beq.w	e090 <__ssvfscanf_r+0x9c>
    e522:	ldr	r2, [sp, #24]
    e524:	adds	r2, #1
    e526:	movs	r3, #0
    e528:	str	r2, [sp, #24]
    e52a:	ldr	r2, [sp, #12]
    e52c:	str	r2, [sp, #20]
    e52e:	strb	r3, [r4, #0]
    e530:	add	r7, r5
    e532:	mov	r4, r6
    e534:	b.n	e084 <__ssvfscanf_r+0x90>
    e536:	str	r3, [sp, #12]
    e538:	bl	aaa8 <__locale_ctype_ptr>
    e53c:	add	r0, r8
    e53e:	ldrb	r3, [r0, #1]
    e540:	and.w	r3, r3, #3
    e544:	cmp	r3, #1
    e546:	ldr.w	r3, [fp, #4]
    e54a:	beq.w	e67a <__ssvfscanf_r+0x686>
    e54e:	cmp	r3, #0
    e550:	bgt.w	e3ce <__ssvfscanf_r+0x3da>
    e554:	b.n	e444 <__ssvfscanf_r+0x450>
    e556:	add	r3, sp, #72	; 0x48
    e558:	mov	r0, r3
    e55a:	movs	r2, #8
    e55c:	movs	r1, #0
    e55e:	str	r3, [sp, #32]
    e560:	bl	88c8 <memset>
    e564:	ands.w	r3, r5, #16
    e568:	str	r3, [sp, #40]	; 0x28
    e56a:	bne.n	e668 <__ssvfscanf_r+0x674>
    e56c:	ldr	r2, [sp, #20]
    e56e:	mov	r3, r2
    e570:	adds	r3, #4
    e572:	ldr.w	r9, [r2]
    e576:	str	r3, [sp, #20]
    e578:	movs	r5, #0
    e57a:	add.w	r8, sp, #336	; 0x150
    e57e:	bl	aa84 <__locale_mb_cur_max>
    e582:	cmp	r0, r5
    e584:	beq.w	e23e <__ssvfscanf_r+0x24a>
    e588:	ldmia.w	fp, {r2, r3}
    e58c:	ldrb.w	r0, [r2], #1
    e590:	str.w	r2, [fp]
    e594:	subs	r3, #1
    e596:	ldr	r2, [sp, #32]
    e598:	str	r2, [sp, #0]
    e59a:	adds	r6, r5, #1
    e59c:	str.w	r3, [fp, #4]
    e5a0:	mov	r1, r9
    e5a2:	strb.w	r0, [r8, r5]
    e5a6:	mov	r3, r6
    e5a8:	mov	r2, r8
    e5aa:	mov	r0, sl
    e5ac:	bl	10984 <_mbrtowc_r>
    e5b0:	adds	r1, r0, #1
    e5b2:	beq.w	e23e <__ssvfscanf_r+0x24a>
    e5b6:	cbnz	r0, e5e2 <__ssvfscanf_r+0x5ee>
    e5b8:	ldr	r3, [sp, #40]	; 0x28
    e5ba:	cbnz	r3, e602 <__ssvfscanf_r+0x60e>
    e5bc:	str.w	r3, [r9]
    e5c0:	add	r7, r6
    e5c2:	subs	r4, #1
    e5c4:	add.w	r9, r9, #4
    e5c8:	ldr.w	r3, [fp, #4]
    e5cc:	cmp	r3, #0
    e5ce:	mov.w	r5, #0
    e5d2:	ble.n	e5f0 <__ssvfscanf_r+0x5fc>
    e5d4:	cmp	r4, #0
    e5d6:	bne.n	e57e <__ssvfscanf_r+0x58a>
    e5d8:	ldr	r3, [sp, #40]	; 0x28
    e5da:	cmp	r3, #0
    e5dc:	beq.w	e4b6 <__ssvfscanf_r+0x4c2>
    e5e0:	b.n	e4bc <__ssvfscanf_r+0x4c8>
    e5e2:	adds	r0, #2
    e5e4:	bne.n	e608 <__ssvfscanf_r+0x614>
    e5e6:	ldr.w	r3, [fp, #4]
    e5ea:	cmp	r3, #0
    e5ec:	mov	r5, r6
    e5ee:	bgt.n	e57e <__ssvfscanf_r+0x58a>
    e5f0:	mov	r1, fp
    e5f2:	mov	r0, sl
    e5f4:	bl	11a2c <__ssrefill_r>
    e5f8:	cmp	r0, #0
    e5fa:	beq.n	e5d4 <__ssvfscanf_r+0x5e0>
    e5fc:	cmp	r5, #0
    e5fe:	beq.n	e5d8 <__ssvfscanf_r+0x5e4>
    e600:	b.n	e23e <__ssvfscanf_r+0x24a>
    e602:	add	r7, r6
    e604:	subs	r4, #1
    e606:	b.n	e5c8 <__ssvfscanf_r+0x5d4>
    e608:	ldr	r3, [sp, #40]	; 0x28
    e60a:	add	r7, r6
    e60c:	subs	r4, #1
    e60e:	cmp	r3, #0
    e610:	bne.n	e5c8 <__ssvfscanf_r+0x5d4>
    e612:	b.n	e5c4 <__ssvfscanf_r+0x5d0>
    e614:	mov	r8, r5
    e616:	mov	r5, r8
    e618:	add	r7, r5
    e61a:	b.n	e532 <__ssvfscanf_r+0x53e>
    e61c:	cmp	r5, #0
    e61e:	beq.w	e090 <__ssvfscanf_r+0x9c>
    e622:	add	r7, r5
    e624:	b.n	e532 <__ssvfscanf_r+0x53e>
    e626:	cmp	r5, #0
    e628:	bne.w	e34e <__ssvfscanf_r+0x35a>
    e62c:	b.n	e23e <__ssvfscanf_r+0x24a>
    e62e:	ldr	r5, [sp, #20]
    e630:	mov	r3, r4
    e632:	ldr	r1, [r5, #0]
    e634:	str.w	fp, [sp]
    e638:	movs	r2, #1
    e63a:	mov	r0, sl
    e63c:	bl	11a68 <_sfread_r>
    e640:	adds	r6, r5, #4
    e642:	cmp	r0, #0
    e644:	beq.w	e23e <__ssvfscanf_r+0x24a>
    e648:	ldr	r3, [sp, #24]
    e64a:	str	r6, [sp, #20]
    e64c:	ldr	r6, [sp, #12]
    e64e:	adds	r3, #1
    e650:	add	r7, r0
    e652:	str	r3, [sp, #24]
    e654:	mov	r4, r6
    e656:	b.n	e084 <__ssvfscanf_r+0x90>
    e658:	mov	r1, fp
    e65a:	mov	r0, sl
    e65c:	bl	11a2c <__ssrefill_r>
    e660:	cmp	r0, #0
    e662:	beq.w	e1b2 <__ssvfscanf_r+0x1be>
    e666:	b.n	e23e <__ssvfscanf_r+0x24a>
    e668:	mov.w	r9, #0
    e66c:	b.n	e578 <__ssvfscanf_r+0x584>
    e66e:	ldrb.w	r8, [r6, #2]
    e672:	orr.w	r5, r5, #2
    e676:	adds	r6, #2
    e678:	b.n	e0a6 <__ssvfscanf_r+0xb2>
    e67a:	cmp	r3, #0
    e67c:	orr.w	r5, r5, #1
    e680:	bgt.w	e3ce <__ssvfscanf_r+0x3da>
    e684:	b.n	e444 <__ssvfscanf_r+0x450>
    e686:	lsls	r4, r5, #31
    e688:	bmi.n	e6a4 <__ssvfscanf_r+0x6b0>
    e68a:	lsls	r0, r5, #30
    e68c:	bpl.n	e6a4 <__ssvfscanf_r+0x6b0>
    e68e:	ldr	r2, [sp, #20]
    e690:	ldr	r6, [sp, #12]
    e692:	ldr	r3, [r2, #0]
    e694:	mov	r0, r7
    e696:	asrs	r1, r7, #31
    e698:	adds	r2, #4
    e69a:	str	r2, [sp, #20]
    e69c:	strd	r0, r1, [r3]
    e6a0:	mov	r4, r6
    e6a2:	b.n	e084 <__ssvfscanf_r+0x90>
    e6a4:	ldr	r2, [sp, #20]
    e6a6:	ldr	r6, [sp, #12]
    e6a8:	ldr	r3, [r2, #0]
    e6aa:	str	r7, [r3, #0]
    e6ac:	mov	r3, r2
    e6ae:	adds	r3, #4
    e6b0:	str	r3, [sp, #20]
    e6b2:	mov	r4, r6
    e6b4:	b.n	e084 <__ssvfscanf_r+0x90>
    e6b6:	mov	r1, fp
    e6b8:	mov	r0, sl
    e6ba:	bl	11a2c <__ssrefill_r>
    e6be:	cmp	r0, #0
    e6c0:	bne.w	e23e <__ssvfscanf_r+0x24a>
    e6c4:	ldr	r3, [pc, #504]	; (e8c0 <__ssvfscanf_r+0x8cc>)
    e6c6:	str	r0, [sp, #16]
    e6c8:	str	r3, [sp, #28]
    e6ca:	movs	r6, #3
    e6cc:	b.n	e200 <__ssvfscanf_r+0x20c>
    e6ce:	mov	r1, fp
    e6d0:	mov	r0, sl
    e6d2:	bl	11a2c <__ssrefill_r>
    e6d6:	cmp	r0, #0
    e6d8:	beq.w	e36e <__ssvfscanf_r+0x37a>
    e6dc:	b.n	e23e <__ssvfscanf_r+0x24a>
    e6de:	mov	r1, fp
    e6e0:	mov	r0, sl
    e6e2:	bl	11a2c <__ssrefill_r>
    e6e6:	cmp	r0, #0
    e6e8:	beq.w	e304 <__ssvfscanf_r+0x310>
    e6ec:	b.n	e23e <__ssvfscanf_r+0x24a>
    e6ee:	mov	r1, fp
    e6f0:	mov	r0, sl
    e6f2:	bl	11a2c <__ssrefill_r>
    e6f6:	cmp	r0, #0
    e6f8:	beq.w	e432 <__ssvfscanf_r+0x43e>
    e6fc:	b.n	e23e <__ssvfscanf_r+0x24a>
    e6fe:	mov	r1, fp
    e700:	mov	r0, sl
    e702:	bl	11a2c <__ssrefill_r>
    e706:	cmp	r0, #0
    e708:	beq.w	e296 <__ssvfscanf_r+0x2a2>
    e70c:	b.n	e23e <__ssvfscanf_r+0x24a>
    e70e:	mov	r1, fp
    e710:	mov	r0, sl
    e712:	bl	11a2c <__ssrefill_r>
    e716:	cmp	r0, #0
    e718:	beq.w	e27e <__ssvfscanf_r+0x28a>
    e71c:	b.n	e23e <__ssvfscanf_r+0x24a>
    e71e:	cmp	r6, #3
    e720:	beq.w	ea62 <__ssvfscanf_r+0xa6e>
    e724:	cmp	r6, #4
    e726:	bne.w	eba4 <__ssvfscanf_r+0xbb0>
    e72a:	mov	r0, sl
    e72c:	bl	10968 <_localeconv_r>
    e730:	subs	r3, r4, #1
    e732:	ldr	r2, [r0, #0]
    e734:	str	r2, [sp, #48]	; 0x30
    e736:	cmp.w	r3, #348	; 0x15c
    e73a:	bls.w	ec0c <__ssvfscanf_r+0xc18>
    e73e:	mvn.w	r1, #348	; 0x15c
    e742:	adds	r3, r4, r1
    e744:	str	r3, [sp, #56]	; 0x38
    e746:	movw	r4, #349	; 0x15d
    e74a:	add	r3, sp, #336	; 0x150
    e74c:	mov.w	r8, #0
    e750:	mov	r2, r3
    e752:	str	r3, [sp, #40]	; 0x28
    e754:	orr.w	r5, r5, #1920	; 0x780
    e758:	mov	r3, r8
    e75a:	str.w	r8, [sp, #60]	; 0x3c
    e75e:	str.w	r8, [sp, #52]	; 0x34
    e762:	mov	r6, r8
    e764:	str.w	r8, [sp, #44]	; 0x2c
    e768:	mov	r9, r2
    e76a:	ldr.w	r0, [fp]
    e76e:	ldrb	r1, [r0, #0]
    e770:	sub.w	lr, r1, #43	; 0x2b
    e774:	cmp.w	lr, #78	; 0x4e
    e778:	bhi.w	ea12 <__ssvfscanf_r+0xa1e>
    e77c:	tbh	[pc, lr, lsl #1]
    e780:	.word	0x0149007a
    e784:	.word	0x0149007a
    e788:	.word	0x006e0149
    e78c:	.word	0x004f004f
    e790:	.word	0x004f004f
    e794:	.word	0x004f004f
    e798:	.word	0x004f004f
    e79c:	.word	0x0149004f
    e7a0:	.word	0x01490149
    e7a4:	.word	0x01490149
    e7a8:	.word	0x01490149
    e7ac:	.word	0x01490144
    e7b0:	.word	0x01490149
    e7b4:	.word	0x0125012c
    e7b8:	.word	0x01490149
    e7bc:	.word	0x014900a2
    e7c0:	.word	0x01490149
    e7c4:	.word	0x008b0149
    e7c8:	.word	0x01490149
    e7cc:	.word	0x01490149
    e7d0:	.word	0x00850149
    e7d4:	.word	0x01490149
    e7d8:	.word	0x01490149
    e7dc:	.word	0x0149007f
    e7e0:	.word	0x01490149
    e7e4:	.word	0x01490149
    e7e8:	.word	0x01490149
    e7ec:	.word	0x01490144
    e7f0:	.word	0x01490149
    e7f4:	.word	0x0125012c
    e7f8:	.word	0x01490149
    e7fc:	.word	0x014900a2
    e800:	.word	0x01490149
    e804:	.word	0x008b0149
    e808:	.word	0x01490149
    e80c:	.word	0x01490149
    e810:	.word	0x00850149
    e814:	.word	0x01490149
    e818:	.word	0x01490149
    e81c:	.short	0x007f
    e81e:	cmn.w	r3, r8
    e822:	bne.n	e852 <__ssvfscanf_r+0x85e>
    e824:	bic.w	r5, r5, #384	; 0x180
    e828:	strb.w	r1, [r9]
    e82c:	add.w	r9, r9, #1
    e830:	ldr.w	r1, [fp, #4]
    e834:	subs	r1, #1
    e836:	cmp	r1, #0
    e838:	add.w	r4, r4, #4294967295
    e83c:	add.w	r7, r7, #1
    e840:	str.w	r1, [fp, #4]
    e844:	ble.w	ea2c <__ssvfscanf_r+0xa38>
    e848:	adds	r0, #1
    e84a:	str.w	r0, [fp]
    e84e:	cmp	r4, #0
    e850:	bne.n	e76a <__ssvfscanf_r+0x776>
    e852:	cmp	r6, #0
    e854:	beq.n	e8dc <__ssvfscanf_r+0x8e8>
    e856:	bic.w	r5, r5, #256	; 0x100
    e85a:	b.n	e8dc <__ssvfscanf_r+0x8e8>
    e85c:	lsls	r2, r5, #23
    e85e:	bpl.n	e81e <__ssvfscanf_r+0x82a>
    e860:	ldr	r2, [sp, #56]	; 0x38
    e862:	bic.w	r5, r5, #128	; 0x80
    e866:	adds	r6, #1
    e868:	cmp	r2, #0
    e86a:	beq.n	e830 <__ssvfscanf_r+0x83c>
    e86c:	subs	r2, #1
    e86e:	str	r2, [sp, #56]	; 0x38
    e870:	adds	r4, #1
    e872:	b.n	e830 <__ssvfscanf_r+0x83c>
    e874:	lsls	r2, r5, #24
    e876:	bpl.n	e852 <__ssvfscanf_r+0x85e>
    e878:	bic.w	r5, r5, #128	; 0x80
    e87c:	b.n	e828 <__ssvfscanf_r+0x834>
    e87e:	cmp.w	r8, #7
    e882:	bne.n	e852 <__ssvfscanf_r+0x85e>
    e884:	mov.w	r8, #8
    e888:	b.n	e828 <__ssvfscanf_r+0x834>
    e88a:	cmp.w	r8, #6
    e88e:	bne.n	e852 <__ssvfscanf_r+0x85e>
    e890:	mov.w	r8, #7
    e894:	b.n	e828 <__ssvfscanf_r+0x834>
    e896:	cmp	r3, #0
    e898:	bne.w	ea58 <__ssvfscanf_r+0xa64>
    e89c:	cbnz	r6, e8aa <__ssvfscanf_r+0x8b6>
    e89e:	and.w	lr, r5, #1792	; 0x700
    e8a2:	cmp.w	lr, #1792	; 0x700
    e8a6:	beq.w	ed30 <__ssvfscanf_r+0xd3c>
    e8aa:	cmp.w	r8, #1
    e8ae:	beq.n	e8b6 <__ssvfscanf_r+0x8c2>
    e8b0:	cmp.w	r8, #4
    e8b4:	bne.n	e852 <__ssvfscanf_r+0x85e>
    e8b6:	add.w	r8, r8, #1
    e8ba:	uxtb.w	r8, r8
    e8be:	b.n	e828 <__ssvfscanf_r+0x834>
    e8c0:	.word	0x0000c8e9
    e8c4:	cmp.w	r8, #0
    e8c8:	bne.w	ea46 <__ssvfscanf_r+0xa52>
    e8cc:	cmp	r6, #0
    e8ce:	bne.n	e856 <__ssvfscanf_r+0x862>
    e8d0:	and.w	lr, r5, #1792	; 0x700
    e8d4:	cmp.w	lr, #1792	; 0x700
    e8d8:	beq.w	ed50 <__ssvfscanf_r+0xd5c>
    e8dc:	subs	r3, #1
    e8de:	cmp	r3, #1
    e8e0:	bls.w	ede6 <__ssvfscanf_r+0xdf2>
    e8e4:	add.w	r3, r8, #4294967295
    e8e8:	cmp	r3, #6
    e8ea:	bhi.n	e91a <__ssvfscanf_r+0x926>
    e8ec:	cmp.w	r8, #2
    e8f0:	bls.w	ee34 <__ssvfscanf_r+0xe40>
    e8f4:	cmp.w	r8, #3
    e8f8:	beq.n	e91a <__ssvfscanf_r+0x926>
    e8fa:	sub.w	r4, r8, #4
    e8fe:	uxtb	r4, r4
    e900:	mvn.w	r8, r4
    e904:	add	r8, r9
    e906:	ldrb.w	r1, [r9, #-1]!
    e90a:	mov	r2, fp
    e90c:	mov	r0, sl
    e90e:	bl	119a8 <_sungetc_r>
    e912:	cmp	r8, r9
    e914:	bne.n	e906 <__ssvfscanf_r+0x912>
    e916:	subs	r7, #1
    e918:	subs	r7, r7, r4
    e91a:	lsls	r1, r5, #23
    e91c:	bpl.n	e958 <__ssvfscanf_r+0x964>
    e91e:	lsls	r2, r5, #21
    e920:	bmi.w	ee0a <__ssvfscanf_r+0xe16>
    e924:	ldrb.w	r1, [r9, #-1]
    e928:	cmp	r1, #101	; 0x65
    e92a:	add.w	r4, r9, #4294967295
    e92e:	add.w	r8, r7, #4294967295
    e932:	beq.n	e94c <__ssvfscanf_r+0x958>
    e934:	cmp	r1, #69	; 0x45
    e936:	beq.n	e94c <__ssvfscanf_r+0x958>
    e938:	mov	r2, fp
    e93a:	mov	r0, sl
    e93c:	bl	119a8 <_sungetc_r>
    e940:	ldrb.w	r1, [r9, #-2]
    e944:	sub.w	r8, r7, #2
    e948:	sub.w	r4, r9, #2
    e94c:	mov	r2, fp
    e94e:	mov	r0, sl
    e950:	bl	119a8 <_sungetc_r>
    e954:	mov	r7, r8
    e956:	mov	r9, r4
    e958:	ands.w	r2, r5, #16
    e95c:	bne.w	e4bc <__ssvfscanf_r+0x4c8>
    e960:	and.w	r3, r5, #1536	; 0x600
    e964:	cmp.w	r3, #1024	; 0x400
    e968:	strb.w	r2, [r9]
    e96c:	beq.w	ed5a <__ssvfscanf_r+0xd66>
    e970:	ldr	r3, [sp, #52]	; 0x34
    e972:	cmp	r3, #0
    e974:	bne.w	ed7c <__ssvfscanf_r+0xd88>
    e978:	ldr	r1, [sp, #40]	; 0x28
    e97a:	movs	r2, #0
    e97c:	mov	r0, sl
    e97e:	bl	c790 <_strtod_r>
    e982:	lsls	r3, r5, #31
    e984:	bmi.w	ec12 <__ssvfscanf_r+0xc1e>
    e988:	ands.w	r5, r5, #2
    e98c:	bne.w	ec12 <__ssvfscanf_r+0xc1e>
    e990:	vmov	r2, r3, d0
    e994:	vmov	r0, r1, d0
    e998:	vstr	d0, [sp, #32]
    e99c:	bl	a590 <__aeabi_dcmpun>
    e9a0:	ldr	r4, [sp, #20]
    e9a2:	vldr	d0, [sp, #32]
    e9a6:	adds	r6, r4, #4
    e9a8:	ldr	r4, [r4, #0]
    e9aa:	cmp	r0, #0
    e9ac:	bne.w	ee68 <__ssvfscanf_r+0xe74>
    e9b0:	vmov	r0, r1, d0
    e9b4:	bl	a64c <__aeabi_d2f>
    e9b8:	str	r6, [sp, #20]
    e9ba:	str	r0, [r4, #0]
    e9bc:	ldr	r3, [sp, #24]
    e9be:	ldr	r6, [sp, #12]
    e9c0:	adds	r3, #1
    e9c2:	str	r3, [sp, #24]
    e9c4:	mov	r4, r6
    e9c6:	b.w	e084 <__ssvfscanf_r+0x90>
    e9ca:	cmp.w	r8, #2
    e9ce:	bne.w	e852 <__ssvfscanf_r+0x85e>
    e9d2:	mov.w	r8, #3
    e9d6:	b.n	e828 <__ssvfscanf_r+0x834>
    e9d8:	and.w	lr, r5, #1280	; 0x500
    e9dc:	cmp.w	lr, #1024	; 0x400
    e9e0:	beq.n	e9ee <__ssvfscanf_r+0x9fa>
    e9e2:	lsls	r2, r5, #21
    e9e4:	bpl.w	e852 <__ssvfscanf_r+0x85e>
    e9e8:	cmp	r6, #0
    e9ea:	beq.w	e8dc <__ssvfscanf_r+0x8e8>
    e9ee:	lsls	r2, r5, #22
    e9f0:	bmi.n	e9fc <__ssvfscanf_r+0xa08>
    e9f2:	ldr	r2, [sp, #44]	; 0x2c
    e9f4:	str.w	r9, [sp, #60]	; 0x3c
    e9f8:	subs	r2, r6, r2
    e9fa:	str	r2, [sp, #52]	; 0x34
    e9fc:	bic.w	r5, r5, #1920	; 0x780
    ea00:	orr.w	r5, r5, #384	; 0x180
    ea04:	movs	r6, #0
    ea06:	b.n	e828 <__ssvfscanf_r+0x834>
    ea08:	cmp	r3, #1
    ea0a:	bne.w	e852 <__ssvfscanf_r+0x85e>
    ea0e:	movs	r3, #2
    ea10:	b.n	e828 <__ssvfscanf_r+0x834>
    ea12:	ldr	r2, [sp, #48]	; 0x30
    ea14:	ldrb.w	lr, [r2]
    ea18:	cmp	lr, r1
    ea1a:	bne.w	e852 <__ssvfscanf_r+0x85e>
    ea1e:	lsls	r2, r5, #22
    ea20:	bpl.w	e852 <__ssvfscanf_r+0x85e>
    ea24:	bic.w	r5, r5, #640	; 0x280
    ea28:	str	r6, [sp, #44]	; 0x2c
    ea2a:	b.n	e828 <__ssvfscanf_r+0x834>
    ea2c:	mov	r1, fp
    ea2e:	mov	r0, sl
    ea30:	str	r3, [sp, #32]
    ea32:	bl	11a2c <__ssrefill_r>
    ea36:	ldr	r3, [sp, #32]
    ea38:	cmp	r0, #0
    ea3a:	bne.w	e852 <__ssvfscanf_r+0x85e>
    ea3e:	cmp	r4, #0
    ea40:	bne.w	e76a <__ssvfscanf_r+0x776>
    ea44:	b.n	e852 <__ssvfscanf_r+0x85e>
    ea46:	cmp.w	r8, #3
    ea4a:	beq.w	e8b6 <__ssvfscanf_r+0x8c2>
    ea4e:	cmp.w	r8, #5
    ea52:	beq.w	e8b6 <__ssvfscanf_r+0x8c2>
    ea56:	b.n	e852 <__ssvfscanf_r+0x85e>
    ea58:	cmp	r3, #2
    ea5a:	bne.w	e8aa <__ssvfscanf_r+0x8b6>
    ea5e:	movs	r3, #3
    ea60:	b.n	e828 <__ssvfscanf_r+0x834>
    ea62:	subs	r3, r4, #1
    ea64:	cmp.w	r3, #348	; 0x15c
    ea68:	itte	hi
    ea6a:	mvnhi.w	r0, #348	; 0x15c
    ea6e:	addhi.w	r9, r4, r0
    ea72:	movls	r9, r8
    ea74:	add	r3, sp, #336	; 0x150
    ea76:	mov	r0, r2
    ea78:	mov	r2, r7
    ea7a:	mov	r7, r9
    ea7c:	ldr.w	r9, [sp, #16]
    ea80:	str	r3, [sp, #40]	; 0x28
    ea82:	it	hi
    ea84:	movwhi	r4, #349	; 0x15d
    ea88:	orr.w	r5, r5, #3456	; 0xd80
    ea8c:	mov	r6, r3
    ea8e:	mov.w	r8, #0
    ea92:	sub.w	r3, r1, #43	; 0x2b
    ea96:	cmp	r3, #77	; 0x4d
    ea98:	bhi.n	eb3e <__ssvfscanf_r+0xb4a>
    ea9a:	tbb	[pc, r3]
    ea9e:	.short	0x507e
    eaa0:	.word	0x6f50507e
    eaa4:	.word	0x69696969
    eaa8:	.word	0x4a696969
    eaac:	.word	0x5050504a
    eab0:	.word	0x50505050
    eab4:	.word	0x44444444
    eab8:	.word	0x50504444
    eabc:	.word	0x50505050
    eac0:	.word	0x50505050
    eac4:	.word	0x50505050
    eac8:	.word	0x27505050
    eacc:	.word	0x50505050
    ead0:	.word	0x50505050
    ead4:	.word	0x44444444
    ead8:	.word	0x50504444
    eadc:	.word	0x50505050
    eae0:	.word	0x50505050
    eae4:	.word	0x50505050
    eae8:	.word	0x27505050
    eaec:	and.w	r3, r5, #1536	; 0x600
    eaf0:	cmp.w	r3, #512	; 0x200
    eaf4:	bne.n	eb3e <__ssvfscanf_r+0xb4a>
    eaf6:	bic.w	r5, r5, #512	; 0x200
    eafa:	orr.w	r5, r5, #1280	; 0x500
    eafe:	mov.w	r9, #16
    eb02:	strb	r1, [r6, #0]
    eb04:	adds	r6, #1
    eb06:	ldr.w	r3, [fp, #4]
    eb0a:	subs	r3, #1
    eb0c:	cmp	r3, #0
    eb0e:	str.w	r3, [fp, #4]
    eb12:	ble.n	ebfa <__ssvfscanf_r+0xc06>
    eb14:	adds	r0, #1
    eb16:	str.w	r0, [fp]
    eb1a:	subs	r4, #1
    eb1c:	beq.n	eb3e <__ssvfscanf_r+0xb4a>
    eb1e:	ldr.w	r0, [fp]
    eb22:	ldrb	r1, [r0, #0]
    eb24:	b.n	ea92 <__ssvfscanf_r+0xa9e>
    eb26:	cmp.w	r9, #10
    eb2a:	ble.n	eb3e <__ssvfscanf_r+0xb4a>
    eb2c:	bic.w	r5, r5, #2944	; 0xb80
    eb30:	b.n	eb02 <__ssvfscanf_r+0xb0e>
    eb32:	ldr	r3, [pc, #756]	; (ee28 <__ssvfscanf_r+0xe34>)
    eb34:	ldrsh.w	r9, [r3, r9, lsl #1]
    eb38:	cmp.w	r9, #8
    eb3c:	bgt.n	eb2c <__ssvfscanf_r+0xb38>
    eb3e:	lsls	r1, r5, #23
    eb40:	mov	r7, r2
    eb42:	str.w	r9, [sp, #16]
    eb46:	bpl.n	eb58 <__ssvfscanf_r+0xb64>
    eb48:	ldr	r3, [sp, #40]	; 0x28
    eb4a:	cmp	r6, r3
    eb4c:	bhi.w	ed38 <__ssvfscanf_r+0xd44>
    eb50:	ldr	r3, [sp, #40]	; 0x28
    eb52:	cmp	r6, r3
    eb54:	beq.w	e090 <__ssvfscanf_r+0x9c>
    eb58:	ands.w	r4, r5, #16
    eb5c:	beq.w	ec84 <__ssvfscanf_r+0xc90>
    eb60:	ldr	r3, [sp, #40]	; 0x28
    eb62:	subs	r6, r6, r3
    eb64:	add	r6, r8
    eb66:	add	r7, r6
    eb68:	ldr	r6, [sp, #12]
    eb6a:	mov	r4, r6
    eb6c:	b.w	e084 <__ssvfscanf_r+0x90>
    eb70:	ldr	r3, [pc, #692]	; (ee28 <__ssvfscanf_r+0xe34>)
    eb72:	bic.w	r5, r5, #2944	; 0xb80
    eb76:	ldrsh.w	r9, [r3, r9, lsl #1]
    eb7a:	b.n	eb02 <__ssvfscanf_r+0xb0e>
    eb7c:	lsls	r3, r5, #20
    eb7e:	bpl.n	eb02 <__ssvfscanf_r+0xb0e>
    eb80:	cmp.w	r9, #0
    eb84:	bne.n	eb8e <__ssvfscanf_r+0xb9a>
    eb86:	orr.w	r5, r5, #512	; 0x200
    eb8a:	mov.w	r9, #8
    eb8e:	lsls	r3, r5, #21
    eb90:	bpl.w	ed14 <__ssvfscanf_r+0xd20>
    eb94:	bic.w	r5, r5, #1408	; 0x580
    eb98:	b.n	eb02 <__ssvfscanf_r+0xb0e>
    eb9a:	lsls	r3, r5, #24
    eb9c:	bpl.n	eb3e <__ssvfscanf_r+0xb4a>
    eb9e:	bic.w	r5, r5, #128	; 0x80
    eba2:	b.n	eb02 <__ssvfscanf_r+0xb0e>
    eba4:	cmp	r4, #0
    eba6:	it	eq
    eba8:	moveq.w	r4, #4294967295
    ebac:	ands.w	r3, r5, #1
    ebb0:	bne.w	e470 <__ssvfscanf_r+0x47c>
    ebb4:	lsls	r1, r5, #27
    ebb6:	bpl.n	ec20 <__ssvfscanf_r+0xc2c>
    ebb8:	mov	r5, r3
    ebba:	bl	aaa8 <__locale_ctype_ptr>
    ebbe:	ldr.w	r3, [fp]
    ebc2:	ldrb	r2, [r3, #0]
    ebc4:	add	r0, r2
    ebc6:	adds	r3, #1
    ebc8:	ldrb	r2, [r0, #1]
    ebca:	lsls	r2, r2, #28
    ebcc:	bmi.w	e34e <__ssvfscanf_r+0x35a>
    ebd0:	ldr.w	r2, [fp, #4]
    ebd4:	str.w	r3, [fp]
    ebd8:	adds	r5, #1
    ebda:	subs	r3, r2, #1
    ebdc:	cmp	r4, r5
    ebde:	str.w	r3, [fp, #4]
    ebe2:	beq.w	e34e <__ssvfscanf_r+0x35a>
    ebe6:	cmp	r3, #0
    ebe8:	bgt.n	ebba <__ssvfscanf_r+0xbc6>
    ebea:	mov	r1, fp
    ebec:	mov	r0, sl
    ebee:	bl	11a2c <__ssrefill_r>
    ebf2:	cmp	r0, #0
    ebf4:	beq.n	ebba <__ssvfscanf_r+0xbc6>
    ebf6:	b.w	e34e <__ssvfscanf_r+0x35a>
    ebfa:	mov	r1, fp
    ebfc:	mov	r0, sl
    ebfe:	str	r2, [sp, #16]
    ec00:	bl	11a2c <__ssrefill_r>
    ec04:	ldr	r2, [sp, #16]
    ec06:	cmp	r0, #0
    ec08:	beq.n	eb1a <__ssvfscanf_r+0xb26>
    ec0a:	b.n	eb3e <__ssvfscanf_r+0xb4a>
    ec0c:	str.w	r8, [sp, #56]	; 0x38
    ec10:	b.n	e74a <__ssvfscanf_r+0x756>
    ec12:	ldr	r2, [sp, #20]
    ec14:	ldr	r3, [r2, #0]
    ec16:	adds	r2, #4
    ec18:	str	r2, [sp, #20]
    ec1a:	vstr	d0, [r3]
    ec1e:	b.n	e9bc <__ssvfscanf_r+0x9c8>
    ec20:	ldr	r2, [sp, #20]
    ec22:	ldr	r5, [r2, #0]
    ec24:	adds	r6, r2, #4
    ec26:	add	r4, r5
    ec28:	mov	r8, r5
    ec2a:	bl	aaa8 <__locale_ctype_ptr>
    ec2e:	ldr.w	r2, [fp]
    ec32:	ldrb	r3, [r2, #0]
    ec34:	add	r0, r3
    ec36:	adds	r1, r2, #1
    ec38:	ldrb	r3, [r0, #1]
    ec3a:	lsls	r3, r3, #28
    ec3c:	bmi.n	ec6a <__ssvfscanf_r+0xc76>
    ec3e:	ldr.w	r3, [fp, #4]
    ec42:	str.w	r1, [fp]
    ec46:	subs	r3, #1
    ec48:	str.w	r3, [fp, #4]
    ec4c:	ldrb	r3, [r2, #0]
    ec4e:	strb.w	r3, [r8], #1
    ec52:	cmp	r4, r8
    ec54:	beq.n	ec6c <__ssvfscanf_r+0xc78>
    ec56:	ldr.w	r3, [fp, #4]
    ec5a:	cmp	r3, #0
    ec5c:	bgt.n	ec2a <__ssvfscanf_r+0xc36>
    ec5e:	mov	r1, fp
    ec60:	mov	r0, sl
    ec62:	bl	11a2c <__ssrefill_r>
    ec66:	cmp	r0, #0
    ec68:	beq.n	ec2a <__ssvfscanf_r+0xc36>
    ec6a:	mov	r4, r8
    ec6c:	ldr	r2, [sp, #24]
    ec6e:	str	r6, [sp, #20]
    ec70:	ldr	r6, [sp, #12]
    ec72:	subs	r5, r4, r5
    ec74:	movs	r3, #0
    ec76:	adds	r2, #1
    ec78:	strb	r3, [r4, #0]
    ec7a:	add	r7, r5
    ec7c:	str	r2, [sp, #24]
    ec7e:	mov	r4, r6
    ec80:	b.w	e084 <__ssvfscanf_r+0x90>
    ec84:	mov	r2, r4
    ec86:	strb	r4, [r6, #0]
    ec88:	ldr	r3, [sp, #16]
    ec8a:	ldr	r1, [sp, #40]	; 0x28
    ec8c:	ldr	r4, [sp, #28]
    ec8e:	mov	r0, sl
    ec90:	blx	r4
    ec92:	lsls	r2, r5, #26
    ec94:	bmi.n	ed24 <__ssvfscanf_r+0xd30>
    ec96:	lsls	r3, r5, #29
    ec98:	bpl.n	ed92 <__ssvfscanf_r+0xd9e>
    ec9a:	ldr	r2, [sp, #20]
    ec9c:	ldr	r3, [r2, #0]
    ec9e:	adds	r2, #4
    eca0:	str	r2, [sp, #20]
    eca2:	strh	r0, [r3, #0]
    eca4:	ldr	r3, [sp, #24]
    eca6:	adds	r3, #1
    eca8:	str	r3, [sp, #24]
    ecaa:	b.n	eb60 <__ssvfscanf_r+0xb6c>
    ecac:	bl	aa84 <__locale_mb_cur_max>
    ecb0:	cmp	r6, r0
    ecb2:	beq.w	e23e <__ssvfscanf_r+0x24a>
    ecb6:	ldmia.w	fp, {r2, r3}
    ecba:	ldrb.w	r0, [r2], #1
    ecbe:	str.w	r2, [fp]
    ecc2:	ldr	r2, [sp, #32]
    ecc4:	str	r2, [sp, #0]
    ecc6:	add	r2, sp, #336	; 0x150
    ecc8:	adds	r5, r6, #1
    ecca:	subs	r3, #1
    eccc:	strb	r0, [r2, r6]
    ecce:	str.w	r3, [fp, #4]
    ecd2:	mov	r1, r8
    ecd4:	mov	r3, r5
    ecd6:	mov	r0, sl
    ecd8:	bl	10984 <_mbrtowc_r>
    ecdc:	adds	r6, r0, #1
    ecde:	beq.w	e23e <__ssvfscanf_r+0x24a>
    ece2:	cmp	r0, #0
    ece4:	bne.n	edbe <__ssvfscanf_r+0xdca>
    ece6:	str.w	r0, [r8]
    ecea:	bl	10948 <iswspace>
    ecee:	cmp	r0, #0
    ecf0:	beq.w	ee52 <__ssvfscanf_r+0xe5e>
    ecf4:	cmp	r5, #0
    ecf6:	beq.w	e4ac <__ssvfscanf_r+0x4b8>
    ecfa:	add	r3, sp, #336	; 0x150
    ecfc:	adds	r4, r3, r5
    ecfe:	subs	r5, #1
    ed00:	mov	r2, fp
    ed02:	ldrb.w	r1, [r4, #-1]!
    ed06:	mov	r0, sl
    ed08:	bl	119a8 <_sungetc_r>
    ed0c:	cmp	r5, #0
    ed0e:	bne.n	ecfe <__ssvfscanf_r+0xd0a>
    ed10:	b.w	e4ac <__ssvfscanf_r+0x4b8>
    ed14:	bic.w	r5, r5, #896	; 0x380
    ed18:	cbz	r7, ed1e <__ssvfscanf_r+0xd2a>
    ed1a:	subs	r7, #1
    ed1c:	adds	r4, #1
    ed1e:	add.w	r8, r8, #1
    ed22:	b.n	eb06 <__ssvfscanf_r+0xb12>
    ed24:	ldr	r2, [sp, #20]
    ed26:	ldr	r3, [r2, #0]
    ed28:	adds	r2, #4
    ed2a:	str	r2, [sp, #20]
    ed2c:	str	r0, [r3, #0]
    ed2e:	b.n	eca4 <__ssvfscanf_r+0xcb0>
    ed30:	bic.w	r5, r5, #1920	; 0x780
    ed34:	movs	r3, #1
    ed36:	b.n	e828 <__ssvfscanf_r+0x834>
    ed38:	ldrb.w	r1, [r6, #-1]
    ed3c:	mov	r2, fp
    ed3e:	mov	r0, sl
    ed40:	bl	119a8 <_sungetc_r>
    ed44:	subs	r6, #1
    ed46:	b.n	eb50 <__ssvfscanf_r+0xb5c>
    ed48:	add.w	r8, sp, #68	; 0x44
    ed4c:	b.w	e492 <__ssvfscanf_r+0x49e>
    ed50:	bic.w	r5, r5, #1920	; 0x780
    ed54:	mov.w	r8, #1
    ed58:	b.n	e828 <__ssvfscanf_r+0x834>
    ed5a:	ldr	r3, [sp, #44]	; 0x2c
    ed5c:	subs	r6, r6, r3
    ed5e:	negs	r2, r6
    ed60:	cmp	r6, #0
    ed62:	beq.w	e978 <__ssvfscanf_r+0x984>
    ed66:	addw	r3, sp, #675	; 0x2a3
    ed6a:	cmp	r9, r3
    ed6c:	it	cs
    ed6e:	addwcs	r9, sp, #674	; 0x2a2
    ed72:	mov	r0, r9
    ed74:	ldr	r1, [pc, #180]	; (ee2c <__ssvfscanf_r+0xe38>)
    ed76:	bl	b658 <sprintf>
    ed7a:	b.n	e978 <__ssvfscanf_r+0x984>
    ed7c:	ldr	r4, [sp, #60]	; 0x3c
    ed7e:	mov	r1, r4
    ed80:	movs	r3, #10
    ed82:	adds	r1, #1
    ed84:	mov	r0, sl
    ed86:	bl	c8e8 <_strtol_r>
    ed8a:	ldr	r3, [sp, #52]	; 0x34
    ed8c:	mov	r9, r4
    ed8e:	subs	r2, r0, r3
    ed90:	b.n	ed66 <__ssvfscanf_r+0xd72>
    ed92:	ands.w	r2, r5, #1
    ed96:	bne.n	ed24 <__ssvfscanf_r+0xd30>
    ed98:	lsls	r4, r5, #30
    ed9a:	bpl.n	ed24 <__ssvfscanf_r+0xd30>
    ed9c:	ldr	r3, [sp, #28]
    ed9e:	mov	r1, r3
    eda0:	ldr	r3, [pc, #140]	; (ee30 <__ssvfscanf_r+0xe3c>)
    eda2:	cmp	r1, r3
    eda4:	mov	r0, sl
    eda6:	ldr	r3, [sp, #16]
    eda8:	ldr	r1, [sp, #40]	; 0x28
    edaa:	beq.n	ee76 <__ssvfscanf_r+0xe82>
    edac:	bl	114e8 <_strtoll_r>
    edb0:	ldr	r2, [sp, #20]
    edb2:	ldr	r3, [r2, #0]
    edb4:	adds	r2, #4
    edb6:	str	r2, [sp, #20]
    edb8:	strd	r0, r1, [r3]
    edbc:	b.n	eca4 <__ssvfscanf_r+0xcb0>
    edbe:	adds	r0, #2
    edc0:	bne.n	ee04 <__ssvfscanf_r+0xe10>
    edc2:	mov	r6, r5
    edc4:	ldr.w	r3, [fp, #4]
    edc8:	cmp	r3, #0
    edca:	bgt.w	e494 <__ssvfscanf_r+0x4a0>
    edce:	mov	r1, fp
    edd0:	mov	r0, sl
    edd2:	bl	11a2c <__ssrefill_r>
    edd6:	cmp	r0, #0
    edd8:	beq.w	e494 <__ssvfscanf_r+0x4a0>
    eddc:	cmp	r6, #0
    edde:	bne.w	e23e <__ssvfscanf_r+0x24a>
    ede2:	b.w	e4ac <__ssvfscanf_r+0x4b8>
    ede6:	ldr	r3, [sp, #40]	; 0x28
    ede8:	cmp	r9, r3
    edea:	bls.w	e090 <__ssvfscanf_r+0x9c>
    edee:	ldrb.w	r1, [r9, #-1]!
    edf2:	mov	r2, fp
    edf4:	mov	r0, sl
    edf6:	bl	119a8 <_sungetc_r>
    edfa:	ldr	r3, [sp, #40]	; 0x28
    edfc:	cmp	r9, r3
    edfe:	bne.n	edee <__ssvfscanf_r+0xdfa>
    ee00:	b.w	e090 <__ssvfscanf_r+0x9c>
    ee04:	ldr.w	r0, [r8]
    ee08:	b.n	ecea <__ssvfscanf_r+0xcf6>
    ee0a:	ldr	r3, [sp, #40]	; 0x28
    ee0c:	cmp	r9, r3
    ee0e:	bls.w	e090 <__ssvfscanf_r+0x9c>
    ee12:	ldrb.w	r1, [r9, #-1]!
    ee16:	mov	r2, fp
    ee18:	mov	r0, sl
    ee1a:	bl	119a8 <_sungetc_r>
    ee1e:	ldr	r3, [sp, #40]	; 0x28
    ee20:	cmp	r9, r3
    ee22:	bne.n	ee12 <__ssvfscanf_r+0xe1e>
    ee24:	b.w	e090 <__ssvfscanf_r+0x9c>
    ee28:	.word	0x0001297c
    ee2c:	.word	0x000129a0
    ee30:	.word	0x00011675
    ee34:	ldr	r3, [sp, #40]	; 0x28
    ee36:	cmp	r9, r3
    ee38:	bls.w	e090 <__ssvfscanf_r+0x9c>
    ee3c:	ldrb.w	r1, [r9, #-1]!
    ee40:	mov	r2, fp
    ee42:	mov	r0, sl
    ee44:	bl	119a8 <_sungetc_r>
    ee48:	ldr	r3, [sp, #40]	; 0x28
    ee4a:	cmp	r9, r3
    ee4c:	bne.n	ee3c <__ssvfscanf_r+0xe48>
    ee4e:	b.w	e090 <__ssvfscanf_r+0x9c>
    ee52:	add	r7, r5
    ee54:	subs	r4, #1
    ee56:	cmp.w	r9, #0
    ee5a:	bne.n	ee64 <__ssvfscanf_r+0xe70>
    ee5c:	add.w	r8, r8, #4
    ee60:	mov	r6, r9
    ee62:	b.n	edc4 <__ssvfscanf_r+0xdd0>
    ee64:	mov	r6, r0
    ee66:	b.n	edc4 <__ssvfscanf_r+0xdd0>
    ee68:	mov	r0, r5
    ee6a:	bl	9cbc <nanf>
    ee6e:	str	r6, [sp, #20]
    ee70:	vstr	s0, [r4]
    ee74:	b.n	e9bc <__ssvfscanf_r+0x9c8>
    ee76:	bl	11884 <_strtoull_r>
    ee7a:	b.n	edb0 <__ssvfscanf_r+0xdbc>

0000ee7c <_vdprintf_r>:
    ee7c:	push	{r4, r5, r6, r7, lr}
    ee7e:	sub.w	sp, sp, #532	; 0x214
    ee82:	add	r5, sp, #16
    ee84:	str	r3, [sp, #0]
    ee86:	mov	r7, r1
    ee88:	mov	r3, r2
    ee8a:	mov.w	r4, #512	; 0x200
    ee8e:	add	r2, sp, #12
    ee90:	mov	r1, r5
    ee92:	str	r4, [sp, #12]
    ee94:	mov	r6, r0
    ee96:	bl	11b64 <_vasnprintf_r>
    ee9a:	cbz	r0, eec0 <_vdprintf_r+0x44>
    ee9c:	mov	r4, r0
    ee9e:	mov	r2, r0
    eea0:	mov	r1, r7
    eea2:	ldr	r3, [sp, #12]
    eea4:	mov	r0, r6
    eea6:	bl	eefc <_write_r>
    eeaa:	cmp	r4, r5
    eeac:	str	r0, [sp, #12]
    eeae:	beq.n	eeba <_vdprintf_r+0x3e>
    eeb0:	mov	r0, r6
    eeb2:	mov	r1, r4
    eeb4:	bl	10010 <_free_r>
    eeb8:	ldr	r0, [sp, #12]
    eeba:	add.w	sp, sp, #532	; 0x214
    eebe:	pop	{r4, r5, r6, r7, pc}
    eec0:	mov.w	r0, #4294967295
    eec4:	b.n	eeba <_vdprintf_r+0x3e>
    eec6:	nop

0000eec8 <vdprintf>:
    eec8:	push	{r4}
    eeca:	ldr	r4, [pc, #16]	; (eedc <vdprintf+0x14>)
    eecc:	mov	r3, r2
    eece:	mov	r2, r1
    eed0:	mov	r1, r0
    eed2:	ldr	r0, [r4, #0]
    eed4:	ldr.w	r4, [sp], #4
    eed8:	b.w	ee7c <_vdprintf_r>
    eedc:	.word	0x1fff1840

0000eee0 <__ascii_wctomb>:
    eee0:	cbz	r1, eeec <__ascii_wctomb+0xc>
    eee2:	cmp	r2, #255	; 0xff
    eee4:	bhi.n	eef0 <__ascii_wctomb+0x10>
    eee6:	strb	r2, [r1, #0]
    eee8:	movs	r0, #1
    eeea:	bx	lr
    eeec:	mov	r0, r1
    eeee:	bx	lr
    eef0:	movs	r3, #138	; 0x8a
    eef2:	str	r3, [r0, #0]
    eef4:	mov.w	r0, #4294967295
    eef8:	bx	lr
    eefa:	nop

0000eefc <_write_r>:
    eefc:	push	{r4, r5, r6, lr}
    eefe:	mov	r5, r1
    ef00:	ldr	r4, [pc, #32]	; (ef24 <_write_r+0x28>)
    ef02:	mov	r1, r2
    ef04:	mov	r6, r0
    ef06:	mov	r2, r3
    ef08:	mov	r0, r5
    ef0a:	movs	r3, #0
    ef0c:	str	r3, [r4, #0]
    ef0e:	bl	21b0 <_write>
    ef12:	adds	r3, r0, #1
    ef14:	beq.n	ef18 <_write_r+0x1c>
    ef16:	pop	{r4, r5, r6, pc}
    ef18:	ldr	r3, [r4, #0]
    ef1a:	cmp	r3, #0
    ef1c:	beq.n	ef16 <_write_r+0x1a>
    ef1e:	str	r3, [r6, #0]
    ef20:	pop	{r4, r5, r6, pc}
    ef22:	nop
    ef24:	.word	0x1fff85ec

0000ef28 <__register_exitproc>:
    ef28:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    ef2c:	ldr	r4, [pc, #148]	; (efc4 <__register_exitproc+0x9c>)
    ef2e:	ldr	r5, [r4, #0]
    ef30:	ldr.w	r4, [r5, #328]	; 0x148
    ef34:	mov	r6, r0
    ef36:	mov	r8, r1
    ef38:	mov	sl, r2
    ef3a:	mov	r9, r3
    ef3c:	cbz	r4, efb0 <__register_exitproc+0x88>
    ef3e:	ldr	r0, [r4, #4]
    ef40:	cmp	r0, #31
    ef42:	bgt.n	ef74 <__register_exitproc+0x4c>
    ef44:	adds	r3, r0, #1
    ef46:	cbz	r6, ef66 <__register_exitproc+0x3e>
    ef48:	add.w	r5, r4, r0, lsl #2
    ef4c:	movs	r2, #1
    ef4e:	str.w	sl, [r5, #136]	; 0x88
    ef52:	ldr.w	r1, [r4, #392]	; 0x188
    ef56:	lsls	r2, r0
    ef58:	orrs	r1, r2
    ef5a:	cmp	r6, #2
    ef5c:	str.w	r1, [r4, #392]	; 0x188
    ef60:	str.w	r9, [r5, #264]	; 0x108
    ef64:	beq.n	efa4 <__register_exitproc+0x7c>
    ef66:	adds	r0, #2
    ef68:	str	r3, [r4, #4]
    ef6a:	str.w	r8, [r4, r0, lsl #2]
    ef6e:	movs	r0, #0
    ef70:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    ef74:	ldr	r3, [pc, #80]	; (efc8 <__register_exitproc+0xa0>)
    ef76:	cbz	r3, efba <__register_exitproc+0x92>
    ef78:	mov.w	r0, #400	; 0x190
    ef7c:	bl	aabc <malloc>
    ef80:	mov	r4, r0
    ef82:	cbz	r0, efba <__register_exitproc+0x92>
    ef84:	ldr.w	r3, [r5, #328]	; 0x148
    ef88:	movs	r7, #0
    ef8a:	stmia.w	r0, {r3, r7}
    ef8e:	str.w	r4, [r5, #328]	; 0x148
    ef92:	mov	r0, r7
    ef94:	movs	r3, #1
    ef96:	str.w	r7, [r4, #392]	; 0x188
    ef9a:	str.w	r7, [r4, #396]	; 0x18c
    ef9e:	cmp	r6, #0
    efa0:	beq.n	ef66 <__register_exitproc+0x3e>
    efa2:	b.n	ef48 <__register_exitproc+0x20>
    efa4:	ldr.w	r1, [r4, #396]	; 0x18c
    efa8:	orrs	r2, r1
    efaa:	str.w	r2, [r4, #396]	; 0x18c
    efae:	b.n	ef66 <__register_exitproc+0x3e>
    efb0:	add.w	r4, r5, #332	; 0x14c
    efb4:	str.w	r4, [r5, #328]	; 0x148
    efb8:	b.n	ef3e <__register_exitproc+0x16>
    efba:	mov.w	r0, #4294967295
    efbe:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    efc2:	nop
    efc4:	.word	0x000128a4
    efc8:	.word	0x0000aabd

0000efcc <register_fini>:
    efcc:	ldr	r3, [pc, #8]	; (efd8 <register_fini+0xc>)
    efce:	cbz	r3, efd6 <register_fini+0xa>
    efd0:	ldr	r0, [pc, #8]	; (efdc <register_fini+0x10>)
    efd2:	b.w	efe0 <atexit>
    efd6:	bx	lr
    efd8:	.word	0x00000000
    efdc:	.word	0x0000ff4d

0000efe0 <atexit>:
    efe0:	movs	r3, #0
    efe2:	mov	r1, r0
    efe4:	mov	r2, r3
    efe6:	mov	r0, r3
    efe8:	b.w	ef28 <__register_exitproc>

0000efec <quorem>:
    efec:	ldr	r2, [r0, #16]
    efee:	ldr	r3, [r1, #16]
    eff0:	cmp	r3, r2
    eff2:	bgt.w	f110 <quorem+0x124>
    eff6:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    effa:	add.w	r8, r3, #4294967295
    effe:	add.w	r7, r1, #20
    f002:	add.w	fp, r0, #20
    f006:	ldr.w	r2, [r7, r8, lsl #2]
    f00a:	ldr.w	r3, [fp, r8, lsl #2]
    f00e:	mov.w	r4, r8, lsl #2
    f012:	sub	sp, #12
    f014:	adds	r2, #1
    f016:	udiv	r9, r3, r2
    f01a:	add.w	r3, fp, r4
    f01e:	str	r4, [sp, #0]
    f020:	add.w	sl, r7, r4
    f024:	str	r3, [sp, #4]
    f026:	cmp.w	r9, #0
    f02a:	beq.n	f0a0 <quorem+0xb4>
    f02c:	movs	r5, #0
    f02e:	mov	ip, r7
    f030:	mov	lr, fp
    f032:	mov	r3, r5
    f034:	ldr.w	r6, [ip], #4
    f038:	ldr.w	r2, [lr]
    f03c:	uxth	r4, r6
    f03e:	mla	r5, r9, r4, r5
    f042:	lsrs	r6, r6, #16
    f044:	lsrs	r4, r5, #16
    f046:	mla	r4, r9, r6, r4
    f04a:	uxth	r5, r5
    f04c:	subs	r3, r3, r5
    f04e:	uxth	r6, r4
    f050:	uxtah	r3, r3, r2
    f054:	rsb	r6, r6, r2, lsr #16
    f058:	add.w	r6, r6, r3, asr #16
    f05c:	uxth	r3, r3
    f05e:	orr.w	r3, r3, r6, lsl #16
    f062:	cmp	sl, ip
    f064:	str.w	r3, [lr], #4
    f068:	mov.w	r5, r4, lsr #16
    f06c:	mov.w	r3, r6, asr #16
    f070:	bcs.n	f034 <quorem+0x48>
    f072:	ldr	r3, [sp, #0]
    f074:	ldr.w	r3, [fp, r3]
    f078:	cbnz	r3, f0a0 <quorem+0xb4>
    f07a:	ldr	r4, [sp, #4]
    f07c:	subs	r3, r4, #4
    f07e:	cmp	fp, r3
    f080:	bcs.n	f09c <quorem+0xb0>
    f082:	ldr.w	r3, [r4, #-4]
    f086:	cbnz	r3, f09c <quorem+0xb0>
    f088:	sub.w	r3, r4, #8
    f08c:	b.n	f094 <quorem+0xa8>
    f08e:	ldr	r2, [r3, #0]
    f090:	subs	r3, #4
    f092:	cbnz	r2, f09c <quorem+0xb0>
    f094:	cmp	fp, r3
    f096:	add.w	r8, r8, #4294967295
    f09a:	bcc.n	f08e <quorem+0xa2>
    f09c:	str.w	r8, [r0, #16]
    f0a0:	mov	r4, r0
    f0a2:	bl	10e88 <__mcmp>
    f0a6:	cmp	r0, #0
    f0a8:	blt.n	f108 <quorem+0x11c>
    f0aa:	add.w	r9, r9, #1
    f0ae:	mov	r5, fp
    f0b0:	movs	r3, #0
    f0b2:	ldr.w	r1, [r7], #4
    f0b6:	ldr	r0, [r5, #0]
    f0b8:	uxth	r2, r1
    f0ba:	subs	r2, r3, r2
    f0bc:	lsrs	r1, r1, #16
    f0be:	uxtah	r2, r2, r0
    f0c2:	rsb	r3, r1, r0, lsr #16
    f0c6:	add.w	r3, r3, r2, asr #16
    f0ca:	uxth	r1, r2
    f0cc:	orr.w	r1, r1, r3, lsl #16
    f0d0:	cmp	sl, r7
    f0d2:	str.w	r1, [r5], #4
    f0d6:	mov.w	r3, r3, asr #16
    f0da:	bcs.n	f0b2 <quorem+0xc6>
    f0dc:	ldr.w	r2, [fp, r8, lsl #2]
    f0e0:	add.w	r3, fp, r8, lsl #2
    f0e4:	cbnz	r2, f108 <quorem+0x11c>
    f0e6:	subs	r2, r3, #4
    f0e8:	cmp	fp, r2
    f0ea:	bcs.n	f104 <quorem+0x118>
    f0ec:	ldr.w	r2, [r3, #-4]
    f0f0:	cbnz	r2, f104 <quorem+0x118>
    f0f2:	subs	r3, #8
    f0f4:	b.n	f0fc <quorem+0x110>
    f0f6:	ldr	r2, [r3, #0]
    f0f8:	subs	r3, #4
    f0fa:	cbnz	r2, f104 <quorem+0x118>
    f0fc:	cmp	fp, r3
    f0fe:	add.w	r8, r8, #4294967295
    f102:	bcc.n	f0f6 <quorem+0x10a>
    f104:	str.w	r8, [r4, #16]
    f108:	mov	r0, r9
    f10a:	add	sp, #12
    f10c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    f110:	movs	r0, #0
    f112:	bx	lr
    f114:			; <UNDEFINED> instruction: 0xffffffff

0000f118 <_dtoa_r>:
    f118:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f11c:	vmov	r6, r7, d0
    f120:	sub	sp, #108	; 0x6c
    f122:	ldr	r4, [r0, #64]	; 0x40
    f124:	ldr	r5, [sp, #144]	; 0x90
    f126:	str	r1, [sp, #0]
    f128:	mov	r9, r0
    f12a:	str	r2, [sp, #20]
    f12c:	str	r3, [sp, #12]
    f12e:	vmov	sl, s0
    f132:	mov	fp, r7
    f134:	cbz	r4, f14c <_dtoa_r+0x34>
    f136:	ldr	r2, [r0, #68]	; 0x44
    f138:	str	r2, [r4, #4]
    f13a:	movs	r3, #1
    f13c:	lsls	r3, r2
    f13e:	str	r3, [r4, #8]
    f140:	mov	r1, r4
    f142:	bl	10a2c <_Bfree>
    f146:	movs	r3, #0
    f148:	str.w	r3, [r9, #64]	; 0x40
    f14c:	cmp.w	fp, #0
    f150:	mov	r4, fp
    f152:	blt.n	f1be <_dtoa_r+0xa6>
    f154:	movs	r3, #0
    f156:	str	r3, [r5, #0]
    f158:	ldr	r3, [pc, #644]	; (f3e0 <_dtoa_r+0x2c8>)
    f15a:	mov	r2, r3
    f15c:	ands	r3, r4
    f15e:	cmp	r3, r2
    f160:	beq.n	f190 <_dtoa_r+0x78>
    f162:	movs	r2, #0
    f164:	movs	r3, #0
    f166:	mov	r0, sl
    f168:	mov	r1, fp
    f16a:	bl	a52c <__aeabi_dcmpeq>
    f16e:	mov	r6, sl
    f170:	mov	r7, fp
    f172:	mov	r8, r0
    f174:	cbz	r0, f1ca <_dtoa_r+0xb2>
    f176:	ldr	r2, [sp, #12]
    f178:	movs	r3, #1
    f17a:	str	r3, [r2, #0]
    f17c:	ldr	r3, [sp, #148]	; 0x94
    f17e:	cmp	r3, #0
    f180:	beq.w	f300 <_dtoa_r+0x1e8>
    f184:	ldr	r0, [pc, #604]	; (f3e4 <_dtoa_r+0x2cc>)
    f186:	str	r0, [r3, #0]
    f188:	subs	r0, #1
    f18a:	add	sp, #108	; 0x6c
    f18c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    f190:	ldr	r2, [sp, #12]
    f192:	movw	r3, #9999	; 0x270f
    f196:	str	r3, [r2, #0]
    f198:	cmp.w	sl, #0
    f19c:	beq.w	f2d4 <_dtoa_r+0x1bc>
    f1a0:	ldr	r0, [pc, #580]	; (f3e8 <_dtoa_r+0x2d0>)
    f1a2:	ldr	r3, [sp, #148]	; 0x94
    f1a4:	cmp	r3, #0
    f1a6:	beq.n	f18a <_dtoa_r+0x72>
    f1a8:	ldrb	r3, [r0, #3]
    f1aa:	cmp	r3, #0
    f1ac:	beq.w	f304 <_dtoa_r+0x1ec>
    f1b0:	add.w	r3, r0, #8
    f1b4:	ldr	r2, [sp, #148]	; 0x94
    f1b6:	str	r3, [r2, #0]
    f1b8:	add	sp, #108	; 0x6c
    f1ba:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    f1be:	movs	r3, #1
    f1c0:	bic.w	r4, fp, #2147483648	; 0x80000000
    f1c4:	str	r3, [r5, #0]
    f1c6:	mov	fp, r4
    f1c8:	b.n	f158 <_dtoa_r+0x40>
    f1ca:	add	r2, sp, #96	; 0x60
    f1cc:	add	r1, sp, #100	; 0x64
    f1ce:	vmov	d0, r6, r7
    f1d2:	mov	r0, r9
    f1d4:	bl	11104 <__d2b>
    f1d8:	lsrs	r5, r4, #20
    f1da:	str	r0, [sp, #40]	; 0x28
    f1dc:	bne.w	f2e6 <_dtoa_r+0x1ce>
    f1e0:	ldr	r5, [sp, #96]	; 0x60
    f1e2:	ldr	r6, [sp, #100]	; 0x64
    f1e4:	add	r6, r5
    f1e6:	addw	r3, r6, #1074	; 0x432
    f1ea:	cmp	r3, #32
    f1ec:	ble.w	f700 <_dtoa_r+0x5e8>
    f1f0:	rsb	r3, r3, #64	; 0x40
    f1f4:	addw	r0, r6, #1042	; 0x412
    f1f8:	lsls	r4, r3
    f1fa:	lsr.w	r0, sl, r0
    f1fe:	orrs	r0, r4
    f200:	bl	9f70 <__aeabi_ui2d>
    f204:	movs	r3, #1
    f206:	subs	r4, r6, #1
    f208:	sub.w	r1, r1, #32505856	; 0x1f00000
    f20c:	str	r3, [sp, #60]	; 0x3c
    f20e:	movs	r2, #0
    f210:	ldr	r3, [pc, #472]	; (f3ec <_dtoa_r+0x2d4>)
    f212:	bl	9cf4 <__aeabi_dsub>
    f216:	add	r3, pc, #432	; (adr r3, f3c8 <_dtoa_r+0x2b0>)
    f218:	ldrd	r2, r3, [r3]
    f21c:	bl	a05c <__aeabi_dmul>
    f220:	add	r3, pc, #428	; (adr r3, f3d0 <_dtoa_r+0x2b8>)
    f222:	ldrd	r2, r3, [r3]
    f226:	bl	9cf8 <__adddf3>
    f22a:	mov	r6, r0
    f22c:	mov	r0, r4
    f22e:	mov	r7, r1
    f230:	bl	9f90 <__aeabi_i2d>
    f234:	add	r3, pc, #416	; (adr r3, f3d8 <_dtoa_r+0x2c0>)
    f236:	ldrd	r2, r3, [r3]
    f23a:	bl	a05c <__aeabi_dmul>
    f23e:	mov	r2, r0
    f240:	mov	r3, r1
    f242:	mov	r0, r6
    f244:	mov	r1, r7
    f246:	bl	9cf8 <__adddf3>
    f24a:	mov	r6, r0
    f24c:	mov	r7, r1
    f24e:	bl	a5bc <__aeabi_d2iz>
    f252:	movs	r2, #0
    f254:	str	r0, [sp, #16]
    f256:	movs	r3, #0
    f258:	mov	r0, r6
    f25a:	mov	r1, r7
    f25c:	bl	a540 <__aeabi_dcmplt>
    f260:	cmp	r0, #0
    f262:	bne.w	f6b6 <_dtoa_r+0x59e>
    f266:	ldr	r6, [sp, #16]
    f268:	cmp	r6, #22
    f26a:	bhi.w	f6b0 <_dtoa_r+0x598>
    f26e:	ldr	r3, [pc, #384]	; (f3f0 <_dtoa_r+0x2d8>)
    f270:	add.w	r3, r3, r6, lsl #3
    f274:	ldrd	r0, r1, [r3]
    f278:	mov	r2, sl
    f27a:	mov	r3, fp
    f27c:	bl	a57c <__aeabi_dcmpgt>
    f280:	cmp	r0, #0
    f282:	beq.w	f70a <_dtoa_r+0x5f2>
    f286:	subs	r3, r6, #1
    f288:	str	r3, [sp, #16]
    f28a:	movs	r3, #0
    f28c:	str	r3, [sp, #52]	; 0x34
    f28e:	subs	r5, r5, r4
    f290:	subs.w	r8, r5, #1
    f294:	bmi.w	f6ec <_dtoa_r+0x5d4>
    f298:	movs	r3, #0
    f29a:	str	r3, [sp, #28]
    f29c:	ldr	r3, [sp, #16]
    f29e:	cmp	r3, #0
    f2a0:	blt.w	f6da <_dtoa_r+0x5c2>
    f2a4:	add	r8, r3
    f2a6:	str	r3, [sp, #48]	; 0x30
    f2a8:	movs	r3, #0
    f2aa:	str	r3, [sp, #24]
    f2ac:	ldr	r3, [sp, #0]
    f2ae:	cmp	r3, #9
    f2b0:	bhi.n	f308 <_dtoa_r+0x1f0>
    f2b2:	cmp	r3, #5
    f2b4:	ble.w	ff40 <_dtoa_r+0xe28>
    f2b8:	subs	r3, #4
    f2ba:	str	r3, [sp, #0]
    f2bc:	movs	r6, #0
    f2be:	ldr	r3, [sp, #0]
    f2c0:	subs	r3, #2
    f2c2:	cmp	r3, #3
    f2c4:	bhi.w	ff0e <_dtoa_r+0xdf6>
    f2c8:	tbh	[pc, r3, lsl #1]
    f2cc:	.word	0x0224032b
    f2d0:	.word	0x04500336
    f2d4:	ldr	r3, [pc, #272]	; (f3e8 <_dtoa_r+0x2d0>)
    f2d6:	ldr	r2, [pc, #284]	; (f3f4 <_dtoa_r+0x2dc>)
    f2d8:	ubfx	r0, r4, #0, #20
    f2dc:	cmp	r0, #0
    f2de:	ite	ne
    f2e0:	movne	r0, r3
    f2e2:	moveq	r0, r2
    f2e4:	b.n	f1a2 <_dtoa_r+0x8a>
    f2e6:	ubfx	r3, fp, #0, #20
    f2ea:	orr.w	r1, r3, #1069547520	; 0x3fc00000
    f2ee:	subw	r4, r5, #1023	; 0x3ff
    f2f2:	mov	r0, sl
    f2f4:	str.w	r8, [sp, #60]	; 0x3c
    f2f8:	orr.w	r1, r1, #3145728	; 0x300000
    f2fc:	ldr	r5, [sp, #96]	; 0x60
    f2fe:	b.n	f20e <_dtoa_r+0xf6>
    f300:	ldr	r0, [pc, #244]	; (f3f8 <_dtoa_r+0x2e0>)
    f302:	b.n	f18a <_dtoa_r+0x72>
    f304:	adds	r3, r0, #3
    f306:	b.n	f1b4 <_dtoa_r+0x9c>
    f308:	movs	r1, #0
    f30a:	str.w	r1, [r9, #68]	; 0x44
    f30e:	mov	r0, r9
    f310:	mov	r4, r1
    f312:	str	r1, [sp, #0]
    f314:	bl	109e0 <_Balloc>
    f318:	mov.w	r3, #4294967295
    f31c:	str	r3, [sp, #32]
    f31e:	str	r3, [sp, #56]	; 0x38
    f320:	movs	r3, #1
    f322:	str	r0, [sp, #36]	; 0x24
    f324:	str.w	r0, [r9, #64]	; 0x40
    f328:	str	r4, [sp, #20]
    f32a:	str	r3, [sp, #44]	; 0x2c
    f32c:	ldr	r3, [sp, #100]	; 0x64
    f32e:	cmp	r3, #0
    f330:	blt.w	f4d4 <_dtoa_r+0x3bc>
    f334:	ldr	r2, [sp, #16]
    f336:	cmp	r2, #14
    f338:	bgt.w	f4d4 <_dtoa_r+0x3bc>
    f33c:	ldr	r3, [pc, #176]	; (f3f0 <_dtoa_r+0x2d8>)
    f33e:	add.w	r3, r3, r2, lsl #3
    f342:	vldr	d7, [r3]
    f346:	ldr	r3, [sp, #20]
    f348:	cmp	r3, #0
    f34a:	vstr	d7, [sp]
    f34e:	blt.w	f94e <_dtoa_r+0x836>
    f352:	mov	r6, sl
    f354:	mov	r7, fp
    f356:	ldrd	sl, fp, [sp]
    f35a:	mov	r0, r6
    f35c:	mov	r2, sl
    f35e:	mov	r3, fp
    f360:	mov	r1, r7
    f362:	bl	a2b0 <__aeabi_ddiv>
    f366:	bl	a5bc <__aeabi_d2iz>
    f36a:	mov	r4, r0
    f36c:	bl	9f90 <__aeabi_i2d>
    f370:	mov	r2, sl
    f372:	mov	r3, fp
    f374:	bl	a05c <__aeabi_dmul>
    f378:	mov	r3, r1
    f37a:	mov	r2, r0
    f37c:	mov	r1, r7
    f37e:	mov	r0, r6
    f380:	bl	9cf4 <__aeabi_dsub>
    f384:	ldr	r5, [sp, #36]	; 0x24
    f386:	add.w	r3, r4, #48	; 0x30
    f38a:	strb	r3, [r5, #0]
    f38c:	ldr	r3, [sp, #32]
    f38e:	cmp	r3, #1
    f390:	mov	r6, r0
    f392:	mov	r7, r1
    f394:	add.w	r5, r5, #1
    f398:	beq.n	f45e <_dtoa_r+0x346>
    f39a:	movs	r2, #0
    f39c:	ldr	r3, [pc, #92]	; (f3fc <_dtoa_r+0x2e4>)
    f39e:	bl	a05c <__aeabi_dmul>
    f3a2:	movs	r2, #0
    f3a4:	movs	r3, #0
    f3a6:	mov	r6, r0
    f3a8:	mov	r7, r1
    f3aa:	bl	a52c <__aeabi_dcmpeq>
    f3ae:	cmp	r0, #0
    f3b0:	bne.n	f4ae <_dtoa_r+0x396>
    f3b2:	str.w	r9, [sp, #20]
    f3b6:	ldr.w	sl, [sp, #32]
    f3ba:	ldr.w	fp, [sp, #36]	; 0x24
    f3be:	ldrd	r8, r9, [sp]
    f3c2:	b.n	f416 <_dtoa_r+0x2fe>
    f3c4:	nop.w
    f3c8:	.word	0x636f4361
    f3cc:	.word	0x3fd287a7
    f3d0:	.word	0x8b60c8b3
    f3d4:	.word	0x3fc68a28
    f3d8:	.word	0x509f79fb
    f3dc:	.word	0x3fd34413
    f3e0:	.word	0x7ff00000
    f3e4:	.word	0x00012969
    f3e8:	.word	0x00012ab8
    f3ec:	.word	0x3ff80000
    f3f0:	.word	0x00012bc0
    f3f4:	.word	0x00012aac
    f3f8:	.word	0x00012968
    f3fc:	.word	0x40240000
    f400:	bl	a05c <__aeabi_dmul>
    f404:	movs	r2, #0
    f406:	movs	r3, #0
    f408:	mov	r6, r0
    f40a:	mov	r7, r1
    f40c:	bl	a52c <__aeabi_dcmpeq>
    f410:	cmp	r0, #0
    f412:	bne.w	fb72 <_dtoa_r+0xa5a>
    f416:	mov	r2, r8
    f418:	mov	r3, r9
    f41a:	mov	r0, r6
    f41c:	mov	r1, r7
    f41e:	bl	a2b0 <__aeabi_ddiv>
    f422:	bl	a5bc <__aeabi_d2iz>
    f426:	mov	r4, r0
    f428:	bl	9f90 <__aeabi_i2d>
    f42c:	mov	r2, r8
    f42e:	mov	r3, r9
    f430:	bl	a05c <__aeabi_dmul>
    f434:	mov	r2, r0
    f436:	mov	r3, r1
    f438:	mov	r0, r6
    f43a:	mov	r1, r7
    f43c:	bl	9cf4 <__aeabi_dsub>
    f440:	add.w	lr, r4, #48	; 0x30
    f444:	strb.w	lr, [r5], #1
    f448:	rsb	lr, fp, r5
    f44c:	cmp	lr, sl
    f44e:	mov	r6, r0
    f450:	mov	r7, r1
    f452:	mov.w	r2, #0
    f456:	ldr	r3, [pc, #696]	; (f710 <_dtoa_r+0x5f8>)
    f458:	bne.n	f400 <_dtoa_r+0x2e8>
    f45a:	ldr.w	r9, [sp, #20]
    f45e:	mov	r2, r6
    f460:	mov	r3, r7
    f462:	mov	r0, r6
    f464:	mov	r1, r7
    f466:	bl	9cf8 <__adddf3>
    f46a:	mov	r6, r0
    f46c:	mov	r7, r1
    f46e:	mov	r2, r0
    f470:	mov	r3, r1
    f472:	ldrd	r0, r1, [sp]
    f476:	bl	a540 <__aeabi_dcmplt>
    f47a:	cbnz	r0, f48e <_dtoa_r+0x376>
    f47c:	mov	r2, r6
    f47e:	mov	r3, r7
    f480:	ldrd	r0, r1, [sp]
    f484:	bl	a52c <__aeabi_dcmpeq>
    f488:	cbz	r0, f4ae <_dtoa_r+0x396>
    f48a:	lsls	r3, r4, #31
    f48c:	bpl.n	f4ae <_dtoa_r+0x396>
    f48e:	ldrb.w	r4, [r5, #-1]
    f492:	ldr	r2, [sp, #36]	; 0x24
    f494:	subs	r3, r5, #1
    f496:	b.n	f4a2 <_dtoa_r+0x38a>
    f498:	cmp	r2, r3
    f49a:	beq.w	fc96 <_dtoa_r+0xb7e>
    f49e:	ldrb.w	r4, [r3, #-1]!
    f4a2:	cmp	r4, #57	; 0x39
    f4a4:	add.w	r5, r3, #1
    f4a8:	beq.n	f498 <_dtoa_r+0x380>
    f4aa:	adds	r4, #1
    f4ac:	strb	r4, [r3, #0]
    f4ae:	ldr	r1, [sp, #40]	; 0x28
    f4b0:	mov	r0, r9
    f4b2:	bl	10a2c <_Bfree>
    f4b6:	movs	r2, #0
    f4b8:	ldr	r3, [sp, #16]
    f4ba:	strb	r2, [r5, #0]
    f4bc:	ldr	r2, [sp, #12]
    f4be:	adds	r3, #1
    f4c0:	str	r3, [r2, #0]
    f4c2:	ldr	r3, [sp, #148]	; 0x94
    f4c4:	cmp	r3, #0
    f4c6:	beq.w	fc00 <_dtoa_r+0xae8>
    f4ca:	ldr	r0, [sp, #36]	; 0x24
    f4cc:	str	r5, [r3, #0]
    f4ce:	add	sp, #108	; 0x6c
    f4d0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    f4d4:	ldr	r2, [sp, #44]	; 0x2c
    f4d6:	cmp	r2, #0
    f4d8:	beq.w	f6f8 <_dtoa_r+0x5e0>
    f4dc:	ldr	r2, [sp, #0]
    f4de:	cmp	r2, #1
    f4e0:	ble.w	f992 <_dtoa_r+0x87a>
    f4e4:	ldr	r3, [sp, #32]
    f4e6:	ldr	r2, [sp, #24]
    f4e8:	subs	r7, r3, #1
    f4ea:	cmp	r2, r7
    f4ec:	blt.w	fc06 <_dtoa_r+0xaee>
    f4f0:	subs	r7, r2, r7
    f4f2:	ldr	r3, [sp, #32]
    f4f4:	cmp	r3, #0
    f4f6:	blt.w	fdfa <_dtoa_r+0xce2>
    f4fa:	ldr	r5, [sp, #28]
    f4fc:	ldr	r3, [sp, #32]
    f4fe:	ldr	r2, [sp, #28]
    f500:	movs	r1, #1
    f502:	add	r2, r3
    f504:	mov	r0, r9
    f506:	str	r2, [sp, #28]
    f508:	add	r8, r3
    f50a:	bl	10bf4 <__i2b>
    f50e:	mov	r6, r0
    f510:	cbz	r5, f52c <_dtoa_r+0x414>
    f512:	cmp.w	r8, #0
    f516:	ble.n	f52c <_dtoa_r+0x414>
    f518:	cmp	r5, r8
    f51a:	ldr	r2, [sp, #28]
    f51c:	mov	r3, r5
    f51e:	it	ge
    f520:	movge	r3, r8
    f522:	subs	r2, r2, r3
    f524:	str	r2, [sp, #28]
    f526:	subs	r5, r5, r3
    f528:	rsb	r8, r3, r8
    f52c:	ldr	r3, [sp, #24]
    f52e:	cmp	r3, #0
    f530:	ble.w	fb1e <_dtoa_r+0xa06>
    f534:	ldr	r2, [sp, #44]	; 0x2c
    f536:	cmp	r2, #0
    f538:	beq.w	f940 <_dtoa_r+0x828>
    f53c:	cmp	r7, #0
    f53e:	beq.w	f940 <_dtoa_r+0x828>
    f542:	mov	r1, r6
    f544:	mov	r2, r7
    f546:	mov	r0, r9
    f548:	bl	10d38 <__pow5mult>
    f54c:	ldr	r2, [sp, #40]	; 0x28
    f54e:	mov	r1, r0
    f550:	mov	r6, r0
    f552:	mov	r0, r9
    f554:	bl	10c08 <__multiply>
    f558:	ldr	r1, [sp, #40]	; 0x28
    f55a:	mov	r4, r0
    f55c:	mov	r0, r9
    f55e:	bl	10a2c <_Bfree>
    f562:	ldr	r3, [sp, #24]
    f564:	subs	r3, r3, r7
    f566:	str	r3, [sp, #24]
    f568:	bne.w	f93e <_dtoa_r+0x826>
    f56c:	movs	r1, #1
    f56e:	mov	r0, r9
    f570:	bl	10bf4 <__i2b>
    f574:	ldr	r3, [sp, #48]	; 0x30
    f576:	str	r0, [sp, #24]
    f578:	cmp	r3, #0
    f57a:	beq.w	f9a8 <_dtoa_r+0x890>
    f57e:	mov	r1, r0
    f580:	mov	r2, r3
    f582:	mov	r0, r9
    f584:	bl	10d38 <__pow5mult>
    f588:	ldr	r3, [sp, #0]
    f58a:	str	r0, [sp, #24]
    f58c:	cmp	r3, #1
    f58e:	ble.w	fb78 <_dtoa_r+0xa60>
    f592:	movs	r7, #0
    f594:	ldr	r2, [sp, #24]
    f596:	ldr	r3, [r2, #16]
    f598:	add.w	r3, r2, r3, lsl #2
    f59c:	ldr	r0, [r3, #16]
    f59e:	bl	10b58 <__hi0bits>
    f5a2:	rsb	r0, r0, #32
    f5a6:	add	r0, r8
    f5a8:	ands.w	r0, r0, #31
    f5ac:	beq.w	f9a4 <_dtoa_r+0x88c>
    f5b0:	rsb	r3, r0, #32
    f5b4:	cmp	r3, #4
    f5b6:	ble.w	ff34 <_dtoa_r+0xe1c>
    f5ba:	rsb	r0, r0, #28
    f5be:	ldr	r3, [sp, #28]
    f5c0:	add	r3, r0
    f5c2:	str	r3, [sp, #28]
    f5c4:	add	r5, r0
    f5c6:	add	r8, r0
    f5c8:	ldr	r3, [sp, #28]
    f5ca:	cmp	r3, #0
    f5cc:	ble.n	f5da <_dtoa_r+0x4c2>
    f5ce:	mov	r1, r4
    f5d0:	mov	r2, r3
    f5d2:	mov	r0, r9
    f5d4:	bl	10dd8 <__lshift>
    f5d8:	mov	r4, r0
    f5da:	cmp.w	r8, #0
    f5de:	ble.n	f5ec <_dtoa_r+0x4d4>
    f5e0:	mov	r2, r8
    f5e2:	ldr	r1, [sp, #24]
    f5e4:	mov	r0, r9
    f5e6:	bl	10dd8 <__lshift>
    f5ea:	str	r0, [sp, #24]
    f5ec:	ldr	r3, [sp, #52]	; 0x34
    f5ee:	cmp	r3, #0
    f5f0:	bne.w	fae8 <_dtoa_r+0x9d0>
    f5f4:	ldr	r3, [sp, #32]
    f5f6:	cmp	r3, #0
    f5f8:	ble.w	fb22 <_dtoa_r+0xa0a>
    f5fc:	ldr	r3, [sp, #44]	; 0x2c
    f5fe:	cmp	r3, #0
    f600:	bne.w	f9ec <_dtoa_r+0x8d4>
    f604:	ldr.w	fp, [sp, #36]	; 0x24
    f608:	ldr	r7, [sp, #32]
    f60a:	ldr.w	r8, [sp, #24]
    f60e:	mov	r5, fp
    f610:	b.n	f618 <_dtoa_r+0x500>
    f612:	bl	10a40 <__multadd>
    f616:	mov	r4, r0
    f618:	mov	r1, r8
    f61a:	mov	r0, r4
    f61c:	bl	efec <quorem>
    f620:	add.w	sl, r0, #48	; 0x30
    f624:	strb.w	sl, [r5], #1
    f628:	rsb	r3, fp, r5
    f62c:	cmp	r3, r7
    f62e:	mov.w	r2, #10
    f632:	mov.w	r3, #0
    f636:	mov	r1, r4
    f638:	mov	r0, r9
    f63a:	blt.n	f612 <_dtoa_r+0x4fa>
    f63c:	ldr	r3, [sp, #36]	; 0x24
    f63e:	ldr	r2, [sp, #32]
    f640:	cmp	r2, #1
    f642:	ite	ge
    f644:	addge	r3, r3, r2
    f646:	addlt	r3, #1
    f648:	mov	r5, r3
    f64a:	mov.w	fp, #0
    f64e:	mov	r1, r4
    f650:	movs	r2, #1
    f652:	mov	r0, r9
    f654:	bl	10dd8 <__lshift>
    f658:	ldr	r1, [sp, #24]
    f65a:	str	r0, [sp, #40]	; 0x28
    f65c:	bl	10e88 <__mcmp>
    f660:	cmp	r0, #0
    f662:	ble.w	fc70 <_dtoa_r+0xb58>
    f666:	ldrb.w	r2, [r5, #-1]
    f66a:	ldr	r1, [sp, #36]	; 0x24
    f66c:	subs	r3, r5, #1
    f66e:	b.n	f67a <_dtoa_r+0x562>
    f670:	cmp	r3, r1
    f672:	beq.w	fb5e <_dtoa_r+0xa46>
    f676:	ldrb.w	r2, [r3, #-1]!
    f67a:	cmp	r2, #57	; 0x39
    f67c:	add.w	r5, r3, #1
    f680:	beq.n	f670 <_dtoa_r+0x558>
    f682:	adds	r2, #1
    f684:	strb	r2, [r3, #0]
    f686:	ldr	r1, [sp, #24]
    f688:	mov	r0, r9
    f68a:	bl	10a2c <_Bfree>
    f68e:	cmp	r6, #0
    f690:	beq.w	f4ae <_dtoa_r+0x396>
    f694:	cmp.w	fp, #0
    f698:	beq.n	f6a6 <_dtoa_r+0x58e>
    f69a:	cmp	fp, r6
    f69c:	beq.n	f6a6 <_dtoa_r+0x58e>
    f69e:	mov	r1, fp
    f6a0:	mov	r0, r9
    f6a2:	bl	10a2c <_Bfree>
    f6a6:	mov	r1, r6
    f6a8:	mov	r0, r9
    f6aa:	bl	10a2c <_Bfree>
    f6ae:	b.n	f4ae <_dtoa_r+0x396>
    f6b0:	movs	r3, #1
    f6b2:	str	r3, [sp, #52]	; 0x34
    f6b4:	b.n	f28e <_dtoa_r+0x176>
    f6b6:	ldr.w	r8, [sp, #16]
    f6ba:	mov	r0, r8
    f6bc:	bl	9f90 <__aeabi_i2d>
    f6c0:	mov	r2, r0
    f6c2:	mov	r3, r1
    f6c4:	mov	r0, r6
    f6c6:	mov	r1, r7
    f6c8:	bl	a52c <__aeabi_dcmpeq>
    f6cc:	cmp	r0, #0
    f6ce:	bne.w	f266 <_dtoa_r+0x14e>
    f6d2:	add.w	r3, r8, #4294967295
    f6d6:	str	r3, [sp, #16]
    f6d8:	b.n	f266 <_dtoa_r+0x14e>
    f6da:	ldr	r2, [sp, #28]
    f6dc:	ldr	r3, [sp, #16]
    f6de:	subs	r2, r2, r3
    f6e0:	negs	r3, r3
    f6e2:	str	r3, [sp, #24]
    f6e4:	movs	r3, #0
    f6e6:	str	r2, [sp, #28]
    f6e8:	str	r3, [sp, #48]	; 0x30
    f6ea:	b.n	f2ac <_dtoa_r+0x194>
    f6ec:	rsb	r3, r8, #0
    f6f0:	str	r3, [sp, #28]
    f6f2:	mov.w	r8, #0
    f6f6:	b.n	f29c <_dtoa_r+0x184>
    f6f8:	ldr	r7, [sp, #24]
    f6fa:	ldr	r5, [sp, #28]
    f6fc:	ldr	r6, [sp, #44]	; 0x2c
    f6fe:	b.n	f510 <_dtoa_r+0x3f8>
    f700:	rsb	r4, r3, #32
    f704:	lsl.w	r0, sl, r4
    f708:	b.n	f200 <_dtoa_r+0xe8>
    f70a:	str	r0, [sp, #52]	; 0x34
    f70c:	b.n	f28e <_dtoa_r+0x176>
    f70e:	nop
    f710:	.word	0x40240000
    f714:	movs	r3, #0
    f716:	str	r3, [sp, #44]	; 0x2c
    f718:	ldr	r3, [sp, #16]
    f71a:	ldr	r2, [sp, #20]
    f71c:	add	r3, r2
    f71e:	str	r3, [sp, #56]	; 0x38
    f720:	adds	r3, #1
    f722:	cmp	r3, #0
    f724:	str	r3, [sp, #32]
    f726:	ble.w	fc24 <_dtoa_r+0xb0c>
    f72a:	ldr	r4, [sp, #32]
    f72c:	mov	r5, r4
    f72e:	movs	r1, #0
    f730:	cmp	r5, #23
    f732:	str.w	r1, [r9, #68]	; 0x44
    f736:	bls.n	f750 <_dtoa_r+0x638>
    f738:	movs	r2, #1
    f73a:	movs	r3, #4
    f73c:	lsls	r3, r3, #1
    f73e:	add.w	r0, r3, #20
    f742:	cmp	r0, r5
    f744:	mov	r1, r2
    f746:	add.w	r2, r2, #1
    f74a:	bls.n	f73c <_dtoa_r+0x624>
    f74c:	str.w	r1, [r9, #68]	; 0x44
    f750:	mov	r0, r9
    f752:	bl	109e0 <_Balloc>
    f756:	cmp	r4, #14
    f758:	str	r0, [sp, #36]	; 0x24
    f75a:	str.w	r0, [r9, #64]	; 0x40
    f75e:	bhi.w	f32c <_dtoa_r+0x214>
    f762:	cmp	r6, #0
    f764:	beq.w	f32c <_dtoa_r+0x214>
    f768:	ldr	r1, [sp, #16]
    f76a:	cmp	r1, #0
    f76c:	strd	sl, fp, [sp, #64]	; 0x40
    f770:	ble.w	fca8 <_dtoa_r+0xb90>
    f774:	ldr	r3, [pc, #576]	; (f9b8 <_dtoa_r+0x8a0>)
    f776:	and.w	r2, r1, #15
    f77a:	asrs	r6, r1, #4
    f77c:	add.w	r3, r3, r2, lsl #3
    f780:	lsls	r0, r6, #27
    f782:	ldrd	r4, r5, [r3]
    f786:	bpl.w	fc16 <_dtoa_r+0xafe>
    f78a:	ldr	r3, [pc, #560]	; (f9bc <_dtoa_r+0x8a4>)
    f78c:	mov	r0, sl
    f78e:	mov	r1, fp
    f790:	ldrd	r2, r3, [r3, #32]
    f794:	bl	a2b0 <__aeabi_ddiv>
    f798:	strd	r0, r1, [sp, #72]	; 0x48
    f79c:	and.w	r6, r6, #15
    f7a0:	mov.w	sl, #3
    f7a4:	cbz	r6, f7c8 <_dtoa_r+0x6b0>
    f7a6:	ldr	r7, [pc, #532]	; (f9bc <_dtoa_r+0x8a4>)
    f7a8:	lsls	r1, r6, #31
    f7aa:	bpl.n	f7c0 <_dtoa_r+0x6a8>
    f7ac:	mov	r0, r4
    f7ae:	mov	r1, r5
    f7b0:	ldrd	r2, r3, [r7]
    f7b4:	bl	a05c <__aeabi_dmul>
    f7b8:	add.w	sl, sl, #1
    f7bc:	mov	r4, r0
    f7be:	mov	r5, r1
    f7c0:	asrs	r6, r6, #1
    f7c2:	add.w	r7, r7, #8
    f7c6:	bne.n	f7a8 <_dtoa_r+0x690>
    f7c8:	mov	r2, r4
    f7ca:	mov	r3, r5
    f7cc:	ldrd	r0, r1, [sp, #72]	; 0x48
    f7d0:	bl	a2b0 <__aeabi_ddiv>
    f7d4:	mov	r6, r0
    f7d6:	mov	r7, r1
    f7d8:	ldr	r3, [sp, #52]	; 0x34
    f7da:	cbz	r3, f7ee <_dtoa_r+0x6d6>
    f7dc:	movs	r2, #0
    f7de:	ldr	r3, [pc, #480]	; (f9c0 <_dtoa_r+0x8a8>)
    f7e0:	mov	r0, r6
    f7e2:	mov	r1, r7
    f7e4:	bl	a540 <__aeabi_dcmplt>
    f7e8:	cmp	r0, #0
    f7ea:	bne.w	fe22 <_dtoa_r+0xd0a>
    f7ee:	mov	r0, sl
    f7f0:	bl	9f90 <__aeabi_i2d>
    f7f4:	mov	r2, r6
    f7f6:	mov	r3, r7
    f7f8:	bl	a05c <__aeabi_dmul>
    f7fc:	ldr	r3, [pc, #452]	; (f9c4 <_dtoa_r+0x8ac>)
    f7fe:	movs	r2, #0
    f800:	bl	9cf8 <__adddf3>
    f804:	ldr	r3, [sp, #32]
    f806:	mov	r4, r0
    f808:	sub.w	r5, r1, #54525952	; 0x3400000
    f80c:	cmp	r3, #0
    f80e:	beq.w	fbc8 <_dtoa_r+0xab0>
    f812:	ldr	r3, [sp, #16]
    f814:	str	r3, [sp, #88]	; 0x58
    f816:	ldr	r3, [sp, #32]
    f818:	str	r3, [sp, #72]	; 0x48
    f81a:	ldr	r3, [sp, #44]	; 0x2c
    f81c:	cmp	r3, #0
    f81e:	beq.w	fd4a <_dtoa_r+0xc32>
    f822:	ldr	r2, [sp, #72]	; 0x48
    f824:	ldr	r3, [pc, #400]	; (f9b8 <_dtoa_r+0x8a0>)
    f826:	ldr	r1, [pc, #416]	; (f9c8 <_dtoa_r+0x8b0>)
    f828:	add.w	r3, r3, r2, lsl #3
    f82c:	ldrd	r2, r3, [r3, #-8]
    f830:	movs	r0, #0
    f832:	bl	a2b0 <__aeabi_ddiv>
    f836:	mov	r2, r4
    f838:	mov	r3, r5
    f83a:	bl	9cf4 <__aeabi_dsub>
    f83e:	mov	sl, r0
    f840:	mov	fp, r1
    f842:	mov	r0, r6
    f844:	mov	r1, r7
    f846:	bl	a5bc <__aeabi_d2iz>
    f84a:	mov	r4, r0
    f84c:	bl	9f90 <__aeabi_i2d>
    f850:	mov	r2, r0
    f852:	mov	r3, r1
    f854:	mov	r0, r6
    f856:	mov	r1, r7
    f858:	bl	9cf4 <__aeabi_dsub>
    f85c:	adds	r4, #48	; 0x30
    f85e:	ldr	r5, [sp, #36]	; 0x24
    f860:	uxtb	r4, r4
    f862:	mov	r6, r0
    f864:	mov	r7, r1
    f866:	strb	r4, [r5, #0]
    f868:	mov	r2, r0
    f86a:	mov	r3, r1
    f86c:	mov	r0, sl
    f86e:	mov	r1, fp
    f870:	adds	r5, #1
    f872:	bl	a57c <__aeabi_dcmpgt>
    f876:	cmp	r0, #0
    f878:	bne.n	f91c <_dtoa_r+0x804>
    f87a:	mov	r2, r6
    f87c:	mov	r3, r7
    f87e:	movs	r0, #0
    f880:	ldr	r1, [pc, #316]	; (f9c0 <_dtoa_r+0x8a8>)
    f882:	bl	9cf4 <__aeabi_dsub>
    f886:	mov	r2, r0
    f888:	mov	r3, r1
    f88a:	mov	r0, sl
    f88c:	mov	r1, fp
    f88e:	bl	a57c <__aeabi_dcmpgt>
    f892:	cmp	r0, #0
    f894:	bne.w	fea8 <_dtoa_r+0xd90>
    f898:	ldr	r2, [sp, #72]	; 0x48
    f89a:	cmp	r2, #1
    f89c:	ble.w	fc8e <_dtoa_r+0xb76>
    f8a0:	ldr	r3, [sp, #72]	; 0x48
    f8a2:	ldr	r2, [sp, #36]	; 0x24
    f8a4:	str.w	r8, [sp, #72]	; 0x48
    f8a8:	add	r3, r2
    f8aa:	mov	r8, r3
    f8ac:	b.n	f8ca <_dtoa_r+0x7b2>
    f8ae:	movs	r0, #0
    f8b0:	ldr	r1, [pc, #268]	; (f9c0 <_dtoa_r+0x8a8>)
    f8b2:	bl	9cf4 <__aeabi_dsub>
    f8b6:	mov	r2, sl
    f8b8:	mov	r3, fp
    f8ba:	bl	a540 <__aeabi_dcmplt>
    f8be:	cmp	r0, #0
    f8c0:	bne.w	fea8 <_dtoa_r+0xd90>
    f8c4:	cmp	r5, r8
    f8c6:	beq.w	fc8a <_dtoa_r+0xb72>
    f8ca:	mov	r0, sl
    f8cc:	mov	r1, fp
    f8ce:	movs	r2, #0
    f8d0:	ldr	r3, [pc, #248]	; (f9cc <_dtoa_r+0x8b4>)
    f8d2:	bl	a05c <__aeabi_dmul>
    f8d6:	movs	r2, #0
    f8d8:	ldr	r3, [pc, #240]	; (f9cc <_dtoa_r+0x8b4>)
    f8da:	mov	sl, r0
    f8dc:	mov	fp, r1
    f8de:	mov	r0, r6
    f8e0:	mov	r1, r7
    f8e2:	bl	a05c <__aeabi_dmul>
    f8e6:	mov	r7, r1
    f8e8:	mov	r6, r0
    f8ea:	bl	a5bc <__aeabi_d2iz>
    f8ee:	mov	r4, r0
    f8f0:	bl	9f90 <__aeabi_i2d>
    f8f4:	mov	r2, r0
    f8f6:	mov	r3, r1
    f8f8:	mov	r0, r6
    f8fa:	mov	r1, r7
    f8fc:	bl	9cf4 <__aeabi_dsub>
    f900:	adds	r4, #48	; 0x30
    f902:	uxtb	r4, r4
    f904:	mov	r2, sl
    f906:	mov	r3, fp
    f908:	strb.w	r4, [r5], #1
    f90c:	mov	r6, r0
    f90e:	mov	r7, r1
    f910:	bl	a540 <__aeabi_dcmplt>
    f914:	mov	r2, r6
    f916:	mov	r3, r7
    f918:	cmp	r0, #0
    f91a:	beq.n	f8ae <_dtoa_r+0x796>
    f91c:	ldr	r3, [sp, #88]	; 0x58
    f91e:	str	r3, [sp, #16]
    f920:	b.n	f4ae <_dtoa_r+0x396>
    f922:	movs	r3, #0
    f924:	str	r3, [sp, #44]	; 0x2c
    f926:	ldr	r3, [sp, #20]
    f928:	cmp	r3, #0
    f92a:	ble.w	fc2e <_dtoa_r+0xb16>
    f92e:	mov	r5, r3
    f930:	mov	r4, r3
    f932:	str	r3, [sp, #56]	; 0x38
    f934:	str	r3, [sp, #32]
    f936:	b.n	f72e <_dtoa_r+0x616>
    f938:	movs	r3, #1
    f93a:	str	r3, [sp, #44]	; 0x2c
    f93c:	b.n	f926 <_dtoa_r+0x80e>
    f93e:	str	r4, [sp, #40]	; 0x28
    f940:	ldr	r2, [sp, #24]
    f942:	ldr	r1, [sp, #40]	; 0x28
    f944:	mov	r0, r9
    f946:	bl	10d38 <__pow5mult>
    f94a:	mov	r4, r0
    f94c:	b.n	f56c <_dtoa_r+0x454>
    f94e:	ldr	r3, [sp, #32]
    f950:	cmp	r3, #0
    f952:	bgt.w	f352 <_dtoa_r+0x23a>
    f956:	bne.w	fbf8 <_dtoa_r+0xae0>
    f95a:	movs	r2, #0
    f95c:	ldr	r3, [pc, #112]	; (f9d0 <_dtoa_r+0x8b8>)
    f95e:	ldrd	r0, r1, [sp]
    f962:	bl	a05c <__aeabi_dmul>
    f966:	mov	r3, fp
    f968:	mov	r2, sl
    f96a:	bl	a568 <__aeabi_dcmpge>
    f96e:	ldr	r3, [sp, #32]
    f970:	str	r3, [sp, #24]
    f972:	mov	r6, r3
    f974:	cmp	r0, #0
    f976:	beq.w	fb4e <_dtoa_r+0xa36>
    f97a:	ldr	r3, [sp, #20]
    f97c:	ldr	r5, [sp, #36]	; 0x24
    f97e:	mvns	r3, r3
    f980:	str	r3, [sp, #16]
    f982:	ldr	r1, [sp, #24]
    f984:	mov	r0, r9
    f986:	bl	10a2c <_Bfree>
    f98a:	cmp	r6, #0
    f98c:	beq.w	f4ae <_dtoa_r+0x396>
    f990:	b.n	f6a6 <_dtoa_r+0x58e>
    f992:	ldr	r2, [sp, #60]	; 0x3c
    f994:	cmp	r2, #0
    f996:	beq.w	fe0a <_dtoa_r+0xcf2>
    f99a:	addw	r3, r3, #1075	; 0x433
    f99e:	ldr	r7, [sp, #24]
    f9a0:	ldr	r5, [sp, #28]
    f9a2:	b.n	f4fe <_dtoa_r+0x3e6>
    f9a4:	movs	r0, #28
    f9a6:	b.n	f5be <_dtoa_r+0x4a6>
    f9a8:	ldr	r3, [sp, #0]
    f9aa:	cmp	r3, #1
    f9ac:	ble.w	feb0 <_dtoa_r+0xd98>
    f9b0:	ldr	r7, [sp, #48]	; 0x30
    f9b2:	movs	r0, #1
    f9b4:	b.n	f5a6 <_dtoa_r+0x48e>
    f9b6:	nop
    f9b8:	.word	0x00012bc0
    f9bc:	.word	0x00012c88
    f9c0:	.word	0x3ff00000
    f9c4:	.word	0x401c0000
    f9c8:	.word	0x3fe00000
    f9cc:	.word	0x40240000
    f9d0:	.word	0x40140000
    f9d4:	mov	r1, r6
    f9d6:	movs	r3, #0
    f9d8:	movs	r2, #10
    f9da:	mov	r0, r9
    f9dc:	bl	10a40 <__multadd>
    f9e0:	ldr	r3, [sp, #56]	; 0x38
    f9e2:	cmp	r3, #0
    f9e4:	mov	r6, r0
    f9e6:	ble.w	ff04 <_dtoa_r+0xdec>
    f9ea:	str	r3, [sp, #32]
    f9ec:	cmp	r5, #0
    f9ee:	ble.n	f9fc <_dtoa_r+0x8e4>
    f9f0:	mov	r1, r6
    f9f2:	mov	r2, r5
    f9f4:	mov	r0, r9
    f9f6:	bl	10dd8 <__lshift>
    f9fa:	mov	r6, r0
    f9fc:	cmp	r7, #0
    f9fe:	bne.w	fcfa <_dtoa_r+0xbe2>
    fa02:	mov	r8, r6
    fa04:	ldr	r3, [sp, #32]
    fa06:	ldr	r2, [sp, #36]	; 0x24
    fa08:	subs	r3, #1
    fa0a:	adds	r3, r2, r3
    fa0c:	str	r3, [sp, #32]
    fa0e:	and.w	r3, sl, #1
    fa12:	str	r3, [sp, #40]	; 0x28
    fa14:	mov	r7, r2
    fa16:	ldr.w	fp, [sp, #24]
    fa1a:	mov	r0, r4
    fa1c:	mov	r1, fp
    fa1e:	bl	efec <quorem>
    fa22:	mov	r1, r6
    fa24:	mov	r5, r0
    fa26:	mov	r0, r4
    fa28:	bl	10e88 <__mcmp>
    fa2c:	mov	r2, r8
    fa2e:	mov	r1, fp
    fa30:	mov	sl, r0
    fa32:	mov	r0, r9
    fa34:	bl	10ecc <__mdiff>
    fa38:	ldr	r2, [r0, #12]
    fa3a:	mov	fp, r0
    fa3c:	add.w	r3, r5, #48	; 0x30
    fa40:	cmp	r2, #0
    fa42:	bne.n	fad8 <_dtoa_r+0x9c0>
    fa44:	mov	r1, r0
    fa46:	mov	r0, r4
    fa48:	str	r3, [sp, #28]
    fa4a:	bl	10e88 <__mcmp>
    fa4e:	mov	r1, fp
    fa50:	str	r0, [sp, #20]
    fa52:	mov	r0, r9
    fa54:	bl	10a2c <_Bfree>
    fa58:	ldr	r2, [sp, #20]
    fa5a:	ldr	r3, [sp, #28]
    fa5c:	cbnz	r2, fa6a <_dtoa_r+0x952>
    fa5e:	ldr	r1, [sp, #0]
    fa60:	cbnz	r1, fa6a <_dtoa_r+0x952>
    fa62:	ldr	r1, [sp, #40]	; 0x28
    fa64:	cmp	r1, #0
    fa66:	beq.w	fed4 <_dtoa_r+0xdbc>
    fa6a:	cmp.w	sl, #0
    fa6e:	blt.w	fc38 <_dtoa_r+0xb20>
    fa72:	bne.n	fa80 <_dtoa_r+0x968>
    fa74:	ldr	r1, [sp, #0]
    fa76:	cbnz	r1, fa80 <_dtoa_r+0x968>
    fa78:	ldr	r1, [sp, #40]	; 0x28
    fa7a:	cmp	r1, #0
    fa7c:	beq.w	fc38 <_dtoa_r+0xb20>
    fa80:	cmp	r2, #0
    fa82:	bgt.w	fd22 <_dtoa_r+0xc0a>
    fa86:	ldr	r2, [sp, #32]
    fa88:	strb	r3, [r7, #0]
    fa8a:	add.w	sl, r7, #1
    fa8e:	cmp	r7, r2
    fa90:	mov	r5, sl
    fa92:	beq.w	fd3a <_dtoa_r+0xc22>
    fa96:	mov	r1, r4
    fa98:	movs	r3, #0
    fa9a:	movs	r2, #10
    fa9c:	mov	r0, r9
    fa9e:	bl	10a40 <__multadd>
    faa2:	cmp	r6, r8
    faa4:	mov	r4, r0
    faa6:	mov	r1, r6
    faa8:	mov.w	r3, #0
    faac:	mov.w	r2, #10
    fab0:	mov	r0, r9
    fab2:	beq.n	facc <_dtoa_r+0x9b4>
    fab4:	bl	10a40 <__multadd>
    fab8:	mov	r1, r8
    faba:	mov	r6, r0
    fabc:	movs	r3, #0
    fabe:	movs	r2, #10
    fac0:	mov	r0, r9
    fac2:	bl	10a40 <__multadd>
    fac6:	mov	r7, sl
    fac8:	mov	r8, r0
    faca:	b.n	fa16 <_dtoa_r+0x8fe>
    facc:	bl	10a40 <__multadd>
    fad0:	mov	r7, sl
    fad2:	mov	r6, r0
    fad4:	mov	r8, r0
    fad6:	b.n	fa16 <_dtoa_r+0x8fe>
    fad8:	mov	r1, r0
    fada:	mov	r0, r9
    fadc:	str	r3, [sp, #20]
    fade:	bl	10a2c <_Bfree>
    fae2:	movs	r2, #1
    fae4:	ldr	r3, [sp, #20]
    fae6:	b.n	fa6a <_dtoa_r+0x952>
    fae8:	ldr	r1, [sp, #24]
    faea:	mov	r0, r4
    faec:	bl	10e88 <__mcmp>
    faf0:	cmp	r0, #0
    faf2:	bge.w	f5f4 <_dtoa_r+0x4dc>
    faf6:	mov	r1, r4
    faf8:	ldr	r4, [sp, #16]
    fafa:	movs	r3, #0
    fafc:	subs	r4, #1
    fafe:	movs	r2, #10
    fb00:	mov	r0, r9
    fb02:	str	r4, [sp, #16]
    fb04:	bl	10a40 <__multadd>
    fb08:	ldr	r3, [sp, #44]	; 0x2c
    fb0a:	mov	r4, r0
    fb0c:	cmp	r3, #0
    fb0e:	bne.w	f9d4 <_dtoa_r+0x8bc>
    fb12:	ldr	r3, [sp, #56]	; 0x38
    fb14:	cmp	r3, #0
    fb16:	ble.w	fef4 <_dtoa_r+0xddc>
    fb1a:	str	r3, [sp, #32]
    fb1c:	b.n	f604 <_dtoa_r+0x4ec>
    fb1e:	ldr	r4, [sp, #40]	; 0x28
    fb20:	b.n	f56c <_dtoa_r+0x454>
    fb22:	ldr	r3, [sp, #0]
    fb24:	cmp	r3, #2
    fb26:	ble.w	f5fc <_dtoa_r+0x4e4>
    fb2a:	ldr	r3, [sp, #32]
    fb2c:	cmp	r3, #0
    fb2e:	bne.w	fe6c <_dtoa_r+0xd54>
    fb32:	ldr	r1, [sp, #24]
    fb34:	movs	r2, #5
    fb36:	mov	r0, r9
    fb38:	bl	10a40 <__multadd>
    fb3c:	mov	r1, r0
    fb3e:	str	r0, [sp, #24]
    fb40:	mov	r0, r4
    fb42:	bl	10e88 <__mcmp>
    fb46:	cmp	r0, #0
    fb48:	str	r4, [sp, #40]	; 0x28
    fb4a:	ble.w	f97a <_dtoa_r+0x862>
    fb4e:	ldr	r2, [sp, #16]
    fb50:	ldr	r1, [sp, #36]	; 0x24
    fb52:	movs	r3, #49	; 0x31
    fb54:	adds	r2, #1
    fb56:	str	r2, [sp, #16]
    fb58:	strb	r3, [r1, #0]
    fb5a:	adds	r5, r1, #1
    fb5c:	b.n	f982 <_dtoa_r+0x86a>
    fb5e:	ldr	r2, [sp, #16]
    fb60:	adds	r2, #1
    fb62:	str	r2, [sp, #16]
    fb64:	ldr	r2, [sp, #36]	; 0x24
    fb66:	movs	r3, #49	; 0x31
    fb68:	strb	r3, [r2, #0]
    fb6a:	b.n	f686 <_dtoa_r+0x56e>
    fb6c:	movs	r3, #1
    fb6e:	str	r3, [sp, #44]	; 0x2c
    fb70:	b.n	f718 <_dtoa_r+0x600>
    fb72:	ldr.w	r9, [sp, #20]
    fb76:	b.n	f4ae <_dtoa_r+0x396>
    fb78:	cmp.w	sl, #0
    fb7c:	bne.w	f592 <_dtoa_r+0x47a>
    fb80:	ubfx	r3, fp, #0, #20
    fb84:	cmp	r3, #0
    fb86:	bne.w	fe06 <_dtoa_r+0xcee>
    fb8a:	bic.w	r7, fp, #2147483648	; 0x80000000
    fb8e:	lsrs	r7, r7, #20
    fb90:	lsls	r7, r7, #20
    fb92:	cbz	r7, fba0 <_dtoa_r+0xa88>
    fb94:	ldr	r3, [sp, #28]
    fb96:	adds	r3, #1
    fb98:	str	r3, [sp, #28]
    fb9a:	add.w	r8, r8, #1
    fb9e:	movs	r7, #1
    fba0:	ldr	r3, [sp, #48]	; 0x30
    fba2:	movs	r0, #1
    fba4:	cmp	r3, #0
    fba6:	beq.w	f5a6 <_dtoa_r+0x48e>
    fbaa:	b.n	f594 <_dtoa_r+0x47c>
    fbac:	mov	r0, sl
    fbae:	bl	9f90 <__aeabi_i2d>
    fbb2:	mov	r2, r6
    fbb4:	mov	r3, r7
    fbb6:	bl	a05c <__aeabi_dmul>
    fbba:	movs	r2, #0
    fbbc:	ldr	r3, [pc, #764]	; (febc <_dtoa_r+0xda4>)
    fbbe:	bl	9cf8 <__adddf3>
    fbc2:	mov	r4, r0
    fbc4:	sub.w	r5, r1, #54525952	; 0x3400000
    fbc8:	mov	r0, r6
    fbca:	mov	r1, r7
    fbcc:	movs	r2, #0
    fbce:	ldr	r3, [pc, #752]	; (fec0 <_dtoa_r+0xda8>)
    fbd0:	bl	9cf4 <__aeabi_dsub>
    fbd4:	mov	r2, r4
    fbd6:	mov	r3, r5
    fbd8:	mov	r6, r0
    fbda:	mov	r7, r1
    fbdc:	bl	a57c <__aeabi_dcmpgt>
    fbe0:	cmp	r0, #0
    fbe2:	bne.w	fd42 <_dtoa_r+0xc2a>
    fbe6:	mov	r2, r4
    fbe8:	add.w	r3, r5, #2147483648	; 0x80000000
    fbec:	mov	r0, r6
    fbee:	mov	r1, r7
    fbf0:	bl	a540 <__aeabi_dcmplt>
    fbf4:	cmp	r0, #0
    fbf6:	beq.n	fc8e <_dtoa_r+0xb76>
    fbf8:	movs	r3, #0
    fbfa:	str	r3, [sp, #24]
    fbfc:	mov	r6, r3
    fbfe:	b.n	f97a <_dtoa_r+0x862>
    fc00:	ldr	r0, [sp, #36]	; 0x24
    fc02:	b.w	f18a <_dtoa_r+0x72>
    fc06:	ldr	r3, [sp, #24]
    fc08:	ldr	r2, [sp, #48]	; 0x30
    fc0a:	str	r7, [sp, #24]
    fc0c:	subs	r3, r7, r3
    fc0e:	add	r2, r3
    fc10:	str	r2, [sp, #48]	; 0x30
    fc12:	movs	r7, #0
    fc14:	b.n	f4f2 <_dtoa_r+0x3da>
    fc16:	vldr	d7, [sp, #64]	; 0x40
    fc1a:	mov.w	sl, #2
    fc1e:	vstr	d7, [sp, #72]	; 0x48
    fc22:	b.n	f7a4 <_dtoa_r+0x68c>
    fc24:	mov	r4, r3
    fc26:	movs	r1, #0
    fc28:	str.w	r1, [r9, #68]	; 0x44
    fc2c:	b.n	f750 <_dtoa_r+0x638>
    fc2e:	movs	r4, #1
    fc30:	str	r4, [sp, #56]	; 0x38
    fc32:	str	r4, [sp, #32]
    fc34:	str	r4, [sp, #20]
    fc36:	b.n	fc26 <_dtoa_r+0xb0e>
    fc38:	cmp	r2, #0
    fc3a:	mov	sl, r3
    fc3c:	ble.n	fc62 <_dtoa_r+0xb4a>
    fc3e:	mov	r1, r4
    fc40:	movs	r2, #1
    fc42:	mov	r0, r9
    fc44:	bl	10dd8 <__lshift>
    fc48:	ldr	r1, [sp, #24]
    fc4a:	mov	r4, r0
    fc4c:	bl	10e88 <__mcmp>
    fc50:	cmp	r0, #0
    fc52:	ble.w	fee6 <_dtoa_r+0xdce>
    fc56:	cmp.w	sl, #57	; 0x39
    fc5a:	beq.w	fe70 <_dtoa_r+0xd58>
    fc5e:	add.w	sl, r5, #49	; 0x31
    fc62:	mov	fp, r6
    fc64:	strb.w	sl, [r7]
    fc68:	adds	r5, r7, #1
    fc6a:	mov	r6, r8
    fc6c:	str	r4, [sp, #40]	; 0x28
    fc6e:	b.n	f686 <_dtoa_r+0x56e>
    fc70:	bne.n	fc7c <_dtoa_r+0xb64>
    fc72:	tst.w	sl, #1
    fc76:	beq.n	fc7c <_dtoa_r+0xb64>
    fc78:	b.n	f666 <_dtoa_r+0x54e>
    fc7a:	mov	r5, r2
    fc7c:	ldrb.w	r3, [r5, #-1]
    fc80:	cmp	r3, #48	; 0x30
    fc82:	add.w	r2, r5, #4294967295
    fc86:	beq.n	fc7a <_dtoa_r+0xb62>
    fc88:	b.n	f686 <_dtoa_r+0x56e>
    fc8a:	ldr.w	r8, [sp, #72]	; 0x48
    fc8e:	ldrd	sl, fp, [sp, #64]	; 0x40
    fc92:	b.w	f32c <_dtoa_r+0x214>
    fc96:	ldr	r1, [sp, #36]	; 0x24
    fc98:	movs	r2, #48	; 0x30
    fc9a:	strb	r2, [r1, #0]
    fc9c:	ldr	r2, [sp, #16]
    fc9e:	ldrb.w	r4, [r5, #-1]
    fca2:	adds	r2, #1
    fca4:	str	r2, [sp, #16]
    fca6:	b.n	f4aa <_dtoa_r+0x392>
    fca8:	ldr	r3, [sp, #16]
    fcaa:	negs	r4, r3
    fcac:	cmp	r4, #0
    fcae:	beq.w	fe18 <_dtoa_r+0xd00>
    fcb2:	ldr	r3, [pc, #528]	; (fec4 <_dtoa_r+0xdac>)
    fcb4:	and.w	r2, r4, #15
    fcb8:	add.w	r3, r3, r2, lsl #3
    fcbc:	ldrd	r2, r3, [r3]
    fcc0:	ldrd	r0, r1, [sp, #64]	; 0x40
    fcc4:	bl	a05c <__aeabi_dmul>
    fcc8:	asrs	r4, r4, #4
    fcca:	mov	r6, r0
    fccc:	mov	r7, r1
    fcce:	beq.w	fefe <_dtoa_r+0xde6>
    fcd2:	ldr	r5, [pc, #500]	; (fec8 <_dtoa_r+0xdb0>)
    fcd4:	mov.w	sl, #2
    fcd8:	lsls	r2, r4, #31
    fcda:	bpl.n	fcf0 <_dtoa_r+0xbd8>
    fcdc:	mov	r0, r6
    fcde:	mov	r1, r7
    fce0:	ldrd	r2, r3, [r5]
    fce4:	bl	a05c <__aeabi_dmul>
    fce8:	add.w	sl, sl, #1
    fcec:	mov	r6, r0
    fcee:	mov	r7, r1
    fcf0:	asrs	r4, r4, #1
    fcf2:	add.w	r5, r5, #8
    fcf6:	bne.n	fcd8 <_dtoa_r+0xbc0>
    fcf8:	b.n	f7d8 <_dtoa_r+0x6c0>
    fcfa:	ldr	r1, [r6, #4]
    fcfc:	mov	r0, r9
    fcfe:	bl	109e0 <_Balloc>
    fd02:	ldr	r3, [r6, #16]
    fd04:	adds	r2, r3, #2
    fd06:	mov	r5, r0
    fd08:	lsls	r2, r2, #2
    fd0a:	add.w	r1, r6, #12
    fd0e:	adds	r0, #12
    fd10:	bl	8720 <memcpy>
    fd14:	mov	r1, r5
    fd16:	movs	r2, #1
    fd18:	mov	r0, r9
    fd1a:	bl	10dd8 <__lshift>
    fd1e:	mov	r8, r0
    fd20:	b.n	fa04 <_dtoa_r+0x8ec>
    fd22:	cmp	r3, #57	; 0x39
    fd24:	beq.w	fe70 <_dtoa_r+0xd58>
    fd28:	add.w	sl, r3, #1
    fd2c:	mov	fp, r6
    fd2e:	strb.w	sl, [r7]
    fd32:	adds	r5, r7, #1
    fd34:	mov	r6, r8
    fd36:	str	r4, [sp, #40]	; 0x28
    fd38:	b.n	f686 <_dtoa_r+0x56e>
    fd3a:	mov	fp, r6
    fd3c:	mov	sl, r3
    fd3e:	mov	r6, r8
    fd40:	b.n	f64e <_dtoa_r+0x536>
    fd42:	movs	r3, #0
    fd44:	str	r3, [sp, #24]
    fd46:	mov	r6, r3
    fd48:	b.n	fb4e <_dtoa_r+0xa36>
    fd4a:	ldr	r3, [sp, #72]	; 0x48
    fd4c:	ldr	r1, [pc, #372]	; (fec4 <_dtoa_r+0xdac>)
    fd4e:	subs	r2, r3, #1
    fd50:	add.w	r1, r1, r2, lsl #3
    fd54:	mov	r3, r5
    fd56:	str	r2, [sp, #92]	; 0x5c
    fd58:	ldrd	r0, r1, [r1]
    fd5c:	mov	r2, r4
    fd5e:	bl	a05c <__aeabi_dmul>
    fd62:	strd	r0, r1, [sp, #80]	; 0x50
    fd66:	mov	r1, r7
    fd68:	mov	r0, r6
    fd6a:	bl	a5bc <__aeabi_d2iz>
    fd6e:	mov	r4, r0
    fd70:	bl	9f90 <__aeabi_i2d>
    fd74:	mov	r3, r1
    fd76:	mov	r2, r0
    fd78:	mov	r1, r7
    fd7a:	mov	r0, r6
    fd7c:	bl	9cf4 <__aeabi_dsub>
    fd80:	ldr	r3, [sp, #72]	; 0x48
    fd82:	mov	r7, r1
    fd84:	ldr	r1, [sp, #36]	; 0x24
    fd86:	adds	r4, #48	; 0x30
    fd88:	cmp	r3, #1
    fd8a:	mov	r6, r0
    fd8c:	strb	r4, [r1, #0]
    fd8e:	add.w	r5, r1, #1
    fd92:	beq.n	fdd6 <_dtoa_r+0xcbe>
    fd94:	ldr	r3, [sp, #72]	; 0x48
    fd96:	ldr	r2, [sp, #36]	; 0x24
    fd98:	add	r3, r2
    fd9a:	mov	sl, r3
    fd9c:	mov	fp, r5
    fd9e:	movs	r2, #0
    fda0:	ldr	r3, [pc, #296]	; (fecc <_dtoa_r+0xdb4>)
    fda2:	mov	r0, r6
    fda4:	mov	r1, r7
    fda6:	bl	a05c <__aeabi_dmul>
    fdaa:	mov	r7, r1
    fdac:	mov	r6, r0
    fdae:	bl	a5bc <__aeabi_d2iz>
    fdb2:	mov	r4, r0
    fdb4:	bl	9f90 <__aeabi_i2d>
    fdb8:	adds	r4, #48	; 0x30
    fdba:	mov	r2, r0
    fdbc:	mov	r3, r1
    fdbe:	mov	r0, r6
    fdc0:	mov	r1, r7
    fdc2:	bl	9cf4 <__aeabi_dsub>
    fdc6:	strb.w	r4, [fp], #1
    fdca:	cmp	sl, fp
    fdcc:	mov	r6, r0
    fdce:	mov	r7, r1
    fdd0:	bne.n	fd9e <_dtoa_r+0xc86>
    fdd2:	ldr	r3, [sp, #92]	; 0x5c
    fdd4:	add	r5, r3
    fdd6:	movs	r2, #0
    fdd8:	ldr	r3, [pc, #244]	; (fed0 <_dtoa_r+0xdb8>)
    fdda:	ldrd	r0, r1, [sp, #80]	; 0x50
    fdde:	bl	9cf8 <__adddf3>
    fde2:	mov	r2, r6
    fde4:	mov	r3, r7
    fde6:	bl	a540 <__aeabi_dcmplt>
    fdea:	cmp	r0, #0
    fdec:	beq.n	fe80 <_dtoa_r+0xd68>
    fdee:	ldr	r3, [sp, #88]	; 0x58
    fdf0:	str	r3, [sp, #16]
    fdf2:	ldrb.w	r4, [r5, #-1]
    fdf6:	b.w	f492 <_dtoa_r+0x37a>
    fdfa:	ldr	r3, [sp, #28]
    fdfc:	ldr	r2, [sp, #32]
    fdfe:	subs	r5, r3, r2
    fe00:	movs	r3, #0
    fe02:	b.w	f4fe <_dtoa_r+0x3e6>
    fe06:	movs	r7, #0
    fe08:	b.n	fba0 <_dtoa_r+0xa88>
    fe0a:	ldr	r3, [sp, #96]	; 0x60
    fe0c:	ldr	r7, [sp, #24]
    fe0e:	ldr	r5, [sp, #28]
    fe10:	rsb	r3, r3, #54	; 0x36
    fe14:	b.w	f4fe <_dtoa_r+0x3e6>
    fe18:	ldrd	r6, r7, [sp, #64]	; 0x40
    fe1c:	mov.w	sl, #2
    fe20:	b.n	f7d8 <_dtoa_r+0x6c0>
    fe22:	ldr	r3, [sp, #32]
    fe24:	cmp	r3, #0
    fe26:	beq.w	fbac <_dtoa_r+0xa94>
    fe2a:	ldr	r3, [sp, #56]	; 0x38
    fe2c:	cmp	r3, #0
    fe2e:	ble.w	fc8e <_dtoa_r+0xb76>
    fe32:	movs	r2, #0
    fe34:	ldr	r3, [pc, #148]	; (fecc <_dtoa_r+0xdb4>)
    fe36:	mov	r0, r6
    fe38:	mov	r1, r7
    fe3a:	bl	a05c <__aeabi_dmul>
    fe3e:	mov	r6, r0
    fe40:	mov	r7, r1
    fe42:	add.w	r0, sl, #1
    fe46:	bl	9f90 <__aeabi_i2d>
    fe4a:	mov	r2, r6
    fe4c:	mov	r3, r7
    fe4e:	bl	a05c <__aeabi_dmul>
    fe52:	movs	r2, #0
    fe54:	ldr	r3, [pc, #100]	; (febc <_dtoa_r+0xda4>)
    fe56:	bl	9cf8 <__adddf3>
    fe5a:	ldr	r2, [sp, #16]
    fe5c:	ldr	r3, [sp, #56]	; 0x38
    fe5e:	str	r3, [sp, #72]	; 0x48
    fe60:	subs	r2, #1
    fe62:	mov	r4, r0
    fe64:	sub.w	r5, r1, #54525952	; 0x3400000
    fe68:	str	r2, [sp, #88]	; 0x58
    fe6a:	b.n	f81a <_dtoa_r+0x702>
    fe6c:	str	r4, [sp, #40]	; 0x28
    fe6e:	b.n	f97a <_dtoa_r+0x862>
    fe70:	movs	r2, #57	; 0x39
    fe72:	mov	fp, r6
    fe74:	str	r4, [sp, #40]	; 0x28
    fe76:	mov	r6, r8
    fe78:	strb	r2, [r7, #0]
    fe7a:	adds	r5, r7, #1
    fe7c:	b.w	f66a <_dtoa_r+0x552>
    fe80:	ldrd	r2, r3, [sp, #80]	; 0x50
    fe84:	movs	r0, #0
    fe86:	ldr	r1, [pc, #72]	; (fed0 <_dtoa_r+0xdb8>)
    fe88:	bl	9cf4 <__aeabi_dsub>
    fe8c:	mov	r2, r6
    fe8e:	mov	r3, r7
    fe90:	bl	a57c <__aeabi_dcmpgt>
    fe94:	cbnz	r0, fe9a <_dtoa_r+0xd82>
    fe96:	b.n	fc8e <_dtoa_r+0xb76>
    fe98:	mov	r5, r2
    fe9a:	ldrb.w	r3, [r5, #-1]
    fe9e:	cmp	r3, #48	; 0x30
    fea0:	add.w	r2, r5, #4294967295
    fea4:	beq.n	fe98 <_dtoa_r+0xd80>
    fea6:	b.n	f91c <_dtoa_r+0x804>
    fea8:	ldr	r3, [sp, #88]	; 0x58
    feaa:	str	r3, [sp, #16]
    feac:	b.w	f492 <_dtoa_r+0x37a>
    feb0:	cmp.w	sl, #0
    feb4:	bne.w	f9b0 <_dtoa_r+0x898>
    feb8:	b.n	fb80 <_dtoa_r+0xa68>
    feba:	nop
    febc:	.word	0x401c0000
    fec0:	.word	0x40140000
    fec4:	.word	0x00012bc0
    fec8:	.word	0x00012c88
    fecc:	.word	0x40240000
    fed0:	.word	0x3fe00000
    fed4:	cmp	r3, #57	; 0x39
    fed6:	mov	fp, sl
    fed8:	mov	sl, r3
    feda:	beq.n	fe70 <_dtoa_r+0xd58>
    fedc:	cmp.w	fp, #0
    fee0:	bgt.w	fc5e <_dtoa_r+0xb46>
    fee4:	b.n	fc62 <_dtoa_r+0xb4a>
    fee6:	bne.w	fc62 <_dtoa_r+0xb4a>
    feea:	tst.w	sl, #1
    feee:	beq.w	fc62 <_dtoa_r+0xb4a>
    fef2:	b.n	fc56 <_dtoa_r+0xb3e>
    fef4:	ldr	r3, [sp, #0]
    fef6:	cmp	r3, #2
    fef8:	bgt.n	ff46 <_dtoa_r+0xe2e>
    fefa:	ldr	r3, [sp, #56]	; 0x38
    fefc:	b.n	fb1a <_dtoa_r+0xa02>
    fefe:	mov.w	sl, #2
    ff02:	b.n	f7d8 <_dtoa_r+0x6c0>
    ff04:	ldr	r3, [sp, #0]
    ff06:	cmp	r3, #2
    ff08:	bgt.n	ff46 <_dtoa_r+0xe2e>
    ff0a:	ldr	r3, [sp, #56]	; 0x38
    ff0c:	b.n	f9ea <_dtoa_r+0x8d2>
    ff0e:	movs	r4, #0
    ff10:	str.w	r4, [r9, #68]	; 0x44
    ff14:	mov	r1, r4
    ff16:	mov	r0, r9
    ff18:	bl	109e0 <_Balloc>
    ff1c:	mov.w	r3, #4294967295
    ff20:	str	r3, [sp, #32]
    ff22:	str	r3, [sp, #56]	; 0x38
    ff24:	movs	r3, #1
    ff26:	str	r0, [sp, #36]	; 0x24
    ff28:	str	r4, [sp, #20]
    ff2a:	str.w	r0, [r9, #64]	; 0x40
    ff2e:	str	r3, [sp, #44]	; 0x2c
    ff30:	b.w	f32c <_dtoa_r+0x214>
    ff34:	beq.w	f5c8 <_dtoa_r+0x4b0>
    ff38:	rsb	r0, r0, #60	; 0x3c
    ff3c:	b.w	f5be <_dtoa_r+0x4a6>
    ff40:	movs	r6, #1
    ff42:	b.w	f2be <_dtoa_r+0x1a6>
    ff46:	ldr	r3, [sp, #56]	; 0x38
    ff48:	str	r3, [sp, #32]
    ff4a:	b.n	fb2a <_dtoa_r+0xa12>

0000ff4c <__libc_fini_array>:
    ff4c:	push	{r3, r4, r5, lr}
    ff4e:	ldr	r5, [pc, #28]	; (ff6c <__libc_fini_array+0x20>)
    ff50:	ldr	r4, [pc, #28]	; (ff70 <__libc_fini_array+0x24>)
    ff52:	subs	r4, r5, r4
    ff54:	asrs	r4, r4, #2
    ff56:	beq.n	ff64 <__libc_fini_array+0x18>
    ff58:	subs	r4, #1
    ff5a:	ldr.w	r3, [r5, #-4]!
    ff5e:	blx	r3
    ff60:	cmp	r4, #0
    ff62:	bne.n	ff58 <__libc_fini_array+0xc>
    ff64:	ldmia.w	sp!, {r3, r4, r5, lr}
    ff68:	b.w	12d1c <__init_array_end>
	...

0000ff74 <_malloc_trim_r>:
    ff74:	push	{r3, r4, r5, r6, r7, lr}
    ff76:	ldr	r7, [pc, #140]	; (10004 <_malloc_trim_r+0x90>)
    ff78:	mov	r4, r1
    ff7a:	mov	r6, r0
    ff7c:	bl	b24c <__malloc_lock>
    ff80:	ldr	r3, [r7, #8]
    ff82:	ldr	r5, [r3, #4]
    ff84:	bic.w	r5, r5, #3
    ff88:	subs	r1, r5, r4
    ff8a:	addw	r1, r1, #4079	; 0xfef
    ff8e:	bic.w	r1, r1, #4080	; 0xff0
    ff92:	bic.w	r1, r1, #15
    ff96:	sub.w	r4, r1, #4096	; 0x1000
    ff9a:	cmp.w	r4, #4096	; 0x1000
    ff9e:	blt.n	ffb0 <_malloc_trim_r+0x3c>
    ffa0:	movs	r1, #0
    ffa2:	mov	r0, r6
    ffa4:	bl	b634 <_sbrk_r>
    ffa8:	ldr	r3, [r7, #8]
    ffaa:	add	r3, r5
    ffac:	cmp	r0, r3
    ffae:	beq.n	ffba <_malloc_trim_r+0x46>
    ffb0:	mov	r0, r6
    ffb2:	bl	b250 <__malloc_unlock>
    ffb6:	movs	r0, #0
    ffb8:	pop	{r3, r4, r5, r6, r7, pc}
    ffba:	negs	r1, r4
    ffbc:	mov	r0, r6
    ffbe:	bl	b634 <_sbrk_r>
    ffc2:	adds	r0, #1
    ffc4:	beq.n	ffe2 <_malloc_trim_r+0x6e>
    ffc6:	ldr	r3, [pc, #64]	; (10008 <_malloc_trim_r+0x94>)
    ffc8:	ldr	r2, [r7, #8]
    ffca:	ldr	r1, [r3, #0]
    ffcc:	subs	r5, r5, r4
    ffce:	orr.w	r5, r5, #1
    ffd2:	mov	r0, r6
    ffd4:	subs	r1, r1, r4
    ffd6:	str	r5, [r2, #4]
    ffd8:	str	r1, [r3, #0]
    ffda:	bl	b250 <__malloc_unlock>
    ffde:	movs	r0, #1
    ffe0:	pop	{r3, r4, r5, r6, r7, pc}
    ffe2:	movs	r1, #0
    ffe4:	mov	r0, r6
    ffe6:	bl	b634 <_sbrk_r>
    ffea:	ldr	r2, [r7, #8]
    ffec:	subs	r3, r0, r2
    ffee:	cmp	r3, #15
    fff0:	ble.n	ffb0 <_malloc_trim_r+0x3c>
    fff2:	ldr	r4, [pc, #24]	; (1000c <_malloc_trim_r+0x98>)
    fff4:	ldr	r1, [pc, #16]	; (10008 <_malloc_trim_r+0x94>)
    fff6:	ldr	r4, [r4, #0]
    fff8:	orr.w	r3, r3, #1
    fffc:	subs	r0, r0, r4
    fffe:	str	r3, [r2, #4]
   10000:	str	r0, [r1, #0]
   10002:	b.n	ffb0 <_malloc_trim_r+0x3c>
   10004:	.word	0x1fff19b0
   10008:	.word	0x1fff85b0
   1000c:	.word	0x1fff1dbc

00010010 <_free_r>:
   10010:	cmp	r1, #0
   10012:	beq.n	100a0 <_free_r+0x90>
   10014:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   10018:	mov	r5, r1
   1001a:	mov	r8, r0
   1001c:	bl	b24c <__malloc_lock>
   10020:	ldr.w	r7, [r5, #-4]
   10024:	ldr	r1, [pc, #424]	; (101d0 <_free_r+0x1c0>)
   10026:	bic.w	r3, r7, #1
   1002a:	sub.w	r4, r5, #8
   1002e:	adds	r2, r4, r3
   10030:	ldr	r6, [r1, #8]
   10032:	ldr	r0, [r2, #4]
   10034:	cmp	r2, r6
   10036:	bic.w	r0, r0, #3
   1003a:	beq.n	10102 <_free_r+0xf2>
   1003c:	lsls	r6, r7, #31
   1003e:	str	r0, [r2, #4]
   10040:	bmi.n	1005a <_free_r+0x4a>
   10042:	ldr.w	r7, [r5, #-8]
   10046:	subs	r4, r4, r7
   10048:	add.w	lr, r1, #8
   1004c:	ldr	r5, [r4, #8]
   1004e:	cmp	r5, lr
   10050:	add	r3, r7
   10052:	beq.n	10134 <_free_r+0x124>
   10054:	ldr	r7, [r4, #12]
   10056:	str	r7, [r5, #12]
   10058:	str	r5, [r7, #8]
   1005a:	adds	r5, r2, r0
   1005c:	ldr	r5, [r5, #4]
   1005e:	lsls	r5, r5, #31
   10060:	bpl.n	100e8 <_free_r+0xd8>
   10062:	orr.w	r2, r3, #1
   10066:	str	r2, [r4, #4]
   10068:	str	r3, [r4, r3]
   1006a:	cmp.w	r3, #512	; 0x200
   1006e:	bcs.n	100a2 <_free_r+0x92>
   10070:	lsrs	r3, r3, #3
   10072:	adds	r2, r3, #1
   10074:	ldr	r5, [r1, #4]
   10076:	ldr.w	r7, [r1, r2, lsl #3]
   1007a:	str	r7, [r4, #8]
   1007c:	movs	r0, #1
   1007e:	asrs	r3, r3, #2
   10080:	lsl.w	r3, r0, r3
   10084:	add.w	r0, r1, r2, lsl #3
   10088:	orrs	r5, r3
   1008a:	subs	r0, #8
   1008c:	str	r0, [r4, #12]
   1008e:	str	r5, [r1, #4]
   10090:	str.w	r4, [r1, r2, lsl #3]
   10094:	str	r4, [r7, #12]
   10096:	mov	r0, r8
   10098:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   1009c:	b.w	b250 <__malloc_unlock>
   100a0:	bx	lr
   100a2:	lsrs	r2, r3, #9
   100a4:	cmp	r2, #4
   100a6:	bhi.n	10150 <_free_r+0x140>
   100a8:	lsrs	r2, r3, #6
   100aa:	add.w	r7, r2, #57	; 0x39
   100ae:	lsls	r7, r7, #1
   100b0:	add.w	r5, r2, #56	; 0x38
   100b4:	add.w	r0, r1, r7, lsl #2
   100b8:	ldr.w	r2, [r1, r7, lsl #2]
   100bc:	ldr	r1, [pc, #272]	; (101d0 <_free_r+0x1c0>)
   100be:	subs	r0, #8
   100c0:	cmp	r0, r2
   100c2:	beq.n	10160 <_free_r+0x150>
   100c4:	ldr	r1, [r2, #4]
   100c6:	bic.w	r1, r1, #3
   100ca:	cmp	r3, r1
   100cc:	bcs.n	100d4 <_free_r+0xc4>
   100ce:	ldr	r2, [r2, #8]
   100d0:	cmp	r0, r2
   100d2:	bne.n	100c4 <_free_r+0xb4>
   100d4:	ldr	r0, [r2, #12]
   100d6:	str	r0, [r4, #12]
   100d8:	str	r2, [r4, #8]
   100da:	str	r4, [r0, #8]
   100dc:	str	r4, [r2, #12]
   100de:	mov	r0, r8
   100e0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   100e4:	b.w	b250 <__malloc_unlock>
   100e8:	ldr	r5, [r2, #8]
   100ea:	ldr	r7, [pc, #232]	; (101d4 <_free_r+0x1c4>)
   100ec:	cmp	r5, r7
   100ee:	add	r3, r0
   100f0:	beq.n	10172 <_free_r+0x162>
   100f2:	ldr	r0, [r2, #12]
   100f4:	str	r0, [r5, #12]
   100f6:	orr.w	r2, r3, #1
   100fa:	str	r5, [r0, #8]
   100fc:	str	r2, [r4, #4]
   100fe:	str	r3, [r4, r3]
   10100:	b.n	1006a <_free_r+0x5a>
   10102:	lsls	r7, r7, #31
   10104:	add	r3, r0
   10106:	bmi.n	10118 <_free_r+0x108>
   10108:	ldr.w	r2, [r5, #-8]
   1010c:	subs	r4, r4, r2
   1010e:	add	r3, r2
   10110:	ldr	r0, [r4, #8]
   10112:	ldr	r2, [r4, #12]
   10114:	str	r2, [r0, #12]
   10116:	str	r0, [r2, #8]
   10118:	ldr	r2, [pc, #188]	; (101d8 <_free_r+0x1c8>)
   1011a:	ldr	r2, [r2, #0]
   1011c:	orr.w	r0, r3, #1
   10120:	cmp	r3, r2
   10122:	str	r0, [r4, #4]
   10124:	str	r4, [r1, #8]
   10126:	bcc.n	10096 <_free_r+0x86>
   10128:	ldr	r3, [pc, #176]	; (101dc <_free_r+0x1cc>)
   1012a:	mov	r0, r8
   1012c:	ldr	r1, [r3, #0]
   1012e:	bl	ff74 <_malloc_trim_r>
   10132:	b.n	10096 <_free_r+0x86>
   10134:	adds	r1, r2, r0
   10136:	ldr	r1, [r1, #4]
   10138:	lsls	r1, r1, #31
   1013a:	bmi.n	101c6 <_free_r+0x1b6>
   1013c:	ldr	r1, [r2, #8]
   1013e:	ldr	r2, [r2, #12]
   10140:	str	r2, [r1, #12]
   10142:	add	r3, r0
   10144:	orr.w	r0, r3, #1
   10148:	str	r1, [r2, #8]
   1014a:	str	r0, [r4, #4]
   1014c:	str	r3, [r4, r3]
   1014e:	b.n	10096 <_free_r+0x86>
   10150:	cmp	r2, #20
   10152:	bhi.n	10184 <_free_r+0x174>
   10154:	add.w	r7, r2, #92	; 0x5c
   10158:	lsls	r7, r7, #1
   1015a:	add.w	r5, r2, #91	; 0x5b
   1015e:	b.n	100b4 <_free_r+0xa4>
   10160:	asrs	r2, r5, #2
   10162:	ldr	r3, [r1, #4]
   10164:	movs	r5, #1
   10166:	lsl.w	r2, r5, r2
   1016a:	orrs	r3, r2
   1016c:	str	r3, [r1, #4]
   1016e:	mov	r2, r0
   10170:	b.n	100d6 <_free_r+0xc6>
   10172:	orr.w	r2, r3, #1
   10176:	str	r4, [r1, #20]
   10178:	str	r4, [r1, #16]
   1017a:	str	r5, [r4, #12]
   1017c:	str	r5, [r4, #8]
   1017e:	str	r2, [r4, #4]
   10180:	str	r3, [r4, r3]
   10182:	b.n	10096 <_free_r+0x86>
   10184:	cmp	r2, #84	; 0x54
   10186:	bhi.n	10196 <_free_r+0x186>
   10188:	lsrs	r2, r3, #12
   1018a:	add.w	r7, r2, #111	; 0x6f
   1018e:	lsls	r7, r7, #1
   10190:	add.w	r5, r2, #110	; 0x6e
   10194:	b.n	100b4 <_free_r+0xa4>
   10196:	cmp.w	r2, #340	; 0x154
   1019a:	bhi.n	101aa <_free_r+0x19a>
   1019c:	lsrs	r2, r3, #15
   1019e:	add.w	r7, r2, #120	; 0x78
   101a2:	lsls	r7, r7, #1
   101a4:	add.w	r5, r2, #119	; 0x77
   101a8:	b.n	100b4 <_free_r+0xa4>
   101aa:	movw	r0, #1364	; 0x554
   101ae:	cmp	r2, r0
   101b0:	bhi.n	101c0 <_free_r+0x1b0>
   101b2:	lsrs	r2, r3, #18
   101b4:	add.w	r7, r2, #125	; 0x7d
   101b8:	lsls	r7, r7, #1
   101ba:	add.w	r5, r2, #124	; 0x7c
   101be:	b.n	100b4 <_free_r+0xa4>
   101c0:	movs	r7, #254	; 0xfe
   101c2:	movs	r5, #126	; 0x7e
   101c4:	b.n	100b4 <_free_r+0xa4>
   101c6:	orr.w	r2, r3, #1
   101ca:	str	r2, [r4, #4]
   101cc:	str	r3, [r4, r3]
   101ce:	b.n	10096 <_free_r+0x86>
   101d0:	.word	0x1fff19b0
   101d4:	.word	0x1fff19b8
   101d8:	.word	0x1fff1db8
   101dc:	.word	0x1fff85ac

000101e0 <rshift>:
   101e0:	ldr	r2, [r0, #16]
   101e2:	asrs	r3, r1, #5
   101e4:	cmp	r3, r2
   101e6:	bge.n	10246 <rshift+0x66>
   101e8:	push	{r4, r5, r6, r7, lr}
   101ea:	ands.w	r1, r1, #31
   101ee:	add.w	r6, r0, #20
   101f2:	add.w	r2, r6, r2, lsl #2
   101f6:	add.w	lr, r6, r3, lsl #2
   101fa:	beq.n	10250 <rshift+0x70>
   101fc:	ldr.w	r3, [r6, r3, lsl #2]
   10200:	add.w	r5, lr, #4
   10204:	cmp	r2, r5
   10206:	lsr.w	r4, r3, r1
   1020a:	rsb	ip, r1, #32
   1020e:	bls.n	10284 <rshift+0xa4>
   10210:	add.w	r7, r0, #16
   10214:	ldr	r3, [r5, #0]
   10216:	lsl.w	r3, r3, ip
   1021a:	orrs	r3, r4
   1021c:	str.w	r3, [r7, #4]!
   10220:	ldr.w	r3, [r5], #4
   10224:	cmp	r2, r5
   10226:	lsr.w	r4, r3, r1
   1022a:	bhi.n	10214 <rshift+0x34>
   1022c:	rsb	r2, lr, r2
   10230:	subs	r2, #5
   10232:	bic.w	r2, r2, #3
   10236:	adds	r2, #4
   10238:	add	r2, r6
   1023a:	str	r4, [r2, #0]
   1023c:	cbz	r4, 10240 <rshift+0x60>
   1023e:	adds	r2, #4
   10240:	subs	r3, r2, r6
   10242:	asrs	r3, r3, #2
   10244:	b.n	10274 <rshift+0x94>
   10246:	movs	r3, #0
   10248:	str	r3, [r0, #16]
   1024a:	movs	r3, #0
   1024c:	str	r3, [r0, #20]
   1024e:	bx	lr
   10250:	cmp	r2, lr
   10252:	bls.n	1027a <rshift+0x9a>
   10254:	add.w	r4, r0, #16
   10258:	mov	r1, lr
   1025a:	ldr.w	r5, [r1], #4
   1025e:	str.w	r5, [r4, #4]!
   10262:	cmp	r2, r1
   10264:	bhi.n	1025a <rshift+0x7a>
   10266:	mvn.w	r3, lr
   1026a:	add	r3, r2
   1026c:	bic.w	r3, r3, #3
   10270:	adds	r3, #4
   10272:	asrs	r3, r3, #2
   10274:	str	r3, [r0, #16]
   10276:	cbz	r3, 1027e <rshift+0x9e>
   10278:	pop	{r4, r5, r6, r7, pc}
   1027a:	movs	r3, #0
   1027c:	str	r3, [r0, #16]
   1027e:	movs	r3, #0
   10280:	str	r3, [r0, #20]
   10282:	pop	{r4, r5, r6, r7, pc}
   10284:	mov	r2, r6
   10286:	b.n	1023a <rshift+0x5a>

00010288 <__gethex>:
   10288:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1028c:	sub	sp, #44	; 0x2c
   1028e:	mov	r9, r1
   10290:	str	r0, [sp, #20]
   10292:	ldr	r0, [sp, #88]	; 0x58
   10294:	str	r2, [sp, #12]
   10296:	str	r3, [sp, #32]
   10298:	bl	10964 <__localeconv_l>
   1029c:	ldr	r3, [r0, #0]
   1029e:	str	r3, [sp, #8]
   102a0:	mov	r0, r3
   102a2:	mov	r4, r3
   102a4:	bl	b700 <strlen>
   102a8:	ldr.w	r3, [r9]
   102ac:	str	r0, [sp, #0]
   102ae:	ldrb	r2, [r3, #2]
   102b0:	adds	r1, r4, r0
   102b2:	cmp	r2, #48	; 0x30
   102b4:	ldrb.w	fp, [r1, #-1]
   102b8:	bne.w	1060e <__gethex+0x386>
   102bc:	adds	r3, #3
   102be:	mov.w	r8, #0
   102c2:	mov	r4, r3
   102c4:	ldrb.w	r2, [r3], #1
   102c8:	cmp	r2, #48	; 0x30
   102ca:	add.w	r8, r8, #1
   102ce:	beq.n	102c2 <__gethex+0x3a>
   102d0:	ldr	r6, [pc, #712]	; (1059c <__gethex+0x314>)
   102d2:	ldrb	r3, [r6, r2]
   102d4:	cmp	r3, #0
   102d6:	beq.w	104ba <__gethex+0x232>
   102da:	ldrb	r3, [r4, #0]
   102dc:	mov.w	sl, #0
   102e0:	ldrb	r3, [r6, r3]
   102e2:	mov	r5, sl
   102e4:	mov	r7, r4
   102e6:	cbz	r3, 102f2 <__gethex+0x6a>
   102e8:	ldrb.w	r3, [r7, #1]!
   102ec:	ldrb	r3, [r6, r3]
   102ee:	cmp	r3, #0
   102f0:	bne.n	102e8 <__gethex+0x60>
   102f2:	ldr	r2, [sp, #0]
   102f4:	ldr	r1, [sp, #8]
   102f6:	mov	r0, r7
   102f8:	bl	b7dc <strncmp>
   102fc:	cmp	r0, #0
   102fe:	beq.w	10426 <__gethex+0x19e>
   10302:	ldrb	r3, [r7, #0]
   10304:	cmp	r5, #0
   10306:	beq.w	105ec <__gethex+0x364>
   1030a:	subs	r5, r5, r7
   1030c:	lsls	r2, r5, #2
   1030e:	str	r2, [sp, #4]
   10310:	cmp	r3, #80	; 0x50
   10312:	beq.w	10438 <__gethex+0x1b0>
   10316:	cmp	r3, #112	; 0x70
   10318:	beq.w	10438 <__gethex+0x1b0>
   1031c:	mov	r5, r7
   1031e:	str.w	r7, [r9]
   10322:	cmp.w	sl, #0
   10326:	bne.w	10498 <__gethex+0x210>
   1032a:	subs	r3, r5, r4
   1032c:	subs	r3, #1
   1032e:	cmp	r3, #7
   10330:	mov	r1, sl
   10332:	ble.n	1033e <__gethex+0xb6>
   10334:	asrs	r3, r3, #1
   10336:	cmp	r3, #7
   10338:	add.w	r1, r1, #1
   1033c:	bgt.n	10334 <__gethex+0xac>
   1033e:	ldr	r0, [sp, #20]
   10340:	bl	109e0 <_Balloc>
   10344:	mov	r3, r0
   10346:	adds	r3, #20
   10348:	cmp	r5, r4
   1034a:	str	r0, [sp, #16]
   1034c:	str	r3, [sp, #28]
   1034e:	bls.w	106f8 <__gethex+0x470>
   10352:	mov	r9, r3
   10354:	ldr	r3, [sp, #0]
   10356:	mov.w	r8, #0
   1035a:	rsb	r3, r3, #1
   1035e:	mov	r7, r8
   10360:	str	r3, [sp, #24]
   10362:	b.n	10384 <__gethex+0xfc>
   10364:	cmp	r7, #32
   10366:	beq.w	104a8 <__gethex+0x220>
   1036a:	mov	r2, r7
   1036c:	adds	r7, #4
   1036e:	ldrb.w	r3, [r5, #-1]
   10372:	ldrb	r3, [r6, r3]
   10374:	mov	r5, sl
   10376:	and.w	r3, r3, #15
   1037a:	lsls	r3, r2
   1037c:	cmp	r5, r4
   1037e:	orr.w	r8, r8, r3
   10382:	bls.n	103b0 <__gethex+0x128>
   10384:	ldrb.w	r3, [r5, #-1]
   10388:	cmp	r3, fp
   1038a:	add.w	sl, r5, #4294967295
   1038e:	bne.n	10364 <__gethex+0xdc>
   10390:	ldr	r3, [sp, #24]
   10392:	add	r3, sl
   10394:	cmp	r3, r4
   10396:	bcc.n	10364 <__gethex+0xdc>
   10398:	mov	r0, r3
   1039a:	ldr	r2, [sp, #0]
   1039c:	ldr	r1, [sp, #8]
   1039e:	str	r3, [sp, #36]	; 0x24
   103a0:	bl	b7dc <strncmp>
   103a4:	ldr	r3, [sp, #36]	; 0x24
   103a6:	cmp	r0, #0
   103a8:	bne.n	10364 <__gethex+0xdc>
   103aa:	mov	r5, r3
   103ac:	cmp	r5, r4
   103ae:	bhi.n	10384 <__gethex+0xfc>
   103b0:	str.w	r8, [r9], #4
   103b4:	ldr	r3, [sp, #28]
   103b6:	ldr	r2, [sp, #16]
   103b8:	rsb	r9, r3, r9
   103bc:	mov.w	r3, r9, asr #2
   103c0:	str	r3, [r2, #16]
   103c2:	mov	r0, r8
   103c4:	mov.w	r9, r3, lsl #5
   103c8:	bl	10b58 <__hi0bits>
   103cc:	ldr	r3, [sp, #12]
   103ce:	ldr	r6, [r3, #0]
   103d0:	rsb	r0, r0, r9
   103d4:	cmp	r0, r6
   103d6:	bgt.w	105a0 <__gethex+0x318>
   103da:	blt.w	105f0 <__gethex+0x368>
   103de:	movs	r7, #0
   103e0:	ldr	r3, [sp, #12]
   103e2:	ldr	r2, [sp, #4]
   103e4:	ldr	r3, [r3, #8]
   103e6:	cmp	r2, r3
   103e8:	bgt.w	1051a <__gethex+0x292>
   103ec:	ldr	r0, [sp, #12]
   103ee:	ldr	r1, [sp, #4]
   103f0:	ldr	r3, [r0, #4]
   103f2:	cmp	r1, r3
   103f4:	bge.w	10562 <__gethex+0x2da>
   103f8:	subs	r5, r3, r1
   103fa:	cmp	r6, r5
   103fc:	bgt.w	1061e <__gethex+0x396>
   10400:	ldr	r2, [r0, #12]
   10402:	cmp	r2, #2
   10404:	beq.w	10706 <__gethex+0x47e>
   10408:	cmp	r2, #3
   1040a:	beq.w	106c6 <__gethex+0x43e>
   1040e:	cmp	r2, #1
   10410:	beq.w	1070e <__gethex+0x486>
   10414:	ldr	r0, [sp, #20]
   10416:	ldr	r1, [sp, #16]
   10418:	bl	10a2c <_Bfree>
   1041c:	ldr	r2, [sp, #80]	; 0x50
   1041e:	movs	r3, #0
   10420:	str	r3, [r2, #0]
   10422:	movs	r0, #80	; 0x50
   10424:	b.n	104a2 <__gethex+0x21a>
   10426:	cmp	r5, #0
   10428:	beq.w	1065e <__gethex+0x3d6>
   1042c:	ldrb	r3, [r7, #0]
   1042e:	b.n	1030a <__gethex+0x82>
   10430:	movs	r3, #0
   10432:	str	r3, [sp, #4]
   10434:	mov.w	sl, #1
   10438:	ldrb	r3, [r7, #1]
   1043a:	cmp	r3, #43	; 0x2b
   1043c:	beq.w	10598 <__gethex+0x310>
   10440:	cmp	r3, #45	; 0x2d
   10442:	beq.n	10530 <__gethex+0x2a8>
   10444:	adds	r1, r7, #1
   10446:	movs	r5, #0
   10448:	ldrb	r3, [r6, r3]
   1044a:	ldr	r0, [pc, #336]	; (1059c <__gethex+0x314>)
   1044c:	subs	r2, r3, #1
   1044e:	cmp	r2, #24
   10450:	bhi.w	1031c <__gethex+0x94>
   10454:	ldrb	r2, [r1, #1]
   10456:	ldrb	r2, [r0, r2]
   10458:	subs	r0, r2, #1
   1045a:	cmp	r0, #24
   1045c:	sub.w	r3, r3, #16
   10460:	add.w	r1, r1, #1
   10464:	bhi.n	1047e <__gethex+0x1f6>
   10466:	ldrb.w	r0, [r1, #1]!
   1046a:	add.w	r3, r3, r3, lsl #2
   1046e:	add.w	r3, r2, r3, lsl #1
   10472:	ldrb	r2, [r6, r0]
   10474:	subs	r0, r2, #1
   10476:	cmp	r0, #24
   10478:	sub.w	r3, r3, #16
   1047c:	bls.n	10466 <__gethex+0x1de>
   1047e:	cbz	r5, 10482 <__gethex+0x1fa>
   10480:	negs	r3, r3
   10482:	ldr	r2, [sp, #4]
   10484:	mov	r5, r7
   10486:	add	r2, r3
   10488:	mov	r7, r1
   1048a:	str	r2, [sp, #4]
   1048c:	str.w	r7, [r9]
   10490:	cmp.w	sl, #0
   10494:	beq.w	1032a <__gethex+0xa2>
   10498:	cmp.w	r8, #0
   1049c:	ite	eq
   1049e:	moveq	r0, #6
   104a0:	movne	r0, #0
   104a2:	add	sp, #44	; 0x2c
   104a4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   104a8:	str.w	r8, [r9]
   104ac:	mov.w	r8, #0
   104b0:	add.w	r9, r9, #4
   104b4:	mov	r2, r8
   104b6:	movs	r7, #4
   104b8:	b.n	1036e <__gethex+0xe6>
   104ba:	ldr	r5, [sp, #0]
   104bc:	ldr	r1, [sp, #8]
   104be:	mov	r2, r5
   104c0:	mov	r0, r4
   104c2:	bl	b7dc <strncmp>
   104c6:	cmp	r0, #0
   104c8:	beq.n	10538 <__gethex+0x2b0>
   104ca:	ldrb	r3, [r4, #0]
   104cc:	mov	r7, r4
   104ce:	cmp	r3, #80	; 0x50
   104d0:	beq.n	10430 <__gethex+0x1a8>
   104d2:	cmp	r3, #112	; 0x70
   104d4:	beq.n	10430 <__gethex+0x1a8>
   104d6:	str.w	r7, [r9]
   104da:	b.n	10498 <__gethex+0x210>
   104dc:	ldr	r3, [sp, #16]
   104de:	ldr	r3, [r3, #8]
   104e0:	cmp	r7, r3
   104e2:	bge.w	1074e <__gethex+0x4c6>
   104e6:	mov	r3, r7
   104e8:	ldr	r0, [sp, #16]
   104ea:	add.w	r2, r0, r3, lsl #2
   104ee:	movs	r1, #1
   104f0:	adds	r3, #1
   104f2:	cmp	r4, #2
   104f4:	str	r3, [r0, #16]
   104f6:	str	r1, [r2, #20]
   104f8:	beq.w	1072c <__gethex+0x4a4>
   104fc:	cmp	r7, r3
   104fe:	bge.w	106b8 <__gethex+0x430>
   10502:	movs	r1, #1
   10504:	ldr	r0, [sp, #16]
   10506:	bl	101e0 <rshift>
   1050a:	ldr	r3, [sp, #12]
   1050c:	ldr	r2, [sp, #4]
   1050e:	ldr	r3, [r3, #8]
   10510:	adds	r2, #1
   10512:	cmp	r2, r3
   10514:	str	r2, [sp, #4]
   10516:	ble.w	106be <__gethex+0x436>
   1051a:	ldr	r0, [sp, #20]
   1051c:	ldr	r1, [sp, #16]
   1051e:	bl	10a2c <_Bfree>
   10522:	ldr	r2, [sp, #80]	; 0x50
   10524:	movs	r3, #0
   10526:	movs	r0, #163	; 0xa3
   10528:	str	r3, [r2, #0]
   1052a:	add	sp, #44	; 0x2c
   1052c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   10530:	movs	r5, #1
   10532:	ldrb	r3, [r7, #2]
   10534:	adds	r1, r7, #2
   10536:	b.n	10448 <__gethex+0x1c0>
   10538:	ldrb	r2, [r4, r5]
   1053a:	ldrb	r3, [r6, r2]
   1053c:	adds	r7, r4, r5
   1053e:	cmp	r3, #0
   10540:	beq.n	10616 <__gethex+0x38e>
   10542:	cmp	r2, #48	; 0x30
   10544:	mov	r4, r7
   10546:	bne.n	10552 <__gethex+0x2ca>
   10548:	ldrb.w	r3, [r4, #1]!
   1054c:	cmp	r3, #48	; 0x30
   1054e:	beq.n	10548 <__gethex+0x2c0>
   10550:	ldrb	r3, [r6, r3]
   10552:	clz	sl, r3
   10556:	mov	r5, r7
   10558:	mov.w	sl, sl, lsr #5
   1055c:	mov.w	r8, #1
   10560:	b.n	102e4 <__gethex+0x5c>
   10562:	movs	r4, #1
   10564:	cbz	r7, 10580 <__gethex+0x2f8>
   10566:	ldr	r3, [sp, #12]
   10568:	ldr	r3, [r3, #12]
   1056a:	cmp	r3, #2
   1056c:	beq.w	1067a <__gethex+0x3f2>
   10570:	cmp	r3, #3
   10572:	beq.w	10682 <__gethex+0x3fa>
   10576:	cmp	r3, #1
   10578:	beq.w	106e6 <__gethex+0x45e>
   1057c:	orr.w	r4, r4, #16
   10580:	ldr	r3, [sp, #80]	; 0x50
   10582:	mov	r2, r3
   10584:	ldr	r3, [sp, #16]
   10586:	str	r3, [r2, #0]
   10588:	ldr	r3, [sp, #32]
   1058a:	mov	r2, r3
   1058c:	ldr	r3, [sp, #4]
   1058e:	str	r3, [r2, #0]
   10590:	mov	r0, r4
   10592:	add	sp, #44	; 0x2c
   10594:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   10598:	movs	r5, #0
   1059a:	b.n	10532 <__gethex+0x2aa>
   1059c:	.word	0x00012abc
   105a0:	subs	r4, r0, r6
   105a2:	mov	r1, r4
   105a4:	ldr	r0, [sp, #16]
   105a6:	bl	11268 <__any_on>
   105aa:	cmp	r0, #0
   105ac:	beq.n	1061a <__gethex+0x392>
   105ae:	subs	r2, r4, #1
   105b0:	asrs	r1, r2, #5
   105b2:	ldr	r0, [sp, #28]
   105b4:	and.w	r3, r2, #31
   105b8:	ldr.w	r1, [r0, r1, lsl #2]
   105bc:	movs	r7, #1
   105be:	lsl.w	r3, r7, r3
   105c2:	tst	r3, r1
   105c4:	beq.n	105dc <__gethex+0x354>
   105c6:	cmp	r2, r7
   105c8:	ble.w	10702 <__gethex+0x47a>
   105cc:	subs	r1, r4, #2
   105ce:	ldr	r0, [sp, #16]
   105d0:	bl	11268 <__any_on>
   105d4:	cmp	r0, #0
   105d6:	beq.w	10702 <__gethex+0x47a>
   105da:	movs	r7, #3
   105dc:	ldr	r3, [sp, #4]
   105de:	ldr	r0, [sp, #16]
   105e0:	add	r3, r4
   105e2:	mov	r1, r4
   105e4:	str	r3, [sp, #4]
   105e6:	bl	101e0 <rshift>
   105ea:	b.n	103e0 <__gethex+0x158>
   105ec:	str	r5, [sp, #4]
   105ee:	b.n	10310 <__gethex+0x88>
   105f0:	subs	r4, r6, r0
   105f2:	ldr	r1, [sp, #16]
   105f4:	ldr	r0, [sp, #20]
   105f6:	mov	r2, r4
   105f8:	bl	10dd8 <__lshift>
   105fc:	ldr	r3, [sp, #4]
   105fe:	str	r0, [sp, #16]
   10600:	subs	r3, r3, r4
   10602:	str	r3, [sp, #4]
   10604:	mov	r3, r0
   10606:	adds	r3, #20
   10608:	str	r3, [sp, #28]
   1060a:	movs	r7, #0
   1060c:	b.n	103e0 <__gethex+0x158>
   1060e:	adds	r4, r3, #2
   10610:	mov.w	r8, #0
   10614:	b.n	102d0 <__gethex+0x48>
   10616:	mov	r3, r2
   10618:	b.n	104ce <__gethex+0x246>
   1061a:	mov	r7, r0
   1061c:	b.n	105dc <__gethex+0x354>
   1061e:	subs	r4, r5, #1
   10620:	cmp	r7, #0
   10622:	bne.n	106c2 <__gethex+0x43a>
   10624:	cbz	r4, 10630 <__gethex+0x3a8>
   10626:	mov	r1, r4
   10628:	ldr	r0, [sp, #16]
   1062a:	bl	11268 <__any_on>
   1062e:	mov	r7, r0
   10630:	asrs	r3, r4, #5
   10632:	ldr	r2, [sp, #28]
   10634:	ldr	r0, [sp, #16]
   10636:	ldr.w	r2, [r2, r3, lsl #2]
   1063a:	and.w	r4, r4, #31
   1063e:	movs	r3, #1
   10640:	lsl.w	r4, r3, r4
   10644:	tst	r4, r2
   10646:	mov	r1, r5
   10648:	it	ne
   1064a:	orrne.w	r7, r7, #2
   1064e:	bl	101e0 <rshift>
   10652:	ldr	r3, [sp, #12]
   10654:	ldr	r3, [r3, #4]
   10656:	str	r3, [sp, #4]
   10658:	subs	r6, r6, r5
   1065a:	movs	r4, #2
   1065c:	b.n	10564 <__gethex+0x2dc>
   1065e:	ldr	r1, [sp, #0]
   10660:	ldrb	r3, [r7, r1]
   10662:	ldrb	r2, [r6, r3]
   10664:	adds	r5, r7, r1
   10666:	mov	r7, r5
   10668:	cmp	r2, #0
   1066a:	beq.w	1030a <__gethex+0x82>
   1066e:	ldrb.w	r3, [r7, #1]!
   10672:	ldrb	r2, [r6, r3]
   10674:	cmp	r2, #0
   10676:	bne.n	1066e <__gethex+0x3e6>
   10678:	b.n	1030a <__gethex+0x82>
   1067a:	ldr	r3, [sp, #84]	; 0x54
   1067c:	rsb	r3, r3, #1
   10680:	str	r3, [sp, #84]	; 0x54
   10682:	ldr	r3, [sp, #84]	; 0x54
   10684:	cmp	r3, #0
   10686:	beq.w	1057c <__gethex+0x2f4>
   1068a:	ldr	r3, [sp, #16]
   1068c:	ldr	r5, [sp, #28]
   1068e:	ldr	r7, [r3, #16]
   10690:	mov.w	r8, r7, lsl #2
   10694:	add.w	r0, r5, r8
   10698:	mov	r3, r5
   1069a:	movs	r1, #0
   1069c:	b.n	106a8 <__gethex+0x420>
   1069e:	str.w	r1, [r3], #4
   106a2:	cmp	r0, r3
   106a4:	bls.w	104dc <__gethex+0x254>
   106a8:	ldr	r2, [r3, #0]
   106aa:	cmp.w	r2, #4294967295
   106ae:	beq.n	1069e <__gethex+0x416>
   106b0:	adds	r2, #1
   106b2:	cmp	r4, #2
   106b4:	str	r2, [r3, #0]
   106b6:	beq.n	1072c <__gethex+0x4a4>
   106b8:	ands.w	r6, r6, #31
   106bc:	bne.n	1073a <__gethex+0x4b2>
   106be:	movs	r4, #33	; 0x21
   106c0:	b.n	10580 <__gethex+0x2f8>
   106c2:	movs	r7, #1
   106c4:	b.n	10630 <__gethex+0x3a8>
   106c6:	ldr	r2, [sp, #84]	; 0x54
   106c8:	cmp	r2, #0
   106ca:	beq.w	10414 <__gethex+0x18c>
   106ce:	ldr	r1, [sp, #32]
   106d0:	str	r3, [r1, #0]
   106d2:	ldr	r3, [sp, #28]
   106d4:	ldr	r1, [sp, #16]
   106d6:	movs	r2, #1
   106d8:	str	r2, [r1, #16]
   106da:	str	r2, [r3, #0]
   106dc:	ldr	r3, [sp, #80]	; 0x50
   106de:	mov	r2, r3
   106e0:	movs	r0, #98	; 0x62
   106e2:	str	r1, [r2, #0]
   106e4:	b.n	104a2 <__gethex+0x21a>
   106e6:	lsls	r2, r7, #30
   106e8:	bpl.w	1057c <__gethex+0x2f4>
   106ec:	ldr	r3, [sp, #28]
   106ee:	ldr	r3, [r3, #0]
   106f0:	orrs	r3, r7
   106f2:	lsls	r3, r3, #31
   106f4:	bmi.n	1068a <__gethex+0x402>
   106f6:	b.n	1057c <__gethex+0x2f4>
   106f8:	ldr.w	r9, [sp, #28]
   106fc:	mov.w	r8, #0
   10700:	b.n	103b0 <__gethex+0x128>
   10702:	movs	r7, #2
   10704:	b.n	105dc <__gethex+0x354>
   10706:	ldr	r2, [sp, #84]	; 0x54
   10708:	cmp	r2, #0
   1070a:	beq.n	106ce <__gethex+0x446>
   1070c:	b.n	10414 <__gethex+0x18c>
   1070e:	cmp	r6, r5
   10710:	bne.w	10414 <__gethex+0x18c>
   10714:	cmp	r6, #1
   10716:	ble.n	106ce <__gethex+0x446>
   10718:	subs	r1, r6, #1
   1071a:	ldr	r0, [sp, #16]
   1071c:	bl	11268 <__any_on>
   10720:	cmp	r0, #0
   10722:	beq.w	10414 <__gethex+0x18c>
   10726:	ldr	r3, [sp, #12]
   10728:	ldr	r3, [r3, #4]
   1072a:	b.n	106ce <__gethex+0x446>
   1072c:	ldr	r3, [sp, #12]
   1072e:	ldr	r3, [r3, #0]
   10730:	subs	r3, #1
   10732:	cmp	r6, r3
   10734:	beq.n	10780 <__gethex+0x4f8>
   10736:	movs	r4, #34	; 0x22
   10738:	b.n	10580 <__gethex+0x2f8>
   1073a:	add	r5, r8
   1073c:	rsb	r6, r6, #32
   10740:	ldr.w	r0, [r5, #-4]
   10744:	bl	10b58 <__hi0bits>
   10748:	cmp	r0, r6
   1074a:	bge.n	106be <__gethex+0x436>
   1074c:	b.n	10502 <__gethex+0x27a>
   1074e:	ldr	r3, [sp, #16]
   10750:	ldr.w	r9, [sp, #20]
   10754:	ldr	r1, [r3, #4]
   10756:	mov	r0, r9
   10758:	adds	r1, #1
   1075a:	bl	109e0 <_Balloc>
   1075e:	ldr	r1, [sp, #16]
   10760:	ldr	r3, [r1, #16]
   10762:	adds	r2, r3, #2
   10764:	mov	r5, r0
   10766:	lsls	r2, r2, #2
   10768:	adds	r1, #12
   1076a:	adds	r0, #12
   1076c:	bl	8720 <memcpy>
   10770:	ldr	r1, [sp, #16]
   10772:	mov	r0, r9
   10774:	bl	10a2c <_Bfree>
   10778:	str	r5, [sp, #16]
   1077a:	ldr	r3, [r5, #16]
   1077c:	adds	r5, #20
   1077e:	b.n	104e8 <__gethex+0x260>
   10780:	asrs	r3, r6, #5
   10782:	and.w	r6, r6, #31
   10786:	ldr.w	r2, [r5, r3, lsl #2]
   1078a:	movs	r3, #1
   1078c:	lsls	r3, r6
   1078e:	tst	r3, r2
   10790:	ite	ne
   10792:	movne	r4, #33	; 0x21
   10794:	moveq	r4, #34	; 0x22
   10796:	b.n	10580 <__gethex+0x2f8>

00010798 <__match>:
   10798:	push	{r4, r5}
   1079a:	ldr	r4, [r0, #0]
   1079c:	b.n	107b0 <__match+0x18>
   1079e:	ldrb.w	r3, [r4, #1]!
   107a2:	sub.w	r5, r3, #65	; 0x41
   107a6:	cmp	r5, #25
   107a8:	it	ls
   107aa:	addls	r3, #32
   107ac:	cmp	r3, r2
   107ae:	bne.n	107c2 <__match+0x2a>
   107b0:	ldrb.w	r2, [r1], #1
   107b4:	cmp	r2, #0
   107b6:	bne.n	1079e <__match+0x6>
   107b8:	adds	r4, #1
   107ba:	str	r4, [r0, #0]
   107bc:	movs	r0, #1
   107be:	pop	{r4, r5}
   107c0:	bx	lr
   107c2:	movs	r0, #0
   107c4:	pop	{r4, r5}
   107c6:	bx	lr

000107c8 <__hexnan>:
   107c8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   107cc:	ldr	r3, [r1, #0]
   107ce:	ldr.w	r9, [pc, #372]	; 10944 <__hexnan+0x17c>
   107d2:	sub	sp, #20
   107d4:	asrs	r1, r3, #5
   107d6:	add.w	r1, r2, r1, lsl #2
   107da:	ands.w	r3, r3, #31
   107de:	str	r1, [sp, #4]
   107e0:	itt	ne
   107e2:	addne	r1, #4
   107e4:	strne	r1, [sp, #4]
   107e6:	ldr	r4, [sp, #4]
   107e8:	str	r0, [sp, #8]
   107ea:	str	r3, [sp, #12]
   107ec:	movs	r3, #0
   107ee:	mov	r1, r3
   107f0:	str.w	r3, [r4, #-4]
   107f4:	mov	sl, r3
   107f6:	mov	lr, r3
   107f8:	ldr	r3, [sp, #8]
   107fa:	sub.w	ip, r4, #4
   107fe:	ldr	r5, [r3, #0]
   10800:	mov	r8, ip
   10802:	mov	r0, ip
   10804:	ldrb.w	r3, [r5, #1]!
   10808:	cbz	r3, 10854 <__hexnan+0x8c>
   1080a:	ldrb.w	r4, [r9, r3]
   1080e:	cmp	r4, #0
   10810:	bne.n	1089a <__hexnan+0xd2>
   10812:	cmp	r3, #32
   10814:	bhi.n	108d2 <__hexnan+0x10a>
   10816:	cmp	lr, sl
   10818:	ble.n	10804 <__hexnan+0x3c>
   1081a:	cmp	r0, r8
   1081c:	bcs.n	10846 <__hexnan+0x7e>
   1081e:	cmp	r1, #7
   10820:	bgt.n	10846 <__hexnan+0x7e>
   10822:	rsb	r1, r1, #8
   10826:	lsls	r1, r1, #2
   10828:	ldr	r6, [r0, #0]
   1082a:	rsb	fp, r1, #32
   1082e:	mov	r3, r0
   10830:	ldr	r7, [r3, #4]
   10832:	lsl.w	r4, r7, fp
   10836:	orrs	r4, r6
   10838:	lsr.w	r6, r7, r1
   1083c:	str	r4, [r3, #0]
   1083e:	str.w	r6, [r3, #4]!
   10842:	cmp	r8, r3
   10844:	bhi.n	10830 <__hexnan+0x68>
   10846:	cmp	r0, r2
   10848:	bhi.n	108c0 <__hexnan+0xf8>
   1084a:	ldrb.w	r3, [r5, #1]!
   1084e:	movs	r1, #8
   10850:	cmp	r3, #0
   10852:	bne.n	1080a <__hexnan+0x42>
   10854:	cmp.w	lr, #0
   10858:	beq.n	108d6 <__hexnan+0x10e>
   1085a:	cmp	r0, r8
   1085c:	bcs.n	10862 <__hexnan+0x9a>
   1085e:	cmp	r1, #7
   10860:	ble.n	1091c <__hexnan+0x154>
   10862:	cmp	r0, r2
   10864:	bls.n	108de <__hexnan+0x116>
   10866:	mov	r3, r2
   10868:	ldr.w	r1, [r0], #4
   1086c:	str.w	r1, [r3], #4
   10870:	cmp	ip, r0
   10872:	bcs.n	10868 <__hexnan+0xa0>
   10874:	movs	r1, #0
   10876:	str.w	r1, [r3], #4
   1087a:	cmp	ip, r3
   1087c:	bcs.n	10876 <__hexnan+0xae>
   1087e:	ldr	r3, [sp, #4]
   10880:	ldr.w	r3, [r3, #-4]
   10884:	cbnz	r3, 10892 <__hexnan+0xca>
   10886:	cmp	r2, ip
   10888:	beq.n	10900 <__hexnan+0x138>
   1088a:	ldr.w	r3, [ip, #-4]!
   1088e:	cmp	r3, #0
   10890:	beq.n	10886 <__hexnan+0xbe>
   10892:	movs	r0, #5
   10894:	add	sp, #20
   10896:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1089a:	adds	r1, #1
   1089c:	cmp	r1, #8
   1089e:	add.w	lr, lr, #1
   108a2:	ble.n	108b2 <__hexnan+0xea>
   108a4:	cmp	r0, r2
   108a6:	bls.n	10804 <__hexnan+0x3c>
   108a8:	movs	r3, #0
   108aa:	str.w	r3, [r0, #-4]
   108ae:	movs	r1, #1
   108b0:	subs	r0, #4
   108b2:	ldr	r3, [r0, #0]
   108b4:	and.w	r4, r4, #15
   108b8:	orr.w	r4, r4, r3, lsl #4
   108bc:	str	r4, [r0, #0]
   108be:	b.n	10804 <__hexnan+0x3c>
   108c0:	movs	r3, #0
   108c2:	sub.w	r8, r0, #4
   108c6:	str.w	r3, [r0, #-4]
   108ca:	mov	sl, lr
   108cc:	mov	r0, r8
   108ce:	mov	r1, r3
   108d0:	b.n	10804 <__hexnan+0x3c>
   108d2:	cmp	r3, #41	; 0x29
   108d4:	beq.n	1090e <__hexnan+0x146>
   108d6:	movs	r0, #4
   108d8:	add	sp, #20
   108da:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   108de:	ldr	r3, [sp, #12]
   108e0:	cmp	r3, #0
   108e2:	beq.n	1087e <__hexnan+0xb6>
   108e4:	ldr	r4, [sp, #4]
   108e6:	ldr	r3, [sp, #12]
   108e8:	ldr.w	r1, [r4, #-4]
   108ec:	rsb	r3, r3, #32
   108f0:	mov.w	r0, #4294967295
   108f4:	lsr.w	r3, r0, r3
   108f8:	ands	r3, r1
   108fa:	str.w	r3, [r4, #-4]
   108fe:	b.n	10884 <__hexnan+0xbc>
   10900:	movs	r3, #1
   10902:	movs	r0, #5
   10904:	str.w	r3, [ip]
   10908:	add	sp, #20
   1090a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1090e:	ldr	r3, [sp, #8]
   10910:	adds	r5, #1
   10912:	str	r5, [r3, #0]
   10914:	cmp.w	lr, #0
   10918:	bne.n	1085a <__hexnan+0x92>
   1091a:	b.n	108d6 <__hexnan+0x10e>
   1091c:	rsb	r3, r1, #8
   10920:	lsls	r3, r3, #2
   10922:	ldr	r5, [r0, #0]
   10924:	rsb	r7, r3, #32
   10928:	mov	r1, r0
   1092a:	ldr	r6, [r1, #4]
   1092c:	lsl.w	r4, r6, r7
   10930:	orrs	r4, r5
   10932:	lsr.w	r5, r6, r3
   10936:	str	r4, [r1, #0]
   10938:	str.w	r5, [r1, #4]!
   1093c:	cmp	r8, r1
   1093e:	bhi.n	1092a <__hexnan+0x162>
   10940:	b.n	10862 <__hexnan+0x9a>
   10942:	nop
   10944:	.word	0x00012abc

00010948 <iswspace>:
   10948:	cmp	r0, #255	; 0xff
   1094a:	bls.n	10950 <iswspace+0x8>
   1094c:	movs	r0, #0
   1094e:	bx	lr
   10950:	push	{r4, lr}
   10952:	mov	r4, r0
   10954:	bl	aaa8 <__locale_ctype_ptr>
   10958:	add	r0, r4
   1095a:	ldrb	r0, [r0, #1]
   1095c:	and.w	r0, r0, #8
   10960:	uxtb	r0, r0
   10962:	pop	{r4, pc}

00010964 <__localeconv_l>:
   10964:	adds	r0, #240	; 0xf0
   10966:	bx	lr

00010968 <_localeconv_r>:
   10968:	ldr	r2, [pc, #16]	; (1097c <_localeconv_r+0x14>)
   1096a:	ldr	r3, [pc, #20]	; (10980 <_localeconv_r+0x18>)
   1096c:	ldr	r2, [r2, #0]
   1096e:	ldr	r0, [r2, #52]	; 0x34
   10970:	cmp	r0, #0
   10972:	it	eq
   10974:	moveq	r0, r3
   10976:	adds	r0, #240	; 0xf0
   10978:	bx	lr
   1097a:	nop
   1097c:	.word	0x1fff1840
   10980:	.word	0x1fff1844

00010984 <_mbrtowc_r>:
   10984:	push	{r4, r5, r6, r7, lr}
   10986:	sub	sp, #12
   10988:	mov	r7, r0
   1098a:	ldr	r5, [sp, #32]
   1098c:	cbz	r2, 109b4 <_mbrtowc_r+0x30>
   1098e:	ldr	r4, [pc, #68]	; (109d4 <_mbrtowc_r+0x50>)
   10990:	ldr	r6, [pc, #68]	; (109d8 <_mbrtowc_r+0x54>)
   10992:	ldr	r4, [r4, #0]
   10994:	ldr	r4, [r4, #52]	; 0x34
   10996:	str	r5, [sp, #0]
   10998:	cmp	r4, #0
   1099a:	it	eq
   1099c:	moveq	r4, r6
   1099e:	ldr.w	r4, [r4, #228]	; 0xe4
   109a2:	blx	r4
   109a4:	adds	r3, r0, #1
   109a6:	bne.n	109b0 <_mbrtowc_r+0x2c>
   109a8:	movs	r2, #0
   109aa:	movs	r3, #138	; 0x8a
   109ac:	str	r2, [r5, #0]
   109ae:	str	r3, [r7, #0]
   109b0:	add	sp, #12
   109b2:	pop	{r4, r5, r6, r7, pc}
   109b4:	ldr	r3, [pc, #28]	; (109d4 <_mbrtowc_r+0x50>)
   109b6:	ldr	r1, [pc, #32]	; (109d8 <_mbrtowc_r+0x54>)
   109b8:	ldr	r3, [r3, #0]
   109ba:	ldr	r3, [r3, #52]	; 0x34
   109bc:	str	r5, [sp, #0]
   109be:	cmp	r3, #0
   109c0:	it	eq
   109c2:	moveq	r3, r1
   109c4:	mov	r4, r2
   109c6:	mov	r1, r4
   109c8:	ldr	r2, [pc, #16]	; (109dc <_mbrtowc_r+0x58>)
   109ca:	ldr.w	r4, [r3, #228]	; 0xe4
   109ce:	movs	r3, #1
   109d0:	blx	r4
   109d2:	b.n	109a4 <_mbrtowc_r+0x20>
   109d4:	.word	0x1fff1840
   109d8:	.word	0x1fff1844
   109dc:	.word	0x00012948

000109e0 <_Balloc>:
   109e0:	ldr	r3, [r0, #76]	; 0x4c
   109e2:	push	{r4, r5, r6, lr}
   109e4:	mov	r5, r0
   109e6:	mov	r4, r1
   109e8:	cbz	r3, 109fe <_Balloc+0x1e>
   109ea:	ldr.w	r0, [r3, r4, lsl #2]
   109ee:	cbz	r0, 10a12 <_Balloc+0x32>
   109f0:	ldr	r2, [r0, #0]
   109f2:	str.w	r2, [r3, r4, lsl #2]
   109f6:	movs	r3, #0
   109f8:	str	r3, [r0, #16]
   109fa:	str	r3, [r0, #12]
   109fc:	pop	{r4, r5, r6, pc}
   109fe:	movs	r2, #33	; 0x21
   10a00:	movs	r1, #4
   10a02:	bl	11bc4 <_calloc_r>
   10a06:	str	r0, [r5, #76]	; 0x4c
   10a08:	mov	r3, r0
   10a0a:	cmp	r0, #0
   10a0c:	bne.n	109ea <_Balloc+0xa>
   10a0e:	movs	r0, #0
   10a10:	pop	{r4, r5, r6, pc}
   10a12:	movs	r1, #1
   10a14:	lsl.w	r6, r1, r4
   10a18:	adds	r2, r6, #5
   10a1a:	mov	r0, r5
   10a1c:	lsls	r2, r2, #2
   10a1e:	bl	11bc4 <_calloc_r>
   10a22:	cmp	r0, #0
   10a24:	beq.n	10a0e <_Balloc+0x2e>
   10a26:	str	r4, [r0, #4]
   10a28:	str	r6, [r0, #8]
   10a2a:	b.n	109f6 <_Balloc+0x16>

00010a2c <_Bfree>:
   10a2c:	cbz	r1, 10a3c <_Bfree+0x10>
   10a2e:	ldr	r3, [r0, #76]	; 0x4c
   10a30:	ldr	r2, [r1, #4]
   10a32:	ldr.w	r0, [r3, r2, lsl #2]
   10a36:	str	r0, [r1, #0]
   10a38:	str.w	r1, [r3, r2, lsl #2]
   10a3c:	bx	lr
   10a3e:	nop

00010a40 <__multadd>:
   10a40:	push	{r4, r5, r6, r7, lr}
   10a42:	ldr	r4, [r1, #16]
   10a44:	sub	sp, #12
   10a46:	mov	r5, r1
   10a48:	mov	r6, r0
   10a4a:	add.w	lr, r1, #20
   10a4e:	movs	r7, #0
   10a50:	ldr.w	r0, [lr]
   10a54:	uxth	r1, r0
   10a56:	mla	r1, r2, r1, r3
   10a5a:	lsrs	r3, r1, #16
   10a5c:	lsrs	r0, r0, #16
   10a5e:	mla	r3, r2, r0, r3
   10a62:	uxth	r1, r1
   10a64:	adds	r7, #1
   10a66:	add.w	r1, r1, r3, lsl #16
   10a6a:	cmp	r4, r7
   10a6c:	str.w	r1, [lr], #4
   10a70:	mov.w	r3, r3, lsr #16
   10a74:	bgt.n	10a50 <__multadd+0x10>
   10a76:	cbz	r3, 10a88 <__multadd+0x48>
   10a78:	ldr	r2, [r5, #8]
   10a7a:	cmp	r4, r2
   10a7c:	bge.n	10a8e <__multadd+0x4e>
   10a7e:	add.w	r2, r5, r4, lsl #2
   10a82:	adds	r4, #1
   10a84:	str	r3, [r2, #20]
   10a86:	str	r4, [r5, #16]
   10a88:	mov	r0, r5
   10a8a:	add	sp, #12
   10a8c:	pop	{r4, r5, r6, r7, pc}
   10a8e:	ldr	r1, [r5, #4]
   10a90:	str	r3, [sp, #4]
   10a92:	adds	r1, #1
   10a94:	mov	r0, r6
   10a96:	bl	109e0 <_Balloc>
   10a9a:	ldr	r2, [r5, #16]
   10a9c:	adds	r2, #2
   10a9e:	add.w	r1, r5, #12
   10aa2:	mov	r7, r0
   10aa4:	lsls	r2, r2, #2
   10aa6:	adds	r0, #12
   10aa8:	bl	8720 <memcpy>
   10aac:	ldr	r2, [r6, #76]	; 0x4c
   10aae:	ldr	r1, [r5, #4]
   10ab0:	ldr	r3, [sp, #4]
   10ab2:	ldr.w	r0, [r2, r1, lsl #2]
   10ab6:	str	r0, [r5, #0]
   10ab8:	str.w	r5, [r2, r1, lsl #2]
   10abc:	mov	r5, r7
   10abe:	b.n	10a7e <__multadd+0x3e>

00010ac0 <__s2b>:
   10ac0:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   10ac4:	ldr	r4, [pc, #140]	; (10b54 <__s2b+0x94>)
   10ac6:	ldr	r5, [sp, #32]
   10ac8:	mov	r7, r3
   10aca:	adds	r3, #8
   10acc:	smull	r4, lr, r4, r3
   10ad0:	asrs	r3, r3, #31
   10ad2:	rsb	lr, r3, lr, asr #1
   10ad6:	cmp.w	lr, #1
   10ada:	mov	r6, r0
   10adc:	mov	r4, r1
   10ade:	mov	r8, r2
   10ae0:	ble.n	10b4e <__s2b+0x8e>
   10ae2:	movs	r3, #1
   10ae4:	movs	r1, #0
   10ae6:	lsls	r3, r3, #1
   10ae8:	cmp	lr, r3
   10aea:	add.w	r1, r1, #1
   10aee:	bgt.n	10ae6 <__s2b+0x26>
   10af0:	mov	r0, r6
   10af2:	bl	109e0 <_Balloc>
   10af6:	movs	r3, #1
   10af8:	cmp.w	r8, #9
   10afc:	str	r5, [r0, #20]
   10afe:	str	r3, [r0, #16]
   10b00:	ble.n	10b46 <__s2b+0x86>
   10b02:	add.w	r9, r4, #9
   10b06:	mov	r5, r9
   10b08:	add	r4, r8
   10b0a:	ldrb.w	r3, [r5], #1
   10b0e:	mov	r1, r0
   10b10:	subs	r3, #48	; 0x30
   10b12:	movs	r2, #10
   10b14:	mov	r0, r6
   10b16:	bl	10a40 <__multadd>
   10b1a:	cmp	r5, r4
   10b1c:	bne.n	10b0a <__s2b+0x4a>
   10b1e:	add.w	r4, r9, r8
   10b22:	subs	r4, #8
   10b24:	cmp	r7, r8
   10b26:	ble.n	10b42 <__s2b+0x82>
   10b28:	rsb	r7, r8, r7
   10b2c:	add	r7, r4
   10b2e:	ldrb.w	r3, [r4], #1
   10b32:	mov	r1, r0
   10b34:	subs	r3, #48	; 0x30
   10b36:	movs	r2, #10
   10b38:	mov	r0, r6
   10b3a:	bl	10a40 <__multadd>
   10b3e:	cmp	r7, r4
   10b40:	bne.n	10b2e <__s2b+0x6e>
   10b42:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   10b46:	adds	r4, #10
   10b48:	mov.w	r8, #9
   10b4c:	b.n	10b24 <__s2b+0x64>
   10b4e:	movs	r1, #0
   10b50:	b.n	10af0 <__s2b+0x30>
   10b52:	nop
   10b54:	.word	0x38e38e39

00010b58 <__hi0bits>:
   10b58:	lsrs	r3, r0, #16
   10b5a:	lsls	r3, r3, #16
   10b5c:	cbnz	r3, 10b8c <__hi0bits+0x34>
   10b5e:	lsls	r0, r0, #16
   10b60:	movs	r3, #16
   10b62:	tst.w	r0, #4278190080	; 0xff000000
   10b66:	itt	eq
   10b68:	lsleq	r0, r0, #8
   10b6a:	addeq	r3, #8
   10b6c:	tst.w	r0, #4026531840	; 0xf0000000
   10b70:	itt	eq
   10b72:	lsleq	r0, r0, #4
   10b74:	addeq	r3, #4
   10b76:	tst.w	r0, #3221225472	; 0xc0000000
   10b7a:	itt	eq
   10b7c:	lsleq	r0, r0, #2
   10b7e:	addeq	r3, #2
   10b80:	cmp	r0, #0
   10b82:	blt.n	10b94 <__hi0bits+0x3c>
   10b84:	lsls	r2, r0, #1
   10b86:	bmi.n	10b90 <__hi0bits+0x38>
   10b88:	movs	r0, #32
   10b8a:	bx	lr
   10b8c:	movs	r3, #0
   10b8e:	b.n	10b62 <__hi0bits+0xa>
   10b90:	adds	r0, r3, #1
   10b92:	bx	lr
   10b94:	mov	r0, r3
   10b96:	bx	lr

00010b98 <__lo0bits>:
   10b98:	ldr	r3, [r0, #0]
   10b9a:	ands.w	r2, r3, #7
   10b9e:	beq.n	10bb0 <__lo0bits+0x18>
   10ba0:	lsls	r1, r3, #31
   10ba2:	bmi.n	10be6 <__lo0bits+0x4e>
   10ba4:	lsls	r2, r3, #30
   10ba6:	bmi.n	10bea <__lo0bits+0x52>
   10ba8:	lsrs	r3, r3, #2
   10baa:	str	r3, [r0, #0]
   10bac:	movs	r0, #2
   10bae:	bx	lr
   10bb0:	uxth	r1, r3
   10bb2:	cbnz	r1, 10bb8 <__lo0bits+0x20>
   10bb4:	lsrs	r3, r3, #16
   10bb6:	movs	r2, #16
   10bb8:	tst.w	r3, #255	; 0xff
   10bbc:	itt	eq
   10bbe:	lsreq	r3, r3, #8
   10bc0:	addeq	r2, #8
   10bc2:	lsls	r1, r3, #28
   10bc4:	itt	eq
   10bc6:	lsreq	r3, r3, #4
   10bc8:	addeq	r2, #4
   10bca:	lsls	r1, r3, #30
   10bcc:	itt	eq
   10bce:	lsreq	r3, r3, #2
   10bd0:	addeq	r2, #2
   10bd2:	lsls	r1, r3, #31
   10bd4:	bmi.n	10be0 <__lo0bits+0x48>
   10bd6:	lsrs	r3, r3, #1
   10bd8:	bne.n	10bde <__lo0bits+0x46>
   10bda:	movs	r0, #32
   10bdc:	bx	lr
   10bde:	adds	r2, #1
   10be0:	str	r3, [r0, #0]
   10be2:	mov	r0, r2
   10be4:	bx	lr
   10be6:	movs	r0, #0
   10be8:	bx	lr
   10bea:	lsrs	r3, r3, #1
   10bec:	str	r3, [r0, #0]
   10bee:	movs	r0, #1
   10bf0:	bx	lr
   10bf2:	nop

00010bf4 <__i2b>:
   10bf4:	push	{r4, lr}
   10bf6:	mov	r4, r1
   10bf8:	movs	r1, #1
   10bfa:	bl	109e0 <_Balloc>
   10bfe:	movs	r2, #1
   10c00:	str	r4, [r0, #20]
   10c02:	str	r2, [r0, #16]
   10c04:	pop	{r4, pc}
   10c06:	nop

00010c08 <__multiply>:
   10c08:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10c0c:	ldr	r5, [r1, #16]
   10c0e:	ldr	r7, [r2, #16]
   10c10:	cmp	r5, r7
   10c12:	sub	sp, #12
   10c14:	mov	r4, r1
   10c16:	mov	r6, r2
   10c18:	bge.n	10c24 <__multiply+0x1c>
   10c1a:	mov	r2, r5
   10c1c:	mov	r4, r6
   10c1e:	mov	r5, r7
   10c20:	mov	r6, r1
   10c22:	mov	r7, r2
   10c24:	ldr	r3, [r4, #8]
   10c26:	ldr	r1, [r4, #4]
   10c28:	add.w	r8, r5, r7
   10c2c:	cmp	r8, r3
   10c2e:	it	gt
   10c30:	addgt	r1, #1
   10c32:	bl	109e0 <_Balloc>
   10c36:	add.w	ip, r0, #20
   10c3a:	add.w	r9, ip, r8, lsl #2
   10c3e:	cmp	ip, r9
   10c40:	str	r0, [sp, #0]
   10c42:	bcs.n	10c50 <__multiply+0x48>
   10c44:	mov	r3, ip
   10c46:	movs	r1, #0
   10c48:	str.w	r1, [r3], #4
   10c4c:	cmp	r9, r3
   10c4e:	bhi.n	10c48 <__multiply+0x40>
   10c50:	add.w	r2, r6, #20
   10c54:	add.w	sl, r2, r7, lsl #2
   10c58:	add.w	r3, r4, #20
   10c5c:	cmp	r2, sl
   10c5e:	add.w	lr, r3, r5, lsl #2
   10c62:	bcs.n	10d0e <__multiply+0x106>
   10c64:	str.w	r9, [sp, #4]
   10c68:	mov	r9, r3
   10c6a:	ldr.w	r3, [r2], #4
   10c6e:	uxth.w	fp, r3
   10c72:	cmp.w	fp, #0
   10c76:	beq.n	10cba <__multiply+0xb2>
   10c78:	movs	r0, #0
   10c7a:	mov	r7, r9
   10c7c:	mov	r6, ip
   10c7e:	mov	r5, r0
   10c80:	b.n	10c84 <__multiply+0x7c>
   10c82:	mov	r6, r3
   10c84:	ldr.w	r4, [r7], #4
   10c88:	ldr	r0, [r6, #0]
   10c8a:	uxth	r1, r4
   10c8c:	uxth	r3, r0
   10c8e:	mla	r1, fp, r1, r3
   10c92:	lsrs	r4, r4, #16
   10c94:	lsrs	r0, r0, #16
   10c96:	adds	r3, r1, r5
   10c98:	mla	r0, fp, r4, r0
   10c9c:	add.w	r0, r0, r3, lsr #16
   10ca0:	uxth	r1, r3
   10ca2:	mov	r3, r6
   10ca4:	orr.w	r1, r1, r0, lsl #16
   10ca8:	cmp	lr, r7
   10caa:	mov.w	r5, r0, lsr #16
   10cae:	str.w	r1, [r3], #4
   10cb2:	bhi.n	10c82 <__multiply+0x7a>
   10cb4:	str	r5, [r6, #4]
   10cb6:	ldr.w	r3, [r2, #-4]
   10cba:	movs.w	fp, r3, lsr #16
   10cbe:	beq.n	10d02 <__multiply+0xfa>
   10cc0:	ldr.w	r3, [ip]
   10cc4:	mov	r7, ip
   10cc6:	mov	r0, r3
   10cc8:	mov	r5, r9
   10cca:	movs	r1, #0
   10ccc:	b.n	10cd0 <__multiply+0xc8>
   10cce:	mov	r7, r6
   10cd0:	ldrh	r4, [r5, #0]
   10cd2:	lsrs	r0, r0, #16
   10cd4:	mla	r0, fp, r4, r0
   10cd8:	add	r1, r0
   10cda:	uxth	r4, r3
   10cdc:	mov	r6, r7
   10cde:	orr.w	r3, r4, r1, lsl #16
   10ce2:	str.w	r3, [r6], #4
   10ce6:	ldr	r0, [r7, #4]
   10ce8:	ldr.w	r4, [r5], #4
   10cec:	uxth	r3, r0
   10cee:	lsrs	r4, r4, #16
   10cf0:	mla	r4, fp, r4, r3
   10cf4:	add.w	r3, r4, r1, lsr #16
   10cf8:	cmp	lr, r5
   10cfa:	mov.w	r1, r3, lsr #16
   10cfe:	bhi.n	10cce <__multiply+0xc6>
   10d00:	str	r3, [r7, #4]
   10d02:	cmp	sl, r2
   10d04:	add.w	ip, ip, #4
   10d08:	bhi.n	10c6a <__multiply+0x62>
   10d0a:	ldr.w	r9, [sp, #4]
   10d0e:	cmp.w	r8, #0
   10d12:	ble.n	10d2c <__multiply+0x124>
   10d14:	ldr.w	r3, [r9, #-4]
   10d18:	sub.w	r9, r9, #4
   10d1c:	cbz	r3, 10d26 <__multiply+0x11e>
   10d1e:	b.n	10d2c <__multiply+0x124>
   10d20:	ldr.w	r3, [r9, #-4]!
   10d24:	cbnz	r3, 10d2c <__multiply+0x124>
   10d26:	subs.w	r8, r8, #1
   10d2a:	bne.n	10d20 <__multiply+0x118>
   10d2c:	ldr	r0, [sp, #0]
   10d2e:	str.w	r8, [r0, #16]
   10d32:	add	sp, #12
   10d34:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00010d38 <__pow5mult>:
   10d38:	ands.w	r3, r2, #3
   10d3c:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   10d40:	mov	r4, r2
   10d42:	mov	r7, r0
   10d44:	bne.n	10da4 <__pow5mult+0x6c>
   10d46:	mov	r6, r1
   10d48:	asrs	r4, r4, #2
   10d4a:	beq.n	10d86 <__pow5mult+0x4e>
   10d4c:	ldr	r5, [r7, #72]	; 0x48
   10d4e:	cbz	r5, 10db6 <__pow5mult+0x7e>
   10d50:	lsls	r3, r4, #31
   10d52:	mov.w	r8, #0
   10d56:	bmi.n	10d66 <__pow5mult+0x2e>
   10d58:	asrs	r4, r4, #1
   10d5a:	beq.n	10d86 <__pow5mult+0x4e>
   10d5c:	ldr	r0, [r5, #0]
   10d5e:	cbz	r0, 10d8c <__pow5mult+0x54>
   10d60:	mov	r5, r0
   10d62:	lsls	r3, r4, #31
   10d64:	bpl.n	10d58 <__pow5mult+0x20>
   10d66:	mov	r2, r5
   10d68:	mov	r1, r6
   10d6a:	mov	r0, r7
   10d6c:	bl	10c08 <__multiply>
   10d70:	cbz	r6, 10da0 <__pow5mult+0x68>
   10d72:	ldr	r2, [r6, #4]
   10d74:	ldr	r3, [r7, #76]	; 0x4c
   10d76:	asrs	r4, r4, #1
   10d78:	ldr.w	r1, [r3, r2, lsl #2]
   10d7c:	str	r1, [r6, #0]
   10d7e:	str.w	r6, [r3, r2, lsl #2]
   10d82:	mov	r6, r0
   10d84:	bne.n	10d5c <__pow5mult+0x24>
   10d86:	mov	r0, r6
   10d88:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   10d8c:	mov	r2, r5
   10d8e:	mov	r1, r5
   10d90:	mov	r0, r7
   10d92:	bl	10c08 <__multiply>
   10d96:	str	r0, [r5, #0]
   10d98:	str.w	r8, [r0]
   10d9c:	mov	r5, r0
   10d9e:	b.n	10d62 <__pow5mult+0x2a>
   10da0:	mov	r6, r0
   10da2:	b.n	10d58 <__pow5mult+0x20>
   10da4:	subs	r2, r3, #1
   10da6:	ldr	r5, [pc, #44]	; (10dd4 <__pow5mult+0x9c>)
   10da8:	movs	r3, #0
   10daa:	ldr.w	r2, [r5, r2, lsl #2]
   10dae:	bl	10a40 <__multadd>
   10db2:	mov	r6, r0
   10db4:	b.n	10d48 <__pow5mult+0x10>
   10db6:	movs	r1, #1
   10db8:	mov	r0, r7
   10dba:	bl	109e0 <_Balloc>
   10dbe:	movw	r1, #625	; 0x271
   10dc2:	movs	r2, #1
   10dc4:	movs	r3, #0
   10dc6:	str	r1, [r0, #20]
   10dc8:	str	r2, [r0, #16]
   10dca:	mov	r5, r0
   10dcc:	str	r0, [r7, #72]	; 0x48
   10dce:	str	r3, [r0, #0]
   10dd0:	b.n	10d50 <__pow5mult+0x18>
   10dd2:	nop
   10dd4:	.word	0x00012cb0

00010dd8 <__lshift>:
   10dd8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   10ddc:	mov	r9, r2
   10dde:	ldr	r2, [r1, #16]
   10de0:	ldr	r3, [r1, #8]
   10de2:	mov.w	r4, r9, asr #5
   10de6:	add.w	r8, r4, r2
   10dea:	add.w	r5, r8, #1
   10dee:	cmp	r5, r3
   10df0:	mov	r6, r1
   10df2:	mov	sl, r0
   10df4:	ldr	r1, [r1, #4]
   10df6:	ble.n	10e02 <__lshift+0x2a>
   10df8:	lsls	r3, r3, #1
   10dfa:	cmp	r5, r3
   10dfc:	add.w	r1, r1, #1
   10e00:	bgt.n	10df8 <__lshift+0x20>
   10e02:	mov	r0, sl
   10e04:	bl	109e0 <_Balloc>
   10e08:	cmp	r4, #0
   10e0a:	add.w	r2, r0, #20
   10e0e:	ble.n	10e82 <__lshift+0xaa>
   10e10:	add.w	r3, r2, r4, lsl #2
   10e14:	movs	r1, #0
   10e16:	str.w	r1, [r2], #4
   10e1a:	cmp	r3, r2
   10e1c:	bne.n	10e16 <__lshift+0x3e>
   10e1e:	ldr	r4, [r6, #16]
   10e20:	add.w	r1, r6, #20
   10e24:	ands.w	r9, r9, #31
   10e28:	add.w	lr, r1, r4, lsl #2
   10e2c:	beq.n	10e72 <__lshift+0x9a>
   10e2e:	rsb	r2, r9, #32
   10e32:	movs	r4, #0
   10e34:	ldr	r7, [r1, #0]
   10e36:	lsl.w	ip, r7, r9
   10e3a:	orr.w	r4, ip, r4
   10e3e:	mov	ip, r3
   10e40:	str.w	r4, [r3], #4
   10e44:	ldr.w	r4, [r1], #4
   10e48:	cmp	lr, r1
   10e4a:	lsr.w	r4, r4, r2
   10e4e:	bhi.n	10e34 <__lshift+0x5c>
   10e50:	str.w	r4, [ip, #4]
   10e54:	cbz	r4, 10e5a <__lshift+0x82>
   10e56:	add.w	r5, r8, #2
   10e5a:	ldr.w	r3, [sl, #76]	; 0x4c
   10e5e:	ldr	r2, [r6, #4]
   10e60:	subs	r5, #1
   10e62:	ldr.w	r1, [r3, r2, lsl #2]
   10e66:	str	r5, [r0, #16]
   10e68:	str	r1, [r6, #0]
   10e6a:	str.w	r6, [r3, r2, lsl #2]
   10e6e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   10e72:	subs	r3, #4
   10e74:	ldr.w	r2, [r1], #4
   10e78:	str.w	r2, [r3, #4]!
   10e7c:	cmp	lr, r1
   10e7e:	bhi.n	10e74 <__lshift+0x9c>
   10e80:	b.n	10e5a <__lshift+0x82>
   10e82:	mov	r3, r2
   10e84:	b.n	10e1e <__lshift+0x46>
   10e86:	nop

00010e88 <__mcmp>:
   10e88:	ldr	r2, [r0, #16]
   10e8a:	ldr	r3, [r1, #16]
   10e8c:	subs	r2, r2, r3
   10e8e:	bne.n	10eb8 <__mcmp+0x30>
   10e90:	lsls	r3, r3, #2
   10e92:	adds	r0, #20
   10e94:	adds	r1, #20
   10e96:	add	r1, r3
   10e98:	push	{r4}
   10e9a:	add	r3, r0
   10e9c:	b.n	10ea2 <__mcmp+0x1a>
   10e9e:	cmp	r0, r3
   10ea0:	bcs.n	10ebc <__mcmp+0x34>
   10ea2:	ldr.w	r4, [r3, #-4]!
   10ea6:	ldr.w	r2, [r1, #-4]!
   10eaa:	cmp	r4, r2
   10eac:	beq.n	10e9e <__mcmp+0x16>
   10eae:	bcc.n	10ec4 <__mcmp+0x3c>
   10eb0:	movs	r0, #1
   10eb2:	ldr.w	r4, [sp], #4
   10eb6:	bx	lr
   10eb8:	mov	r0, r2
   10eba:	bx	lr
   10ebc:	movs	r0, #0
   10ebe:	ldr.w	r4, [sp], #4
   10ec2:	bx	lr
   10ec4:	mov.w	r0, #4294967295
   10ec8:	b.n	10eb2 <__mcmp+0x2a>
   10eca:	nop

00010ecc <__mdiff>:
   10ecc:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   10ed0:	ldr	r3, [r1, #16]
   10ed2:	mov	r7, r1
   10ed4:	ldr	r1, [r2, #16]
   10ed6:	subs	r3, r3, r1
   10ed8:	cmp	r3, #0
   10eda:	mov	r8, r2
   10edc:	bne.n	10f0e <__mdiff+0x42>
   10ede:	lsls	r1, r1, #2
   10ee0:	add.w	r2, r7, #20
   10ee4:	add.w	r5, r8, #20
   10ee8:	adds	r3, r2, r1
   10eea:	add	r1, r5
   10eec:	b.n	10ef2 <__mdiff+0x26>
   10eee:	cmp	r2, r3
   10ef0:	bcs.n	10fb0 <__mdiff+0xe4>
   10ef2:	ldr.w	r6, [r3, #-4]!
   10ef6:	ldr.w	r4, [r1, #-4]!
   10efa:	cmp	r6, r4
   10efc:	beq.n	10eee <__mdiff+0x22>
   10efe:	bcs.n	10fc2 <__mdiff+0xf6>
   10f00:	mov	r3, r7
   10f02:	mov	r4, r2
   10f04:	mov	r7, r8
   10f06:	mov.w	r9, #1
   10f0a:	mov	r8, r3
   10f0c:	b.n	10f1c <__mdiff+0x50>
   10f0e:	blt.n	10fcc <__mdiff+0x100>
   10f10:	add.w	r5, r7, #20
   10f14:	add.w	r4, r2, #20
   10f18:	mov.w	r9, #0
   10f1c:	ldr	r1, [r7, #4]
   10f1e:	bl	109e0 <_Balloc>
   10f22:	ldr.w	r3, [r8, #16]
   10f26:	ldr	r6, [r7, #16]
   10f28:	str.w	r9, [r0, #12]
   10f2c:	add.w	ip, r4, r3, lsl #2
   10f30:	mov	lr, r4
   10f32:	add.w	r7, r5, r6, lsl #2
   10f36:	add.w	r4, r0, #20
   10f3a:	movs	r3, #0
   10f3c:	ldr.w	r1, [lr], #4
   10f40:	ldr.w	r8, [r5], #4
   10f44:	uxth	r2, r1
   10f46:	uxtah	r3, r3, r8
   10f4a:	lsrs	r1, r1, #16
   10f4c:	subs	r2, r3, r2
   10f4e:	rsb	r3, r1, r8, lsr #16
   10f52:	add.w	r3, r3, r2, asr #16
   10f56:	uxth	r2, r2
   10f58:	orr.w	r2, r2, r3, lsl #16
   10f5c:	cmp	ip, lr
   10f5e:	str.w	r2, [r4], #4
   10f62:	mov.w	r3, r3, asr #16
   10f66:	bhi.n	10f3c <__mdiff+0x70>
   10f68:	cmp	r7, r5
   10f6a:	bls.n	10f9c <__mdiff+0xd0>
   10f6c:	mov	ip, r4
   10f6e:	mov	r1, r5
   10f70:	ldr.w	lr, [r1], #4
   10f74:	uxtah	r2, r3, lr
   10f78:	asrs	r3, r2, #16
   10f7a:	add.w	r3, r3, lr, lsr #16
   10f7e:	uxth	r2, r2
   10f80:	orr.w	r2, r2, r3, lsl #16
   10f84:	cmp	r7, r1
   10f86:	str.w	r2, [ip], #4
   10f8a:	mov.w	r3, r3, asr #16
   10f8e:	bhi.n	10f70 <__mdiff+0xa4>
   10f90:	mvns	r5, r5
   10f92:	add	r5, r7
   10f94:	bic.w	r5, r5, #3
   10f98:	adds	r5, #4
   10f9a:	add	r4, r5
   10f9c:	subs	r4, #4
   10f9e:	cbnz	r2, 10faa <__mdiff+0xde>
   10fa0:	ldr.w	r3, [r4, #-4]!
   10fa4:	subs	r6, #1
   10fa6:	cmp	r3, #0
   10fa8:	beq.n	10fa0 <__mdiff+0xd4>
   10faa:	str	r6, [r0, #16]
   10fac:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   10fb0:	movs	r1, #0
   10fb2:	bl	109e0 <_Balloc>
   10fb6:	movs	r2, #1
   10fb8:	movs	r3, #0
   10fba:	str	r2, [r0, #16]
   10fbc:	str	r3, [r0, #20]
   10fbe:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   10fc2:	mov	r4, r5
   10fc4:	mov.w	r9, #0
   10fc8:	mov	r5, r2
   10fca:	b.n	10f1c <__mdiff+0x50>
   10fcc:	mov	r3, r7
   10fce:	add.w	r4, r7, #20
   10fd2:	add.w	r5, r8, #20
   10fd6:	mov	r7, r8
   10fd8:	mov.w	r9, #1
   10fdc:	mov	r8, r3
   10fde:	b.n	10f1c <__mdiff+0x50>

00010fe0 <__ulp>:
   10fe0:	ldr	r3, [pc, #76]	; (11030 <__ulp+0x50>)
   10fe2:	vmov	r2, s1
   10fe6:	ands	r2, r3
   10fe8:	sub.w	r3, r2, #54525952	; 0x3400000
   10fec:	cmp	r3, #0
   10fee:	ble.n	10ffa <__ulp+0x1a>
   10ff0:	movs	r0, #0
   10ff2:	mov	r1, r3
   10ff4:	vmov	d0, r0, r1
   10ff8:	bx	lr
   10ffa:	negs	r3, r3
   10ffc:	asrs	r3, r3, #20
   10ffe:	cmp	r3, #19
   11000:	ble.n	1101e <__ulp+0x3e>
   11002:	subs	r3, #20
   11004:	cmp	r3, #30
   11006:	ittte	le
   11008:	rsble	r3, r3, #31
   1100c:	movle	r2, #1
   1100e:	lslle.w	r3, r2, r3
   11012:	movgt	r3, #1
   11014:	movs	r1, #0
   11016:	mov	r0, r3
   11018:	vmov	d0, r0, r1
   1101c:	bx	lr
   1101e:	mov.w	r2, #524288	; 0x80000
   11022:	movs	r0, #0
   11024:	asr.w	r1, r2, r3
   11028:	vmov	d0, r0, r1
   1102c:	bx	lr
   1102e:	nop
   11030:	.word	0x7ff00000

00011034 <__b2d>:
   11034:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   11038:	ldr	r6, [r0, #16]
   1103a:	add.w	r8, r0, #20
   1103e:	add.w	r6, r8, r6, lsl #2
   11042:	ldr.w	r7, [r6, #-4]
   11046:	mov	r0, r7
   11048:	bl	10b58 <__hi0bits>
   1104c:	rsb	r3, r0, #32
   11050:	cmp	r0, #10
   11052:	str	r3, [r1, #0]
   11054:	sub.w	r3, r6, #4
   11058:	bgt.n	1108c <__b2d+0x58>
   1105a:	cmp	r8, r3
   1105c:	rsb	r2, r0, #11
   11060:	it	cc
   11062:	ldrcc.w	r3, [r6, #-8]
   11066:	lsr.w	r1, r7, r2
   1106a:	add.w	r0, r0, #21
   1106e:	orr.w	r5, r1, #1069547520	; 0x3fc00000
   11072:	ite	cc
   11074:	lsrcc	r3, r2
   11076:	movcs	r3, #0
   11078:	lsl.w	r0, r7, r0
   1107c:	orr.w	r5, r5, #3145728	; 0x300000
   11080:	orr.w	r4, r0, r3
   11084:	vmov	d0, r4, r5
   11088:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1108c:	cmp	r8, r3
   1108e:	bcs.n	110d2 <__b2d+0x9e>
   11090:	subs.w	r3, r0, #11
   11094:	ldr.w	r2, [r6, #-8]
   11098:	beq.n	110d8 <__b2d+0xa4>
   1109a:	lsl.w	r0, r7, r3
   1109e:	orr.w	r7, r0, #1069547520	; 0x3fc00000
   110a2:	rsb	lr, r3, #32
   110a6:	sub.w	r1, r6, #8
   110aa:	orr.w	r7, r7, #3145728	; 0x300000
   110ae:	lsr.w	r0, r2, lr
   110b2:	cmp	r8, r1
   110b4:	orr.w	r5, r7, r0
   110b8:	bcs.n	110fc <__b2d+0xc8>
   110ba:	ldr.w	r1, [r6, #-12]
   110be:	lsl.w	r0, r2, r3
   110c2:	lsr.w	r3, r1, lr
   110c6:	orrs	r0, r3
   110c8:	mov	r4, r0
   110ca:	vmov	d0, r4, r5
   110ce:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   110d2:	subs	r0, #11
   110d4:	bne.n	110ea <__b2d+0xb6>
   110d6:	mov	r2, r0
   110d8:	orr.w	r5, r7, #1069547520	; 0x3fc00000
   110dc:	orr.w	r5, r5, #3145728	; 0x300000
   110e0:	mov	r4, r2
   110e2:	vmov	d0, r4, r5
   110e6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   110ea:	lsl.w	r0, r7, r0
   110ee:	orr.w	r5, r0, #1069547520	; 0x3fc00000
   110f2:	movs	r0, #0
   110f4:	orr.w	r5, r5, #3145728	; 0x300000
   110f8:	mov	r4, r0
   110fa:	b.n	110ca <__b2d+0x96>
   110fc:	lsl.w	r0, r2, r3
   11100:	mov	r4, r0
   11102:	b.n	110ca <__b2d+0x96>

00011104 <__d2b>:
   11104:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   11108:	vmov	r6, r7, d0
   1110c:	sub	sp, #12
   1110e:	mov	r8, r1
   11110:	movs	r1, #1
   11112:	mov	r4, r7
   11114:	ubfx	r5, r7, #20, #11
   11118:	mov	r7, r2
   1111a:	bl	109e0 <_Balloc>
   1111e:	ubfx	r4, r4, #0, #20
   11122:	mov	r9, r0
   11124:	cbz	r5, 1112a <__d2b+0x26>
   11126:	orr.w	r4, r4, #1048576	; 0x100000
   1112a:	str	r4, [sp, #4]
   1112c:	cbz	r6, 11176 <__d2b+0x72>
   1112e:	add	r0, sp, #8
   11130:	str.w	r6, [r0, #-8]!
   11134:	bl	10b98 <__lo0bits>
   11138:	cmp	r0, #0
   1113a:	bne.n	111a6 <__d2b+0xa2>
   1113c:	ldmia.w	sp, {r2, r3}
   11140:	str.w	r2, [r9, #20]
   11144:	cmp	r3, #0
   11146:	ite	eq
   11148:	moveq	r1, #1
   1114a:	movne	r1, #2
   1114c:	str.w	r3, [r9, #24]
   11150:	str.w	r1, [r9, #16]
   11154:	cbnz	r5, 1118e <__d2b+0x8a>
   11156:	add.w	r3, r9, r1, lsl #2
   1115a:	subw	r0, r0, #1074	; 0x432
   1115e:	str.w	r0, [r8]
   11162:	ldr	r0, [r3, #16]
   11164:	bl	10b58 <__hi0bits>
   11168:	rsb	r0, r0, r1, lsl #5
   1116c:	str	r0, [r7, #0]
   1116e:	mov	r0, r9
   11170:	add	sp, #12
   11172:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   11176:	add	r0, sp, #4
   11178:	bl	10b98 <__lo0bits>
   1117c:	ldr	r3, [sp, #4]
   1117e:	str.w	r3, [r9, #20]
   11182:	movs	r1, #1
   11184:	adds	r0, #32
   11186:	str.w	r1, [r9, #16]
   1118a:	cmp	r5, #0
   1118c:	beq.n	11156 <__d2b+0x52>
   1118e:	subw	r5, r5, #1075	; 0x433
   11192:	add	r5, r0
   11194:	rsb	r0, r0, #53	; 0x35
   11198:	str.w	r5, [r8]
   1119c:	str	r0, [r7, #0]
   1119e:	mov	r0, r9
   111a0:	add	sp, #12
   111a2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   111a6:	ldmia.w	sp, {r2, r3}
   111aa:	rsb	r1, r0, #32
   111ae:	lsl.w	r1, r3, r1
   111b2:	orrs	r2, r1
   111b4:	lsrs	r3, r0
   111b6:	str	r3, [sp, #4]
   111b8:	str.w	r2, [r9, #20]
   111bc:	b.n	11144 <__d2b+0x40>
   111be:	nop

000111c0 <__ratio>:
   111c0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   111c4:	sub	sp, #12
   111c6:	mov	r8, r1
   111c8:	mov	r1, sp
   111ca:	mov	r9, r0
   111cc:	bl	11034 <__b2d>
   111d0:	mov	r0, r8
   111d2:	add	r1, sp, #4
   111d4:	vmov	r4, r5, d0
   111d8:	bl	11034 <__b2d>
   111dc:	ldmia.w	sp, {r1, r3}
   111e0:	ldr.w	r2, [r9, #16]
   111e4:	ldr.w	r0, [r8, #16]
   111e8:	subs	r1, r1, r3
   111ea:	subs	r0, r2, r0
   111ec:	add.w	r3, r1, r0, lsl #5
   111f0:	cmp	r3, #0
   111f2:	vmov	r6, r7, d0
   111f6:	ble.n	11214 <__ratio+0x54>
   111f8:	add.w	r1, r5, r3, lsl #20
   111fc:	mov	r5, r1
   111fe:	mov	r2, r6
   11200:	mov	r3, r7
   11202:	mov	r0, r4
   11204:	mov	r1, r5
   11206:	bl	a2b0 <__aeabi_ddiv>
   1120a:	vmov	d0, r0, r1
   1120e:	add	sp, #12
   11210:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   11214:	sub.w	r9, r7, r3, lsl #20
   11218:	vmov	r6, s0
   1121c:	mov	r7, r9
   1121e:	b.n	111fe <__ratio+0x3e>

00011220 <__copybits>:
   11220:	push	{r4, r5, r6}
   11222:	ldr	r4, [r2, #16]
   11224:	add.w	r3, r2, #20
   11228:	subs	r1, #1
   1122a:	asrs	r6, r1, #5
   1122c:	add.w	r4, r3, r4, lsl #2
   11230:	adds	r6, #1
   11232:	cmp	r3, r4
   11234:	add.w	r6, r0, r6, lsl #2
   11238:	bcs.n	11254 <__copybits+0x34>
   1123a:	subs	r1, r0, #4
   1123c:	ldr.w	r5, [r3], #4
   11240:	str.w	r5, [r1, #4]!
   11244:	cmp	r4, r3
   11246:	bhi.n	1123c <__copybits+0x1c>
   11248:	subs	r3, r4, r2
   1124a:	subs	r3, #21
   1124c:	bic.w	r3, r3, #3
   11250:	adds	r3, #4
   11252:	add	r0, r3
   11254:	cmp	r6, r0
   11256:	bls.n	11262 <__copybits+0x42>
   11258:	movs	r3, #0
   1125a:	str.w	r3, [r0], #4
   1125e:	cmp	r6, r0
   11260:	bhi.n	1125a <__copybits+0x3a>
   11262:	pop	{r4, r5, r6}
   11264:	bx	lr
   11266:	nop

00011268 <__any_on>:
   11268:	ldr	r3, [r0, #16]
   1126a:	asrs	r2, r1, #5
   1126c:	cmp	r3, r2
   1126e:	push	{r4}
   11270:	add.w	r4, r0, #20
   11274:	bge.n	11298 <__any_on+0x30>
   11276:	add.w	r3, r4, r3, lsl #2
   1127a:	cmp	r4, r3
   1127c:	bcs.n	112c2 <__any_on+0x5a>
   1127e:	ldr.w	r0, [r3, #-4]
   11282:	subs	r3, #4
   11284:	cbz	r0, 1128e <__any_on+0x26>
   11286:	b.n	112b4 <__any_on+0x4c>
   11288:	ldr.w	r2, [r3, #-4]!
   1128c:	cbnz	r2, 112b4 <__any_on+0x4c>
   1128e:	cmp	r4, r3
   11290:	bcc.n	11288 <__any_on+0x20>
   11292:	ldr.w	r4, [sp], #4
   11296:	bx	lr
   11298:	ble.n	112bc <__any_on+0x54>
   1129a:	ands.w	r1, r1, #31
   1129e:	beq.n	112bc <__any_on+0x54>
   112a0:	ldr.w	r0, [r4, r2, lsl #2]
   112a4:	lsr.w	r3, r0, r1
   112a8:	lsl.w	r1, r3, r1
   112ac:	cmp	r0, r1
   112ae:	add.w	r3, r4, r2, lsl #2
   112b2:	beq.n	1127a <__any_on+0x12>
   112b4:	movs	r0, #1
   112b6:	ldr.w	r4, [sp], #4
   112ba:	bx	lr
   112bc:	add.w	r3, r4, r2, lsl #2
   112c0:	b.n	1127a <__any_on+0x12>
   112c2:	movs	r0, #0
   112c4:	b.n	11292 <__any_on+0x2a>
   112c6:	nop

000112c8 <__sccl>:
   112c8:	push	{r4, r5, r6}
   112ca:	ldrb	r5, [r1, #0]
   112cc:	cmp	r5, #94	; 0x5e
   112ce:	beq.n	11330 <__sccl+0x68>
   112d0:	movs	r2, #0
   112d2:	adds	r1, #1
   112d4:	mov	r6, r2
   112d6:	subs	r3, r0, #1
   112d8:	add.w	r4, r0, #255	; 0xff
   112dc:	strb.w	r2, [r3, #1]!
   112e0:	cmp	r3, r4
   112e2:	bne.n	112dc <__sccl+0x14>
   112e4:	cbz	r5, 11308 <__sccl+0x40>
   112e6:	eor.w	r2, r6, #1
   112ea:	strb	r2, [r0, r5]
   112ec:	adds	r4, r1, #1
   112ee:	ldrb.w	r3, [r4, #-1]
   112f2:	cmp	r3, #45	; 0x2d
   112f4:	beq.n	11314 <__sccl+0x4c>
   112f6:	cmp	r3, #93	; 0x5d
   112f8:	beq.n	1130e <__sccl+0x46>
   112fa:	cbz	r3, 11302 <__sccl+0x3a>
   112fc:	mov	r5, r3
   112fe:	mov	r1, r4
   11300:	b.n	112ea <__sccl+0x22>
   11302:	mov	r0, r1
   11304:	pop	{r4, r5, r6}
   11306:	bx	lr
   11308:	subs	r0, r1, #1
   1130a:	pop	{r4, r5, r6}
   1130c:	bx	lr
   1130e:	mov	r0, r4
   11310:	pop	{r4, r5, r6}
   11312:	bx	lr
   11314:	ldrb	r6, [r1, #1]
   11316:	cmp	r6, #93	; 0x5d
   11318:	beq.n	112fc <__sccl+0x34>
   1131a:	cmp	r5, r6
   1131c:	bgt.n	112fc <__sccl+0x34>
   1131e:	adds	r1, #2
   11320:	adds	r3, r0, r5
   11322:	adds	r5, #1
   11324:	cmp	r6, r5
   11326:	strb.w	r2, [r3, #1]!
   1132a:	bgt.n	11322 <__sccl+0x5a>
   1132c:	adds	r4, #2
   1132e:	b.n	112ee <__sccl+0x26>
   11330:	movs	r2, #1
   11332:	ldrb	r5, [r1, #1]
   11334:	mov	r6, r2
   11336:	adds	r1, #2
   11338:	b.n	112d6 <__sccl+0xe>
   1133a:	nop

0001133c <_strtoll_l.isra.0>:
   1133c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11340:	sub	sp, #20
   11342:	mov	sl, r3
   11344:	str	r1, [sp, #8]
   11346:	str	r0, [sp, #12]
   11348:	str	r2, [sp, #4]
   1134a:	mov	r7, r1
   1134c:	ldr	r6, [sp, #56]	; 0x38
   1134e:	b.n	11352 <_strtoll_l.isra.0+0x16>
   11350:	mov	r7, r5
   11352:	mov	r5, r7
   11354:	mov	r0, r6
   11356:	ldrb.w	r4, [r5], #1
   1135a:	bl	aaa0 <__locale_ctype_ptr_l>
   1135e:	add	r0, r4
   11360:	ldrb	r3, [r0, #1]
   11362:	and.w	r3, r3, #8
   11366:	and.w	r2, r3, #255	; 0xff
   1136a:	cmp	r3, #0
   1136c:	bne.n	11350 <_strtoll_l.isra.0+0x14>
   1136e:	cmp	r4, #45	; 0x2d
   11370:	beq.w	1147a <_strtoll_l.isra.0+0x13e>
   11374:	cmp	r4, #43	; 0x2b
   11376:	it	eq
   11378:	ldrbeq	r4, [r7, #1]
   1137a:	str	r2, [sp, #0]
   1137c:	it	eq
   1137e:	addeq	r5, r7, #2
   11380:	cmp.w	sl, #0
   11384:	beq.n	113a0 <_strtoll_l.isra.0+0x64>
   11386:	cmp.w	sl, #16
   1138a:	beq.w	114b8 <_strtoll_l.isra.0+0x17c>
   1138e:	ldr	r3, [sp, #0]
   11390:	mov	r6, sl
   11392:	asrs	r7, r6, #31
   11394:	cbnz	r3, 113b2 <_strtoll_l.isra.0+0x76>
   11396:	mov.w	r8, #4294967295
   1139a:	mvn.w	r9, #2147483648	; 0x80000000
   1139e:	b.n	113ba <_strtoll_l.isra.0+0x7e>
   113a0:	cmp	r4, #48	; 0x30
   113a2:	beq.n	114a4 <_strtoll_l.isra.0+0x168>
   113a4:	movs	r6, #10
   113a6:	movs	r7, #0
   113a8:	mov.w	sl, #10
   113ac:	ldr	r3, [sp, #0]
   113ae:	cmp	r3, #0
   113b0:	beq.n	11396 <_strtoll_l.isra.0+0x5a>
   113b2:	mov.w	r8, #0
   113b6:	mov.w	r9, #2147483648	; 0x80000000
   113ba:	mov	r2, r6
   113bc:	mov	r3, r7
   113be:	mov	r0, r8
   113c0:	mov	r1, r9
   113c2:	bl	a6ec <__aeabi_uldivmod>
   113c6:	mov	r3, r7
   113c8:	mov	fp, r2
   113ca:	mov	r0, r8
   113cc:	mov	r2, r6
   113ce:	mov	r1, r9
   113d0:	bl	a6ec <__aeabi_uldivmod>
   113d4:	mov.w	lr, #0
   113d8:	movs	r2, #0
   113da:	movs	r3, #0
   113dc:	b.n	113fe <_strtoll_l.isra.0+0xc2>
   113de:	beq.n	1146c <_strtoll_l.isra.0+0x130>
   113e0:	mul.w	r4, r2, r7
   113e4:	mla	r4, r6, r3, r4
   113e8:	umull	r2, r3, r2, r6
   113ec:	add	r3, r4
   113ee:	adds.w	r2, r2, ip
   113f2:	adc.w	r3, r3, ip, asr #31
   113f6:	mov.w	lr, #1
   113fa:	ldrb.w	r4, [r5], #1
   113fe:	sub.w	ip, r4, #48	; 0x30
   11402:	cmp.w	ip, #9
   11406:	bls.n	11416 <_strtoll_l.isra.0+0xda>
   11408:	sub.w	ip, r4, #65	; 0x41
   1140c:	cmp.w	ip, #25
   11410:	bhi.n	1142e <_strtoll_l.isra.0+0xf2>
   11412:	sub.w	ip, r4, #55	; 0x37
   11416:	cmp	sl, ip
   11418:	ble.n	11440 <_strtoll_l.isra.0+0x104>
   1141a:	cmp.w	lr, #4294967295
   1141e:	beq.n	113fa <_strtoll_l.isra.0+0xbe>
   11420:	cmp	r1, r3
   11422:	it	eq
   11424:	cmpeq	r0, r2
   11426:	bcs.n	113de <_strtoll_l.isra.0+0xa2>
   11428:	mov.w	lr, #4294967295
   1142c:	b.n	113fa <_strtoll_l.isra.0+0xbe>
   1142e:	sub.w	ip, r4, #97	; 0x61
   11432:	cmp.w	ip, #25
   11436:	bhi.n	11440 <_strtoll_l.isra.0+0x104>
   11438:	sub.w	ip, r4, #87	; 0x57
   1143c:	cmp	sl, ip
   1143e:	bgt.n	1141a <_strtoll_l.isra.0+0xde>
   11440:	cmp.w	lr, #4294967295
   11444:	beq.n	11484 <_strtoll_l.isra.0+0x148>
   11446:	ldr	r1, [sp, #0]
   11448:	cbz	r1, 11450 <_strtoll_l.isra.0+0x114>
   1144a:	negs	r2, r2
   1144c:	sbc.w	r3, r3, r3, lsl #1
   11450:	ldr	r1, [sp, #4]
   11452:	cmp	r1, #0
   11454:	beq.n	114dc <_strtoll_l.isra.0+0x1a0>
   11456:	cmp.w	lr, #0
   1145a:	bne.n	1149c <_strtoll_l.isra.0+0x160>
   1145c:	ldr	r5, [sp, #8]
   1145e:	mov	r0, r2
   11460:	mov	r1, r3
   11462:	ldr	r3, [sp, #4]
   11464:	str	r5, [r3, #0]
   11466:	add	sp, #20
   11468:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1146c:	cmp	fp, ip
   1146e:	bge.n	113e0 <_strtoll_l.isra.0+0xa4>
   11470:	mov	r2, r0
   11472:	mov	r3, r1
   11474:	mov.w	lr, #4294967295
   11478:	b.n	113fa <_strtoll_l.isra.0+0xbe>
   1147a:	movs	r3, #1
   1147c:	adds	r5, r7, #2
   1147e:	ldrb	r4, [r7, #1]
   11480:	str	r3, [sp, #0]
   11482:	b.n	11380 <_strtoll_l.isra.0+0x44>
   11484:	ldr	r3, [sp, #0]
   11486:	cbnz	r3, 114d4 <_strtoll_l.isra.0+0x198>
   11488:	mov.w	r0, #4294967295
   1148c:	mvn.w	r1, #2147483648	; 0x80000000
   11490:	ldr	r2, [sp, #12]
   11492:	movs	r3, #34	; 0x22
   11494:	str	r3, [r2, #0]
   11496:	ldr	r3, [sp, #4]
   11498:	cbnz	r3, 114a0 <_strtoll_l.isra.0+0x164>
   1149a:	b.n	11466 <_strtoll_l.isra.0+0x12a>
   1149c:	mov	r0, r2
   1149e:	mov	r1, r3
   114a0:	subs	r5, #1
   114a2:	b.n	11462 <_strtoll_l.isra.0+0x126>
   114a4:	ldrb	r3, [r5, #0]
   114a6:	and.w	r3, r3, #223	; 0xdf
   114aa:	cmp	r3, #88	; 0x58
   114ac:	beq.n	114c6 <_strtoll_l.isra.0+0x18a>
   114ae:	movs	r6, #8
   114b0:	movs	r7, #0
   114b2:	mov.w	sl, #8
   114b6:	b.n	113ac <_strtoll_l.isra.0+0x70>
   114b8:	cmp	r4, #48	; 0x30
   114ba:	bne.n	114e2 <_strtoll_l.isra.0+0x1a6>
   114bc:	ldrb	r3, [r5, #0]
   114be:	and.w	r3, r3, #223	; 0xdf
   114c2:	cmp	r3, #88	; 0x58
   114c4:	bne.n	114e2 <_strtoll_l.isra.0+0x1a6>
   114c6:	ldrb	r4, [r5, #1]
   114c8:	movs	r6, #16
   114ca:	movs	r7, #0
   114cc:	adds	r5, #2
   114ce:	mov.w	sl, #16
   114d2:	b.n	113ac <_strtoll_l.isra.0+0x70>
   114d4:	movs	r0, #0
   114d6:	mov.w	r1, #2147483648	; 0x80000000
   114da:	b.n	11490 <_strtoll_l.isra.0+0x154>
   114dc:	mov	r0, r2
   114de:	mov	r1, r3
   114e0:	b.n	11466 <_strtoll_l.isra.0+0x12a>
   114e2:	movs	r6, #16
   114e4:	movs	r7, #0
   114e6:	b.n	113ac <_strtoll_l.isra.0+0x70>

000114e8 <_strtoll_r>:
   114e8:	push	{r4, r5, lr}
   114ea:	ldr	r4, [pc, #24]	; (11504 <_strtoll_r+0x1c>)
   114ec:	ldr	r5, [pc, #24]	; (11508 <_strtoll_r+0x20>)
   114ee:	ldr	r4, [r4, #0]
   114f0:	ldr	r4, [r4, #52]	; 0x34
   114f2:	sub	sp, #12
   114f4:	cmp	r4, #0
   114f6:	it	eq
   114f8:	moveq	r4, r5
   114fa:	str	r4, [sp, #0]
   114fc:	bl	1133c <_strtoll_l.isra.0>
   11500:	add	sp, #12
   11502:	pop	{r4, r5, pc}
   11504:	.word	0x1fff1840
   11508:	.word	0x1fff1844

0001150c <_strtoul_l.isra.0>:
   1150c:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11510:	ldr.w	r9, [sp, #40]	; 0x28
   11514:	mov	r6, r1
   11516:	mov	r7, r0
   11518:	mov	r5, r2
   1151a:	mov	r8, r3
   1151c:	mov	fp, r1
   1151e:	b.n	11522 <_strtoul_l.isra.0+0x16>
   11520:	mov	fp, r4
   11522:	mov	r4, fp
   11524:	mov	r0, r9
   11526:	ldrb.w	sl, [r4], #1
   1152a:	bl	aaa0 <__locale_ctype_ptr_l>
   1152e:	add	r0, sl
   11530:	ldrb	r0, [r0, #1]
   11532:	and.w	r0, r0, #8
   11536:	and.w	ip, r0, #255	; 0xff
   1153a:	cmp	r0, #0
   1153c:	bne.n	11520 <_strtoul_l.isra.0+0x14>
   1153e:	mov	r1, sl
   11540:	cmp	r1, #45	; 0x2d
   11542:	beq.n	11608 <_strtoul_l.isra.0+0xfc>
   11544:	cmp	r1, #43	; 0x2b
   11546:	itt	eq
   11548:	ldrbeq.w	r1, [fp, #1]
   1154c:	addeq.w	r4, fp, #2
   11550:	cmp.w	r8, #0
   11554:	beq.n	11570 <_strtoul_l.isra.0+0x64>
   11556:	cmp.w	r8, #16
   1155a:	beq.n	11616 <_strtoul_l.isra.0+0x10a>
   1155c:	mov.w	r3, #4294967295
   11560:	udiv	r3, r3, r8
   11564:	mul.w	sl, r8, r3
   11568:	mvn.w	sl, sl
   1156c:	mov	r9, r8
   1156e:	b.n	11580 <_strtoul_l.isra.0+0x74>
   11570:	cmp	r1, #48	; 0x30
   11572:	beq.n	11638 <_strtoul_l.isra.0+0x12c>
   11574:	mov.w	r8, #10
   11578:	ldr	r3, [pc, #244]	; (11670 <_strtoul_l.isra.0+0x164>)
   1157a:	mov	r9, r8
   1157c:	mov.w	sl, #5
   11580:	mov.w	lr, #0
   11584:	mov	r0, lr
   11586:	b.n	11596 <_strtoul_l.isra.0+0x8a>
   11588:	beq.n	115ea <_strtoul_l.isra.0+0xde>
   1158a:	mla	r0, r9, r0, r2
   1158e:	mov.w	lr, #1
   11592:	ldrb.w	r1, [r4], #1
   11596:	sub.w	r2, r1, #48	; 0x30
   1159a:	cmp	r2, #9
   1159c:	bls.n	115aa <_strtoul_l.isra.0+0x9e>
   1159e:	sub.w	r2, r1, #65	; 0x41
   115a2:	cmp	r2, #25
   115a4:	bhi.n	115be <_strtoul_l.isra.0+0xb2>
   115a6:	sub.w	r2, r1, #55	; 0x37
   115aa:	cmp	r8, r2
   115ac:	ble.n	115ce <_strtoul_l.isra.0+0xc2>
   115ae:	cmp.w	lr, #4294967295
   115b2:	beq.n	11592 <_strtoul_l.isra.0+0x86>
   115b4:	cmp	r0, r3
   115b6:	bls.n	11588 <_strtoul_l.isra.0+0x7c>
   115b8:	mov.w	lr, #4294967295
   115bc:	b.n	11592 <_strtoul_l.isra.0+0x86>
   115be:	sub.w	r2, r1, #97	; 0x61
   115c2:	cmp	r2, #25
   115c4:	bhi.n	115ce <_strtoul_l.isra.0+0xc2>
   115c6:	sub.w	r2, r1, #87	; 0x57
   115ca:	cmp	r8, r2
   115cc:	bgt.n	115ae <_strtoul_l.isra.0+0xa2>
   115ce:	cmp.w	lr, #4294967295
   115d2:	beq.n	115f8 <_strtoul_l.isra.0+0xec>
   115d4:	cmp.w	ip, #0
   115d8:	beq.n	115dc <_strtoul_l.isra.0+0xd0>
   115da:	negs	r0, r0
   115dc:	cbz	r5, 115f4 <_strtoul_l.isra.0+0xe8>
   115de:	cmp.w	lr, #0
   115e2:	bne.n	11600 <_strtoul_l.isra.0+0xf4>
   115e4:	str	r6, [r5, #0]
   115e6:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   115ea:	cmp	r2, sl
   115ec:	ble.n	1158a <_strtoul_l.isra.0+0x7e>
   115ee:	mov.w	lr, #4294967295
   115f2:	b.n	11592 <_strtoul_l.isra.0+0x86>
   115f4:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   115f8:	movs	r3, #34	; 0x22
   115fa:	str	r3, [r7, #0]
   115fc:	mov	r0, lr
   115fe:	cbz	r5, 11652 <_strtoul_l.isra.0+0x146>
   11600:	subs	r6, r4, #1
   11602:	str	r6, [r5, #0]
   11604:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11608:	add.w	r4, fp, #2
   1160c:	ldrb.w	r1, [fp, #1]
   11610:	mov.w	ip, #1
   11614:	b.n	11550 <_strtoul_l.isra.0+0x44>
   11616:	cmp	r1, #48	; 0x30
   11618:	bne.n	11656 <_strtoul_l.isra.0+0x14a>
   1161a:	ldrb	r3, [r4, #0]
   1161c:	and.w	r3, r3, #223	; 0xdf
   11620:	cmp	r3, #88	; 0x58
   11622:	bne.n	11662 <_strtoul_l.isra.0+0x156>
   11624:	mov.w	r9, #16
   11628:	ldrb	r1, [r4, #1]
   1162a:	mov	r8, r9
   1162c:	mov.w	sl, #15
   11630:	adds	r4, #2
   11632:	mvn.w	r3, #4026531840	; 0xf0000000
   11636:	b.n	11580 <_strtoul_l.isra.0+0x74>
   11638:	ldrb	r3, [r4, #0]
   1163a:	and.w	r3, r3, #223	; 0xdf
   1163e:	cmp	r3, #88	; 0x58
   11640:	beq.n	11624 <_strtoul_l.isra.0+0x118>
   11642:	mov.w	r8, #8
   11646:	mov	r9, r8
   11648:	mov.w	sl, #7
   1164c:	mvn.w	r3, #3758096384	; 0xe0000000
   11650:	b.n	11580 <_strtoul_l.isra.0+0x74>
   11652:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11656:	mov.w	sl, #15
   1165a:	mvn.w	r3, #4026531840	; 0xf0000000
   1165e:	mov	r9, r8
   11660:	b.n	11580 <_strtoul_l.isra.0+0x74>
   11662:	mov	r9, r8
   11664:	mov.w	sl, #15
   11668:	mvn.w	r3, #4026531840	; 0xf0000000
   1166c:	b.n	11580 <_strtoul_l.isra.0+0x74>
   1166e:	nop
   11670:	.word	0x19999999

00011674 <_strtoul_r>:
   11674:	push	{r4, r5, lr}
   11676:	ldr	r4, [pc, #24]	; (11690 <_strtoul_r+0x1c>)
   11678:	ldr	r5, [pc, #24]	; (11694 <_strtoul_r+0x20>)
   1167a:	ldr	r4, [r4, #0]
   1167c:	ldr	r4, [r4, #52]	; 0x34
   1167e:	sub	sp, #12
   11680:	cmp	r4, #0
   11682:	it	eq
   11684:	moveq	r4, r5
   11686:	str	r4, [sp, #0]
   11688:	bl	1150c <_strtoul_l.isra.0>
   1168c:	add	sp, #12
   1168e:	pop	{r4, r5, pc}
   11690:	.word	0x1fff1840
   11694:	.word	0x1fff1844

00011698 <_strtoull_l.isra.0>:
   11698:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1169c:	sub	sp, #20
   1169e:	mov	fp, r1
   116a0:	str	r0, [sp, #8]
   116a2:	mov	r7, r2
   116a4:	mov	r6, r3
   116a6:	mov	r8, r1
   116a8:	ldr	r4, [sp, #56]	; 0x38
   116aa:	b.n	116ae <_strtoull_l.isra.0+0x16>
   116ac:	mov	r8, r5
   116ae:	mov	r5, r8
   116b0:	mov	r0, r4
   116b2:	ldrb.w	r9, [r5], #1
   116b6:	bl	aaa0 <__locale_ctype_ptr_l>
   116ba:	add	r0, r9
   116bc:	ldrb	r3, [r0, #1]
   116be:	and.w	r3, r3, #8
   116c2:	and.w	r2, r3, #255	; 0xff
   116c6:	cmp	r3, #0
   116c8:	bne.n	116ac <_strtoull_l.isra.0+0x14>
   116ca:	mov	r4, r9
   116cc:	cmp	r4, #45	; 0x2d
   116ce:	beq.w	117ea <_strtoull_l.isra.0+0x152>
   116d2:	cmp	r4, #43	; 0x2b
   116d4:	it	eq
   116d6:	ldrbeq.w	r4, [r8, #1]
   116da:	str	r2, [sp, #4]
   116dc:	it	eq
   116de:	addeq.w	r5, r8, #2
   116e2:	cbz	r6, 1171c <_strtoull_l.isra.0+0x84>
   116e4:	cmp	r6, #16
   116e6:	beq.w	117f8 <_strtoull_l.isra.0+0x160>
   116ea:	mov.w	r9, r6, asr #31
   116ee:	mov	r2, r6
   116f0:	mov	r3, r9
   116f2:	mov.w	r0, #4294967295
   116f6:	mov.w	r1, #4294967295
   116fa:	bl	a6ec <__aeabi_uldivmod>
   116fe:	mov	r2, r6
   11700:	str	r0, [sp, #12]
   11702:	mov	sl, r1
   11704:	mov	r3, r9
   11706:	mov.w	r0, #4294967295
   1170a:	mov.w	r1, #4294967295
   1170e:	bl	a6ec <__aeabi_uldivmod>
   11712:	mov	r8, r6
   11714:	mov	lr, r2
   11716:	ldr	r2, [sp, #12]
   11718:	mov	r3, sl
   1171a:	b.n	11736 <_strtoull_l.isra.0+0x9e>
   1171c:	cmp	r4, #48	; 0x30
   1171e:	beq.w	11824 <_strtoull_l.isra.0+0x18c>
   11722:	ldr	r3, [pc, #348]	; (11880 <_strtoull_l.isra.0+0x1e8>)
   11724:	mov.w	lr, #5
   11728:	mov.w	r2, #2576980377	; 0x99999999
   1172c:	mov.w	r8, #10
   11730:	mov.w	r9, #0
   11734:	movs	r6, #10
   11736:	mov.w	ip, #0
   1173a:	movs	r0, #0
   1173c:	movs	r1, #0
   1173e:	b.n	11766 <_strtoull_l.isra.0+0xce>
   11740:	cmp	r1, r3
   11742:	it	eq
   11744:	cmpeq	r0, r2
   11746:	beq.n	117ca <_strtoull_l.isra.0+0x132>
   11748:	mul.w	r4, r0, r9
   1174c:	mla	r4, r8, r1, r4
   11750:	umull	r0, r1, r0, r8
   11754:	add	r1, r4
   11756:	adds.w	r0, r0, sl
   1175a:	adc.w	r1, r1, sl, asr #31
   1175e:	mov.w	ip, #1
   11762:	ldrb.w	r4, [r5], #1
   11766:	sub.w	sl, r4, #48	; 0x30
   1176a:	cmp.w	sl, #9
   1176e:	bls.n	1177e <_strtoull_l.isra.0+0xe6>
   11770:	sub.w	sl, r4, #65	; 0x41
   11774:	cmp.w	sl, #25
   11778:	bhi.n	11796 <_strtoull_l.isra.0+0xfe>
   1177a:	sub.w	sl, r4, #55	; 0x37
   1177e:	cmp	r6, sl
   11780:	ble.n	117a8 <_strtoull_l.isra.0+0x110>
   11782:	cmp.w	ip, #4294967295
   11786:	beq.n	11762 <_strtoull_l.isra.0+0xca>
   11788:	cmp	r3, r1
   1178a:	it	eq
   1178c:	cmpeq	r2, r0
   1178e:	bcs.n	11740 <_strtoull_l.isra.0+0xa8>
   11790:	mov.w	ip, #4294967295
   11794:	b.n	11762 <_strtoull_l.isra.0+0xca>
   11796:	sub.w	sl, r4, #97	; 0x61
   1179a:	cmp.w	sl, #25
   1179e:	bhi.n	117a8 <_strtoull_l.isra.0+0x110>
   117a0:	sub.w	sl, r4, #87	; 0x57
   117a4:	cmp	r6, sl
   117a6:	bgt.n	11782 <_strtoull_l.isra.0+0xea>
   117a8:	cmp.w	ip, #4294967295
   117ac:	beq.n	117d4 <_strtoull_l.isra.0+0x13c>
   117ae:	ldr	r3, [sp, #4]
   117b0:	cbz	r3, 117b8 <_strtoull_l.isra.0+0x120>
   117b2:	negs	r0, r0
   117b4:	sbc.w	r1, r1, r1, lsl #1
   117b8:	cbz	r7, 117c4 <_strtoull_l.isra.0+0x12c>
   117ba:	cmp.w	ip, #0
   117be:	bne.n	117e6 <_strtoull_l.isra.0+0x14e>
   117c0:	mov	r5, fp
   117c2:	str	r5, [r7, #0]
   117c4:	add	sp, #20
   117c6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   117ca:	cmp	sl, lr
   117cc:	ble.n	11748 <_strtoull_l.isra.0+0xb0>
   117ce:	mov.w	ip, #4294967295
   117d2:	b.n	11762 <_strtoull_l.isra.0+0xca>
   117d4:	ldr	r2, [sp, #8]
   117d6:	movs	r3, #34	; 0x22
   117d8:	str	r3, [r2, #0]
   117da:	mov.w	r0, #4294967295
   117de:	mov.w	r1, #4294967295
   117e2:	cmp	r7, #0
   117e4:	beq.n	117c4 <_strtoull_l.isra.0+0x12c>
   117e6:	subs	r5, #1
   117e8:	b.n	117c2 <_strtoull_l.isra.0+0x12a>
   117ea:	movs	r3, #1
   117ec:	add.w	r5, r8, #2
   117f0:	ldrb.w	r4, [r8, #1]
   117f4:	str	r3, [sp, #4]
   117f6:	b.n	116e2 <_strtoull_l.isra.0+0x4a>
   117f8:	cmp	r4, #48	; 0x30
   117fa:	bne.n	11846 <_strtoull_l.isra.0+0x1ae>
   117fc:	ldrb	r3, [r5, #0]
   117fe:	and.w	r3, r3, #223	; 0xdf
   11802:	cmp	r3, #88	; 0x58
   11804:	bne.n	1185c <_strtoull_l.isra.0+0x1c4>
   11806:	mov.w	r3, #4294967295
   1180a:	ldrb	r4, [r5, #1]
   1180c:	str	r3, [sp, #12]
   1180e:	mov.w	lr, #15
   11812:	adds	r5, #2
   11814:	mvn.w	sl, #4026531840	; 0xf0000000
   11818:	mov.w	r8, #16
   1181c:	mov.w	r9, #0
   11820:	movs	r6, #16
   11822:	b.n	11716 <_strtoull_l.isra.0+0x7e>
   11824:	ldrb	r3, [r5, #0]
   11826:	and.w	r3, r3, #223	; 0xdf
   1182a:	cmp	r3, #88	; 0x58
   1182c:	beq.n	11806 <_strtoull_l.isra.0+0x16e>
   1182e:	mov.w	lr, #7
   11832:	mov.w	r2, #4294967295
   11836:	mvn.w	r3, #3758096384	; 0xe0000000
   1183a:	mov.w	r8, #8
   1183e:	mov.w	r9, #0
   11842:	movs	r6, #8
   11844:	b.n	11736 <_strtoull_l.isra.0+0x9e>
   11846:	mov.w	lr, #15
   1184a:	mov.w	r2, #4294967295
   1184e:	mvn.w	r3, #4026531840	; 0xf0000000
   11852:	mov.w	r8, #16
   11856:	mov.w	r9, #0
   1185a:	b.n	11736 <_strtoull_l.isra.0+0x9e>
   1185c:	mov.w	r8, #16
   11860:	mov.w	r9, #0
   11864:	mov	r2, r8
   11866:	mov	r3, r9
   11868:	mov.w	r0, #4294967295
   1186c:	mov.w	r1, #4294967295
   11870:	bl	a6ec <__aeabi_uldivmod>
   11874:	mvn.w	r3, #4026531840	; 0xf0000000
   11878:	mov	lr, r2
   1187a:	mov.w	r2, #4294967295
   1187e:	b.n	11736 <_strtoull_l.isra.0+0x9e>
   11880:	.word	0x19999999

00011884 <_strtoull_r>:
   11884:	push	{r4, r5, lr}
   11886:	ldr	r4, [pc, #24]	; (118a0 <_strtoull_r+0x1c>)
   11888:	ldr	r5, [pc, #24]	; (118a4 <_strtoull_r+0x20>)
   1188a:	ldr	r4, [r4, #0]
   1188c:	ldr	r4, [r4, #52]	; 0x34
   1188e:	sub	sp, #12
   11890:	cmp	r4, #0
   11892:	it	eq
   11894:	moveq	r4, r5
   11896:	str	r4, [sp, #0]
   11898:	bl	11698 <_strtoull_l.isra.0>
   1189c:	add	sp, #12
   1189e:	pop	{r4, r5, pc}
   118a0:	.word	0x1fff1840
   118a4:	.word	0x1fff1844

000118a8 <__ssprint_r>:
   118a8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   118ac:	ldr	r3, [r2, #8]
   118ae:	sub	sp, #12
   118b0:	mov	r8, r2
   118b2:	cmp	r3, #0
   118b4:	beq.n	1199c <__ssprint_r+0xf4>
   118b6:	mov	fp, r0
   118b8:	mov.w	r9, #0
   118bc:	ldr	r6, [r2, #0]
   118be:	ldr	r0, [r1, #0]
   118c0:	ldr	r3, [r1, #8]
   118c2:	mov	r5, r1
   118c4:	mov	r4, r9
   118c6:	cmp	r4, #0
   118c8:	beq.n	11956 <__ssprint_r+0xae>
   118ca:	cmp	r4, r3
   118cc:	mov	r7, r3
   118ce:	mov	sl, r3
   118d0:	bcc.n	11960 <__ssprint_r+0xb8>
   118d2:	ldrh	r3, [r5, #12]
   118d4:	tst.w	r3, #1152	; 0x480
   118d8:	beq.n	11936 <__ssprint_r+0x8e>
   118da:	ldr	r7, [r5, #20]
   118dc:	ldr	r1, [r5, #16]
   118de:	add.w	r7, r7, r7, lsl #1
   118e2:	rsb	sl, r1, r0
   118e6:	add.w	r7, r7, r7, lsr #31
   118ea:	adds	r0, r4, #1
   118ec:	asrs	r7, r7, #1
   118ee:	add	r0, sl
   118f0:	cmp	r0, r7
   118f2:	mov	r2, r7
   118f4:	itt	hi
   118f6:	movhi	r7, r0
   118f8:	movhi	r2, r7
   118fa:	lsls	r3, r3, #21
   118fc:	bpl.n	11966 <__ssprint_r+0xbe>
   118fe:	mov	r1, r2
   11900:	mov	r0, fp
   11902:	bl	aadc <_malloc_r>
   11906:	cmp	r0, #0
   11908:	beq.n	1197a <__ssprint_r+0xd2>
   1190a:	mov	r2, sl
   1190c:	ldr	r1, [r5, #16]
   1190e:	str	r0, [sp, #4]
   11910:	bl	8720 <memcpy>
   11914:	ldrh	r2, [r5, #12]
   11916:	ldr	r3, [sp, #4]
   11918:	bic.w	r2, r2, #1152	; 0x480
   1191c:	orr.w	r2, r2, #128	; 0x80
   11920:	strh	r2, [r5, #12]
   11922:	rsb	r2, sl, r7
   11926:	add.w	r0, r3, sl
   1192a:	str	r7, [r5, #20]
   1192c:	str	r3, [r5, #16]
   1192e:	str	r0, [r5, #0]
   11930:	str	r2, [r5, #8]
   11932:	mov	r7, r4
   11934:	mov	sl, r4
   11936:	mov	r2, sl
   11938:	mov	r1, r9
   1193a:	bl	b184 <memmove>
   1193e:	ldr.w	r2, [r8, #8]
   11942:	ldr	r3, [r5, #8]
   11944:	ldr	r0, [r5, #0]
   11946:	subs	r3, r3, r7
   11948:	add	r0, sl
   1194a:	subs	r4, r2, r4
   1194c:	str	r3, [r5, #8]
   1194e:	str	r0, [r5, #0]
   11950:	str.w	r4, [r8, #8]
   11954:	cbz	r4, 1199c <__ssprint_r+0xf4>
   11956:	ldr.w	r9, [r6]
   1195a:	ldr	r4, [r6, #4]
   1195c:	adds	r6, #8
   1195e:	b.n	118c6 <__ssprint_r+0x1e>
   11960:	mov	r7, r4
   11962:	mov	sl, r4
   11964:	b.n	11936 <__ssprint_r+0x8e>
   11966:	mov	r0, fp
   11968:	bl	b254 <_realloc_r>
   1196c:	mov	r3, r0
   1196e:	cmp	r0, #0
   11970:	bne.n	11922 <__ssprint_r+0x7a>
   11972:	ldr	r1, [r5, #16]
   11974:	mov	r0, fp
   11976:	bl	10010 <_free_r>
   1197a:	movs	r3, #12
   1197c:	str.w	r3, [fp]
   11980:	ldrh	r3, [r5, #12]
   11982:	movs	r2, #0
   11984:	orr.w	r3, r3, #64	; 0x40
   11988:	mov.w	r0, #4294967295
   1198c:	strh	r3, [r5, #12]
   1198e:	str.w	r2, [r8, #8]
   11992:	str.w	r2, [r8, #4]
   11996:	add	sp, #12
   11998:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1199c:	movs	r0, #0
   1199e:	str.w	r0, [r8, #4]
   119a2:	add	sp, #12
   119a4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

000119a8 <_sungetc_r>:
   119a8:	adds	r3, r1, #1
   119aa:	push	{r4, r5, r6, lr}
   119ac:	beq.n	119e6 <_sungetc_r+0x3e>
   119ae:	ldrh	r3, [r2, #12]
   119b0:	ldr	r4, [r2, #48]	; 0x30
   119b2:	bic.w	r3, r3, #32
   119b6:	strh	r3, [r2, #12]
   119b8:	uxtb	r5, r1
   119ba:	cbz	r4, 119ec <_sungetc_r+0x44>
   119bc:	mov	r4, r2
   119be:	ldr	r2, [r2, #4]
   119c0:	ldr	r3, [r4, #52]	; 0x34
   119c2:	cmp	r2, r3
   119c4:	mov	r6, r1
   119c6:	bge.n	119dc <_sungetc_r+0x34>
   119c8:	ldr	r3, [r4, #0]
   119ca:	subs	r2, r3, #1
   119cc:	str	r2, [r4, #0]
   119ce:	strb.w	r6, [r3, #-1]
   119d2:	ldr	r3, [r4, #4]
   119d4:	adds	r3, #1
   119d6:	str	r3, [r4, #4]
   119d8:	mov	r0, r5
   119da:	pop	{r4, r5, r6, pc}
   119dc:	mov	r1, r4
   119de:	bl	11aec <__submore>
   119e2:	cmp	r0, #0
   119e4:	beq.n	119c8 <_sungetc_r+0x20>
   119e6:	mov.w	r5, #4294967295
   119ea:	b.n	119d8 <_sungetc_r+0x30>
   119ec:	ldr	r0, [r2, #16]
   119ee:	ldr	r3, [r2, #0]
   119f0:	cbz	r0, 119fe <_sungetc_r+0x56>
   119f2:	cmp	r0, r3
   119f4:	bcs.n	119fe <_sungetc_r+0x56>
   119f6:	ldrb.w	r0, [r3, #-1]
   119fa:	cmp	r5, r0
   119fc:	beq.n	11a1e <_sungetc_r+0x76>
   119fe:	str	r3, [r2, #56]	; 0x38
   11a00:	mov	r3, r2
   11a02:	ldr	r6, [r2, #4]
   11a04:	str	r6, [r2, #60]	; 0x3c
   11a06:	add.w	r4, r2, #64	; 0x40
   11a0a:	movs	r0, #3
   11a0c:	str	r0, [r2, #52]	; 0x34
   11a0e:	str	r4, [r2, #48]	; 0x30
   11a10:	strb.w	r1, [r3, #66]!
   11a14:	movs	r1, #1
   11a16:	str	r3, [r2, #0]
   11a18:	str	r1, [r2, #4]
   11a1a:	mov	r0, r5
   11a1c:	pop	{r4, r5, r6, pc}
   11a1e:	ldr	r1, [r2, #4]
   11a20:	subs	r3, #1
   11a22:	adds	r1, #1
   11a24:	str	r3, [r2, #0]
   11a26:	str	r1, [r2, #4]
   11a28:	b.n	119d8 <_sungetc_r+0x30>
   11a2a:	nop

00011a2c <__ssrefill_r>:
   11a2c:	push	{r4, lr}
   11a2e:	mov	r4, r1
   11a30:	ldr	r1, [r1, #48]	; 0x30
   11a32:	cbz	r1, 11a50 <__ssrefill_r+0x24>
   11a34:	add.w	r3, r4, #64	; 0x40
   11a38:	cmp	r1, r3
   11a3a:	beq.n	11a40 <__ssrefill_r+0x14>
   11a3c:	bl	10010 <_free_r>
   11a40:	ldr	r3, [r4, #60]	; 0x3c
   11a42:	str	r3, [r4, #4]
   11a44:	movs	r0, #0
   11a46:	str	r0, [r4, #48]	; 0x30
   11a48:	cbz	r3, 11a50 <__ssrefill_r+0x24>
   11a4a:	ldr	r3, [r4, #56]	; 0x38
   11a4c:	str	r3, [r4, #0]
   11a4e:	pop	{r4, pc}
   11a50:	ldrh	r3, [r4, #12]
   11a52:	ldr	r2, [r4, #16]
   11a54:	str	r2, [r4, #0]
   11a56:	orr.w	r3, r3, #32
   11a5a:	movs	r2, #0
   11a5c:	strh	r3, [r4, #12]
   11a5e:	str	r2, [r4, #4]
   11a60:	mov.w	r0, #4294967295
   11a64:	pop	{r4, pc}
   11a66:	nop

00011a68 <_sfread_r>:
   11a68:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11a6c:	sub	sp, #12
   11a6e:	mul.w	r9, r2, r3
   11a72:	str	r2, [sp, #4]
   11a74:	mov	sl, r3
   11a76:	ldr	r4, [sp, #48]	; 0x30
   11a78:	cmp.w	r9, #0
   11a7c:	beq.n	11ad2 <_sfread_r+0x6a>
   11a7e:	mov	r7, r0
   11a80:	mov	r6, r1
   11a82:	mov	r5, r9
   11a84:	mov.w	r8, #0
   11a88:	b.n	11aaa <_sfread_r+0x42>
   11a8a:	ldr	r1, [r4, #0]
   11a8c:	bl	8720 <memcpy>
   11a90:	ldr	r2, [r4, #0]
   11a92:	str.w	r8, [r4, #4]
   11a96:	add	r2, fp
   11a98:	str	r2, [r4, #0]
   11a9a:	mov	r1, r4
   11a9c:	mov	r0, r7
   11a9e:	add	r6, fp
   11aa0:	rsb	r5, fp, r5
   11aa4:	bl	11a2c <__ssrefill_r>
   11aa8:	cbnz	r0, 11ada <_sfread_r+0x72>
   11aaa:	ldr.w	fp, [r4, #4]
   11aae:	cmp	r5, fp
   11ab0:	mov	r0, r6
   11ab2:	mov	r2, fp
   11ab4:	bhi.n	11a8a <_sfread_r+0x22>
   11ab6:	mov	r2, r5
   11ab8:	ldr	r1, [r4, #0]
   11aba:	bl	8720 <memcpy>
   11abe:	ldr	r2, [r4, #4]
   11ac0:	ldr	r3, [r4, #0]
   11ac2:	subs	r2, r2, r5
   11ac4:	add	r3, r5
   11ac6:	mov	r0, sl
   11ac8:	str	r2, [r4, #4]
   11aca:	str	r3, [r4, #0]
   11acc:	add	sp, #12
   11ace:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11ad2:	mov	r0, r9
   11ad4:	add	sp, #12
   11ad6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11ada:	ldr	r3, [sp, #4]
   11adc:	rsb	r9, r5, r9
   11ae0:	udiv	r0, r9, r3
   11ae4:	add	sp, #12
   11ae6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11aea:	nop

00011aec <__submore>:
   11aec:	add.w	r3, r1, #64	; 0x40
   11af0:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   11af4:	mov	r4, r1
   11af6:	ldr	r1, [r1, #48]	; 0x30
   11af8:	cmp	r1, r3
   11afa:	beq.n	11b26 <__submore+0x3a>
   11afc:	ldr	r6, [r4, #52]	; 0x34
   11afe:	lsls	r7, r6, #1
   11b00:	mov	r2, r7
   11b02:	bl	b254 <_realloc_r>
   11b06:	mov	r5, r0
   11b08:	cbz	r0, 11b5c <__submore+0x70>
   11b0a:	add.w	r8, r0, r6
   11b0e:	mov	r2, r6
   11b10:	mov	r0, r8
   11b12:	mov	r1, r5
   11b14:	bl	8720 <memcpy>
   11b18:	str.w	r8, [r4]
   11b1c:	str	r5, [r4, #48]	; 0x30
   11b1e:	str	r7, [r4, #52]	; 0x34
   11b20:	movs	r0, #0
   11b22:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   11b26:	mov.w	r1, #1024	; 0x400
   11b2a:	bl	aadc <_malloc_r>
   11b2e:	cbz	r0, 11b5c <__submore+0x70>
   11b30:	ldrb.w	r3, [r4, #66]	; 0x42
   11b34:	str	r0, [r4, #48]	; 0x30
   11b36:	mov.w	r2, #1024	; 0x400
   11b3a:	str	r2, [r4, #52]	; 0x34
   11b3c:	strb.w	r3, [r0, #1023]	; 0x3ff
   11b40:	ldrb.w	r3, [r4, #65]	; 0x41
   11b44:	strb.w	r3, [r0, #1022]	; 0x3fe
   11b48:	ldrb.w	r3, [r4, #64]	; 0x40
   11b4c:	strb.w	r3, [r0, #1021]	; 0x3fd
   11b50:	addw	r0, r0, #1021	; 0x3fd
   11b54:	str	r0, [r4, #0]
   11b56:	movs	r0, #0
   11b58:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   11b5c:	mov.w	r0, #4294967295
   11b60:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00011b64 <_vasnprintf_r>:
   11b64:	push	{r4, r5, r6, lr}
   11b66:	mov	r5, r2
   11b68:	sub	sp, #104	; 0x68
   11b6a:	ldr	r4, [r2, #0]
   11b6c:	cbz	r1, 11b72 <_vasnprintf_r+0xe>
   11b6e:	cmp	r4, #0
   11b70:	bne.n	11ba8 <_vasnprintf_r+0x44>
   11b72:	movs	r4, #0
   11b74:	mov.w	r2, #648	; 0x288
   11b78:	strh.w	r2, [sp, #12]
   11b7c:	str	r4, [sp, #0]
   11b7e:	str	r4, [sp, #16]
   11b80:	mov	r2, r3
   11b82:	movw	r6, #65535	; 0xffff
   11b86:	ldr	r3, [sp, #120]	; 0x78
   11b88:	str	r4, [sp, #8]
   11b8a:	mov	r1, sp
   11b8c:	str	r4, [sp, #20]
   11b8e:	strh.w	r6, [sp, #14]
   11b92:	bl	c910 <_svfprintf_r>
   11b96:	cmp	r0, #0
   11b98:	blt.n	11bbe <_vasnprintf_r+0x5a>
   11b9a:	ldr	r3, [sp, #0]
   11b9c:	str	r0, [r5, #0]
   11b9e:	movs	r2, #0
   11ba0:	strb	r2, [r3, #0]
   11ba2:	ldr	r0, [sp, #16]
   11ba4:	add	sp, #104	; 0x68
   11ba6:	pop	{r4, r5, r6, pc}
   11ba8:	mov.w	r2, #1544	; 0x608
   11bac:	str	r1, [sp, #0]
   11bae:	str	r1, [sp, #16]
   11bb0:	strh.w	r2, [sp, #12]
   11bb4:	bge.n	11b80 <_vasnprintf_r+0x1c>
   11bb6:	movs	r3, #139	; 0x8b
   11bb8:	str	r3, [r0, #0]
   11bba:	movs	r0, #0
   11bbc:	b.n	11ba4 <_vasnprintf_r+0x40>
   11bbe:	movs	r0, #0
   11bc0:	b.n	11ba4 <_vasnprintf_r+0x40>
   11bc2:	nop

00011bc4 <_calloc_r>:
   11bc4:	push	{r4, lr}
   11bc6:	mul.w	r1, r2, r1
   11bca:	bl	aadc <_malloc_r>
   11bce:	mov	r4, r0
   11bd0:	cbz	r0, 11c0a <_calloc_r+0x46>
   11bd2:	ldr.w	r2, [r0, #-4]
   11bd6:	bic.w	r2, r2, #3
   11bda:	subs	r2, #4
   11bdc:	cmp	r2, #36	; 0x24
   11bde:	bhi.n	11c12 <_calloc_r+0x4e>
   11be0:	cmp	r2, #19
   11be2:	bls.n	11c0e <_calloc_r+0x4a>
   11be4:	movs	r3, #0
   11be6:	cmp	r2, #27
   11be8:	str	r3, [r0, #0]
   11bea:	str	r3, [r0, #4]
   11bec:	bls.n	11c1c <_calloc_r+0x58>
   11bee:	cmp	r2, #36	; 0x24
   11bf0:	str	r3, [r0, #8]
   11bf2:	str	r3, [r0, #12]
   11bf4:	iteee	ne
   11bf6:	addne.w	r2, r0, #16
   11bfa:	streq	r3, [r0, #16]
   11bfc:	streq	r3, [r0, #20]
   11bfe:	addeq.w	r2, r0, #24
   11c02:	movs	r3, #0
   11c04:	str	r3, [r2, #0]
   11c06:	str	r3, [r2, #4]
   11c08:	str	r3, [r2, #8]
   11c0a:	mov	r0, r4
   11c0c:	pop	{r4, pc}
   11c0e:	mov	r2, r0
   11c10:	b.n	11c02 <_calloc_r+0x3e>
   11c12:	movs	r1, #0
   11c14:	bl	88c8 <memset>
   11c18:	mov	r0, r4
   11c1a:	pop	{r4, pc}
   11c1c:	add.w	r2, r0, #8
   11c20:	b.n	11c02 <_calloc_r+0x3e>
   11c22:	nop
   11c24:	.word	0x25206425
   11c28:	.short	0x0a64
   11c2a:	.byte	0x00
   11c2b:	.byte	0x62
   11c2c:	.word	0x63697361
   11c30:	.word	0x756f5320
   11c34:	.word	0x5220646e
   11c38:	.word	0x726f6365
   11c3c:	.word	0x20726564
   11c40:	.word	0x73726556
   11c44:	.word	0x3a6e6f69
   11c48:	.word	0x62654620
   11c4c:	.word	0x20312020
   11c50:	.word	0x32323032
   11c54:	.word	0x3a303220
   11c58:	.word	0x353a3530
   11c5c:	.word	0x6e450036
   11c60:	.word	0x666f2064
   11c64:	.word	0x74655320
   11c68:	.word	0xff007075

00011c6c <vtable for Stream>:
	...
   11c74:	....o...........
   11c84:	............

00011c90 <vtable for StreamFile<FsBaseFile, unsigned long long>>:
	...
   11c98:	w...m...........
   11ca8:	............

00011cb4 <vtable for FsFile>:
	...
   11cbc:	w...m...........
   11ccc:	............

00011cd8 <vtable for File>:
	...
   11ce0:	Y...........'...
   11cf0:	....3...........
   11d00:	....

00011d04 <vtable for SDFile>:
	...
   11d0c:	Q...u...........
   11d1c:	................
   11d2c:	).......)...)...
   11d3c:	....A...........
   11d4c:	....u.......#...
   11d5c:	..../Config.txt.
   11d6c:	%10d.... Menu. '
   11d7c:	:h'  : print hel
   11d8c:	p. ':s'  : start
   11d9c:	 acquisition. ':
   11dac:	e'  : stop acqui
   11dbc:	sition. ':w'  : 
   11dcc:	write parameters
   11ddc:	 to microSD card
   11dec:	. ':l'  : list d
   11dfc:	isks. ':r'  : re
   11e0c:	set MTP. ':b'  :
   11e1c:	 reboot CPU. '?p
   11e2c:	'  : show all pa
   11e3c:	rameters. '?d'  
   11e4c:	: get date. '?t'
   11e5c:	  : get time. '?
   11e6c:	a'  : get file d
   11e7c:	uration (s). '!d
   11e8c:	 yyyy/mm/dd<cr>'
   11e9c:	  : set date. '!
   11eac:	t hh:mm:ss<cr>' 
   11ebc:	   : set time. '
   11ecc:	!a val<cr>'  : s
   11edc:	et file duration
   11eec:	 (s).CVAS_V3 Ver
   11efc:	sion: Feb  1 202
   11f0c:	2 20:05:56.Teens
   11f1c:	y: %d: %06x..Dat
   11f2c:	e d = %04d/%02d/
   11f3c:	%02d..Time t = %
   11f4c:	02d:%02d:%02d..T
   11f5c:	_acq a = %d..%d%
   11f6c:	c%d%c%d.start.st
   11f7c:	op.rebooting CPU
	...

00011f8d <monthDays>:
   11f8d:	...............

00011f9c <vtable for MySpiClass>:
	...
   11fa4:	....Q...........
   11fb4:	-...............

00011fc4 <cs>:
   11fc4:	...."...!...#...
   11fd4:	$...%...&...No s
   11fe4:	dio storage.No s
   11ff4:	pi storage.Stora
   12004:	ge %d %d %s .%d 
   12014:	%d.: .D./%s%06x_
   12024:	%04d%02d%02d/%02
   12034:	d/./%s%06x_%04d%
   12044:	02d%02d/%02d_%02
   12054:	d/.F.%s_%02d%02d
   12064:	%02d.bin.Failing
   12074:	 open file.WMXZ.
   12084:	%s%04d%02d%02d_%
   12094:	02d%02d%02d.sdio
   120a4:	.sd1.sd2.sd3.sd4
   120b4:	.sd5.sd6..

000120be <SPISettings::ctar_div_table>:
   120be:	................
   120ce:	...... .(.8.@.`.
   120de:	..............

000120ec <SPIClass::spi0_hardware>:
   120ec:	<..@............
   120fc:	....-%....'.....
   1210c:	................
   1211c:	................
   1212c:	................
   1213c:	..........-.....
   1214c:	................
   1215c:	................
   1216c:	................
   1217c:	.. .

00012180 <SPISettings::ctar_clock_table>:
   12180:	................
   12190:	................
   121a0:	. ....... ...0..
   121b0:	. ... ...@...@..
   121c0:	.P...P...`...`..
   121d0:	.p...`...p..

000121dc <TwoWire::i2c0_hardware>:
   121dc:	4..@@.....".0...
   121ec:	....!./.........

000121fc <TwoWire::i2c1_hardware>:
   121fc:	4..@....&:......
   1220c:	..%;............

0001221c <TwoWire::i2c2_hardware>:
   1221c:	(..@@...........
   1222c:	............J...

0001223c <vtable for TwoWire>:
	...
   12244:	;'..a'......9'..
   12254:	.&...'..#'..

00012260 <vtable for SDClass>:
	...
   12268:	y....(...)...*..
   12278:	k)...)...*...*..
   12288:	.+...,..

00012290 <FsGetPartitionInfo::mbdpGuid>:
   12290:	......3D..h..&..
   122a0:	EFI PART..

000122aa <lookupTable>:
   122aa:	..x...C.........
   122ba:	..............=.
   122ca:	.. .............
   122da:	................
   122ea:	................
   122fa:	....:.e,<.;.>.f,
   1230a:	B.A.S...T...V...
   1231a:	W...Y...[...`...
   1232a:	c...h...i...k.b,
   1233a:	o...r...u...}.d,
   1234a:	..............D.
   1235a:	..........E.....
   1236a:	{...|...}.......
   1237a:	................
   1238a:	................
   1239a:	}.c,Q.Y.S.[.U.].
   123aa:	W._.x...y.......
   123ba:	............N!2!
   123ca:	.!.!a,`,v,u,

000123d6 <mapTable>:
   123d6:	a..............0
   123e6:	2...9...J...y...
   123f6:	................
   12406:	.......("...F...
   12416:	................
   12426:	0.. P...`.."...6
   12436:	.......Da..&....
   12446:	...Z........ ...
   12456:	0...@...`...p.J.
   12466:	r.V.v.d.z.p.|.~.
   12476:	................
   12486:	........p!...$..
   12496:	0,./g,...,.d.-.&
   124a6:	A...Device is to
   124b6:	o small...Writin
   124c6:	g FAT ...Writing
   124d6:	 upcase table...
   124e6:	Writing root...F
   124f6:	ormat done...For
   12506:	mat failed...EXF
   12516:	AT.Bad cluster c
   12526:	ount...Card is t
   12536:	oo small....Form
   12546:	at Done...Format
   12556:	 Failed...

00012560 <vtable for SdSpiCard>:
	...
   12568:	.o...o...p...n..
   12578:	.t...u...o...u..
   12588:	cw...p...q...u..
   12598:	.n...n..ct..[t..
   125a8:	.s.......o...v..
   125b8:	.u..{v..

000125c0 <vtable for SdioCard>:
	...
   125c8:	)y...y......q...
   125d8:	....w...m{......
   125e8:	.....~.......{..
   125f8:	.x...x...x...x..
   12608:	.y..Ez...y...}..
   12618:	!~...}..

00012620 <digital_pin_to_info_PGM>:
   12620:	@..C@..@D..CD..@
   12630:	...C...@0..C0..@
   12640:	4..C4..@...C...@
   12650:	...C...@...C...@
   12660:	...C...@...C...@
   12670:	...C...@...C...@
   12680:	...C...@...C...@
   12690:	...C...@...C...@
   126a0:	...C...@...C...@
   126b0:	...C...@...C...@
   126c0:	...C...@...C...@
   126d0:	...C...@...C...@
   126e0:	h .Ch..@...C...@
   126f0:	8..C8..@<..C<..@
   12700:	@..C@..@H..CH..@
   12710:	L..CL..@(..C(..@
   12720:	,..C,..@` .C`..@
   12730:	d .Cd..@ ..C ..@
   12740:	$..C$..@(..C(..@
   12750:	,..C,..@D..CD..@
   12760:	p..Cp..@t..Ct..@
   12770:	h..Ch..@P..CP..@
   12780:	X..CX..@\..C\..@
   12790:	T..CT..@ ..C ..@
   127a0:	$..C$..@...C...@
   127b0:	...C...@8..C8..@
   127c0:	4..C4..@0..C0..@
   127d0:	<..C<..@,..C,..@
   127e0:	( .C(..@, .C,..@
   127f0:	. .C...@. .C...@
   12800:	. .C...@. .C...@
   12810:	. .C...@. .C...@

00012820 <vtable for usb_serial_class>:
	...
   12828:	i...a...]...Y...
   12838:	U...Q...M...I...
   12848:	..

0001284a <usb_endpoint_config_table>:
   1284a:	......

00012850 <usb_descriptor_list>:
   12850:	....y...........
   12860:	....C...........
   12870:	................
   12880:	................
   12890:	................
   128a0:	....

000128a4 <_global_impure_ptr>:
   128a4:	....C...POSIX...
   128b4:	....

000128b8 <fpi.6173>:
   128b8:	5...............
   128c8:	....nf..inity...
   128d8:	an..

000128dc <fpinan.6209>:
   128dc:	4...............
   128ec:	....

000128f0 <tinytens>:
   128f0:	.......<3...#.I9
   12900:	=..D...2......[%
   12910:	Co.d(.h.

00012918 <zeroes.7258>:
   12918:	0000000000000000
   12928:	INF.inf.NAN.nan.
   12938:	0123456789ABCDEF
   12948:	....0123456789ab
   12958:	cdef....(null)..
   12968:	0...

0001296c <blanks.7257>:
   1296c:	                

0001297c <basefix.7328>:
   1297c:	................
   1298c:	................
   1299c:	....e%ld....

000129a8 <_ctype_>:
   129a8:	.         ((((( 
   129b8:	                
   129c8:	 ...............
   129d8:	................
   129e8:	..AAAAAA........
   129f8:	................
   12a08:	..BBBBBB........
   12a18:	................
   12a28:	 ...............
	...
   12aa8:	....Infinity....
   12ab8:	NaN.

00012abc <__hexdig>:
	...
   12aec:	................
   12afc:	................
	...
   12b1c:	................
	...
   12bbc:	....

00012bc0 <__mprec_tens>:
   12bc0:	.......?......$@
   12bd0:	......Y@.....@.@
   12be0:	.......@.....j.@
   12bf0:	.......A......cA
   12c00:	.......A....e..A
   12c10:	... _..B....vH7B
   12c20:	......mB..@..0.B
   12c30:	.......B..4&.k.C
   12c40:	...7y.AC....W4vC
   12c50:	..Ngm..C.=.`.X.C
   12c60:	@..x...DP.....KD
   12c70:	..M....D.J...-.D
   12c80:	...yCx.D

00012c88 <__mprec_bigtens>:
   12c88:	...7y.AC.n.....F
   12c98:	..?..O8M2.0.Hw.Z
   12ca8:	<.s..O.u

00012cb0 <p05.6087>:
   12cb0:	........}...

00012cbc <_init>:
   12cbc:	push	{r3, r4, r5, r6, r7, lr}
   12cbe:	nop
   12cc0:	pop	{r3, r4, r5, r6, r7}
   12cc2:	pop	{r3}
   12cc4:	mov	lr, r3
   12cc6:	bx	lr

00012cc8 <__init_array_start>:
   12cc8:	.word	0x0000efcd

00012ccc <__frame_dummy_init_array_entry>:
   12ccc:	5.... ..I%..a%..
   12cdc:	y%...%...%...%..
   12cec:	.%...&..!&..9&..
   12cfc:	Q&..i&...&...&..
   12d0c:	.&...&...&..m,..

Disassembly of section .fini:

00012d1c <_fini>:
   12d1c:	push	{r3, r4, r5, r6, r7, lr}
   12d1e:	nop
